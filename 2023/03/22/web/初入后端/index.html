<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>初入后端（未完）</title><meta name="description" content="菜"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="[toc]
Maven
视频地址
01 Maven概述

Maven 时apache 旗下的一个开源软件，是一款用于管理和构建java项目的工具
他基于项目对象模型（POM）的概念，通过一小段描述信息来管理项目的构建
作用

依赖管理：方便快件的管理项目依赖的资源(jar包)，避免版本冲突
统一项目结构：提供标准，同一的项目结构
项目构建：标准跨平台（Linux，Windows，MacOS）的自动化项目构建方式


官网

Maven介绍
02 IDEA集成Maven


Maven安装：按视频走即可


根据视频进行maven的配置。


IDEA创建Maven项目

创建模块，选择Maven，点击Next
填写模块名称，坐标信息，点击Finish，创建完成
编写程序运行



Maven坐标

什么是坐.."><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Mr_cold's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">初入后端（未完）</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#maven"><span class="toc-text">Maven</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#01-maven%E6%A6%82%E8%BF%B0"><span class="toc-text">01 Maven概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#02-idea%E9%9B%86%E6%88%90maven"><span class="toc-text">02 IDEA集成Maven</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#03-%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86"><span class="toc-text">03 依赖管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#web-%E5%85%A5%E9%97%A8"><span class="toc-text">Web 入门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#01-springbootweb%E5%85%A5%E9%97%A8"><span class="toc-text">01 SpringBootWeb入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#02-http%E5%8D%8F%E8%AE%AE"><span class="toc-text">02 HTTP协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#03-web%E6%9C%8D%E5%8A%A1%E5%99%A8-tomcat"><span class="toc-text">03 Web服务器-Tomcat</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94"><span class="toc-text">请求响应</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#01-%E8%AF%B7%E6%B1%82"><span class="toc-text">01 请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#02-%E5%93%8D%E5%BA%94"><span class="toc-text">02 响应</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#03-%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90"><span class="toc-text">03 请求和响应综合案例分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#04-%E5%88%86%E5%B1%82%E8%A7%A3%E8%80%A6"><span class="toc-text">04 分层解耦</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mysql"><span class="toc-text">MySQL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#01-mysql%E6%A6%82%E8%BF%B0"><span class="toc-text">01 MySQL概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#02-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1-ddl"><span class="toc-text">02 数据库设计-DDL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#03-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1-dml"><span class="toc-text">03 数据库设计-DML</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#04-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1-dql"><span class="toc-text">04 数据库设计-DQL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#05-%E5%A4%9A%E8%A1%A8%E8%AE%BE%E8%AE%A1"><span class="toc-text">05 多表设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#06-%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="toc-text">06 多表查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#07-%E4%BA%8B%E5%8A%A1"><span class="toc-text">07 事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#08-%E7%B4%A2%E5%BC%95"><span class="toc-text">08 索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mybaits"><span class="toc-text">MyBaits</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#01-mybatis%E5%85%A5%E9%97%A8"><span class="toc-text">01 Mybatis入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#02-mybatis%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C"><span class="toc-text">02 Mybatis基础操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#03-xml%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6"><span class="toc-text">03 XML映射文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#04-mybatis%E5%8A%A8%E6%80%81sql"><span class="toc-text">04 Mybatis动态SQL</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spring"><span class="toc-text">Spring</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-spring-%E5%88%9D%E8%AF%86"><span class="toc-text">1 Spring 初识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-spring-framework"><span class="toc-text">2 Spring Framework</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-spring-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-text">3 Spring 核心概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-ioc%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B"><span class="toc-text">4 IoC入门案例</span></a></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/%E5%90%8E%E7%AB%AF"><i class="tag post-item-tag">后端</i></a><a href="/tags/web"><i class="tag post-item-tag">web</i></a><a href="/tags/IDEA"><i class="tag post-item-tag">IDEA</i></a><a href="/tags/spring,springboot"><i class="tag post-item-tag">spring,springboot</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">初入后端（未完）</h1><time class="has-text-grey" datetime="2023-03-22T13:20:28.676Z">2023-03-22</time><article class="mt-2 post-content"><p>[toc]</p>
<h2 id="maven" tabindex="-1">Maven</h2>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1m84y1w7Tb?p=50&amp;vd_source=240b8edf72530a8ec2d9f48cc6514072">视频地址</a></p>
<h3 id="01-maven%E6%A6%82%E8%BF%B0" tabindex="-1">01 Maven概述</h3>
<ul>
<li>Maven 时apache 旗下的一个开源软件，是一款用于管理和构建java项目的工具</li>
<li>他基于项目对象模型（POM）的概念，通过一小段描述信息来管理项目的构建</li>
<li>作用
<ul>
<li>依赖管理：方便快件的管理项目依赖的资源(jar包)，避免版本冲突</li>
<li>统一项目结构：提供标准，同一的项目结构</li>
<li>项目构建：标准跨平台（Linux，Windows，MacOS）的自动化项目构建方式</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="http://maven.apache.org/">官网</a></li>
</ul>
<p><a href="/images/web/%E5%88%9D%E5%85%A5%E5%90%8E%E7%AB%AF/Maven%E4%BB%8B%E7%BB%8D.jpg">Maven介绍</a></p>
<h3 id="02-idea%E9%9B%86%E6%88%90maven" tabindex="-1">02 IDEA集成Maven</h3>
<ul>
<li>
<p>Maven安装：按视频走即可</p>
</li>
<li>
<p>根据视频进行maven的配置。</p>
</li>
<li>
<p>IDEA创建Maven项目</p>
<ul>
<li>创建模块，选择Maven，点击Next</li>
<li>填写模块名称，坐标信息，点击Finish，创建完成</li>
<li>编写程序运行</li>
</ul>
</li>
<li>
<p>Maven坐标</p>
<ul>
<li>什么是坐标？
<ul>
<li>Maven中的坐标是资源的唯一标识，通过该坐标可以唯一定位资源位置</li>
<li>使用坐标来定义项目或引入项目中的依赖</li>
</ul>
</li>
<li>Maven坐标的主要组成
<ul>
<li>groupId：定义当前Maven项目隶属组织名称（通常是域名反写）</li>
<li>artifactId：定义当前Maven项目名称（通常是模块名称）</li>
<li>version：定义当前项目版本号</li>
</ul>
</li>
</ul>
</li>
<li>
<p>IDEA导入Maven项目</p>
<ul>
<li>法一：打开IDEA，选择右侧Maven面板，点击+号，选中对应醒目的pom.xml文件，双击即可。</li>
<li>法二：打开IDEA中File中Project Structure -&gt; moudle -&gt; import mode 选中pom.xml文件即可</li>
</ul>
</li>
</ul>
<h3 id="03-%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86" tabindex="-1">03 依赖管理</h3>
<ul>
<li>依赖配置
<ul>
<li>依赖：指当前项目运行所需要的jar包，一个项目中可以引入多个依赖</li>
<li>配置
<ul>
<li>
<ol>
<li>在pos.xml中编写&lt;dependencies&gt;标签</li>
</ol>
</li>
<li>
<ol start="2">
<li>在&lt;dependencies&gt;标签中使用&lt;dependency&gt;引入坐标</li>
</ol>
</li>
<li>
<ol start="3">
<li>定义坐标的 groupId,artifactId,version</li>
</ol>
</li>
<li>
<ol start="4">
<li>定义刷新按钮，引入最新加入的坐标<br>
<a target="_blank" rel="noopener" href="http://mvnrepository.com">依赖仓库</a>,每次可以直接在这里找到所需依赖和对应坐标<br>
如果引入的依赖不存在，将会连接远程仓库/中央仓库 然后下载依赖</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>&lt;!-- 坐标代码示例 --&gt;
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
        &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
        &lt;version&gt;1.2.3&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<ul>
<li>
<p>依赖传递</p>
<ul>
<li>依赖具有传递性
<ul>
<li>直接依赖：在当前项目中通过依赖配置建立的依赖关系</li>
<li>间接依赖：被依赖的资源如果依赖其它资源，当前项目间接依赖其它资源</li>
</ul>
</li>
<li>可以在maven的项目文件夹中看到依赖项，同时在xml文件中右键选择 Diagrams可以看到依赖的可视化界面</li>
<li>&lt;exclusions&gt;与<exclusion>可以排除指定依赖</exclusion></li>
</ul>
</li>
<li>
<p>依赖范围</p>
<ul>
<li>依赖的jar包，默认情况下，可以在任何地方使用。可以通过&lt;scope&gt;…&lt;\scope&gt;设置其作用范围：
<ul>
<li>主程序范围有效（main文件夹范围内）</li>
<li>测试程序范围有效（test文件夹范围内）</li>
<li>是否参与打包运行（package指令范围内）</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
    <tr>
        <th>scope值</th>
        <th>主程序</th>
        <th>测试程序</th>
        <th>打包（运行）</th>
        <th>范例</th>
    </tr>
    <tr>
        <td>compile（默认）</td>
        <td>Y</td>
        <td>Y</td>
        <td>Y</td>
        <td>lo4g4j</td>
    </tr>
    <tr>
        <td>test</td>
        <td>-</td>
        <td>Y</td>
        <td>-</td>
        <td>junit</td>
    </tr>
    <tr>
        <td>provided</td>
        <td>Y</td>
        <td>Y</td>
        <td>-</td>
        <td>servlet-api</td>
    </tr>
    <tr>
        <td>runtime</td>
        <td>-</td>
        <td>Y</td>
        <td>Y</td>
        <td>jdbc驱动</td>
    </tr>
</table>
<ul>
<li>生命周期
<ul>
<li>Maven的生命周期就是为了对所有的Maven项目构建过程进行抽象和统一</li>
<li>Maven中有三套相互独立的生命周期
<ul>
<li>clean：清理工作</li>
<li>default：核心工作，如：编译，测试，打包，安装，部署等</li>
<li>site：生成报告，发布站点</li>
<li>在同一个生命周期中，当运行后面的阶段时，前面的阶段都会运行</li>
</ul>
</li>
<li>重点掌握5个
<ul>
<li>clean：移除上一次构建生成的文件</li>
<li>compile：编译项目源代码</li>
<li>test：使用合适的单元测试框架运行测试（junt）</li>
<li>package：将编译后的文件打包，如：jar，war</li>
<li>install：安装项目到本地仓库</li>
</ul>
</li>
<li>执行生命周期的两种方式：
<ul>
<li>在idea中，右侧的maven工具栏，选中对应的生命周期，双击执行</li>
<li>在命令行中，通过命令执行</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="web-%E5%85%A5%E9%97%A8" tabindex="-1">Web 入门</h2>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1m84y1w7Tb/?p=58&amp;vd_source=240b8edf72530a8ec2d9f48cc6514072">视频地址</a></p>
<h3 id="01-springbootweb%E5%85%A5%E9%97%A8" tabindex="-1">01 SpringBootWeb入门</h3>
<ul>
<li>需求:
<ul>
<li>使用springboot开发一个web应用，浏览器发起/hello后，给浏览器返回字符串“hello world”</li>
<li>步骤：
<ul>
<li>
<ol>
<li>创建springboot工程，并勾选web开发相关依赖</li>
</ol>
</li>
<li>
<ol start="2">
<li>定义helloController类，添加方法hello，并添加注解</li>
</ol>
</li>
<li>
<ol start="3">
<li>运行测试</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="02-http%E5%8D%8F%E8%AE%AE" tabindex="-1">02 HTTP协议</h3>
<ul>
<li>HTTP概述
<ul>
<li>概念：Hyper Text Transfer Protocol 超文本传输协议，规定了浏览器和服务器之间的数据传输</li>
<li>特点：
<ul>
<li>
<ol>
<li>基于TCP协议：面向连接，安全</li>
</ol>
</li>
<li>
<ol start="2">
<li>基于请求-响应模型：一次请求对应一次响应</li>
</ol>
</li>
<li>
<ol start="3">
<li>HTTP协议是无状态的协议：对于事务处理没有记忆能力，每次请求和响应都是独立的</li>
</ol>
<ul>
<li>缺点：多次请求之间不能共享数据（可以克服）</li>
<li>优点：速度快</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>HTTP请求协议
<ul>
<li>请求数据格式
<ul>
<li>请求行：请求数据的第一行（请求方式，资源路径，协议）</li>
<li>请求头：从第二行开始，格式key：value</li>
<li>请求体：POST请求，存放请求参数
<ul>
<li>请求方式GET：请求参数在请求行中，没有请求体，GET请求大小是有限的</li>
<li>请求方式POST:请求参数在请求体中，POST请求大小是没有限制的</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>HTTP响应协议
<ul>
<li>响应数据格式
<ul>
<li>响应行：响应数据的第一行（协议，状态码，描述）<br>
状态码大类</li>
<li>响应头：第二行开始，格式key：value</li>
<li>响应体：最后一部分，存放响应数据</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>状态码分类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1xx</td>
<td>响应中–临时状态码，标识请求已经接受，告诉客户端应该继续请求或者如果已完成则忽略</td>
</tr>
<tr>
<td>2xx</td>
<td>成功–标识请求已经成功被接受，处理已经完成</td>
</tr>
<tr>
<td>3xx</td>
<td>重定向–重定向到其他地方：他让客户端再发起一个请求以完成整个处理</td>
</tr>
<tr>
<td>4xx</td>
<td>客户端错误–处理发生错误，责任在客户端，如：客户端请求一个不存在的资源，客户端未被授权，禁止访问等</td>
</tr>
<tr>
<td>5xx</td>
<td>服务器端错误–处理发生错误，责任在服务端，如：服务端抛出异常，路由错误，HTTP版本不支持等</td>
</tr>
</tbody>
</table>
<ul>
<li>HTTP协议解析
<ul>
<li>HTTP协议解析代码将会很复杂，但因为HTTP的广泛使用，且协议的标准型，已经有公司提供出专用的web服务器软件，Tomcat便是一种</li>
</ul>
</li>
</ul>
<h3 id="03-web%E6%9C%8D%E5%8A%A1%E5%99%A8-tomcat" tabindex="-1">03 Web服务器-Tomcat</h3>
<p>Web服务器是一个软件程序，对HTTP协议的操作进行封装，使得程序员不必直接对协议操作，让web开发更加便捷。主要功能是“提供网上信息浏览服务”</p>
<ul>
<li>简介
<ul>
<li>概念：Tomcat是Apache软件基金会的一个核心项目，是一个开源免费的轻量级Web服务器，支持Servlet/JSP少量JavaEE规范</li>
<li>JavaEE：Java Enterprise Edition，Java企业版。指Java企业级开发的技术规范的总和</li>
<li>JavaSE：Java标准版 JavaME：java小型版，多用于嵌入式</li>
<li>Tomcat也被称为Web容器，Servlet容器。Servlet程序需要依赖于Tomcat才能运行</li>
<li><a target="_blank" rel="noopener" href="https://tomcat.apache.org">官网</a></li>
</ul>
</li>
<li>基本使用:发现本地使用不了，寄</li>
<li>入门程序解析：
<ul>
<li>起步依赖,原理是maven依赖传递
<ul>
<li>spring-boot-stater-web</li>
<li>spring-boot-stater-test</li>
</ul>
</li>
<li>内嵌tomcat服务器：springboot自带tomcat作为服务器，tomcat白雪，不用运行</li>
</ul>
</li>
</ul>
<h2 id="%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94" tabindex="-1">请求响应</h2>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1m84y1w7Tb/?p=67&amp;vd_source=240b8edf72530a8ec2d9f48cc6514072">视频连接</a></p>
<ul>
<li>前端控制器 DispatchServlet，提供了两个对象
<ul>
<li>请求对象 HttpServletRequest : 获取请求程序</li>
<li>响应对象 HttpServletResponse : 设置响应数据</li>
</ul>
</li>
<li>BS架构： Browser/Server，浏览器/服务器架构。客户端只需要浏览器，应用程序和逻辑都存储在服务器端(维护方便，体验一般)</li>
<li>CS架构： Client/Server，客户端/服务器模式 （开发，维护麻烦，但体验不错）</li>
</ul>
<h3 id="01-%E8%AF%B7%E6%B1%82" tabindex="-1">01 请求</h3>
<ul>
<li>
<p>当前最主流开发模式：前后端分离，原型+需求决定接口文档，前后端依据接口文档进行开发</p>
</li>
<li>
<p>postman的使用：</p>
<ul>
<li>postman是一款功能强大的网页调试与发送网页http请求的chrome插件，常用于接口测试</li>
</ul>
</li>
<li>
<p>简单参数</p>
<ul>
<li>原始方式：在原始的web程序中，获取请求参数，需要通过HttpServletRequest对象手动获取。但这种方法繁琐，需要手动转换类型</li>
</ul>
<pre><code class="language-java">@RequestMapping(&quot;/simpleParam&quot;)
  public String simpleParam(HttpServletRequest request)&#123;
      String name=request.getParameter(&quot;name&quot;);
      String ageStr=request.getParameter(&quot;age&quot;);
      int age = Integer.parseInt(ageStr);
      System.out.println(name+&quot;:&quot;+age);
      return &quot;OK&quot;;
  &#125;
</code></pre>
<ul>
<li>springboot方式：只要参数名和形参变量名相同，定义形参即可接受参数</li>
</ul>
<pre><code class="language-java">@RequestMapping(&quot;/simpleParam&quot;)
  public String simpleParam(String name,Integer age)&#123;
      System.out.println(name+&quot;:&quot;+age);
      return &quot;OK&quot;;
  &#125;
</code></pre>
<ul>
<li>springboot方式中，如果方法形参名称与请求参数名称不匹配，可以使用<code>@RequestParam</code>进行映射。
<ul>
<li><code>@RequestParam</code>中的<code>required</code>属性值默认为true，代表该参数必须传递，不传递将会报错。如果该参数是可选的，可以将<code>required</code>值设置为false</li>
</ul>
</li>
</ul>
<pre><code class="language-java">  @RequestMapping(&quot;/simpleParam&quot;)
  public String simpleParam(@RequestParam(name=&quot;name&quot;) String username, Integer age)&#123;
      System.out.println(username+&quot;:&quot;+age);
      return &quot;OK&quot;;
  &#125;
</code></pre>
</li>
<li>
<p>实体参数</p>
<ul>
<li>简单实体参数：请求参数名和形参对象属性名相同，定义POJO接受即可</li>
<li>复杂实体参数：即实体的嵌套，请求参数名和形参对象属性名相同，按照对象层次结构关系即可接受嵌套POJO属性参数</li>
</ul>
<pre><code class="language-java">//http://localhost:8080/simplePojo?name=Tom&amp;age=10&amp;address.province=陕西&amp;address.city=西安
public class User &#123;
  private String name;
  private Integer age;
  private address Address;
&#125;
public class address &#123;
  private String province;
  private String city;
&#125;
</code></pre>
</li>
<li>
<p>数组集合参数</p>
<ul>
<li>数组参数：请求参数名与形参数组名称相同且请求参数为多个，定义数组类型形参即可接受参数</li>
</ul>
<pre><code class="language-java">//http://localhost:8080/arrayParam?hobby=game&amp;hobby=java&amp;hobby=sing
@RequestMapping(&quot;/arrayParam&quot;)
  public String arrayParam(String[] hobby)&#123;
      System.out.println(Arrays.toString(hobby));
      return &quot;OK&quot;;
  &#125;
</code></pre>
<ul>
<li>集合参数：请求参数名与形参数组名称相同，通过@RequestParam绑定参数关系</li>
</ul>
<pre><code class="language-java">//http://localhost:8080/listParam?hobby=game&amp;hobby=java&amp;hobby=sing
@RequestMapping(&quot;/listParam&quot;)
  public String arrayParam(@RequestParam List&lt;String&gt; hobby)&#123;
      System.out.println(hobby);
      return &quot;OK&quot;;
  &#125;
</code></pre>
</li>
<li>
<p>日期参数：</p>
<ul>
<li>使用<code>@DateTimeFormat</code>注解完成日期参数格式转换</li>
</ul>
<pre><code class="language-java">  //http://localhost:8080/dateParam?updateTime=2023-03-25 15:40:00
  @RequestMapping(&quot;/dateParam&quot;)
  public String dataParam(@DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)LocalDateTime updateTime)&#123;
      System.out.println(updateTime);
      return &quot;OK&quot;;
  &#125;
</code></pre>
</li>
<li>
<p>JSON参数</p>
<ul>
<li>json数据键名与形参对象属性名相同，定义POJO类型形参即可接收参数，需要使用<code>RequestBody</code>标识</li>
</ul>
<pre><code class="language-java">//http://localhost:8080/jsonParam
@RequestMapping(&quot;/jsonParam&quot;)
  public String jsonParam(@RequestBody User user)&#123;
      System.out.println(user);
      return &quot;OK&quot;;
  &#125;
</code></pre>
</li>
<li>
<p>路径参数</p>
<ul>
<li>通过请求url直接传递参数，使用{…}来标识路径参数，需要使用<code>@PathVariable</code>获取路径参数</li>
</ul>
<pre><code class="language-java">//http://localhost:8080/path/10
@RequestMapping(&quot;/path/&#123;id&#125;&quot;)
  public String pathParam(@PathVariable Integer id)&#123;
      System.out.println(id);
      return &quot;OK&quot;;
  &#125;
//传递两个参数
//http://localhost:8080/path/10/Tom
@RequestMapping(&quot;/path/&#123;id&#125;/&#123;name&#125;&quot;)
  public String path2Param(@PathVariable Integer id,@PathVariable String name)&#123;
      System.out.println(id+&quot;:&quot;+name);
      return &quot;OK&quot;;
  &#125;
</code></pre>
</li>
</ul>
<h3 id="02-%E5%93%8D%E5%BA%94" tabindex="-1">02 响应</h3>
<ul>
<li>响应数据使用<code>@ResponseBody</code>注解
<ul>
<li>类型：方法注解，类注解</li>
<li>位置：Controller方法/类上</li>
<li>作用：将方法返回值直接响应，如果返回值类型是实体对象/集合，将会转换为JSON格式</li>
<li>说明：<code>@RestController=@Controller+@ResponseBody</code></li>
</ul>
</li>
<li>使用同一响应结果，方便项目管理和维护，如设置一个result类，所有返回结果均为result类</li>
<li><code>Result(code,msg,data)</code></li>
</ul>
<h3 id="03-%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90" tabindex="-1">03 请求和响应综合案例分析</h3>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1m84y1w7Tb/?p=74&amp;vd_source=240b8edf72530a8ec2d9f48cc6514072">视频连接</a></p>
<p>前端和后端的组合小案例</p>
<h3 id="04-%E5%88%86%E5%B1%82%E8%A7%A3%E8%80%A6" tabindex="-1">04 分层解耦</h3>
<ul>
<li>
<p>三层架构</p>
<ul>
<li>controller:控制层，接收前端发送的请求，对请求进行处理，并响应数据</li>
<li>service：业务逻辑层，处理具体的业务逻辑</li>
<li>dao：数据访问层（Data Access Object）（持久层），负责数据访问操作，包括数据的增删改查</li>
<li>三层架构 复用性强，便于维护，利于拓展</li>
</ul>
</li>
<li>
<p>分层解耦</p>
<ul>
<li>内聚：软件中各个功能模块内部的功能联系</li>
<li>耦合：衡量软件中各个层/模块之间的依赖和关联程度</li>
<li>软件设计原则：高内聚低耦合</li>
<li></li>
</ul>
</li>
<li>
<p>IoC (Inversion of Control) 控制反转</p>
<ul>
<li>使用对象时，由主动new产生对象转换为由外部提供对象，此过程中对像创建控制权由程序转移到外部，此思想称为控制反转</li>
<li>Spring技术对IoC技术进行了实现
<ul>
<li>Spring提供了一个容器，称为IoC容器，用来充当IoC思想中的“外部”</li>
<li>IoC容器负责对象的创建，初始化等一系列工作，被创建或被管理的对象再IoC容器里称为<code>Bean</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>DI (Dependency Injection) 依赖注入</p>
<ul>
<li>在容器中简历bean和bean之间的依赖关系的整个过程，称为依赖注入</li>
</ul>
</li>
<li>
<p>IOC与DI入门程序</p>
<ul>
<li>在类前加<code>@Component</code>表示将当前类交给IOC容器管理，称为IOC容器里的bean。该操作实现控制反转</li>
<li>在对象前加<code>@Autowired</code>表示在运行时，IOC容器会提供该类型的bean对象，并赋值给该变量。该操作实现依赖注入。</li>
</ul>
</li>
<li>
<p>IOC详解</p>
<ul>
<li>Bean的声明：要把某个对象交给IOC容器管理，需要在对应的类上加上如下注解之一：</li>
</ul>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
<th>位置</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Component</td>
<td>声明bean的基础解释</td>
<td>不属于以下三类时，用此注解</td>
</tr>
<tr>
<td>@Controller</td>
<td>@Component的衍生注解</td>
<td>标注在控制器类上</td>
</tr>
<tr>
<td>@Service</td>
<td>@Component的衍生注解</td>
<td>标注在业务类上</td>
</tr>
<tr>
<td>@Repository</td>
<td>@Component的衍生注解</td>
<td>标注在数据访问类上（由于与mybatis整合，用的很少）</td>
</tr>
</tbody>
</table>
<ul>
<li>注意事项：
<ul>
<li>声明bean时，可以通过value属性指定bean的名字，如果没有指定，默认为类名首字母小写</li>
<li>使用以上四个注解都可以声明bean，但是在springboot集成web开发中，声明控制器bean只能用<code>@Controller</code></li>
</ul>
</li>
<li>Bean的组件扫描
<ul>
<li>前面声明的bean的四大注解，想要生效，还需要被组件扫描注解<code>@ComponentScan</code>扫描</li>
<li><code>@ComponentScan</code>注解虽然没有显式配置，但是实际上已经包含在了启动类声明注解<code>@SpringBootApplication</code>中，默认扫描范围时启动类所在包及其子包</li>
<li>可以手动设置扫描范围以覆盖默认扫描范围，但推荐还是把项目中的所有bean都放在启动类中</li>
</ul>
</li>
</ul>
</li>
<li>
<p>DI详解</p>
<ul>
<li><code>@Autowired</code>：默认安装类型自动装配</li>
<li>如果同类型的bean存在多个
<ul>
<li><code>@Primary</code>：放到bean的注解前，用来指定优先级</li>
<li><code>@AutoWired+@qualifier(&quot;bean的名称&quot;)</code>根据名称选择</li>
<li><code>@Resource(name=&quot;bean的名称&quot;)</code>根据名称选择</li>
</ul>
</li>
<li><code>@AutoWired</code>和<code>@Resource</code>的区别
<ul>
<li><code>@Resource</code>是JDK提供的注解,<code>@AutoWired</code>是spring框架提供的注解</li>
<li><code>@AutoWired</code>默认按照类型进行注入,<code>@Resource</code>默认按照名称进行注入</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="mysql" tabindex="-1">MySQL</h2>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1m84y1w7Tb/?p=80&amp;vd_source=240b8edf72530a8ec2d9f48cc6514072">视频地址</a></p>
<p>以下内容可分为三个部分</p>
<ul>
<li>数据库设计
<ul>
<li>MySQL概述</li>
<li>数据库设计-DDL</li>
<li>多表设计</li>
</ul>
</li>
<li>数据库操作
<ul>
<li>数据库操作-DML</li>
<li>数据库操作-DQL</li>
<li>事务</li>
<li>查询</li>
</ul>
</li>
<li>数据库优化
<ul>
<li>索引</li>
<li>SQL优化</li>
</ul>
</li>
</ul>
<h3 id="01-mysql%E6%A6%82%E8%BF%B0" tabindex="-1">01 MySQL概述</h3>
<ul>
<li>
<p>安装社区版MySQL，<a target="_blank" rel="noopener" href="https://dev.mysql.com/downloads/mysql/">官网</a><br>
安装步骤视频讲的很细</p>
</li>
<li>
<p>MySQL连接：<code>mysql -u用户名 -p 密码 [-h数据库服务器IP地址 -P端口号]</code></p>
</li>
<li>
<p>MySQL-企业开发使用方式</p>
<ul>
<li>远程使用服务器</li>
</ul>
</li>
<li>
<p>MySQL数据库模型</p>
<ul>
<li>关系型数据库（RDBMS）：建立在关系模型基础上，由多张相互连接的二维表组成的数据库</li>
<li>特点：
<ul>
<li>使用表存储数据，格式统一，便于维护</li>
<li>使用SQL语言操作，标准统一，使用方便，可用于复杂查询</li>
</ul>
</li>
</ul>
</li>
<li>
<p>SQL简介</p>
<ul>
<li>SQL：一门操作关系型数据库的编程语言，定义操作所有关系型数据库的统一标准</li>
<li>通用语法：
<ul>
<li>SQL语句可以单行或者多行书写，以分号结尾</li>
<li>SQL语句可以使用空格或缩进来增强语句可读性</li>
<li>MYSQL数据库的SQL语句不区分大小写</li>
<li>注释
<ul>
<li>
<ol>
<li>单行注释：<code>-- 注释内容</code> 或 <code># 注释内容</code>(MySQL特有)</li>
</ol>
</li>
<li>
<ol start="2">
<li>多行注释：<code>/*注释内容*/</code></li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>SQL分类
<ul>
<li>SQL语句通常分为四类</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>分类</th>
<th>全称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>DDL</td>
<td>Data Definition Language</td>
<td>数据定义语言，用来定义数据库对象（数据库与，表，字段）</td>
</tr>
<tr>
<td>DML</td>
<td>Data Manipulation Language</td>
<td>数据操作语言，用来对数据库表中的数据进行增删改</td>
</tr>
<tr>
<td>DQL</td>
<td>Data Query Language</td>
<td>数据查询语言，用来查询数据库表中的数据</td>
</tr>
<tr>
<td>DCL</td>
<td>Data Control Language</td>
<td>数据控制语言，用来创建数据库用户，控制数据库的访问权限</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3 id="02-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1-ddl" tabindex="-1">02 数据库设计-DDL</h3>
<ul>
<li>
<p>DDL 数据库操作</p>
<ul>
<li>查询：
<ul>
<li>查询所有数据库：<code>show databases</code></li>
<li>查询当前数据库：<code>select database()</code></li>
</ul>
</li>
<li>使用
<ul>
<li>使用数据库：<code>use 数据库名</code></li>
</ul>
</li>
<li>创建
<ul>
<li>创建数据库：<code>create database [if not exist] 数据库名</code></li>
</ul>
</li>
<li>删除
<ul>
<li>删除数据库：<code>drop database [if exists] 数据库名</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>用命令行使用mysql语句的缺点</p>
<ul>
<li>无提示，操作繁琐，无历史记录</li>
<li>因此可以使用mysql的可视化工具，有
<ul>
<li>SQLyog，Navicat，DataGrip</li>
</ul>
</li>
<li>这里使用DataGrip，其为Jetbrains旗下的一款数据库管理工具，是管理和开发MySQL，Oracle，PostgreSQL的理想解决方案</li>
<li>DataGrip为IDEA自带，（IDEA贵有贵的道理）</li>
</ul>
</li>
<li>
<p>DDL表（创建，查询，修改，删除）</p>
</li>
<li>
<p>创建</p>
<pre><code class="language-SQL">create table 表名(
  字段1 字段类型 [约束][comment 字段1注释]
  ...
  字段n 字段类型 [约束][comment 字段n注释]
)[comment 表注释]
</code></pre>
<ul>
<li>
<p>约束</p>
<ul>
<li>概念：约束是作用表中字段上的规则，用于限制存储在表中的数据</li>
<li>目的：保证数据库中数据的正确性，有效性，完整性</li>
<li>SQL语句主要提供以下5种约束</li>
</ul>
<table>
<thead>
<tr>
<th>约束</th>
<th>描述</th>
<th>关键字</th>
</tr>
</thead>
<tbody>
<tr>
<td>非空约束</td>
<td>限制该字段值不能为null</td>
<td>not null</td>
</tr>
<tr>
<td>唯一约束</td>
<td>保证字段的所有数据都是唯一，不重复的</td>
<td>unique</td>
</tr>
<tr>
<td>主键约束</td>
<td>主键是一行数据的唯一标识，要求非空且唯一</td>
<td>primary key (auto_increment 设置自动增长)</td>
</tr>
<tr>
<td>默认约束</td>
<td>保存数据时，如果未指定该字段，则使用默认值</td>
<td>default</td>
</tr>
<tr>
<td>外键约束</td>
<td>让两张表的数据建立连接，保证数据的一致性和完整性</td>
<td>foreign key</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>数据类型：主要分为三类</p>
<ul>
<li>数值类型：主要使用 tinyint,int,float,double</li>
<li>字符串类型:char(定长字符，性能高)，varchar(边长字符，性能低但占空间少)</li>
<li>日期时间类型</li>
</ul>
</li>
<li>
<p>表结构设计基本流程</p>
<ul>
<li>页面原型+需求 -&gt; 原型字段(类型，约束) + 基础字段（创建时间，上一次更改时间）-&gt; 得到需要的表</li>
</ul>
</li>
</ul>
</li>
<li>
<p>查询</p>
<ul>
<li>查询当前数据库的所有表：<code>show tables</code></li>
<li>查询表结构：<code>desc 表名</code></li>
<li>查询建表语句：<code>show create table 表名</code></li>
</ul>
</li>
<li>
<p>修改</p>
<ul>
<li>添加字段：<code>alter 表名 add 字段名 类型(长度) [comment 注释][约束]</code></li>
<li>修改字段类型：<code>alter table 表名 modify 字段名 新数据类型(长度)</code></li>
<li>修改字段名和字段类型：<code>alter table 表名 change 旧字段名 新字段名(长度)[comment 注释][约束]</code></li>
<li>删除字段：<code>alter table 表名 drop column 字段名</code></li>
<li>修改表明：<code>rename table 表名 to 新表名</code></li>
</ul>
</li>
<li>
<p>删除</p>
<ul>
<li>删除表： <code>drop table [if exists] 表名</code></li>
<li>在删除表的首，表中的数据也会删除</li>
</ul>
</li>
</ul>
<h3 id="03-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1-dml" tabindex="-1">03 数据库设计-DML</h3>
<p>DML（Data Manipulation Language） 数据操作语言，用来对数据库表中的数据进行增删改操作</p>
<ul>
<li>
<p>insert 插入</p>
<ul>
<li>语法
<ul>
<li>指定字段添加数据：<code>insert 表名 (字段名1，字段名2) values (值1，值2)</code></li>
<li>全部字段添加数据：<code>insert 表名 values(值1，值2)</code></li>
<li>批量添加数据（指定字段）<code>insert 表名 (字段名1，字段名2) values (值1，值2),values (值1，值2)</code></li>
<li>鼻梁添加数据（全部字段）<code>insert 表名 values(值1，值2),values(值1，值2)</code></li>
</ul>
</li>
<li>注意事项
<ul>
<li>
<ol>
<li>插入数据时，指定的字段顺序需要和值的顺序是一一对应的</li>
</ol>
</li>
<li>
<ol start="2">
<li>字符串和日期类型数据应该包含在引号里</li>
</ol>
</li>
<li>
<ol start="3">
<li>插入的数据大小，应该在字段的规定范围内</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>update 更新</p>
<ul>
<li>语法
<ul>
<li>修改数据：<code>updata 表名 set 字段值1=值1,字段值2=值2,...[where 条件]</code></li>
</ul>
</li>
<li>注意事项
<ul>
<li>修改语句的条件可有可无，如无，则会修改整张表</li>
</ul>
</li>
</ul>
</li>
<li>
<p>delete 删除</p>
<ul>
<li>语法
<ul>
<li>删除数据:<code>delete from 表名 [where 条件]</code></li>
</ul>
</li>
<li>注意事项
<ul>
<li>
<ol>
<li>DELETE语句的条件可有可无，若没有则会删除整张表</li>
</ol>
</li>
<li>
<ol start="2">
<li>DELETE语句不能删除某一个字段的值(如果操作，可以使用UPDATE，将该字段值置为NULL)</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="04-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1-dql" tabindex="-1">04 数据库设计-DQL</h3>
<ul>
<li>
<p>DQL（Data Query Language）（数据查询语言），用来查询数据库表中的数据</p>
</li>
<li>
<p>关键词 SELECT</p>
<ul>
<li>语法：<br>
<img src="/images/web/%E5%88%9D%E5%85%A5%E5%90%8E%E7%AB%AF/DQL0.jpg" alt="DQL语法"></li>
</ul>
</li>
<li>
<p>基本查询</p>
<ul>
<li>查询多个字段：<code>selcet 字段1,字段2,字段3 from 表名</code></li>
<li>查询所有字段（通配符）：<code>select * from 表名</code>(该方法不直观，且效率低)</li>
<li>设置别名：<code>select 字段1 [as 别名1], 字段2 [as 别名2] from 表名</code></li>
<li>去除重复记录：<code>select distinct 字段列表 from 表名</code></li>
</ul>
</li>
<li>
<p>条件查询</p>
<ul>
<li>语法：<code>select 字段列表 from 表名 where 条件列表</code></li>
<li>比较运算符：<code>&gt;,&gt;=,&lt;,&lt;=,=,&lt;&gt;或!=(不等于),between ... and ..., in(...),like (字符串和占位符),is null </code></li>
<li>逻辑运算符：<code>and或&amp;&amp;,or或||,not或!</code></li>
</ul>
</li>
<li>
<p>分组查询</p>
<ul>
<li>聚合函数
<ul>
<li>介绍：将一列数据作为一个整体，并进行纵向计算</li>
<li>语法：<code>select 聚合函数(字段列表) from 表名</code></li>
<li>常见聚合函数<code>count,max,min,avg,sum</code></li>
<li>注意事项：null不参与聚合函数</li>
</ul>
</li>
<li>语法：
<ul>
<li>分组查询：<code>select 字段列表 from 表名 [where 条件]  group 分组字段名 [having 分组过滤后的条件]</code></li>
</ul>
</li>
<li>where和having区别
<ul>
<li>
<ol>
<li>执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组之后对结果进行过滤</li>
</ol>
</li>
<li>
<ol start="2">
<li>判断条件不同：where不能对聚合函数进行判断，而having可以</li>
</ol>
</li>
</ul>
</li>
<li>注意事项：
<ul>
<li>分组后，查询的字段为分组字段和聚合函数，查询其它字段无意义</li>
<li>执行顺序：where&gt;聚合函数&gt;having</li>
</ul>
</li>
</ul>
</li>
<li>
<p>排序查询</p>
<ul>
<li>语法：
<ul>
<li>条件查询：<code>select 字段列表 from 表名 [where 条件列表][group by 分组字段] order by 字段1 排序方式1, 字段2 排序方式2...;</code></li>
</ul>
</li>
<li>排序方式
<ul>
<li><code>ASC</code>升序（默认值），<code>DESC</code>降序</li>
</ul>
</li>
</ul>
</li>
<li>
<p>分页查询</p>
<ul>
<li>语法：<code>select 字段列表 from 表名 limit 起始索引,查询记录数</code></li>
<li>注意事项：
<ul>
<li>
<ol>
<li>起始索引从0开始，起始索引=(查询页码-1)*每页显示记录数</li>
</ol>
</li>
<li>
<ol start="2">
<li>分页查询是数据库的方言，不同数据库实现不同</li>
</ol>
</li>
<li>
<ol start="3">
<li>如果查询的数据是第一页的数据，起始索引可以省略</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>函数</p>
<ul>
<li><code>if(表达式,tvalue,fvalue)</code>:当表达式为true时，取tvalue，否则取fvalue</li>
<li><code>case expr when value1 then result1 [when value2 then result2..][else result] end</code> 类似switch语句</li>
</ul>
</li>
</ul>
<h3 id="05-%E5%A4%9A%E8%A1%A8%E8%AE%BE%E8%AE%A1" tabindex="-1">05 多表设计</h3>
<ul>
<li>
<p>一对多</p>
<ul>
<li>使用外键约束，保证数据的一致性和完整性</li>
<li>外键语法：</li>
</ul>
<pre><code class="language-sql"># 创建时添加外键
create table 表名(
  字段民 数据类型,
  ...
  [constraint] [外键名称] foreign key (外键字段名) references 主表 (字段名)
);
# 创建后添加外键
alter table 表名 add constraint 外键名称 foreign key (外键字段名) references 主表(字段名) 
</code></pre>
<ul>
<li>物理外键
<ul>
<li>概念：使用<code>foreign key</code>定义外键关联另一张表</li>
<li>缺点：
<ul>
<li>影响增删改的效率（需要查外键关系）</li>
<li>仅用于单节点数据库，不适用于分布式，集群场景</li>
<li>容易引发数据库的死锁问题，消耗性能</li>
</ul>
</li>
<li>引起缺点在企业中已经很少使用，甚至明文禁止</li>
</ul>
</li>
<li>逻辑外键
<ul>
<li>概念：在业务层逻辑，解决外键连接</li>
<li>通过逻辑外键，可以很方便解决</li>
</ul>
</li>
</ul>
</li>
<li>
<p>一对一</p>
<ul>
<li>关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其它字段放在另一张表中，以提升效率</li>
<li>实现：在任意一方加入外键，关联另一方的主键，并且设置外键为唯一的。</li>
</ul>
</li>
<li>
<p>多对多</p>
<ul>
<li>关系：一个学生可以选多个课程，一个课程可供多个学生选择</li>
<li>实现：建立第三张表，中间表至少包含两个外键，分别关联两方主键</li>
</ul>
</li>
</ul>
<h3 id="06-%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2" tabindex="-1">06 多表查询</h3>
<ul>
<li>
<p>概念：从多个表中查询数据</p>
<ul>
<li>笛卡尔积</li>
<li>内连接</li>
<li>外连接
<ul>
<li>左外连接：查询左表所有数据（包括两张表交集部分数据）</li>
<li>右外连接：查询右表所有数据（包括两张表交集部分数据）</li>
</ul>
</li>
<li>子查询</li>
</ul>
</li>
<li>
<p>内连接</p>
<ul>
<li>语法
<ul>
<li>隐式内连接：<code>select 字段列表 from 表1,表2 where 条件 ...;</code></li>
<li>显式内连接：<code>select 字段列表 from 表1 [inner] join 表2 on 条件;</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>左外连接：<code>select 字段列表 from 表1 left [outer] join 表2 on 连接条件</code></p>
</li>
<li>
<p>左外连接：<code>select 字段列表 from 表1 right [outer] join 表2 on 连接条件</code></p>
</li>
<li>
<p>子查询</p>
<ul>
<li>介绍：SQL语句种嵌套select语句，称为嵌套查询，又称子查询</li>
<li>形式：<code>select * from t1 where column1 = (select column1 from t2 ..)</code></li>
<li>子查询外部的语句可以是insert/update/delete/select的任何一个，最常见的是select</li>
<li>分类
<ul>
<li>标量子查询，列子查询，行子查询，表子查询</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="07-%E4%BA%8B%E5%8A%A1" tabindex="-1">07 事务</h3>
<ul>
<li>介绍
<ul>
<li>概念：事务是一组操作集合，他是一个不可分割的工作单位。事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败</li>
<li>注意事项：默认MySQL的事务是自动提交的，即当执行依据DML语句，MySQL会立即隐式地提交事务</li>
</ul>
</li>
<li>事务控制
<ul>
<li>开启事务：<code>start transaction; / begin</code></li>
<li>提交事务：<code>commit</code></li>
<li>回归事务：<code>rollback</code></li>
</ul>
</li>
<li>事务四大特性
<ul>
<li>原子性Atomicity  ：事务是不可分割的最小单位，要么全部成功，要么全部失败</li>
<li>一致性Consistency：事务完成时，必须使所有的数据都保持一致性</li>
<li>隔离性Isolation  ：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li>
<li>持久性Durability ：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li>
</ul>
</li>
</ul>
<h3 id="08-%E7%B4%A2%E5%BC%95" tabindex="-1">08 索引</h3>
<ul>
<li>
<p>概念：帮助数据库高效获取数据的数据结构</p>
</li>
<li>
<p>优点：</p>
<ul>
<li>提高数据查询效率，降低数据库IO成本</li>
<li>通过索引列对数据进行排序，降低数据排序成本，降低CPU消耗</li>
</ul>
</li>
<li>
<p>缺点</p>
<ul>
<li>索引会占据存储空间</li>
<li>索引大大提高了查询效率，但降低了增删改的效率</li>
<li>然而缺点影响不大，当今企业存储空间已经不是问题，且一个正常的数据库系统90%是查询操作</li>
</ul>
</li>
<li>
<p>结构</p>
<ul>
<li>MySQL数据库支持的索引结构很多，如：hash索引，B+Tree索引，Full-Text索引等。但MySQL默认索引为B+Tree结果组织的索引。</li>
</ul>
</li>
<li>
<p>语法</p>
<ul>
<li>创建索引：<code>creat [unique] index 索引名 on 表名(字段名)</code></li>
<li>查看索引：<code>show index from 表名</code></li>
<li>删除索引：<code>drop index 索引名 on 表名</code></li>
</ul>
</li>
<li>
<p>注意事项：</p>
<ul>
<li>主键字段，在建表时，会自动创建主键索引</li>
<li>添加唯一约束时，数据库实际上会添加唯一索引</li>
</ul>
</li>
</ul>
<h2 id="mybaits" tabindex="-1">MyBaits</h2>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1m84y1w7Tb?p=116&amp;vd_source=240b8edf72530a8ec2d9f48cc6514072">课程连接</a></p>
<ul>
<li>Mybaits是一款优秀的持久层（即三层中的第三层）框架，用于简化JDBC的开发</li>
<li></li>
</ul>
<h3 id="01-mybatis%E5%85%A5%E9%97%A8" tabindex="-1">01 Mybatis入门</h3>
<ul>
<li>
<p>使用Mybatis查询所有用户数据</p>
<ul>
<li>1 准备工作（创建springboot工程，数据库表user，实体类User）</li>
<li>2 引入Mybatis的相关依赖，配置Mybaits(数据库连接信息)</li>
<li>3 编写SQL语句（注解/XML）</li>
</ul>
</li>
<li>
<p>配置SQL提示</p>
</li>
<li>
<p>JDBC（Java DataBase Connectivity）,就是使用Java语言操作关系型数据库的一套API</p>
<ul>
<li>本质
<ul>
<li>sun公司官方定义的一套操作所用关系型数据的规范，即接口</li>
<li>各个数据库厂商去实现这套接口，提供数据库的驱动jar包</li>
<li>使用这套接口编程，真正执行的是驱动jar包中的代码</li>
</ul>
</li>
</ul>
</li>
<li>
<p>数据库连接池</p>
<ul>
<li>概念
<ul>
<li>数据库连接池是一个容器，负责分配，管理数据库连接</li>
<li>允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个</li>
<li>释放空闲时间超过最大空闲时间的连接，来避免因为没有释放连接而引起的数据库连接遗漏</li>
</ul>
</li>
<li>优势
<ul>
<li>资源重用</li>
<li>提升系统响应速度</li>
<li>避免数据库连接遗漏</li>
</ul>
</li>
<li>便准接口：DataSource
<ul>
<li>官方sun提供的供数据库连接池接口，由第三方组织实现该接口</li>
<li>功能：获取连接</li>
</ul>
</li>
</ul>
</li>
<li>
<p>lombok</p>
<ul>
<li>定义：Lombok是一个实用的java类库，能通过注解的形式自动生成构造器getter/setter,equals,hashcode,toString等方法，并可以自动化生成日志变量，简化java开发，提高效率</li>
</ul>
<table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Getter/@Setter</td>
<td>为所有属性提供get/set方法</td>
</tr>
<tr>
<td>@ToString</td>
<td>会给类自动生成易读的toString方法</td>
</tr>
<tr>
<td>@EqualsAndHashCode</td>
<td>根据类所拥有的非静态字段自动重写equals方法和hashcode方法</td>
</tr>
<tr>
<td>@Data</td>
<td>提供了更综合的生成代码功能（包含以上四个方法）</td>
</tr>
<tr>
<td>@NoArgsConstructor</td>
<td>为实体类生成无参的构造器方法</td>
</tr>
<tr>
<td>@AllArgsConstructor</td>
<td>为实体类生成除static修饰的字段之外带有各参数的构造器方法</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3 id="02-mybatis%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C" tabindex="-1">02 Mybatis基础操作</h3>
<ul>
<li>
<p>准备</p>
</li>
<li>
<p>删除</p>
<ul>
<li>SQL语句：<code>delete from emp where id=17</code></li>
<li>接口方法：</li>
</ul>
<pre><code class="language-java">@Delete(&quot;delete from emp where id=#&#123;id&#125;&quot;)
//也可以是@Delete(&quot;delete from emp where id=$&#123;id&#125;&quot;)
//但#&#123;&#125;为预编译，$&#123;&#125;为直接嵌入
public void delete(Integer id);
</code></pre>
<ul>
<li>如果mapper接口方法形参只有一个普通类型的参数，#{…}里面的属性名可以随便写，否则要对应</li>
<li>日志输出：再application.properties中配置<code>mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl</code>，打开mybatis日志，并指定输出到控制台中</li>
<li>预编译
<ul>
<li>性能更高</li>
<li>更安全（防止SQL注入 ）
<ul>
<li>sQL注入：通过操作输入的数据来修改实现定义好的SQL语句，以达到执行代码对服务器进行攻击的方法</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>新增</p>
<ul>
<li>SQL语句</li>
</ul>
<pre><code class="language-sql">insert into emp(username, name, gender, image, job, entrydate, dept_id, create_time, update_time)
    values ('Tom','汤姆','1','1.jpg',1,'2005-01-01',1,now(),now())
</code></pre>
<ul>
<li>接口方法</li>
</ul>
<pre><code class="language-java">@Options(useGeneratedKeys = true,keyProperty = &quot;id&quot;)//该注解可以返回生成的主键，默认是不返回的
@Insert(&quot;insert into emp(username, name, gender, image, job, entrydate, dept_id, create_time, update_time)&quot; +
          &quot; values (#&#123;username&#125;,#&#123;name&#125;,#&#123;gender&#125;,#&#123;image&#125;,#&#123;job&#125;,#&#123;entrydate&#125;,#&#123;deptId&#125;,#&#123;createTime&#125;,#&#123;updateTime&#125;)&quot;)
  public void insert(Emp emp);
</code></pre>
</li>
<li>
<p>更新</p>
<ul>
<li>SQL语句</li>
</ul>
<pre><code class="language-sql">update emp set username='',name='',gender='',image='',job='',
entrydate='',dept_id='',create_time='',update_time='' where id=1;
</code></pre>
<ul>
<li>接口方法</li>
</ul>
<pre><code class="language-java">@Update(&quot;update emp set username=#&#123;username&#125;,name=#&#123;name&#125;,gender=#&#123;gender&#125;,image=#&#123;image&#125;,&quot;+
&quot;job=#&#123;job&#125;,entrydate=#&#123;entrydate&#125;,dept_id=#&#123;deptId&#125;,update_time=#&#123;updateTime&#125; where id=#&#123;id&#125;&quot;)
  public void update(Emp emp);
</code></pre>
</li>
<li>
<p>查询</p>
<ul>
<li>SQL语句：<code>select * from emp where id=15</code></li>
<li>接口方法：</li>
</ul>
<pre><code class="language-java">@Select(&quot;select * from emp where id=#&#123;id&#125;&quot;)
  public Emp getById(Integer id);
</code></pre>
<ul>
<li>mybatis数据封装
<ul>
<li>实体类属性名和数据库表查询返回的字段名一致，mybatis会自动封装</li>
<li>不一致时解决方案：
<ul>
<li>
<ol>
<li>在sql语句中起别名</li>
</ol>
</li>
<li>
<ol start="2">
<li>通过<code>@Results,@Result</code>注解手动映射</li>
</ol>
</li>
<li>
<ol start="3">
<li>通过mybaits的驼峰命名自动映射开关</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>条件查询</p>
<ul>
<li>SQL语句</li>
</ul>
<pre><code class="language-sql">select * from emp where name like '%张%' and gender = 1 and entrydate between '2010-01-01' and '2020-01-01' order by update_time desc
</code></pre>
<ul>
<li>接口方法</li>
</ul>
<pre><code class="language-java">@Select(&quot;select * from emp where name like concat('%',#&#123;name&#125;,'%') and gender = #&#123;gender&#125; and &quot; +
  &quot;entrydate between #&#123;begin&#125; and #&#123;end&#125; order by update_time desc&quot;)
  public List&lt;Emp&gt; list(String name, short gender, LocalDate begin,LocalDate end);
</code></pre>
</li>
</ul>
<h3 id="03-xml%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6" tabindex="-1">03 XML映射文件</h3>
<p>//之后在本次突击还没用到，以后闲了看看</p>
<h3 id="04-mybatis%E5%8A%A8%E6%80%81sql" tabindex="-1">04 Mybatis动态SQL</h3>
<h2 id="spring" tabindex="-1">Spring</h2>
<p>Spring技术是JavaEE开发必备技能，企业开发技术选型命中率&gt;90%</p>
<ul>
<li>
<p>简化开发，降低企业级开发的复杂性</p>
</li>
<li>
<p>框架整合，高效整合其它技术，提高企业级应用开发和运行效率</p>
</li>
<li>
<p>学什么？</p>
<ul>
<li>IoC</li>
<li>AOP</li>
<li>事务处理</li>
<li>框架整合</li>
</ul>
</li>
<li>
<p>怎么学？</p>
<ul>
<li>学习Spring框架的设计思想</li>
<li>学习基础操作，思考操作与思想间的联系</li>
<li>学习案例，熟练应用操作的同时，体会思想</li>
</ul>
</li>
</ul>
<h3 id="1-spring-%E5%88%9D%E8%AF%86" tabindex="-1">1 Spring 初识</h3>
<ul>
<li>Spring 既是一门技术，也是一套项目，已经形成了开发的生态圈，Spring 全家桶</li>
<li>包含重点：
<ul>
<li>Spring Framework：基础框架，全家桶所有都基于此</li>
<li>Spring Boot：Spring开发已经更简单，该技术让Spring开发更迅速</li>
<li>Spring Cloud：提供分布式开发相关技术</li>
</ul>
</li>
</ul>
<h3 id="2-spring-framework" tabindex="-1">2 Spring Framework</h3>
<ul>
<li>该项目为Spring生态圈最基础的项目<br>
<img src="/images/web/spring/Spring4.0%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg" alt="Spring4.0架构图"></li>
<li>然而该架构配置繁琐，入门难度大</li>
<li>为此推出Spring Boot 简化配置和快速开发</li>
</ul>
<h3 id="3-spring-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5" tabindex="-1">3 Spring 核心概念</h3>
<ul>
<li>
<p>Ioc/DI</p>
</li>
<li>
<p>IoC容器</p>
</li>
<li>
<p>Bean</p>
</li>
<li>
<p>IoC (Inversion of Control) 控制反转</p>
<ul>
<li>使用对象时，由主动new产生对象转换为由外部提供对象，此过程中对像创建控制权由程序转移到外部，此思想称为控制反转</li>
</ul>
</li>
<li>
<p>Spring技术对IoC技术进行了实现</p>
<ul>
<li>Spring提供了一个容器，称为IoC容器，用来充当IoC思想中的“外部”</li>
<li>IoC容器负责对象的创建，初始化等一系列工作，被创建或被管理的对象再IoC容器里称为<code>Bean</code></li>
</ul>
</li>
<li>
<p>DI (Dependency Injection) 依赖注入</p>
<ul>
<li>在容器中简历bean和bean之间的依赖关系的整个过程，称为依赖注入</li>
</ul>
</li>
<li>
<p>核心概念</p>
<ul>
<li>目标：充分解耦
<ul>
<li>使用IoC容器管理bean（IoC）</li>
<li>在IoC容器内将有依赖关系的bean进行关系绑定（DI）</li>
</ul>
</li>
<li>最终效果
<ul>
<li>使用对象时不仅可以直接从IoC容器中获取，并且获取到的bean已经绑定了所有的依赖关系</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-ioc%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B" tabindex="-1">4 IoC入门案例</h3>
<ol>
<li>管理什么？（Service与Dao）</li>
<li>如何将管理的对象告知IoC容器（配置）</li>
<li>被管理的对象交给IoC容器，如何获取IoC容器（接口）</li>
<li>IoC容器得到后，如何获得其中bean（接口方法）</li>
<li>使用Spring导入哪些坐标（pos.xml）</li>
</ol>
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2023/03/22/git%E5%AD%A6%E4%B9%A0/" title="git学习"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: git学习</span></a><a class="button is-default" href="/2023/03/07/%E6%9C%AC%E7%A7%91/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" title="编译原理（未完）"><span class="has-text-weight-semibold">Next: 编译原理（未完）</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="Haojen/Claudia-theme-blog" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/Mrcold2002"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Mr_cold 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>
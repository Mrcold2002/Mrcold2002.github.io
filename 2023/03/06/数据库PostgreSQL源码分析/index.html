<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>数据库试验--PostgreSQL源码分析--遗传算法的使用</title><meta name="description" content="菜"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="[toc]

源码地址
1 PostgreSQL的体系结构PostgreSQL数据库由连接管理系统(系统控制器)、编译执行系统、存储管理系统、事务系统、系统表五大部分组成

连接管理系统接受外部操作对系统的请求，对操作请求进行预处理和分发，起系统逻辑控制作用
编译执行系统由查询编译器、查询执行器组成，完成操作请求在数据库中的分析处理和转化工作，最终实现物理存储介质中数据的操作
存储管理系统由索引管理器、内存管理器、外存管理器组成，负责存储和管理物理数据，提供对编译查询系统的支持;
事务系统囱事务管理器、日志管理器、并发控制、锁管理器组成，日志管理器和事务管理器完成对操作请求处理的事务一致性支持，锁管理器和并发控制提供对并发访问数据的一致性支持
系统表是 PostgreSQL 数据库的元信息管理中心，包括数据.."><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Mr_cold's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">数据库试验--PostgreSQL源码分析--遗传算法的使用</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-PostgreSQL%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-text">1 PostgreSQL的体系结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-PostgreSQL%E7%9A%84%E6%9F%A5%E8%AF%A2%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5%E4%B8%AD%E7%9A%84%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95"><span class="toc-text">2 PostgreSQL的查询编译阶段中的遗传算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%9F%A5%E8%AF%A2%E8%A7%84%E5%88%92%E7%9A%84%E6%80%BB%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="toc-text">3 查询规划的总体流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%B7%AF%E5%BE%84%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95"><span class="toc-text">4 路径生成算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0"><span class="toc-text">5 遗传算法概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-PostgreSQL%E4%B8%AD%E7%9A%84%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95"><span class="toc-text">6 PostgreSQL中的遗传算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E4%B8%AA%E4%BD%93%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F%E5%8F%8A%E7%A7%8D%E7%BE%A4%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">（1）个体编码方式及种群初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E9%80%82%E5%BA%94%E5%80%BC"><span class="toc-text">（2）适应值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E7%88%B6%E4%BD%93%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5"><span class="toc-text">（3）父体选择策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E6%9D%82%E4%BA%A4%E7%AE%97%E5%AD%90"><span class="toc-text">（4）杂交算子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-%E8%BE%B9%E9%87%8D%E7%BB%84%E6%9D%82%E4%BA%A4"><span class="toc-text">a 边重组杂交</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-%E9%83%A8%E5%88%86%E5%8C%B9%E9%85%8D%E6%9D%82%E4%BA%A4"><span class="toc-text">b 部分匹配杂交</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-%E5%BE%AA%E7%8E%AF%E6%9D%82%E4%BA%A4"><span class="toc-text">c 循环杂交</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#d-%E5%9F%BA%E4%BA%8E%E4%BD%8D%E7%BD%AE%E7%9A%84%E6%9D%82%E4%BA%A4"><span class="toc-text">d 基于位置的杂交</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#e-%E9%A1%BA%E5%BA%8F%E6%9D%82%E4%BA%A4ox1"><span class="toc-text">e 顺序杂交ox1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#f-%E9%A1%BA%E5%BA%8F%E6%9D%82%E4%BA%A4ox2"><span class="toc-text">f 顺序杂交ox2</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E5%8F%98%E5%BC%82%E7%AE%97%E5%AD%90"><span class="toc-text">（5）变异算子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%886%EF%BC%89%E7%BB%88%E6%AD%A2%E6%9D%A1%E4%BB%B6"><span class="toc-text">（6）终止条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%887%EF%BC%89%E5%9F%BA%E4%BA%8E%E6%8E%92%E5%88%97%E7%94%9F%E6%88%90%E8%B7%AF%E5%BE%84"><span class="toc-text">（7）基于排列生成路径</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">7 源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E7%9B%AE%E5%BD%95%E5%88%86%E6%9E%90"><span class="toc-text">源码目录分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#src-backend-optimizer%E7%9B%AE%E5%BD%95%E5%88%86%E6%9E%90"><span class="toc-text">src&#x2F;backend&#x2F;optimizer目录分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#geqo%E4%B8%8B%E7%9A%84%E4%BB%A3%E7%A0%81%E5%85%B7%E4%BD%93%E5%88%86%E6%9E%90"><span class="toc-text">geqo下的代码具体分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-geqo-main-c"><span class="toc-text">(1) geqo_main.c</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-geqo-misc-c"><span class="toc-text">(2) geqo_misc.c</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-geqo-mutation-c"><span class="toc-text">(3) geqo_mutation.c</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-geqo-pool-c"><span class="toc-text">(4) geqo_pool.c</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-geqo-random-c"><span class="toc-text">(5) geqo_random.c</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-geqo-selection-c"><span class="toc-text">(6) geqo_selection.c</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-geqo-copy-c"><span class="toc-text">(7) geqo_copy.c</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E5%87%A0%E4%B8%AA%E6%9D%82%E4%BA%A4%E7%AE%97%E5%AD%90%E6%96%87%E4%BB%B6"><span class="toc-text">(8) 几个杂交算子文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-geqo-eval-c"><span class="toc-text">(9) geqo_eval.c</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-geqo-recombination-c"><span class="toc-text">(10) geqo_recombination.c</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E6%80%BB%E7%BB%93"><span class="toc-text">8 总结</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93"><i class="tag post-item-tag">数据库</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">数据库试验--PostgreSQL源码分析--遗传算法的使用</h1><time class="has-text-grey" datetime="2023-03-06T09:20:30.100Z">2023-03-06</time><article class="mt-2 post-content"><p>[toc]</p>
<p><img src="/images/meitu/5.jpg"></p>
<p><a target="_blank" rel="noopener" href="https://github.com/postgres/postgres.git">源码地址</a></p>
<h2 id="1-PostgreSQL的体系结构"><a href="#1-PostgreSQL的体系结构" class="headerlink" title="1 PostgreSQL的体系结构"></a>1 PostgreSQL的体系结构</h2><p>PostgreSQL数据库由连接管理系统(系统控制器)、编译执行系统、存储管理系统、事务系统、系统表五大部分组成</p>
<ul>
<li>连接管理系统接受外部操作对系统的请求，对操作请求进行预处理和分发，起系统逻辑控制作用</li>
<li>编译执行系统由查询编译器、查询执行器组成，完成操作请求在数据库中的分析处理和转化工作，最终实现物理存储介质中数据的操作</li>
<li>存储管理系统由索引管理器、内存管理器、外存管理器组成，负责存储和管理物理数据，提供对编译查询系统的支持;</li>
<li>事务系统囱事务管理器、日志管理器、并发控制、锁管理器组成，日志管理器和事务管理器完成对操作请求处理的事务一致性支持，锁管理器和并发控制提供对并发访问数据的一致性支持</li>
<li>系统表是 PostgreSQL 数据库的元信息管理中心，包括数据库对象信息和数据库管理控制信息,系统表管理元数据信息，将 PostgreSQL 数据库的各个模块有机地连接在一起，形成个高效的数据管理系统。</li>
</ul>
<h2 id="2-PostgreSQL的查询编译阶段中的遗传算法"><a href="#2-PostgreSQL的查询编译阶段中的遗传算法" class="headerlink" title="2 PostgreSQL的查询编译阶段中的遗传算法"></a>2 PostgreSQL的查询编译阶段中的遗传算法</h2><p>查询处理器是数据库管理系统中的一个部件集合，它允许用户使用 SQL 语言在较高层次上表达查询，其主要职责是将用户的各种命令转化成数据库上的操作序列并执行。查询处理分查询编译和查询执行两个阶段。</p>
<p>当PostgreSQL 的后台服务进程接收到查询语句后，首先将其传递到查询分析模块，进行词法、语法和语义分析 若是简单的命令(例如建表、创建用户、备份等)则将其分配到功能性命令处理模块;</p>
<p>对于复杂的命令( SELECT/INSERT/DELETEl UPDA四)则要为其构建查询树( Query 结构体) .然后交给查询重写模块。查询重写模块接收到查询树后，按照该查询所涉及的规则和视图对查询树进行重写，生成新的查询树。</p>
<p>生成路径模块依据重写过的查询树，考虑关系的访问方式、连接方式和连接顺序等问题，采用动态规划算法或遗传算法，生成最优的表连接路径 最后，由最优路径生成可执行的计划，并将其传递到查询执行模块执行。</p>
<p>因此PG中的遗传算法的使用主要在生成最优的表链接路径上</p>
<h2 id="3-查询规划的总体流程"><a href="#3-查询规划的总体流程" class="headerlink" title="3 查询规划的总体流程"></a>3 查询规划的总体流程</h2><p>查询规划的最终目的是得到可被执行器执行的最优计划，整个过程可分为预处理、生成路径和生成计划三个阶段。</p>
<ul>
<li>预处理实际上是对查询树( Query 结构体)的进一步改造，这种改造可通过 SQL语句体现。在此过程中，最重要的是提升子链接和提升子查询。</li>
<li>在生成路径阶段，接收到改造后的查询树后，采用动态规划算法或遗传算法，生成最优连接路径和候选的路径链表。</li>
<li>在生成计划阶段，用得到的最优路径 首先生成基本计划树，然后添加 GROUPBY HAVING ORDER BY 子句所对应的计划节点形成 整计划树</li>
</ul>
<h2 id="4-路径生成算法"><a href="#4-路径生成算法" class="headerlink" title="4 路径生成算法"></a>4 路径生成算法</h2><p>路径代表了对一个表或者多个表中数据的访问方式。</p>
<p>由于单个表的访问方式(顺序访问、索引访问)、两个表间的连接方式(嵌套循环连接、归并连接、 Hash 连接)以及多个表间的连接顺序(左连接、右连接和布希连接)都有多种，因此访问 表或多个袤的路径也会有多种，</p>
<p>每个路径都可能是上述访问方式、连接方式和连接顺序的一种组合。查询执行模块只需要执行效率最高的路径。因此在准备计划时，查询规划器需要考虑所有的路径，并从中挑选出最优的路径来生成执行计划，这个生成并挑选最优路径的工作由路径生成算法完成</p>
<p>PostgreSQL 中有两种路径生成算法:动态规划算法和遗传算法。</p>
<p>动态规划算法是生成路径的默认算法，但在某些情况下，检查一个查询所有可能的路径会花去很多的时间和内存空间，特别是所要执行的查询涉及大量的关系的时候。在这种情况下，为了在合理的时间里判断一个合理的执行计划， PostgreSQ 将使用遗传算法生成路径。</p>
<p>是否启用遗传算法由两个因素决定:</p>
<ul>
<li>在系统配置中是否允许使用遗传算法：由全局变量enable_geqo控制，其值来自于配置文件中的 geqo 配置项，默认情况下是允许。</li>
<li>需要连接的基本关系是否超过使用遗传算法的阈值：由全局变量geqo_threshold 控制，其值来自于配置文件中的geqo_threshold配置选项，<br>默认值是 12 ，即参加连续的基本关系数大于或等于 12 时就会采用遗传算法来生成路径</li>
</ul>
<h2 id="5-遗传算法概述"><a href="#5-遗传算法概述" class="headerlink" title="5 遗传算法概述"></a>5 遗传算法概述</h2><p>遗传算法 (GA) 是一种种启发式的优化方法 (heuristic optimization method) ，它通过既定的随机搜索进行操作。</p>
<p>优化问题的可能解的集合被认为是个体(individuals)组成的种群(population).一个个体对它的环境的适应程度由它的适应值(fitness) 。一个个体在搜索空间里的参照物是用染色体(chromosomes)表示的,实际上这是一套字符串。一个基因(gene)是染色体的一个片段，基因是被优化的单个参数的编码。对一个基因的典型的编码 以是二进制 (binary)或整数(integer)。通过仿真进化过程的重组(recombination)、变异(mutation) 和选择(selection )找到新一代的搜索点，它们的平均适应值要比它们的祖先好。</p>
<p>在PostgreSQL中，遗传算法将路径作为个体，将个体以某种方式编码(个体体现了连接顺序),然后通过重组得到后代，考虑连接代价来计算后代的适应值，再选择合适的后代进行下一次迭代。当到达一定的迭代次数之后，遗传算法终止。选择遗传算法可以减少生成路径的时间，但是遗传算法并不一定能找到”最好”的规划，它只能找到相对较优的路径。</p>
<h2 id="6-PostgreSQL中的遗传算法"><a href="#6-PostgreSQL中的遗传算法" class="headerlink" title="6 PostgreSQL中的遗传算法"></a>6 PostgreSQL中的遗传算法</h2><p>PostgreSQ 中，遗传算法主要用在连接路径的生成操作中，其流程如下：</p>
<p><img src="/images/PostgreSQL/GA_process.jpg" alt="GA_process"></p>
<h3 id="（1）个体编码方式及种群初始化"><a href="#（1）个体编码方式及种群初始化" class="headerlink" title="（1）个体编码方式及种群初始化"></a>（1）个体编码方式及种群初始化</h3><p>PG中用遗传算法解决表连接的问题的方式类似于TSP问题。可能的连接路径被当作整数串进行编码。v每个穿代表查询中的一种可能的连接顺序。</p>
<p>如下图的查询书可以用整数串<code>&quot;4132&quot;</code>编码,即首先连接表”4”和”1” 得到的结果表再和表 “3” 连接，最后再和”2” 连接。</p>
<p><img src="/images/PostgreSQL/查询树1.jpg" alt="查询树"></p>
<p>遗传算法执行第一步为随机初始化种群。假设种群大小为n，首先随机初始化n个排列树，每一个排列数即是一个个体。然后基于n各排列数生成的基本表的连接路径，在此过程中进行代价评估，将最后的代价作为适应值衡量该个体的优劣。</p>
<p>每一个个体都用Chromosome结构表示，记录了个体的排列和代价</p>
<pre><code class="lang-c">typedef int Gene;
typedef struct Chromosome&#123;
    Gene *string;//染色体的数据值
    Cost worth;//对染色体的代价评估
&#125;//Chromosome
</code></pre>
<h3 id="（2）适应值"><a href="#（2）适应值" class="headerlink" title="（2）适应值"></a>（2）适应值</h3><p>个体的适应值等于该个体中N个表的连接代价。适应值计算由geqo_eval实现，包括以下步骤：</p>
<ol>
<li>检查个体的有效性</li>
<li>确定个体的连接次序以及连接方式</li>
<li>计算个体的适应值</li>
</ol>
<p>计算个体的适应值时.首先要检查个体是否有效。也就是说，对一个给定的个体，能不能把这个个体中的表按照某种次序连接起来，因为有些表之间是不能连接的。如果一个个体按任何次序都不能连接，那么这么个体是无效的。对于有效的个体，还要确定连续次序和连接方式。在连接次序和连接方式确定之后才能计算个体的</p>
<h3 id="（3）父体选择策略"><a href="#（3）父体选择策略" class="headerlink" title="（3）父体选择策略"></a>（3）父体选择策略</h3><p>附体选择策略是基于排名的选择策略，选择概率函数如下公式。<br>其中max是个体总数，bias默认值是2.0，geo_rand是0.0~1.0之间的随机数，f(geo_rand)表示当前个体在种群中的编号（该编号是根据当前个体的适应值在种群中的排名来确定）。<br>该函数表明，排名越前的个体被选择的概率越大。</p>
<script type="math/tex; mode=display">f(geo\_rand)=\left\{
\begin{array}{rcl}
max*\frac{bias-A}{2*bias-1}&& {A<0}\\
max*\frac{bias-\sqrt{A}}{2*bias-1}&& {A\geq 0}\\
其中,A=bias*bias-4*(bias-1)*geo\_rand
\end{array} \right.</script><h3 id="（4）杂交算子"><a href="#（4）杂交算子" class="headerlink" title="（4）杂交算子"></a>（4）杂交算子</h3><p>PostgreSQL 中的遗传算法提供 边重组杂交、部分匹配杂交、循环杂交、基于位置的杂交和顺序杂交等多种杂交算子，用于从父辈种群中产生新的后代个体，默认使用的是边重组杂交算法</p>
<h4 id="a-边重组杂交"><a href="#a-边重组杂交" class="headerlink" title="a 边重组杂交"></a>a 边重组杂交</h4><p>边重组杂交算子自函数gimme_edge_table和gimme_tour实现。函数 gimme_edge_table 用来计算边关系;函数 gimme_tour由边关系得到后代。<br>边重组杂交过程如下：</p>
<ol>
<li>两个父体中的基因构成循环队列<br><img src="/images/PostgreSQL/GA_ERX.jpg" alt="查询树"></li>
<li>确定父体间的边关系<br>在步骤1中的循环队列中，任意一个基因和相邻的基因构成“边关系”。如果某“边关系”同时在父体1和父体2中出现，则称为“共享边”。</li>
<li>由边关系得到后代<br>边重组杂交的基本思想是:随机地选择一个基因作为起始点，顺着它的边关系找到下一<br>个基因(优先考虑共享边) ，再顺着找到的基因的边关系找到第三个基因，直到找到的基因能够构成一个个体为止，最后将找到的基因按找到的顺序组成一个个体即可。</li>
</ol>
<h4 id="b-部分匹配杂交"><a href="#b-部分匹配杂交" class="headerlink" title="b 部分匹配杂交"></a>b 部分匹配杂交</h4><p>由函数pmx实现，该函数流程如下：</p>
<ol>
<li>在字串上均匀随机地选择两点，由这两点确定的子串称为映射段，定义两个整型变量left和right(left&lt; right) 表示选取的映射段的起始边界。</li>
<li>用父体2的映射段替换父体1的映射段产生原始后代。</li>
<li>确定两映射段之间的映射关系</li>
<li>根据映射关系将后代合法化</li>
</ol>
<h4 id="c-循环杂交"><a href="#c-循环杂交" class="headerlink" title="c 循环杂交"></a>c 循环杂交</h4><p>循环杂交算子由函数 cx 实现，该方法从一个双亲中取一些基因，而其他的基因则取自另外一个双亲。</p>
<p>该方法首先随机确定一个初始位置，作为当前位置，把父体1当前位置下的基因(即编<br>号)赋值给当前位置下的子代，并标记此基因已被使用 然后推进当前位置到父体2当前位置(未修改前的位置)下的基因在父体1中的位置，同样把父体1当前位置下的基因赋值给当前位置下的子代。<br>同理推进当前位置，生成子代的基因片段，直到循环到初始位置下父体1的基因与父体2中的当前位置下的基因一样时循环结束。如果循环结束后仍有部分基因没有被使用，则将父体2中的这些基因按在父体2中存在的位置赋值到子代中同样位置。</p>
<h4 id="d-基于位置的杂交"><a href="#d-基于位置的杂交" class="headerlink" title="d 基于位置的杂交"></a>d 基于位置的杂交</h4><p>基于位置的杂交算子由函数 px 实现，该函数的处理流程如下:</p>
<ol>
<li>根据基因数目 gene ，首先随机选择一个区间[gene/3 , 2/3 * gene ]中的整数p,从父体1中随机选择p个基因，设为集合A</li>
<li>对于在A中的基因，从父体1拷贝到后代中对应的位置上。</li>
<li>不在A中的基因，按它们在父体2中的顺序拷贝到后代剩余的位置上。</li>
</ol>
<h4 id="e-顺序杂交ox1"><a href="#e-顺序杂交ox1" class="headerlink" title="e 顺序杂交ox1"></a>e 顺序杂交ox1</h4><p>顺序杂交算子有两种：OX1和OX1。OX1算子由函数 ox1 实现，函数 oxl 的处理流程如下:</p>
<ol>
<li>从第一个父体中随机选择一个子串。</li>
<li>将子串复制到一个空串的相应位置，产生一个原始后代。</li>
<li>删去第二个父体中子串已有的基因，得到原始后代需要的其他基因的顺序。</li>
<li>按照这个基因顺序，从左到右将这些基因复制到后代的空缺位置上。</li>
</ol>
<h4 id="f-顺序杂交ox2"><a href="#f-顺序杂交ox2" class="headerlink" title="f 顺序杂交ox2"></a>f 顺序杂交ox2</h4><p>OX2 算子由函数ox2实现，其处理流程如下:</p>
<ol>
<li>根据基因的数目 gene ，随机选择一个 [gene/3 , 2/3 * gene] 之间的整数 ，从父体1中随机选择p个基因，设为集合A</li>
<li>对于父体2中不在A中基因，拷贝到后代对应的位置中。</li>
<li>对在A中的基因，按它们在父体 中的顺序依次拷贝到后代剩余的位中。</li>
</ol>
<h3 id="（5）变异算子"><a href="#（5）变异算子" class="headerlink" title="（5）变异算子"></a>（5）变异算子</h3><p>变异算子由函数geqo_mutation实现，该函数随机地从父体中产生两个变异位，交换这两个变异位的数值，执行num_gene(基因数目)次这样的操作。</p>
<h3 id="（6）终止条件"><a href="#（6）终止条件" class="headerlink" title="（6）终止条件"></a>（6）终止条件</h3><p>遗传算法采用设定演化代数的方法，但演化到一定数量的代数时，就停止演化。默认的演化代数是种群的大小(pool_size ，缓冲池的大小)。演化代数的计算涉及下面两个参数:</p>
<ol>
<li>geqo_effort :整型变量，是用于限制种群大小的影响因子。取值范围是 [1 10 ]，默认值为5</li>
<li>geqo_pool_size :整型变量 ，表示缓冲池(用于存储种群中的个体)大小.缓冲池的大小和种群大小相同， 其值至少为2</li>
</ol>
<p>种群大小(缓冲池的大小) pool_size 由函数伊gimme_pool_size 确定，其参数 nr_rel 为查询中表的数量。计算方法如下:</p>
<ol>
<li>计算上限值 maxsize和下限值minsize<script type="math/tex; mode=display">maxsize=50*geqo_effort\\minsize=10*geqo_effort</script></li>
<li>计算基准大小$size=pow(2.0,nr_rel+1.0)$</li>
<li>如果基准大小位于上限值和下限值之间，则取基准大小作为种群大小;如果低于下限值，则取下限值;如果高于上限值，则取上限值</li>
</ol>
<h3 id="（7）基于排列生成路径"><a href="#（7）基于排列生成路径" class="headerlink" title="（7）基于排列生成路径"></a>（7）基于排列生成路径</h3><p>在遗传算法中由排列生成连接路径由以下算法实现</p>
<p><img src="/images/PostgreSQL/GA_creat_path.jpg" alt="GA_creat_path"></p>
<p>其中变量rels中保存了按照排列数所对应的各个基本关系（即基本表）。<br>变量rels_temp用来保存当前不可连接的关系。（不可连接指只能用笛卡尔积进行连接）</p>
<p>该算法的处理过程：</p>
<p>依次取rels中的所有基本表，在rels_temp中依次寻找可以与其连接的表，如果存在可连接的表，则把这两个表进行连接生成新的表，并从头开始继续在rels_temp中寻找可连接的表，并将其与新生成的表连接，一直到找不到可连接的表位置，最后将最终生成的新表插入rels_temp结尾；继续在rels中取下一个表，重复上述过程。</p>
<h2 id="7-源码分析"><a href="#7-源码分析" class="headerlink" title="7 源码分析"></a>7 源码分析</h2><h3 id="源码目录分析"><a href="#源码目录分析" class="headerlink" title="源码目录分析"></a>源码目录分析</h3><p>access文件夹包含各种存储访问方法、索引的实现。(重要)<br>bootstrap文件夹为数据库初始化时调用方法。<br>catalog文件夹为系统目录。<br>commands文件夹为SQL命令。(重要)<br>executor文件夹为执行器相关代码。(重要)<br>foreign文件夹为FDW相关代码，使得用户可以通过SQL访问没有存储在数据库中的数据。(扩展)<br>jit文件夹为Just-In-Time Compilation，为即时编译的相关代码，用于提高查询语句性能。（扩展）<br>lib文件夹为通用函数。<br>libpq文件夹为c/cpp的库函数，处理与客户端的通信。<br>main文件夹为主程序。<br>nodes文件夹为链表、节点等数据结构，以及相关的方法。(重要)<br>optimizer文件夹为优化器相关代码。(重要)<br>parser文件夹为编译器相关代码。(重要)<br>partitioning文件夹为分片相关代码。(重要)<br>po文件夹为语言文件配置。<br>port文件夹为平台兼容性处理相关代码。<br>postmaster文件夹为postmaster进程，以及相关辅助进程的代码。<br>regex文件夹为正则处理相关代码。(重要)<br>replication文件夹为有关流复制的相关代码。(重要)<br>rewrite文件夹为规则与视图相关的重写处理。<br>snowball文件夹为全文检索相关（语干处理）代码。<br>statisics文件夹为收集统计信息相关代码，与估算相关。<br>storage文件夹为管理各种类型存储系统相关代码。(重要)<br>tcop文件夹为postgres服务进程的主要处理部分，即查询流程调用的相关代码。(重要)<br>tsearch文件夹为全文检索。(扩展)<br>utils文件夹为各种支持函数，如错误报告、各种初始化操作、内存管理等。</p>
<p>我的分析任务：PG中遗传算法的使用分析</p>
<p>在文件src/backend/optimizer/geqo中为<code>遗传优化计划器</code></p>
<h3 id="src-backend-optimizer目录分析"><a href="#src-backend-optimizer目录分析" class="headerlink" title="src/backend/optimizer目录分析"></a>src/backend/optimizer目录分析</h3><p>该目录下的文件使用解析器返回的查询结构，生成执行器使用的计划。</p>
<p>/plan目录生成实际的输出计划<br>/path目录生成所有可能的连接表的方法<br>/geqo目录下位单独的“遗传优化”计划器<br>/prep目录处理特殊情况下的预处理步骤<br>/util目录下为公用的模块</p>
<h3 id="geqo下的代码具体分析"><a href="#geqo下的代码具体分析" class="headerlink" title="geqo下的代码具体分析"></a>geqo下的代码具体分析</h3><h4 id="1-geqo-main-c"><a href="#1-geqo-main-c" class="headerlink" title="(1) geqo_main.c"></a>(1) geqo_main.c</h4><p>其中共有三个函数</p>
<ul>
<li><p><code>RelOptInfo * geqo(PlannerInfo *root, int number_of_rels, List *initial_rels)</code><br>  该函数为遗传算法优化的主函数，通过调用该函数来用遗传算法生成查询计划。<br>  该函数有三个参数</p>
<ul>
<li><code>root</code>：PlannerInfo 结构体包含有关正在优化的查询的各种信息，包括涉及的表、连接条件以及可能相关的任何约束或索引。遗传算法使用此信息生成潜在查询计划并评估其适合度。</li>
<li><code>number_of_rels</code>：这个整数表示正在优化的关系数，即查询中涉及的表数。</li>
<li><code>initial_rels</code>：这是一个 RelOptInfos 的 List，表示正在优化的初始关系。</li>
</ul>
</li>
</ul>
<p>函数返回一个指向 RelOptInfo 结构体的指针，该结构体表示遗传算法找到的最佳查询计划。</p>
<p>随后该函数依次完成：</p>
<p>初始化数据；获得随机数种子；设置GA相关参数；为缓冲池分配空间；随机初始化缓冲池；并按适应值对缓冲池中的个体进行排序；为重组杂交进行空间分配；进行遗传算的迭代，依次进行选择重组变异；选择最优个体；释放空间；返回最优个体。</p>
<p>该函数为遗传算法的主要部分，main函数。</p>
<ul>
<li><code>static int gimme_pool_size(int nr_rel)</code><br>该函数用于确定缓冲池大小（种群大小）</li>
<li><code>static int gimme_number_generations(int pool_size)</code><br>从该函数得到迭代次数</li>
</ul>
<h4 id="2-geqo-misc-c"><a href="#2-geqo-misc-c" class="headerlink" title="(2) geqo_misc.c"></a>(2) geqo_misc.c</h4><p>该文件下函数主要进行调试使用，对算法中间的结果进行输出</p>
<ol>
<li><code>static double avg_pool(Pool *pool)</code><br>返回平均代价值</li>
<li><code>void print_pool(FILE *fp, Pool *pool, int start, int stop)</code><br>输出当前种群中所有个体的染色体和代价</li>
<li><code>void print_gen(FILE *fp, Pool *pool, int generation)</code><br>输出某一代基因的最好，最坏，中位数和平均代价值</li>
<li><code>void print_edge_table(FILE *fp, Edge *edge_table, int num_gene)</code><br>输出边重组杂交的边表</li>
</ol>
<h4 id="3-geqo-mutation-c"><a href="#3-geqo-mutation-c" class="headerlink" title="(3) geqo_mutation.c"></a>(3) geqo_mutation.c</h4><p>只有一个函数，对种群中的个体实施变异操作<br><code>void geqo_mutation(PlannerInfo *root, Gene *tour, int num_gene)</code></p>
<h4 id="4-geqo-pool-c"><a href="#4-geqo-pool-c" class="headerlink" title="(4) geqo_pool.c"></a>(4) geqo_pool.c</h4><p>该文件中包含与缓冲区的相关函数</p>
<ol>
<li><code>Pool * alloc_pool(PlannerInfo *root, int pool_size, int string_length)</code><br>为遗传算法缓冲器分配空间</li>
<li><code>void free_pool(PlannerInfo *root, Pool *pool)</code><br>释放1函数中分配的空间</li>
<li><code>voidrandom_init_pool(PlannerInfo *root, Pool *pool)</code><br>随机初始化缓冲池</li>
<li><code>void sort_pool(PlannerInfo *root, Pool *pool)</code><br>从小到大按适应度排序缓冲池中的个体</li>
<li><code>static int compare(const void *arg1, const void *arg2)</code><br>排序的方法，源码中使用快速排序算法</li>
<li><code>Chromosome * alloc_chromo(PlannerInfo *root, int string_length)</code><br>为个体分配空间</li>
<li><code>void free_chromo(PlannerInfo *root, Chromosome *chromo)</code><br>释放为个体分配的空间</li>
<li><code>void spread_chromo(PlannerInfo *root, Chromosome *chromo, Pool *pool)</code><br>插入一个新的个体到缓冲池中，代替缓冲池中的最差的个体</li>
</ol>
<h4 id="5-geqo-random-c"><a href="#5-geqo-random-c" class="headerlink" title="(5) geqo_random.c"></a>(5) geqo_random.c</h4><p>该文件用来产生随机数，含有三个函数</p>
<ol>
<li><code>void geqo_set_seed(PlannerInfo *root, double seed)</code><br>设置GEQO随机数生成器的种子，以确保每次运行GEQO时使用相同的随机数序列</li>
<li><code>double geqo_rand(PlannerInfo *root)</code><br>函数使用了简单的线性同余算法来生成伪随机数。该函数返回一个范围在 0 到 1 之间的双精度浮点数</li>
<li><code>int geqo_randint(PlannerInfo *root, int upper, int lower)</code><br>函数的作用是生成一个介于 upper 和 lower 之间的随机整数。</li>
</ol>
<h4 id="6-geqo-selection-c"><a href="#6-geqo-selection-c" class="headerlink" title="(6) geqo_selection.c"></a>(6) geqo_selection.c</h4><p>该文件内进行父体选择</p>
<ol>
<li><code>static int linear_rand(PlannerInfo *root, int pool_size, double bias)</code><br>该函数实现线性随机选择算法,使用了类似于概率密度函数的方法，其中偏差参数用于增加某些候选项被选择的概率,用于选择父代来产生后代。</li>
<li><code>void geqo_selection(PlannerInfo *root, Chromosome *momma, Chromosome *daddy,Pool *pool, double bias)</code><br> 该函数使用随机选择过程来选择两个父染色体进行交叉。</li>
</ol>
<h4 id="7-geqo-copy-c"><a href="#7-geqo-copy-c" class="headerlink" title="(7) geqo_copy.c"></a>(7) geqo_copy.c</h4><p>该文件内只有一个函数<code>void geqo_copy(PlannerInfo *root, Chromosome *chromo1, Chromosome *chromo2,int string_length)</code>,用来复制个体</p>
<h4 id="8-几个杂交算子文件"><a href="#8-几个杂交算子文件" class="headerlink" title="(8) 几个杂交算子文件"></a>(8) 几个杂交算子文件</h4><ul>
<li>geqo_cx.c 循环杂交<br>包含函数<code>int cx(PlannerInfo *root, Gene *tour1, Gene *tour2, Gene *offspring,int num_gene, City * city_table)</code></li>
<li>geqo_erx.c 边重组杂交,包含以下函数<ul>
<li><code>Edge * alloc_edge_table(PlannerInfo *root, int num_gene)</code>为边表分配空间</li>
<li><code>void free_edge_table(PlannerInfo *root, Edge *edge_table)</code>释放边表空间</li>
<li><code>float gimme_edge_table(PlannerInfo *root, Gene *tour1, Gene *tour2, int num_gene, Edge *edge_table)</code>填充记录两个个体间的边的数据结构</li>
<li><code>static int gimme_edge(PlannerInfo *root, Gene gene1, Gene gene2, Edge *edge_table)</code>从给定基因中构建一条边并将其加入边表</li>
<li><code>int gimme_tour(PlannerInfo *root, Edge *edge_table, Gene *new_gene, int num_gene)</code>通过边表和基因返回一条可行的路径长度</li>
<li><code>static void remove_gene(PlannerInfo *root, Gene gene, Edge edge, Edge *edge_table)</code>从边表中移除该基因</li>
<li><code>static Gene gimme_gene(PlannerInfo *root, Edge edge, Edge *edge_table)</code>从给定的边表中返回一个基因</li>
<li><code>static Gene edge_failure(PlannerInfo *root, Gene *gene, int index, Edge *edge_table, int num_gene)</code>当遇到失败的边缘时，对基因进行修复</li>
</ul>
</li>
<li>geqo_pmx.c 部分匹配杂交<br>包含函数<code>void pmx(PlannerInfo *root, Gene *tour1, Gene *tour2, Gene *offspring, int num_gene)</code></li>
<li>geqo_ox1.c 顺序杂交1<br><code>void ox1(PlannerInfo *root, Gene *tour1, Gene *tour2, Gene *offspring, int num_gene,City * city_table)</code></li>
<li>geqo_ox1.c 顺序杂交2<br><code>voidox2(PlannerInfo *root, Gene *tour1, Gene *tour2, Gene *offspring, int num_gene, City * city_table)</code></li>
<li>geqo_px.c 基于位置的杂交<br><code>void px(PlannerInfo *root, Gene *tour1, Gene *tour2, Gene *offspring, int num_gene,City * city_table)</code></li>
</ul>
<h4 id="9-geqo-eval-c"><a href="#9-geqo-eval-c" class="headerlink" title="(9) geqo_eval.c"></a>(9) geqo_eval.c</h4><p>该文件对查询树进行估价</p>
<ul>
<li><code>Cost geqo_eval(PlannerInfo *root, Gene *tour, int num_gene)</code><br>返回一个个体的查询树的代价</li>
<li><code>RelOptInfo * gimme_tree(PlannerInfo *root, Gene *tour, int num_gene)</code>接收一个查询优化器（PlannerInfo）的指针和一组遗传算法的基因（Gene），然后返回一个查询优化树（RelOptInfo）。</li>
<li><code>static List * merge_clump(PlannerInfo *root, List *clumps, Clump *new_clump, int num_gene,bool force)</code>作用是合并一个新的数据块（new_clump）到一个包含多个数据块的列表中（clumps），并返回合并后的列表。参数 num_gene 表示数据块中基因的数量，而参数 force 用于控制是否强制进行合并。</li>
<li><code>static bool desirable_join(PlannerInfo *root,RelOptInfo *outer_rel, RelOptInfo *inner_rel)</code>用于确定是否应该对两个关系进行连接，这两个关系分别由 outer_rel 和 inner_rel 表示，其确定连接是否可行是基于多个因素，如连接的预估成本和选择性等</li>
</ul>
<h4 id="10-geqo-recombination-c"><a href="#10-geqo-recombination-c" class="headerlink" title="(10) geqo_recombination.c"></a>(10) geqo_recombination.c</h4><p>该文件为杂交重组程序，包含以下函数</p>
<ul>
<li><code>void init_tour(PlannerInfo *root, Gene *tour, int num_gene)</code>随机生成一条合法的“旅行推销员”路径（即每个点仅访问一次）</li>
<li><code>City * alloc_city_table(PlannerInfo *root, int num_gene)</code>为城市表分配内存</li>
<li><code>void free_city_table(PlannerInfo *root, City * city_table)</code>为城市表回收内存</li>
</ul>
<h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8 总结"></a>8 总结</h2><p>本次数据库实验我主要对PostgreSQL源码中的遗传算法部分进行了分析，分析了源码中该部分的具体函数，并了解了遗传算法在PG中的工作流程，如果之后有空，希望能研习全部的PG源码。</p>
<p>源码中遗传算法用于寻找最优的生成路径，这一点与TSP问题相似。</p>
<p>当点数过多时，使用动态规划难以求出最优解，这时就可以使用遗传算法较快地求出较优解来生成路径，提升了查询编译地速度。</p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2023/03/07/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/" title="软件分析（未完）"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: 软件分析（未完）</span></a><a class="button is-default" href="/2023/03/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%95%E9%AA%8C/" title="操作系统试验--在linux环境下复现操作系统（未完）"><span class="has-text-weight-semibold">Next: 操作系统试验--在linux环境下复现操作系统（未完）</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="Haojen/Claudia-theme-blog" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/Mrcold2002"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Mr_cold 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>
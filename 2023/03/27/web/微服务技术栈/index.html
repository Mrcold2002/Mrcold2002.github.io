<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>微服务技术栈（未完）</title><meta name="description" content="菜"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="[toc]
视频地址

认识微服务
01 服务框架演变

单体架构

概念：将业务的所有功能集中在一个项目中进行开发，打成一个包部署
优点：架构简单，部署成本低
缺点：耦合度高


分布式架构

概念：根据业务功能对系统进行拆分，每个业务模块作为独立项目开发，成为一个服务
优点：降低服务耦合，有利于服务拓展升级
考虑问题：

服务拆分粒度如何？
服务集群地址如何维护？
服务之间如何实现远程调用？
服务健康状态如何感知？




微服务：是一种经过良好架构设计的分布式架构方案

微服务架构特征：

单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责，避免重复业务开发
面向服务：微服务对外暴露业务接口
自治：团队独立，技术独立，数据独立，部署独立
隔离性强：服务调用做好隔离，容错，降级，.."><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Mr_cold's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">微服务技术栈（未完）</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A1"><span class="toc-text">认识微服务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#01-%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6%E6%BC%94%E5%8F%98"><span class="toc-text">01 服务框架演变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#02-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E5%AF%B9%E6%AF%94"><span class="toc-text">02 微服务技术对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#03-springcloud"><span class="toc-text">03 SpringCloud</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86%E4%B8%8E%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8"><span class="toc-text">服务拆分与远程调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#01-%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86"><span class="toc-text">01 服务拆分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#02-%E6%9C%8D%E5%8A%A1%E9%97%B4%E8%B0%83%E7%94%A8"><span class="toc-text">02 服务间调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#eureka-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="toc-text">Eureka 注册中心</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#01-%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">01 远程调用的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#02-eureka%E5%8E%9F%E7%90%86"><span class="toc-text">02 eureka原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#03-%E6%90%AD%E5%BB%BAeurekaserver"><span class="toc-text">03 搭建EurekaServer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#04-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C"><span class="toc-text">04 服务注册</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#05-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0"><span class="toc-text">05 服务发现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ribbon-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%8E%9F%E7%90%86"><span class="toc-text">Ribbon 负载均衡原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#01-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%8E%9F%E7%90%86"><span class="toc-text">01 负载均衡原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#02-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5"><span class="toc-text">02 负载均衡策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#03-%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-text">03 懒加载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nacos-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="toc-text">Nacos 注册中心</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http%E5%AE%A2%E6%88%B7%E7%AB%AFfeign"><span class="toc-text">http客户端Feign</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#01-feign%E6%9B%BF%E4%BB%A3resttemplate"><span class="toc-text">01 Feign替代RestTemplate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#02-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE"><span class="toc-text">02 自定义配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#03-feign%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96"><span class="toc-text">03 Feign使用优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#04-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-text">04 最佳实践</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%9F%E4%B8%80%E7%BD%91%E5%85%B3gateway"><span class="toc-text">统一网关Gateway</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#01-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%BD%91%E5%85%B3"><span class="toc-text">01 为什么需要网关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#02-gateway%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-text">02 gateway快速入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#03-%E6%96%AD%E8%A8%80%E5%B7%A5%E5%8E%82"><span class="toc-text">03 断言工厂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#04-%E8%BF%87%E6%BB%A4%E5%99%A8%E5%B7%A5%E5%8E%82"><span class="toc-text">04 过滤器工厂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#05-%E5%85%A8%E5%B1%80%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-text">05 全局过滤器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#06-%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86"><span class="toc-text">06 跨域问题处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker"><span class="toc-text">Docker</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#01-%E5%88%9D%E5%A7%8Bdocker"><span class="toc-text">01 初始Docker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#02-docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-text">02 Docker基本操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mq"><span class="toc-text">MQ</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/%E5%90%8E%E7%AB%AF"><i class="tag post-item-tag">后端</i></a><a href="/tags/web"><i class="tag post-item-tag">web</i></a><a href="/tags/IDEA"><i class="tag post-item-tag">IDEA</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">微服务技术栈（未完）</h1><time class="has-text-grey" datetime="2023-03-27T10:23:42.352Z">2023-03-27</time><article class="mt-2 post-content"><p>[toc]</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1LQ4y127n4/?p=1">视频地址</a></p>
<p><img src="/images/web/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E6%A0%88/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E6%A0%88%E5%9B%BE.jpg" alt="微服务技术栈图"></p>
<h2 id="%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A1" tabindex="-1">认识微服务</h2>
<h3 id="01-%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6%E6%BC%94%E5%8F%98" tabindex="-1">01 服务框架演变</h3>
<ul>
<li>单体架构
<ul>
<li>概念：将业务的所有功能集中在一个项目中进行开发，打成一个包部署</li>
<li>优点：架构简单，部署成本低</li>
<li>缺点：耦合度高</li>
</ul>
</li>
<li>分布式架构
<ul>
<li>概念：根据业务功能对系统进行拆分，每个业务模块作为独立项目开发，成为一个服务</li>
<li>优点：降低服务耦合，有利于服务拓展升级</li>
<li>考虑问题：
<ul>
<li>服务拆分粒度如何？</li>
<li>服务集群地址如何维护？</li>
<li>服务之间如何实现远程调用？</li>
<li>服务健康状态如何感知？</li>
</ul>
</li>
</ul>
</li>
<li>微服务：是一种经过良好架构设计的分布式架构方案
<ul>
<li>微服务架构特征：
<ul>
<li>单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责，避免重复业务开发</li>
<li>面向服务：微服务对外暴露业务接口</li>
<li>自治：团队独立，技术独立，数据独立，部署独立</li>
<li>隔离性强：服务调用做好隔离，容错，降级，避免出现级联问题</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="02-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E5%AF%B9%E6%AF%94" tabindex="-1">02 微服务技术对比</h3>
<ul>
<li>微服务这种方案需要技术框架来落地，国内最知名为SpringCloud和阿里巴巴的Duddo<br>
<img src="/images/web/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E6%A0%88/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E5%AF%B9%E6%AF%94.jpg" alt="微服务技术对比"></li>
</ul>
<h3 id="03-springcloud" tabindex="-1">03 SpringCloud</h3>
<ul>
<li>SpringCloud是目前全球使用最广泛的微服务框架</li>
<li>SpringCloud集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配，从而提供了良好的开箱即用体验</li>
<li>SpringCloud和SpringCloud搭配使用需要注意版本兼容</li>
</ul>
<h2 id="%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86%E4%B8%8E%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8" tabindex="-1">服务拆分与远程调用</h2>
<h3 id="01-%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86" tabindex="-1">01 服务拆分</h3>
<ul>
<li>服务拆分注意事项
<ul>
<li>
<ol>
<li>不同微服务，不要重复开发相同业务</li>
</ol>
</li>
<li>
<ol start="2">
<li>微服务数据独立，不要访问其它微服务的数据库</li>
</ol>
</li>
<li>
<ol start="3">
<li>微服务可以将自己的业务暴露为接口，供其它微服务调用</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="02-%E6%9C%8D%E5%8A%A1%E9%97%B4%E8%B0%83%E7%94%A8" tabindex="-1">02 服务间调用</h3>
<ul>
<li>
<p>微服务调用方式</p>
<ul>
<li>基于RestTemplate发起的http请求实现远程调用</li>
<li>http请求做远程调用是与语言无关的调用，只需直到对方的ip，端口，接口路径，请求参数即可</li>
</ul>
</li>
<li>
<p>步骤：</p>
<ul>
<li>
<ol>
<li>注册RestTemplate</li>
</ol>
</li>
</ul>
<pre><code class="language-java"> @Bean
  public RestTemplate restTemplate()&#123;
      return new RestTemplate();
  &#125;
</code></pre>
<ul>
<li>
<ol start="2">
<li>服务远程调用RestTempla</li>
</ol>
</li>
</ul>
<pre><code class="language-java">  @GetMapping(&quot;&#123;orderId&#125;&quot;)
  public Order queryOrderByUserId(@PathVariable(&quot;orderId&quot;) Long orderId) &#123;
      // 1. 查询订单
      Order order=orderService.queryOrderById(orderId);
      // 2. 利用RestTemplate发起http请求，查询用户
      //(1)url路径
      String url=&quot;http://localhost:8081/user/&quot;+order.getUserId();
      //(2)发送http请求，实现远程调用
      User user=restTemplate.getForObject(url,User.class);
      // 3. 封装user到Order
      order.setUser(user);
      // 4. 返回
      return order;
  &#125;
</code></pre>
</li>
<li>
<p>服务调用关系</p>
<ul>
<li>服务提供者：暴露接口给其它微服务调用</li>
<li>服务消费者：调用其他微服务提供的接口</li>
<li>提供者和消费者角色是相对的</li>
<li>一个服务可以同时是服务提供者和消费者</li>
</ul>
</li>
</ul>
<h2 id="eureka-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83" tabindex="-1">Eureka 注册中心</h2>
<h3 id="01-%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98" tabindex="-1">01 远程调用的问题</h3>
<ul>
<li>服务消费者该如何获取服务提供者的地址信息?</li>
<li>如果有多个服务者，消费者如何选择?</li>
<li>消费者如何得知服务提供者的健康状态?</li>
</ul>
<h3 id="02-eureka%E5%8E%9F%E7%90%86" tabindex="-1">02 eureka原理</h3>
<p><img src="../../images/web/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E6%A0%88/Eureka%E4%BD%9C%E7%94%A8%E5%9B%BE.jpg" alt></p>
<ul>
<li>
<p>服务消费者该如何获取服务提供者的地址信息?</p>
<ul>
<li>服务提供者启动时向eureka注册自己的信息</li>
<li>eureka保存这些信息</li>
<li>消费者根据服务名称向eureka拉取提供者信息</li>
</ul>
</li>
<li>
<p>如果有多个服务者，消费者如何选择?</p>
<ul>
<li>服务消费者利用负载均衡算法选择一个执行</li>
</ul>
</li>
<li>
<p>消费者如何得知服务提供者的健康状态?</p>
<ul>
<li>服务提供者每30s向eurekaServer发送心跳请求，报告健康状态</li>
<li>eureeure</li>
</ul>
</li>
<li>
<p>在Eureka架构中，微服务角色有两类</p>
<ul>
<li>EurekaServer：服务端，注册中心
<ul>
<li>记录服务信息，心跳监控</li>
</ul>
</li>
<li>EureClient：客户端
<ul>
<li>Provider：服务提供者
<ul>
<li>注册自己的信息到EurekaServer</li>
<li>每隔30s向EurekaServer发送心跳</li>
</ul>
</li>
<li>consumer：服务消费者
<ul>
<li>根据服务名称从EurekaServer拉取服务列表</li>
<li>基于服务列表做负载均衡，选中一个微服务后发起远程调用</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="03-%E6%90%AD%E5%BB%BAeurekaserver" tabindex="-1">03 搭建EurekaServer</h3>
<ul>
<li>搭建步骤
<ul>
<li>
<ol>
<li>创建项目，引入依赖</li>
</ol>
</li>
</ul>
<pre><code class="language-xml">&lt;dependency&gt;
      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
      &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;
  &lt;/dependency&gt;
</code></pre>
<ul>
<li>
<ol start="2">
<li>编写启动类，添加@EnableEurekaServer注解</li>
</ol>
</li>
</ul>
<pre><code class="language-java">  @EnableEurekaServer
  @SpringBootApplication
  public class EurekaApplication &#123;
  public static void main(String[] args) &#123;
      SpringApplication.run(EurekaApplication.class,args);
      &#125;
  &#125;
</code></pre>
<ul>
<li>
<ol start="3">
<li>添加application.yml文件，编写配置</li>
</ol>
</li>
</ul>
<pre><code class="language-yaml">  server:
      port: 10086
  spring:
      application:
          name: eurekaserver #eureka服务名称
  eureka:
      client:
          service-url:
              defaultZone: http://127.0.0.1:10086/eureka
</code></pre>
</li>
</ul>
<h3 id="04-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C" tabindex="-1">04 服务注册</h3>
<ul>
<li>步骤如下：
<ul>
<li>
<ol>
<li>在user-service项目引入<code>spring-cloud-starter-netflix-eureka-client</code>的依赖</li>
</ol>
</li>
</ul>
<pre><code class="language-xml">  &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
      &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
  &lt;/dependency&gt;
</code></pre>
<ul>
<li>
<ol start="2">
<li>在<code>application.yml</code>文件，编写下面配置</li>
</ol>
</li>
</ul>
<pre><code class="language-yaml">  server:
      port: 10086
  spring:
      application:
          name: eurekaclient #eureka服务名称
  eureka:
      client:
          service-url:
              defaultZone: http://127.0.0.1:10086/eureka
</code></pre>
</li>
</ul>
<h3 id="05-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0" tabindex="-1">05 服务发现</h3>
<ul>
<li>服务拉取是基于服务名称获取服务列表，然后在对服务列表做负载均衡
<ul>
<li>
<ol>
<li>修改代码，修改url路径，用服务名代替ip和端口号<br>
<code>String url=&quot;http://userservice/user/&quot;+order.getUserId();</code></li>
</ol>
</li>
<li>
<ol start="2">
<li>在项目启动类中添加负载均衡注解</li>
</ol>
</li>
</ul>
<pre><code class="language-java">    @LoadBalanced
  public RestTemplate restTemplate()&#123;
      return new RestTemplate();
  &#125;
</code></pre>
</li>
</ul>
<h2 id="ribbon-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%8E%9F%E7%90%86" tabindex="-1">Ribbon 负载均衡原理</h2>
<h3 id="01-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%8E%9F%E7%90%86" tabindex="-1">01 负载均衡原理</h3>
<p><img src="images/web/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E6%A0%88/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%B5%81%E7%A8%8B.jpg" alt="负载均衡流程"><br>
<img src="images/web/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E6%A0%88/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%B5%81%E7%A8%8B2.jpg" alt="负载均衡流程2"></p>
<h3 id="02-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5" tabindex="-1">02 负载均衡策略</h3>
<p><img src="/images/web/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E6%A0%88/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5.jpg" alt="负载均衡策略"></p>
<ul>
<li>通过定义rule可以修改负载均衡规则
<ul>
<li>
<ol>
<li>代码方式：在order-service中的OrderApplication类中，定义一个新的Rule，这种方法会对整个项目起作用，配置灵活，但修改时需要重新打包</li>
</ol>
</li>
</ul>
<pre><code class="language-java">@Bean
public IRule randomRule()&#123;
  return new RandomRule();
&#125;
</code></pre>
<ul>
<li>
<ol start="2">
<li>配置文件方式：在order-service的application.yml文件中，添加新的配置也可以修改规则,直观方便，不需要重新打包，但无法做全局配置</li>
</ol>
</li>
</ul>
<pre><code class="language-yml">userservice:
  ribbon:
    NFLoadBalancerRuleClassName:com.netflix.loadbalancer.RandomRule
</code></pre>
</li>
</ul>
<h3 id="03-%E6%87%92%E5%8A%A0%E8%BD%BD" tabindex="-1">03 懒加载</h3>
<ul>
<li>Ribbon默认是采用懒加载，即第一访问时才回去创建LoadBalanceClient，请求时间较长。</li>
<li>而饥饿加载会在项目启动时创建，降低第一次访问的时间消耗，通过下面配置饥饿加载</li>
</ul>
<pre><code class="language-yml">ribbon:
  eager-load:
    enabled: true
    clients: userservice # 指定对userservice这个服务饥饿加载
</code></pre>
<h2 id="nacos-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83" tabindex="-1">Nacos 注册中心</h2>
<p>这里暂时不需要，以后再来填坑<br>
<img src="https://www.bilibili.com/video/BV1LQ4y127n4?p=17&amp;spm_id_from=pageDriver&amp;vd_source=240b8edf72530a8ec2d9f48cc6514072" alt="视频地址"></p>
<h2 id="http%E5%AE%A2%E6%88%B7%E7%AB%AFfeign" tabindex="-1">http客户端Feign</h2>
<h3 id="01-feign%E6%9B%BF%E4%BB%A3resttemplate" tabindex="-1">01 Feign替代RestTemplate</h3>
<ul>
<li>
<p>RestTempla存在的问题</p>
<pre><code class="language-java">String url=&quot;http://userservice/user/&quot;+order.getUserId();
User user=restTemplate.getForObject(url,User.class);
</code></pre>
<ul>
<li>代码可读性差，编程体验不统一</li>
<li>参数复杂URL难以维护</li>
</ul>
</li>
<li>
<p>Feign 是一个声明式htpp客户端，其作用可以让我们更优雅的实现http发送请求</p>
</li>
<li>
<p>定义和使用Feign客户端：</p>
<ul>
<li>
<ol>
<li>引入依赖</li>
</ol>
</li>
</ul>
<pre><code class="language-xml">  &lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
  &lt;/dependency&gt;
</code></pre>
<ul>
<li>
<ol start="2">
<li>在order-service的启动类中添加注解开启Feign开关<code>@EnableFeignClients</code></li>
</ol>
</li>
<li>
<ol start="3">
<li>编写Feign客户端，主要基于SpringMVC的注解来声明说成调用信息</li>
</ol>
</li>
</ul>
<pre><code class="language-java">@FeignClient(&quot;userservice&quot;)
public interface UserClient &#123;
  @GetMapping(&quot;/user/&#123;id&#125;&quot;)
  User findById(@PathVariable(&quot;id&quot;) Long id);
&#125;
</code></pre>
<ul>
<li>
<ol start="4">
<li>使用FeignClien中定义的方法代替RestTemplate</li>
</ol>
</li>
</ul>
<pre><code class="language-java">public Order queryOrderById(Long orderId) &#123;
      // 1.查询订单
      Order order = orderMapper.findById(orderId);
      // 2. 利用Feign远程调用
      User user=userClient.findById(order.getUserId());
      // 3。 封装user到Order
      order.setUser(user);
      // 4.返回
      return order;
  &#125;
</code></pre>
</li>
</ul>
<h3 id="02-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE" tabindex="-1">02 自定义配置</h3>
<p><img src="/images/web/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E6%A0%88/Feign%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE.jpg" alt></p>
<ul>
<li>配置feign的日志
<ul>
<li>
<ol>
<li>配置文件方式</li>
</ol>
</li>
</ul>
<pre><code class="language-yaml">feign:
  client:
    config:
      default/userservice: #默认为全局配置，或使用服务名仅针对某个服务 
        loggerLevel: FULl # 日志级别
</code></pre>
<ul>
<li>
<ol start="2">
<li>使用java代码</li>
</ol>
</li>
</ul>
<pre><code class="language-java">public class DefaultFeignConfiguration &#123;
  @Bean
  public Logger.Level logLevel()&#123;return Logger.Level.BASIC;&#125;
&#125;
</code></pre>
</li>
</ul>
<h3 id="03-feign%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96" tabindex="-1">03 Feign使用优化</h3>
<ul>
<li>优化手段
<ul>
<li>
<ol>
<li>使用连接池代替默认的URLConnection</li>
</ol>
<ul>
<li>引入HTTPClient依赖</li>
</ul>
</li>
</ul>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt;
    &lt;artifactId&gt;feign-httpclient&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-yml">feign:
  httpclient:
    enable: true # 支持HttpClient开关
    max-connections: 200 #最大连接数
    max-connections-per-route: 50 #单个路径最大连接数
</code></pre>
<ul>
<li>
<ol start="2">
<li>日志级别，最好用basic或none</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="04-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5" tabindex="-1">04 最佳实践</h3>
<ul>
<li>
<ol>
<li>继承：给消费者的FeignClient和提供者的controller定义统一的父接口作为标准</li>
</ol>
<ul>
<li>服务紧耦合（API已经相同了）</li>
<li>父接口参数列表中的映射不会被继承</li>
</ul>
</li>
<li>
<ol start="2">
<li>抽取：将FeignClient抽取为独立模块，并且把接口有关的POJO，默认的Feign配置都放到这个模块中，提供给所有消费者使用</li>
</ol>
</li>
<li>
<p>抽取实践</p>
<ul>
<li>步骤：
<ul>
<li>
<ol>
<li>首先创建一个module，命名为feign-api，然后引入feign的starter依赖</li>
</ol>
</li>
<li>
<ol start="2">
<li>将order-service中编写的UserClient，User，DefaultFeignConfiguration都复制到feign-api项目中</li>
</ol>
</li>
<li>
<ol start="3">
<li>在order-service中引入feign-api依赖</li>
</ol>
</li>
<li>
<ol start="4">
<li>修改order-service中的所有与上述三个组件相关部分的import部分，改成导入feign-api的包</li>
</ol>
</li>
<li>
<ol start="5">
<li>重启测试</li>
</ol>
</li>
</ul>
</li>
<li>当定义的FeignClient不在SpringBootApplication的扫描包范围时，这些FeignClien无法使用，有两种解决办法
<ul>
<li>
<ol>
<li>指定FeignClient所在包<code>@EnableFeignClients(basePackages=&quot;cn.itcast.feign.clients&quot;)</code></li>
</ol>
</li>
<li>
<ol start="2">
<li>指定FeignCLient字节码<code>@EnableFeignClients(clients=&#123;UserClient&#125;)</code></li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="%E7%BB%9F%E4%B8%80%E7%BD%91%E5%85%B3gateway" tabindex="-1">统一网关Gateway</h2>
<h3 id="01-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%BD%91%E5%85%B3" tabindex="-1">01 为什么需要网关</h3>
<ul>
<li>
<p>网关功能</p>
<ul>
<li>身份认证和权限校验</li>
<li>服务路由，负载均衡</li>
<li>请求限流</li>
</ul>
</li>
<li>
<p>在springcloud中网关的实现有两种</p>
<ul>
<li>gateway和zuul</li>
<li>zuul是基于Servlet的实现，属于阻塞式编程。</li>
<li>而SpringCloudGateway则是属于Spring5中提供的WebFlux，属于响应式编程的实现，具有更好的性能。</li>
</ul>
</li>
</ul>
<h3 id="02-gateway%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8" tabindex="-1">02 gateway快速入门</h3>
<ul>
<li>搭建网关服务的步骤
<ul>
<li>
<ol>
<li>创建新的moudle，引入SpringCloudGateway的依赖和eureka的服务发现依赖</li>
</ol>
</li>
</ul>
<pre><code class="language-xml">&lt;!--gateway--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;!--eureka--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>
<ol start="2">
<li>编写路由配置及eureka地址</li>
</ol>
<ul>
<li>路由配置包括：
<ul>
<li>
<ol>
<li>路由id：路由的唯一标识</li>
</ol>
</li>
<li>
<ol start="2">
<li>路由目标uri：路由的目标地址，http代表目标地址，lb代表根据服务名负载均衡</li>
</ol>
</li>
<li>
<ol start="3">
<li>路由断言predicates：判断路由的规则</li>
</ol>
</li>
<li>
<ol start="4">
<li>路由过滤器filters：对请求或响应做处理</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-yml">server:
port: 10010
spring:
  application:
    name: gateway
  cloud:
    gateway:
      routes:
        - id: user-service # 路由标识
          uri: lb://userservice #路由的目标地址
          predicates: #路由断言，判断请求是否符合规则
            - Path=/user/** # 路径断言，判断路径是否以/user开头，如果是则符合
        - id: order-service
          uri: lb://orderservice
          predicates:
            - Path=/order/**
</code></pre>
</li>
</ul>
<p><img src="/images/web/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E6%A0%88/%E7%BD%91%E5%85%B3%E6%9C%8D%E5%8A%A1%E5%9B%BE%E8%A7%A3.jpg" alt="网关服务图解"></p>
<h3 id="03-%E6%96%AD%E8%A8%80%E5%B7%A5%E5%8E%82" tabindex="-1">03 断言工厂</h3>
<ul>
<li>在配置文件中写的断言规则只是字符串，这些字符串会被Pred Factory读取并处理，转变为路由判断的条件</li>
</ul>
<p><img src="/images/web/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E6%A0%88/%E6%96%AD%E8%A8%80%E5%B7%A5%E5%8E%82.jpg" alt></p>
<p>具体使用可以参考<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/">官网</a></p>
<h3 id="04-%E8%BF%87%E6%BB%A4%E5%99%A8%E5%B7%A5%E5%8E%82" tabindex="-1">04 过滤器工厂</h3>
<ul>
<li>路由过滤器GatewayFilter
<ul>
<li>GatewaFilter是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理</li>
<li>Spring提供了31种不同的路由过滤器工厂，同样详见<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/">官网</a></li>
</ul>
<pre><code class="language-yml">spring:
  application:
    name: gateway
  cloud:
    gateway:
      routes:
        - id: user-service # 路由标识
          uri: lb://userservice #路由的目标地址
          predicates: #路由断言，判断请求是否符合规则
           - Path=/user/** # 路径断言，判断路径是否以/user开头，如果是则符合
        - id: order-service
          uri: lb://orderservice
          predicates:
           - Path=/order/**
          filters:
            - AddRequestHeader = &quot;&quot; # 添加请求头
      #default-filters: 这个是全路由过滤器，对所有的路由都生效，与routes平级
        #- AddRequestHeader = &quot;&quot; # 添加请求头
</code></pre>
</li>
</ul>
<h3 id="05-%E5%85%A8%E5%B1%80%E8%BF%87%E6%BB%A4%E5%99%A8" tabindex="-1">05 全局过滤器</h3>
<ul>
<li>全局过滤器GlobalFilter的作用也是处理一切进入网关的请求和微服务响应，与GatewayFilter作用一样。</li>
<li>区别是GatewaFilter通过配置定义，处理逻辑是固定的。而GlobalFilter的逻辑需要自己写代码实现，定义方法是实现GlobalFilter接口</li>
<li>实现全局过滤器的步骤
<ul>
<li>
<ol>
<li>实现GlobalFilter接口</li>
</ol>
</li>
<li>
<ol start="2">
<li>添加@Order注解或实现Ordered接口</li>
</ol>
</li>
<li>
<ol start="3">
<li>编写处理逻辑</li>
</ol>
</li>
</ul>
</li>
</ul>
<pre><code class="language-java">@Order(-1)//设置优先级
@Component//bean
public class AuthorizeFilter implements GlobalFilter &#123;
    @Override
    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;
        // 1. 获取请求参数
        MultiValueMap&lt;String,String&gt; params = exchange.getRequest().getQueryParams();;
        // 2. 获取参数中的authorization参数
        String auth = params.getFirst(&quot;authorization&quot;);
        // 3. 判断参数值是否为admin
        if(&quot;admin&quot;.equals(auth))&#123;
            // 4. 是，放行
            return chain.filter(exchange);
        &#125;
        // 5. 否，拦截
        exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
        return exchange.getResponse().setComplete();
    &#125;
&#125;
</code></pre>
<ul>
<li>过滤器执行顺序
<ul>
<li>请求进入网关后会碰到三类过滤器：当前路由的过滤器，DefaultFilter，GlobalFilter。请求路由后，会将当前路由过滤器和DefaultFilter，GlobalFilter合并到一个过滤器链（集合）中，排序后依次执行每个过滤器</li>
<li>每一个过滤器都必须指定一个int类型的order值，order值越小，优先级越高，执行顺序越靠前。</li>
<li>GlobalFilter通过实现Ordered接口或者添加@Order注解来指定order值，有编码者自己指定</li>
<li>路由过滤器和defaultFilter的order由Spring指定，默认是按照声明顺序从1递增</li>
<li>当过滤器的order值一样时，会按照 defaultFilter&gt;路由过滤器&gt;GlobalFilter的顺序执行</li>
</ul>
</li>
</ul>
<h3 id="06-%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86" tabindex="-1">06 跨域问题处理</h3>
<ul>
<li>跨域：域名不一致就是跨域，主要包括
<ul>
<li>域名不同</li>
<li>域名相同，端口不同：</li>
</ul>
</li>
<li>跨域问题：浏览器禁止请求的发起者与服务端发生跨域ajax请求，请求被浏览器拦截的问题</li>
<li>解决方案：CORS</li>
<li>gateway已经实现CORS，使用者需要配置</li>
</ul>
<pre><code class="language-yml">spring:
  cloud:
    gateway:
      globalcors: # 全局的跨域处理
        add-to-simple-url-handler-mapping: true # 解决options请求被拦截问题
        corsConfigurations:
          '[/**]':
            allowedOrigins: # 允许哪些网站的跨域请求
              - &quot;http://localhost:8090&quot;
              - &quot;http://www.leyou.com&quot;
            allowedMethods: # 允许的跨域ajax的请求方式
              - &quot;GET&quot;
              - &quot;POST&quot;
              - &quot;DELETE&quot;
              - &quot;PUT&quot;
              - &quot;OPTIONS&quot;
            allowedHeaders: &quot;*&quot; # 允许在请求中携带的头信息
            allowCredentials: true # 是否允许携带cookie
            maxAge: 360000 # 这次跨域检测的有效期
</code></pre>
<h2 id="docker" tabindex="-1">Docker</h2>
<h3 id="01-%E5%88%9D%E5%A7%8Bdocker" tabindex="-1">01 初始Docker</h3>
<ul>
<li>
<p>什么是Docker？</p>
<ul>
<li>项目部署问题：大型项目组件较多，运行环境也较为复杂，部署时会碰到一些问题
<ul>
<li>依赖关系复杂，容易产生兼容性问题</li>
<li>开发，测试，生产环境有差异</li>
</ul>
</li>
<li>Docker如何解决依赖的兼容问题
<ul>
<li>将应用的Libs(函数库)，Deps(依赖)，配置和应用一起打包</li>
<li>将每个应用放到一个隔离容器去运行，避免相互干扰</li>
</ul>
</li>
<li>Docker如何解决不同系统环境的问题
<ul>
<li>Docker将用户程序与所需要调用的系统(比如Ubuntu)函数库一起打包</li>
<li>Docker运行到不同操作系统时，直接基于打包的库函数，借助于操作系统的Linux内核来运行</li>
<li>即Docker镜像中包含完整的运行环境，包含系统函数库，仅依赖系统的Linux内核，因此可以在任意Linux操作系统上运行</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Docker和虚拟机的差异</p>
<ul>
<li>docker是一个系统进程；虚拟机是在操作系统中的操作系统</li>
<li>docker体积小，启动速度快，性能好；虚拟机体积大，启动速度慢，性能一般</li>
</ul>
</li>
<li>
<p>Docker架构</p>
<ul>
<li>镜像和容器
<ul>
<li>镜像(Image):Docker将应用程序及其所需依赖，函数库，环境，配置等文件打包在一起，称为镜像</li>
<li>容器(Container):镜像中的应用程序运行后形成的进程就是容器，只是docker会给容器做隔离，对外不可见</li>
</ul>
</li>
<li>Docker和DockerHub
<ul>
<li>DockerHub：是一个Docker镜像的托管平台，这样的平台称为Docker Registry</li>
<li>国内有类似DockerHub的公开服务，如网易云镜像服务，阿里云镜像服务</li>
</ul>
</li>
<li>Docker是一个CS架构，由两部分组成
<ul>
<li>服务端(server):Docker守护进程，负责处理Docker指令，管理镜像，容器等</li>
<li>客户端(client):通过命令或RestAPI向Docker服务端发送指令。可以在本地或远程向服务端发送指令</li>
</ul>
</li>
</ul>
</li>
<li>
<p>安装Docker<br>
<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1LQ4y127n4/?p=46&amp;spm_id_from=pageDriver&amp;vd_source=240b8edf72530a8ec2d9f48cc6514072">跟着视频按即可</a></p>
</li>
</ul>
<h3 id="02-docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C" tabindex="-1">02 Docker基本操作</h3>
<ul>
<li>
<p>镜像操作<br>
<img src="/images/web/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E6%A0%88/Docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.jpg" alt="Docker基本操作"><br>
主要是查看文档</p>
</li>
<li>
<p>容器操作<br>
<img src="/images/web/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E6%A0%88/Docker%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4.jpg" alt="Docker相关命令"></p>
</li>
<li>
<p>创建一个Nginx容器</p>
<ul>
<li>去docker hub查看Nginx的容器的命令<br>
<code>docker run --name containerName -p 80:80 -d nginx</code>
<ul>
<li>命令解读：
<ul>
<li>docker run:创建并运行一个容器</li>
<li>–name：给容器起一个名字，比如叫做mn</li>
<li>-p：将宿主机端口与容器端口映射，冒号左边是宿主机端口，右侧是容器端口</li>
<li>-d：后台运行容器</li>
<li>nginx：镜像名称</li>
</ul>
</li>
</ul>
</li>
<li>查看容器日志的命令：
<ul>
<li><code>docker logs</code></li>
<li>添加-f参数可以持续查看日志</li>
</ul>
</li>
<li>查看容器状态：<code>docker ps</code></li>
</ul>
</li>
<li>
<p>数据卷（容器数据管理）</p>
</li>
</ul>
<h2 id="mq" tabindex="-1">MQ</h2>
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2023/03/29/PL/java%E5%9F%BA%E7%A1%80/" title="java基础（未完）"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: java基础（未完）</span></a><a class="button is-default" href="/2023/03/22/%E5%B7%A5%E5%85%B7/git%E5%AD%A6%E4%B9%A0/" title="git学习"><span class="has-text-weight-semibold">Next: git学习</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="Haojen/Claudia-theme-blog" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/Mrcold2002"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Mr_cold 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>
<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>Software Debloating 论文阅读 (3)</title><meta name="description" content="菜"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="
Effective Program Debloating via Reinforcement Learning (Chisel)
2018 ACM SIGSAC Conference on Computer and Communications Security (CCS ’18)　CCFA会
0 摘要

在软件工程中，代码重用和“一刀切”的方法是导致软件规模和复杂性显著增加的主要因素。由此产生的软件膨胀导致了性能下降和安全漏洞的增加。
我们提出了一个名为Chisel的系统，旨在帮助程序员有效地定制和去膨胀程序。

Chisel接受一个待去膨胀的程序和一个对其所需功能的高级别规范作为输入
输出是一个根据规范正确减少的版本的程序
与其它方法相比,Chisel通过使用一种基于强化学习的新颖方法来加速搜索减少的.."><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Mr_cold's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Software Debloating 论文阅读 (3)</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#effective-program-debloating-via-reinforcement-learning-(chisel)"><span class="toc-text">Effective Program Debloating via Reinforcement Learning (Chisel)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0-%E6%91%98%E8%A6%81"><span class="toc-text">0 摘要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8D"><span class="toc-text">1 介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-motivating-example"><span class="toc-text">2 MOTIVATING EXAMPLE</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2.1-%E6%98%8E%E7%A1%AEchisel%E7%9A%84%E8%BE%93%E5%85%A5"><span class="toc-text">2.1 明确Chisel的输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2.2-chisel%E4%B8%8E%E5%85%B6%E5%AE%83%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%93%E6%9E%9C%E6%AF%94%E8%BE%83"><span class="toc-text">2.2 Chisel与其它方法的结果比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2.3-%E5%88%86%E6%9E%90chisel%E7%9A%84%E8%BE%93%E5%87%BA"><span class="toc-text">2.3 分析Chisel的输出</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E7%A7%BB%E9%99%A4"><span class="toc-text">安全漏洞移除</span></a></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/Software%20Engineering"><i class="tag post-item-tag">Software Engineering</i></a><a href="/tags/Software%20Debloating"><i class="tag post-item-tag">Software Debloating</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">Software Debloating 论文阅读 (3)</h1><time class="has-text-grey" datetime="2023-10-31T06:49:57.632Z">2023-10-31</time><article class="mt-2 post-content"><p><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(3)_x.png" alt></p>
<h1 id="effective-program-debloating-via-reinforcement-learning-(chisel)" tabindex="-1">Effective Program Debloating via Reinforcement Learning (Chisel)</h1>
<p>2018 ACM SIGSAC Conference on Computer and Communications Security (CCS ’18)　CCFA会</p>
<h2 id="0-%E6%91%98%E8%A6%81" tabindex="-1">0 摘要</h2>
<ul>
<li>在软件工程中，代码重用和“一刀切”的方法是导致软件规模和复杂性显著增加的主要因素。由此产生的软件膨胀导致了性能下降和安全漏洞的增加。</li>
<li>我们提出了一个名为Chisel的系统，旨在帮助程序员有效地定制和去膨胀程序。
<ul>
<li>Chisel接受一个待去膨胀的程序和一个对其所需功能的高级别规范作为输入</li>
<li>输出是一个根据规范正确减少的版本的程序</li>
<li>与其它方法相比,Chisel通过使用一种基于强化学习的新颖方法来加速搜索减少的程序并扩展到大型程序，从而显著提高了效果。</li>
</ul>
</li>
<li>我们对一组包含10个广泛使用的UNIX实用程序的13-90 KLOC(Kilo lines of code) C源代码套件进行了评估，结果表明Chisel能够成功去除所有不需要的功能并减少攻击面。</li>
</ul>
<h2 id="1-%E4%BB%8B%E7%BB%8D" tabindex="-1">1 介绍</h2>
<ul>
<li>
<p>软件膨胀导致性能下降并增加安全漏洞,此外常见库中的各种gadget使得攻击者可以在不向应用程序注入任何代码的情况下执行任意算法</p>
</li>
<li>
<p>此外软件经常包含一些被用户几乎没用过的功能,但没有给用户任何实际和有效的方法去除它们</p>
<ul>
<li>目前流行的做法是对现有程序重新进行一个轻量级的实现.例如针对嵌入式平台的轻量级实现:WebServer(Lighttpd),DataBase(SQLite),C/C++ libaries(EGLIBC,yClibc-bg),命令行实用程序(BusyBox,ToyBox). 但这种方法需要源代码开源且需要大量手动工作</li>
<li>在移动应用程序中,IOS APP引入乐系统瘦身,可以自动检测用户设备型号,仅下载特定设备所需的内容,但这需要开发者标记其软件来对应关系,这导致在IOS上该方法也不常用</li>
</ul>
</li>
<li>
<p>我们开发了一个实用的系统,使得程序员能够定制和简化程序</p>
<ul>
<li>该系统将一个程序,及其需要保留功能的相关高级规范作为输入</li>
<li>输出一个根据规范正确简化的程序</li>
</ul>
</li>
<li>
<p>我们认为简化后的程序有效需要以下五个关键点</p>
<ul>
<li><strong>Minimality</strong> 最小:系统是否尽可能地 根据期望地特点 修建了程序</li>
<li><strong>Efficiency</strong> 效率:系统是否高效地 找到了最小化地程序并且可以扩展到大规模的程序</li>
<li><strong>Robustness</strong> 鲁棒:系统是否避免了 引入新的异常和漏洞 在生成的程序中</li>
<li><strong>Naturalness</strong> 自然:系统是否生成了 可维护和可扩展 的代码</li>
<li><strong>Generality</strong> 通用:系统是否可以应用于 大量不同的 程序和特点吗</li>
</ul>
</li>
<li>
<p>如下图示,Chisel系统需要一个程序P和一个质量测试函数S,来检查获选程序是否满足或与需要的属性冲突,最后输出一个最简化的程序P’同时满足S<br>
<img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(3)_1.png" alt></p>
</li>
<li>
<p>Chisel提供了一个 在生成程序最小性上的 正是保证,叫做 1-minimality,已经被证实在程序简化中有效</p>
<ul>
<li>调用质量测试函数可能很昂贵,例如其可能会参与候选程序的编译和 在程序套件运行</li>
<li>而1-minimality 保证 缩小算法在最坏情况下,调用质量测试函数的次数 为 程序大小的二次方</li>
<li>尽管 此保证 不能保证找到最优解,但也有次优性质,也很难扩展到大程序</li>
<li>而Chisel通过避免生成大量的 语义或语法上 无效的候选程序 来避免这个问题</li>
</ul>
</li>
<li>
<p>Chisel保证简化后的程序满足给定的属性期望,所以其具有鲁棒性.</p>
<ul>
<li>其避免会随换程序或破环其自然性的转换</li>
<li>最后,其将 程序和属性 都视为黑盒,使其适用于各种不同类型的程序和规范</li>
</ul>
</li>
<li>
<p>C-REDUCE 和 PERSES不满足上述特点,这两个工具同Chisel一样,接受一个需要简化的程序和一个质量测试函数作为输入,并输出一个简化的程序</p>
<ul>
<li>C-REDUCE满足了与Chisel相同的最小性和正确性标准,但其牺牲了效率,自然度和通用性.C-Reduce针对手写的程序转换规则是定制且紧密耦合的,由于这些规则是短时的,所以C-reduce在寻找简化程序时会产生大量的语义和语法无效的候选程序,此外,该工具经常生成不自然的代码</li>
<li>Perses同样牺牲了效率和通用性,其简化过程是基于语法引导的,这可以避免在搜索过程中产生语法无意义的候选程序.然而依然无法避免语义无效的候选程序,因为其无法感知程序元素间的语义依赖关系(例如def-use关系). 同时,基于语法感知的简化在每一步都太过保守,因此比C-Reduce效率更低.</li>
</ul>
</li>
<li>
<p>我们客服现有方法限制的 主要技术见解 是 使用 强化学习 来 加速程序的简化</p>
<ul>
<li>通过反复的试错,chisel构建并完善了一个静态模型,来决定每个候选程序通过测试的可能性,该模型可以有效的捕捉程序元素间的语义依赖同时引导搜索至最小程序</li>
<li>Chisel的学习方法是跨语言的,因为模型是从 尝试的候选程序和他们的属性测试结果 的简单向量中 学习的</li>
</ul>
</li>
<li>
<p>在10个UNIX上广泛使用的实用程序套件上对Chisel进行评估,Chisel高效地收敛到最小程序,由于其它所有方法.</p>
<ul>
<li>并成功修复了10个程序中的6个漏洞(CVE),平均消除了66.2%的gadgets,简化的程序通过SOTA的fuzz:AFL的持续三天的进一步验证</li>
<li>此外,我们还手动分析了简化后的源码,确认删除功能符合预期,同时保留了诸如 模块化和局部性的理想软件工程实践</li>
</ul>
</li>
<li>
<p><strong>论文贡献总结</strong></p>
<ul>
<li>
<ol>
<li>提出Chisel系统来减少程序的大小和复杂度,其目标是从现有软件中移除不需要的功能并减少他们的攻击面</li>
</ol>
</li>
<li>
<ol start="2">
<li>提出了一个通用的强化学习框架,为了更高效和更大的程序简化. 该框架可以在不同目标语言和规范上使用</li>
</ol>
</li>
<li>
<ol start="3">
<li>使用一组UNIX的通用程序对Chisel进行评估,结果显示其可以减少软件的缺陷和攻击面且不引入新的bug</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="2-motivating-example" tabindex="-1">2 MOTIVATING EXAMPLE</h2>
<ul>
<li>我们通过一个例子(Unix通用工具 tar)来解释Chisel如何帮助程序员定制和简化程序.
<ul>
<li>假设针对嵌入式 我们需要一个简易的tar,目前针对嵌入式的tar有一个BusyBox.原始的tar提供97个命令行选项,BusyBox仅提供8个</li>
<li>我们将演示如何通过向Chisel提供简单而高级的规范来自动获取与BusyBox有相同功能的程序</li>
<li>同时我们还将展示这种简化如何导致 简化的代码 和 安全性的增强. 最后我们解释了如何保证结果程序的鲁棒性</li>
</ul>
</li>
</ul>
<h3 id="2.1-%E6%98%8E%E7%A1%AEchisel%E7%9A%84%E8%BE%93%E5%85%A5" tabindex="-1">2.1 明确Chisel的输入</h3>
<ul>
<li>首先,我们需要用户编写一个高等级的特征规范,该规范描述了程序的期望功能.
<ul>
<li>规范可以是一个脚本程序,其接收一个源程序并编译,并检查编译后的程序恮输出行为是否符合期望,如果不符合返回false,否则返回true</li>
</ul>
</li>
</ul>
<pre><code class="language-bash">1 #!/bin/bash
2
3 function compile &#123;
4 clang −o tar.debloat tar−1.14.c
5 return $?
6 &#125;
7
8 function core &#123;
9 # test 1: archiving multiple files
10 touch foo bar
11 ./tar.debloat cf foo.tar foo bar
12 rm foo bar
13 ./tar.debloat xf foo.tar
14 test −f foo −a −f bar || exit 1
15
16 # test 2: extracting from stdin
17 touch foo
18 ./tar.debloat cf foo.tar foo
19 rm foo
20 cat foo.tar | ./tar.debloat x
21 test −f foo || exit 1
22 ... #12 more tests that exercise the 8 target options
23 return 0
24 &#125;
25
26 function non_core &#123;
27 for test_script in ‘ls other_tests/∗.sh‘; do # for all optional test cases
28 &#123; sh −x −e $test_script; &#125; &gt;&amp; log
29 grep 'Segmentation fault' log &amp;&amp; exit 1
30 done
31 return 0
32 &#125;
33
34 compile || exit 1
35 core || exit 1
36 non_core || exit 1
</code></pre>
<ul>
<li>上述代码是一个可用作规范的脚本程序,该脚本包括三个步骤
<ul>
<li>
<ol>
<li>第一步中调用complie函数(第三行),检查源程序是否可以编译</li>
</ol>
</li>
<li>
<ol start="2">
<li>第二步调用core函数来检查程序是否表现出期望的属性,这一步包括14个测试用例,用于测试8个命令行选项,仅在通过全部测试用例时进入下一步</li>
</ol>
<ul>
<li>例如:第14行,第一个测试用例,检测是否可以压缩和解压缩文件</li>
</ul>
</li>
<li>
<ol start="3">
<li>第三步调用non_core避免简化带来新的错误,其指定了一种要求,即调用了简化去掉的功能时,程序至少不能崩溃(第29行),如果没有这个要求,简化器可能会随意地删除非核心功能地代码,这将导致移除删除功能被调用后很容易崩溃和受到攻击</li>
</ol>
</li>
</ul>
</li>
<li>为了完成这样的脚本,我们需要广泛覆盖目标功能地测试程序,这些测试用例可以通过开发人员使用自动测试生成技术活回归测试套件来获得.本文中,使用开发人员为原始程序写的测试套件</li>
</ul>
<h3 id="2.2-chisel%E4%B8%8E%E5%85%B6%E5%AE%83%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%93%E6%9E%9C%E6%AF%94%E8%BE%83" tabindex="-1">2.2 Chisel与其它方法的结果比较</h3>
<ul>
<li>给定tar的原始程序(45778行,13227个语句),12小时内,Chisel生成了简化版本(1687行,538个语句),而C-Reduce和Perses都无法在12小时内生成简化版本,简化例子如下</li>
</ul>
<pre><code class="language-C">1 /∗ Chisel: global variable declarations removed ∗/
2 
3
4 char ∗safer_name_suffix (char ∗file_name, int link_target) &#123;
5     /∗ Chisel: code containing CVE removed ∗/
6     return file_name;
7 &#125;
8
9 void extract_archive() &#123;
10    char ∗file_name = safer_name_suffix(stat_info.file_name, 0);
11    /∗ Chisel: overwriting functionalities removed ∗/
12 &#125;
13
14 void list_archive() &#123; ... /∗ same as original ∗/ &#125;
15
16 void read_and(void ∗(do_something)(void)) &#123;
17  enum read_header status;
18  while (...) &#123;
19    status = read_header();
20      switch (status) &#123;
21        case HEADER_SUCCESS: (∗do_something)(); continue;
22        /∗ Chisel: unnecessary functionalities removed ∗/
23        default: break;
24      &#125;
25    &#125;
26 &#125;
27
28 /∗ Supports only 8 options: −c, −f, −x, −v, −t, −O, −o, −k ∗/
29 int main(int argc, char ∗∗argv) &#123;
30    int optchar;
31    while (optchar = getopt_long(argc, argv) != −1) &#123;
32        switch (optchar) &#123;
33          case 'x': read_and(&amp;extract_archive); break;
34          case 't': read_and(&amp;list_archive); break;
35          /∗ Chisel: unsupported options removed ∗/
36        &#125; 
37      &#125;
38 ... /∗ same as original ∗/
39 &#125;
/*
  Code snippet of the original version of tar
*/
1 int absolute_names;
2 int ignore_zeros_option;
3 struct tar_stat_info stat_info;
4
5 char ∗safer_name_suffix (char ∗file_name, int link_target) &#123;
6     char ∗p;
7     if (absolute_names) &#123;
8       p = file_name;
9     &#125; else &#123;
10      /∗ CVE−2016−6321 ∗/
11      /∗ Incorrect sanitization when &quot;file_name&quot; contains &quot;..&quot; ∗/
12      /∗ &quot;p&quot; points to the longest suffix of &quot;file_name&quot; without &quot;../&quot; ∗/
13      ...
14    &#125;
15    ...
16    return p;
17 &#125;
18
19 void extract_archive() &#123;
20    char ∗file_name = safer_name_suffix(stat_info.file_name, 0);
21    /∗ Overwrite &quot;file_name&quot; if exists ∗/
22    ...
23 &#125;
24
25 void list_archive() &#123; ... &#125;
26 void read_and(void ∗(do_something)(void)) &#123;
27    while (...) &#123;
28       enum read_header status = read_header();
29      switch (status) &#123;
30        case HEADER_SUCCESS: (∗do_something)(); continue;
31        case HEADER_ZERO_BLOCK:
32          if (ignore_zeros_option) continue;
33          else break;
34        ...
35        default: break;
36      &#125;
37    &#125;
38  ...
39 &#125;
40
41 /∗ Support all options: −x, −t, −P, −i, ... ∗/
42 int main(int argc, char ∗∗argv) &#123;
43    int optchar;
44    while (optchar = getopt_long(argc, argv) != −1) &#123;
45      switch (optchar) &#123;
46        case 'x': read_and(&amp;extract_archive); break;
47        case 't': read_and(&amp;list_archive); break;
48        case 'P': absolute_names = 1; break;
49        case 'i': ignore_zeros_option = 1; break;
50        ...
51      &#125;
52    &#125;
53  ...
54 &#125;
</code></pre>
<ol>
<li><code>main</code>函数中reduced版本,与原始版本比较,减少了不需要得选项</li>
<li><code>read_and</code>函数检查输入文件的头部,并在头部无效时进行异常处理,如果头部有效,根据命令调用响应函数.在简化版本中,异常处理部分被移除,头部无效即终止程序</li>
<li><code>safer_name_suffix</code>函数通过和三处冗余分支得到显著简化</li>
</ol>
<ul>
<li>实现上述简化,不能只是用典型的静态分析和动态分析
<ul>
<li>静态分析保守地保留了所有代码部分,因为在编译时命令行选项和输入文件都是未知的,因此静态方法无法删除函数<code>read_and</code>中的任何代码,因为原本代码中29行status无法确定</li>
<li>动态可达性不能删除函数<code>safer_name_suffix</code>中的任何代码,因为测试用例中没有执行选项’-P’,所以变量absolute_name总为0,结果动态方法总是覆盖第9行地分支,因此无法删除从原始代码第9行开始的讨论安全漏洞的方法</li>
</ul>
</li>
</ul>
<h3 id="2.3-%E5%88%86%E6%9E%90chisel%E7%9A%84%E8%BE%93%E5%87%BA" tabindex="-1">2.3 分析Chisel的输出</h3>
<ul>
<li>从两方面进行 输出安全漏洞和进一步验证</li>
<li>
<h2 id="%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E7%A7%BB%E9%99%A4" tabindex="-1"><strong>安全漏洞移除</strong></h2>
</li>
</ul>
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><em></em><a class="button is-default" href="/2023/10/28/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/SoftwareDebloating/Software%20Debloating%20%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB(2)/" title="Software Debloating 论文阅读 (2)"><span class="has-text-weight-semibold">Next: Software Debloating 论文阅读 (2)</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="Haojen/Claudia-theme-blog" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/Mrcold2002"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Mr_cold 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>
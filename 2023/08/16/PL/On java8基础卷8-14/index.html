<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>On java 8 基础卷（8-14章）</title><meta name="description" content="菜"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="
8 复用
8.1 组合语法

组合:将对象引用放入新类中即可
初始化引用有以下4中方式



在定义时立刻初始化




在类的构造器中




在对象实际使用之前




使用实例初始化





class Soap &amp;#123;
  private String s;
  Soap() &amp;#123;//2 构造器初始化
    System.out.println(&amp;quot;Soap()&amp;quot;);
    s = &amp;quot;Constructed&amp;quot;;
  &amp;#125;
  @Override public String toString() &amp;#123; return s; &amp;#125;
&amp;#125;

public class Bath &amp;#123;
  private Str.."><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Mr_cold's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">On java 8 基础卷（8-14章）</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%A4%8D%E7%94%A8"><span class="toc-text">8 复用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8.1-%E7%BB%84%E5%90%88%E8%AF%AD%E6%B3%95"><span class="toc-text">8.1 组合语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8.2-%E7%BB%A7%E6%89%BF%E8%AF%AD%E6%B3%95"><span class="toc-text">8.2 继承语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9F%BA%E7%B1%BB"><span class="toc-text">初始化基类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8.3-%E5%A7%94%E6%89%98"><span class="toc-text">8.3 委托</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8.4-%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF%E7%9B%B8%E7%BB%93%E5%90%88"><span class="toc-text">8.4 组合与继承相结合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8.4.1-%E7%A1%AE%E4%BF%9D%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%B8%85%E7%90%86"><span class="toc-text">8.4.1 确保正确的清理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8.4.2-%E5%90%8D%E7%A7%B0%E9%9A%90%E8%97%8F"><span class="toc-text">8.4.2 名称隐藏</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8.5-%E9%80%89%E6%8B%A9%E7%BB%84%E5%90%88%E8%BF%98%E6%98%AF%E7%BB%A7%E6%89%BF"><span class="toc-text">8.5 选择组合还是继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8.6-protected%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">8.6 protected关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8.7-%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B"><span class="toc-text">8.7 向上转型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8.8-final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">8.8 final关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8.8.1-final-%E6%95%B0%E6%8D%AE"><span class="toc-text">8.8.1 final 数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8.8.2-final-%E6%96%B9%E6%B3%95"><span class="toc-text">8.8.2 final 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8.8.3-final-%E7%B1%BB"><span class="toc-text">8.8.3 final 类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8.9-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD"><span class="toc-text">8.9 初始化和类的加载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E5%A4%9A%E6%80%81"><span class="toc-text">9 多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9.1-%E5%86%8D%E8%AE%BA%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B"><span class="toc-text">9.1 再论向上转型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9.2-%E9%9A%BE%E7%82%B9"><span class="toc-text">9.2 难点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9.2.1-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E7%BB%91%E5%AE%9A"><span class="toc-text">9.2.1 方法调用绑定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9.2.2-%E4%BA%A7%E7%94%9F%E6%AD%A3%E7%A1%AE%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="toc-text">9.2.2 产生正确的行为</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9.2.3-%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7"><span class="toc-text">9.2.3 可扩展性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9.2.4-%E9%99%B7%E9%98%B1:%22%E9%87%8D%E5%86%99%22private%E6%96%B9%E6%B3%95"><span class="toc-text">9.2.4 陷阱:&quot;重写&quot;private方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9.2.5-%E9%99%B7%E9%98%B1:%E5%AD%97%E6%AE%B5%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-text">9.2.5 陷阱:字段和静态方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9.3-%E6%9E%84%E9%80%A0%E5%99%A8%E5%92%8C%E5%A4%9A%E6%80%81"><span class="toc-text">9.3 构造器和多态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9.3.1-%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%84%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F"><span class="toc-text">9.3.1 构造器的调用顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9.3.2-%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B8%85%E7%90%86"><span class="toc-text">9.3.2 继承与清理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9.3.3-%E6%9E%84%E9%80%A0%E5%99%A8%E5%86%85%E9%83%A8%E7%9A%84%E5%A4%9A%E6%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="toc-text">9.3.3 构造器内部的多态方法的行为</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9.4-%E5%8D%8F%E5%8F%98%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="toc-text">9.4 协变返回类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9.5-%E7%94%A8%E7%BB%A7%E6%89%BF%E8%BF%9B%E8%A1%8C%E8%AE%BE%E8%AE%A1"><span class="toc-text">9.5 用继承进行设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9.5.1-%E6%9B%BF%E6%8D%A2%E5%92%8C%E6%89%A9%E5%B1%95"><span class="toc-text">9.5.1 替换和扩展</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9.5.2-%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B%E5%92%8C%E5%8F%8D%E5%B0%84"><span class="toc-text">9.5.2 向下转型和反射</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E6%8E%A5%E5%8F%A3"><span class="toc-text">10 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10.1-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-text">10.1 抽象类和抽象方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10.2-%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89"><span class="toc-text">10.2 接口定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10.2.1-%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95"><span class="toc-text">10.2.1 默认方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10.2.2-%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-text">10.2.2 多重继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10.2.3-%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-text">10.2.3 接口中的静态方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10.3-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="toc-text">10.3 抽象类和接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10.4-%E5%AE%8C%E5%85%A8%E8%A7%A3%E8%80%A6"><span class="toc-text">10.4 完全解耦</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10.5-%E7%BB%84%E5%90%88%E5%A4%9A%E4%B8%AA%E6%8E%A5%E5%8F%A3"><span class="toc-text">10.5 组合多个接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10.6-%E9%80%9A%E8%BF%87%E7%BB%A7%E6%89%BF%E6%89%A9%E5%B1%95%E6%8E%A5%E5%8F%A3"><span class="toc-text">10.6 通过继承扩展接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10.7-%E9%80%82%E9%85%8D%E6%8E%A5%E5%8F%A3"><span class="toc-text">10.7 适配接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10.8-%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E5%AD%97%E6%AE%B5"><span class="toc-text">10.8 接口中的字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10.9-%E5%B5%8C%E5%A5%97%E6%8E%A5%E5%8F%A3"><span class="toc-text">10.9 嵌套接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10.10-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%B7%A5%E5%8E%82"><span class="toc-text">10.10 接口和工厂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10.11-%E6%96%B0%E7%89%B9%E6%80%A7:%E6%8E%A5%E5%8F%A3%E7%9A%84private%E6%96%B9%E6%B3%95"><span class="toc-text">10.11 新特性:接口的private方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10.12-%E6%96%B0%E7%89%B9%E6%80%A7:%E5%AF%86%E5%B0%81%E7%B1%BB%E5%92%8C%E5%AF%86%E5%B0%81%E6%8E%A5%E5%8F%A3"><span class="toc-text">10.12 新特性:密封类和密封接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">11 内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11.1-%E5%88%9B%E5%BB%BA%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">11.1 创建内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11.2-%E5%88%B0%E5%A4%96%E9%83%A8%E7%B1%BB%E7%9A%84%E9%93%BE%E6%8E%A5"><span class="toc-text">11.2 到外部类的链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11.3-%E4%BD%BF%E7%94%A8.this%E5%92%8C.new"><span class="toc-text">11.3 使用.this和.new</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11.4-%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B"><span class="toc-text">11.4 内部类和向上转型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11.5-%E5%9C%A8%E6%96%B9%E6%B3%95%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%AD%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">11.5 在方法和作用域中的内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11.6-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">11.6 匿名内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11.7-%E5%B5%8C%E5%A5%97%E7%B1%BB"><span class="toc-text">11.7 嵌套类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11.7.1-%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E7%B1%BB"><span class="toc-text">11.7.1 接口中的类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11.7.2-%E4%BB%8E%E5%A4%9A%E5%B1%82%E5%B5%8C%E5%A5%97%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB%E4%B8%AD%E8%AE%BF%E9%97%AE%E5%A4%96%E9%83%A8%E6%88%90%E5%91%98"><span class="toc-text">11.7.2 从多层嵌套的内部类中访问外部成员</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11.8-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">11.8 为什么需要内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11.8.1-%E9%97%AD%E5%8C%85%E5%92%8C%E5%9B%9E%E8%B0%83"><span class="toc-text">11.8.1 闭包和回调</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11.8.2-%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E6%8E%A7%E5%88%B6%E6%A1%86%E6%9E%B6"><span class="toc-text">11.8.2 内部类和控制框架</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11.9-%E7%BB%A7%E6%89%BF%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">11.9 继承内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11.10-%E5%86%85%E9%83%A8%E7%B1%BB%E5%8F%AF%E4%BB%A5%E8%A2%AB%E9%87%8D%E5%86%99%E5%90%97"><span class="toc-text">11.10 内部类可以被重写吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11.11-%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">11.11　局部内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11.12-%E5%86%85%E9%83%A8%E7%B1%BB%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-text">11.12 内部类标识符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E9%9B%86%E5%90%88"><span class="toc-text">12 集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12.1-%E6%B3%9B%E5%9E%8B%E5%92%8C%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88"><span class="toc-text">12.1 泛型和类型安全的集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12.2-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">12.2 基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12.3-%E6%B7%BB%E5%8A%A0%E4%B8%80%E7%BB%84%E5%85%83%E7%B4%A0"><span class="toc-text">12.3 添加一组元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12.4-%E9%9B%86%E5%90%88%E6%89%93%E5%8D%B0"><span class="toc-text">12.4 集合打印</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12.5-list"><span class="toc-text">12.5 List</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12.6-iterator"><span class="toc-text">12.6 Iterator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12.7-linkedlist"><span class="toc-text">12.7 LinkedList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12.8-stack"><span class="toc-text">12.8 Stack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12.9-set"><span class="toc-text">12.9 Set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12.10-map"><span class="toc-text">12.10 Map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12.11-%E6%96%B0%E7%89%B9%E6%80%A7:%E8%AE%B0%E5%BD%95(record)%E7%B1%BB%E5%9E%8B"><span class="toc-text">12.11 新特性:记录(record)类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12.12-queue"><span class="toc-text">12.12 Queue</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#priorityqueue"><span class="toc-text">PriorityQueue</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12.13-collection%E5%92%8Citerator"><span class="toc-text">12.13 Collection和Iterator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12.14-for-in%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">12.14 for-in与迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%96%B9%E6%B3%95"><span class="toc-text">适配器方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12.15-%E6%80%BB%E7%BB%93"><span class="toc-text">12.15 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-text">13 函数式编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13.1-%E6%96%B0%E6%96%B9%E5%BC%8F%E5%92%8C%E6%97%A7%E6%96%B9%E5%BC%8F"><span class="toc-text">13.1 新方式和旧方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13.2-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">13.2 lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-text">递归</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13.3-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-text">13.3 方法引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13.3.1-runnable%E6%8E%A5%E5%8F%A3"><span class="toc-text">13.3.1 Runnable接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13.3.2-%E6%9C%AA%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-text">13.3.2 未绑定方法引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13.3.3-%E6%9E%84%E9%80%A0%E5%99%A8%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-text">13.3.3 构造器方法引用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13.4-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-text">13.4 函数式接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13.4.1-%E5%B8%A6%E6%9C%89%E6%9B%B4%E5%A4%9A%E5%8F%82%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-text">13.4.1 带有更多参数的函数式接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13.4.2-%E8%A7%A3%E5%86%B3%E7%BC%BA%E4%B9%8F%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">13.4.2 解决缺乏基本类型函数式接口的问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13.5-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="toc-text">13.5 高阶函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13.6-%E9%97%AD%E5%8C%85"><span class="toc-text">13.6 闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13.7-%E5%87%BD%E6%95%B0%E7%BB%84%E5%90%88"><span class="toc-text">13.7 函数组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13.8-%E6%9F%AF%E9%87%8C%E5%8C%96%E5%92%8C%E9%83%A8%E5%88%86%E6%B1%82%E5%80%BC"><span class="toc-text">13.8 柯里化和部分求值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13.9-%E7%BA%AF%E5%87%BD%E6%95%B0%E5%BC%8F%E5%8F%98%E6%88%90&13.10-%E6%80%BB%E7%BB%93"><span class="toc-text">13.9 纯函数式变成&amp;13.10 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E6%B5%81"><span class="toc-text">14 流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14.1-java8-%E5%AF%B9%E6%B5%81%E7%9A%84%E6%94%AF%E6%8C%81"><span class="toc-text">14.1 Java8 对流的支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14.2-%E6%B5%81%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-text">14.2 流的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14.3-%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C"><span class="toc-text">14.3 中间操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14.4-optional"><span class="toc-text">14.4 Optional</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#14.4.1-%E4%BE%BF%E6%8D%B7%E5%87%BD%E6%95%B0"><span class="toc-text">14.4.1 便捷函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14.4.2-%E5%88%9B%E5%BB%BAoptional"><span class="toc-text">14.4.2 创建Optional</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14.4.3-optional%E5%AF%B9%E8%B1%A1%E4%B8%8A%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">14.4.3 Optional对象上的操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14.4.4-%E7%94%B1optional%E7%BB%84%E6%88%90%E7%9A%84%E6%B5%81"><span class="toc-text">14.4.4 由Optional组成的流</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14.5-%E7%BB%88%E7%BB%93%E6%93%8D%E4%BD%9C"><span class="toc-text">14.5 终结操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14.6-%E5%B0%8F%E7%BB%93"><span class="toc-text">14.6 小结</span></a></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/java"><i class="tag post-item-tag">java</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">On java 8 基础卷（8-14章）</h1><time class="has-text-grey" datetime="2023-08-16T13:48:11.624Z">2023-08-16</time><article class="mt-2 post-content"><p><img src="/images/PL/OnJava8/x_x.jpg" alt></p>
<h2 id="8-%E5%A4%8D%E7%94%A8" tabindex="-1">8 复用</h2>
<h3 id="8.1-%E7%BB%84%E5%90%88%E8%AF%AD%E6%B3%95" tabindex="-1">8.1 组合语法</h3>
<ul>
<li>组合:将对象引用放入新类中即可</li>
<li>初始化引用有以下4中方式
<ul>
<li>
<ol>
<li>在定义时立刻初始化</li>
</ol>
</li>
<li>
<ol start="2">
<li>在类的构造器中</li>
</ol>
</li>
<li>
<ol start="3">
<li>在对象实际使用之前</li>
</ol>
</li>
<li>
<ol start="4">
<li>使用实例初始化</li>
</ol>
</li>
</ul>
</li>
</ul>
<pre><code class="language-java">class Soap &#123;
  private String s;
  Soap() &#123;//2 构造器初始化
    System.out.println(&quot;Soap()&quot;);
    s = &quot;Constructed&quot;;
  &#125;
  @Override public String toString() &#123; return s; &#125;
&#125;

public class Bath &#123;
  private String // 1. 立即初始化
    s1 = &quot;Happy&quot;,
    s2 = &quot;Happy&quot;,
    s3, s4;
  private Soap castile;
  private int i;
  private float toy;
  public Bath() &#123;
    System.out.println(&quot;Inside Bath()&quot;);
    s3 = &quot;Joy&quot;;
    toy = 3.14f;
    castile = new Soap();
  &#125;
  // 实例初始化
  &#123; i = 47; &#125;
  @Override public String toString() &#123;
    if(s4 == null) // 延迟初始化
      s4 = &quot;Joy&quot;;
    return
      &quot;s1 = &quot; + s1 + &quot;\n&quot; +
      &quot;s2 = &quot; + s2 + &quot;\n&quot; +
      &quot;s3 = &quot; + s3 + &quot;\n&quot; +
      &quot;s4 = &quot; + s4 + &quot;\n&quot; +
      &quot;i = &quot; + i + &quot;\n&quot; +
      &quot;toy = &quot; + toy + &quot;\n&quot; +
      &quot;castile = &quot; + castile;
  &#125;
  public static void main(String[] args) &#123;
    Bath b = new Bath();
    System.out.println(b);
  &#125;
&#125;
/* Output:
Inside Bath()
Soap()
s1 = Happy
s2 = Happy
s3 = Joy
s4 = Joy
i = 47
toy = 3.14
castile = Constructed
*/
</code></pre>
<h3 id="8.2-%E7%BB%A7%E6%89%BF%E8%AF%AD%E6%B3%95" tabindex="-1">8.2 继承语法</h3>
<ul>
<li>创建一个类时,如无指定继承对象,将会隐式继承标准根类Object</li>
<li>Java只允许单继承</li>
<li>继承通过关键字<code>extends</code>后跟基类实现,此时自动获得基类的所有字段和方法</li>
<li>通过<code>super</code>关键字,来指代当前类继承的&quot;基类&quot;的</li>
</ul>
<h4 id="%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9F%BA%E7%B1%BB" tabindex="-1">初始化基类</h4>
<ul>
<li>
<p>对于子类和基类,当创建子类对象时,其里面包含了一个基类的<code>子对象</code>(subobject),该子对象等同于直接创建基类对象,只是该对象被包括在子对象中</p>
</li>
<li>
<p>Java会自动在子类构造其中插入对基类构造器的调用<br>
<img src="/images/PL/OnJava8/8_2_1.png" alt></p>
</li>
<li>
<p>对于带参的构造器,需要使用super关键字和对应的参数列表,来显式的调用基类构造器,否则编译报错</p>
</li>
</ul>
<p><img src="/images/PL/OnJava8/8_2_2.png" alt></p>
<h3 id="8.3-%E5%A7%94%E6%89%98" tabindex="-1">8.3 委托</h3>
<ul>
<li>
<p>第三种关系<code>委托(delegation)</code>,介于继承和组合之间</p>
<ul>
<li>将成员对象放在构建的类中(类似组合),但同时在新类中公开了成员对象的所有方法(类似继承)</li>
</ul>
</li>
<li>
<p>例子:对于一艘太空船需要一个控制模块,这里使用继承方法,但逻辑上讲不通,而组合方法中,不能通过太空船直接掉用到控制模块的方法,此时可以使用委托</p>
</li>
<li>
<p>这里相当于方法调用被转发到了内部的controls对象,这里的接口与继承得到的接口相同</p>
<ul>
<li><strong>但是</strong>,这里可以更好的控制委托,因为这里可以选择仅提供成员对象的部分方法,比如控制模块的一些不能暴露给飞船控制人员的方法</li>
</ul>
</li>
</ul>
<pre><code class="language-java">public class SpaceShipDelegation &#123;
  private String name;
  private SpaceShipControls controls =
    new SpaceShipControls();
  public SpaceShipDelegation(String name) &#123;
    this.name = name;
  &#125;
  // Delegated methods 委托方法:
  public void back(int velocity) &#123;
    controls.back(velocity);
  &#125;
  public void down(int velocity) &#123;
    controls.down(velocity);
  &#125;
  public void forward(int velocity) &#123;
    controls.forward(velocity);
  &#125;
  public void left(int velocity) &#123;
    controls.left(velocity);
  &#125;
  public void right(int velocity) &#123;
    controls.right(velocity);
  &#125;
  public void turboBoost() &#123;
    controls.turboBoost();
  &#125;
  public void up(int velocity) &#123;
    controls.up(velocity);
  &#125;
  public static void main(String[] args) &#123;
    SpaceShipDelegation protector =
      new SpaceShipDelegation(&quot;NSEA Protector&quot;);
    protector.forward(100);
  &#125;
&#125;
</code></pre>
<h3 id="8.4-%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF%E7%9B%B8%E7%BB%93%E5%90%88" tabindex="-1">8.4 组合与继承相结合</h3>
<h4 id="8.4.1-%E7%A1%AE%E4%BF%9D%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%B8%85%E7%90%86" tabindex="-1">8.4.1 确保正确的清理</h4>
<ul>
<li>Java中没有C++中析构函数的概念,析构函数会在对象被销毁时自动调用,而Java中有GC,会在需要时回收内存</li>
<li>然而,类可能需要自己执行一些清理活动,因为你不知道GC什么时候被调用,所以此时必须明确地编写一个特殊的方法来实现
<ul>
<li>该方法与构造器方法类似,需要显式的声明,顺序与构造器顺序相反</li>
</ul>
</li>
</ul>
<pre><code class="language-java">package reuse;

class Shape &#123;
  Shape(int i) &#123;
    System.out.println(&quot;Shape constructor&quot;);
  &#125;
  void dispose() &#123;
    System.out.println(&quot;Shape dispose&quot;);
  &#125;
&#125;

class Circle extends Shape &#123;
  Circle(int i) &#123;
    super(i);
    System.out.println(&quot;Drawing Circle&quot;);
  &#125;
  @Override void dispose() &#123;
    System.out.println(&quot;Erasing Circle&quot;);
    super.dispose();
  &#125;
&#125;

class Triangle extends Shape &#123;
  Triangle(int i) &#123;
    super(i);
    System.out.println(&quot;Drawing Triangle&quot;);
  &#125;
  @Override void dispose() &#123;
    System.out.println(&quot;Erasing Triangle&quot;);
    super.dispose();
  &#125;
&#125;

class Line extends Shape &#123;
  private int start, end;
  Line(int start, int end) &#123;
    super(start);
    this.start = start;
    this.end = end;
    System.out.println(
      &quot;Drawing Line: &quot; + start + &quot;, &quot; + end);
  &#125;
  @Override void dispose() &#123;
    System.out.println(
      &quot;Erasing Line: &quot; + start + &quot;, &quot; + end);
    super.dispose();
  &#125;
&#125;

public class CADSystem extends Shape &#123;
  private Circle c;
  private Triangle t;
  private Line[] lines = new Line[3];
  public CADSystem(int i) &#123;
    super(i + 1);
    for(int j = 0; j &lt; lines.length; j++)
      lines[j] = new Line(j, j*j);
    c = new Circle(1);
    t = new Triangle(1);
    System.out.println(&quot;Combined constructor&quot;);
  &#125;
  @Override public void dispose() &#123;
    System.out.println(&quot;CADSystem.dispose()&quot;);
    // The order of cleanup is the reverse
    // of the order of initialization:
    t.dispose();
    c.dispose();
    for(int i = lines.length - 1; i &gt;= 0; i--)
      lines[i].dispose();
    super.dispose();
  &#125;
  public static void main(String[] args) &#123;
    CADSystem x = new CADSystem(47);
    try &#123;
      // Code and exception handling...
    &#125; finally &#123;
      x.dispose();
    &#125;
  &#125;
&#125;
/* Output:
Shape constructor
Shape constructor
Drawing Line: 0, 0
Shape constructor
Drawing Line: 1, 1
Shape constructor
Drawing Line: 2, 4
Shape constructor
Drawing Circle
Shape constructor
Drawing Triangle
Combined constructor
CADSystem.dispose()
Erasing Triangle
Shape dispose
Erasing Circle
Shape dispose
Erasing Line: 2, 4
Shape dispose
Erasing Line: 1, 1
Shape dispose
Erasing Line: 0, 0
Shape dispose
Shape dispose
*/
</code></pre>
<h4 id="8.4.2-%E5%90%8D%E7%A7%B0%E9%9A%90%E8%97%8F" tabindex="-1">8.4.2 名称隐藏</h4>
<ul>
<li>如果Java基类的方法名称被多次重载,则在子类中重新定义该方法名称不会隐藏任何基类版本.无论方法实在子类还是基类中定义,重载都有效
<ul>
<li>即基类的方法名重载后,子类中依然可以进行方法名重载,均可以使用</li>
</ul>
</li>
</ul>
<pre><code class="language-java">class Homer &#123;
  char doh(char c) &#123;
    System.out.println(&quot;doh(char)&quot;);
    return 'd';
  &#125;
  float doh(float f) &#123;
    System.out.println(&quot;doh(float)&quot;);
    return 1.0f;
  &#125;
&#125;

class Milhouse &#123;&#125;

class Bart extends Homer &#123;
  void doh(Milhouse m) &#123;
    System.out.println(&quot;doh(Milhouse)&quot;);
  &#125;
  /*
  以下这种写法是错的,不是重写函数而是正常的同一函数名不同参数的重载函数,本质是同名的不同函数,相当于在子类中新造乐一个函数
  @Override void doh(Milhouse m) &#123;
    System.out.println(&quot;doh(Milhouse)&quot;);
  &#125;
  */
&#125;

public class Hide &#123;
  public static void main(String[] args) &#123;
    Bart b = new Bart();
    b.doh(1);
    b.doh('x');
    b.doh(1.0f);
    b.doh(new Milhouse());
  &#125;
&#125;
/* Output:
doh(float)
doh(char)
doh(float)
doh(Milhouse)
*/
</code></pre>
<h3 id="8.5-%E9%80%89%E6%8B%A9%E7%BB%84%E5%90%88%E8%BF%98%E6%98%AF%E7%BB%A7%E6%89%BF" tabindex="-1">8.5 选择组合还是继承</h3>
<ul>
<li>
<p>组合和继承都会将对象放在新类中(组合是显式执行,继承是隐式执行)</p>
</li>
<li>
<p>新类中使用现有类的功能而不是接口时,使用<strong>组合</strong>,即在心累中嵌入一个对象来实现自己的特性(多是private),新类的用户看到的是新类的定义而不是嵌入对象的接口.</p>
<ul>
<li>又是组合的成员对象也可以为public(类似一种半委托)</li>
</ul>
</li>
<li>
<p>当使用<strong>继承</strong>时,通过现有的类生成一个特殊版本,意味着对通用类进行定制.</p>
</li>
<li>
<p><strong>继承</strong>是&quot;is-a&quot;关系,<strong>组合</strong>是&quot;has-a&quot;关系</p>
</li>
</ul>
<h3 id="8.6-protected%E5%85%B3%E9%94%AE%E5%AD%97" tabindex="-1">8.6 protected关键字</h3>
<ul>
<li>protected:包访问权限和子类访问权限</li>
</ul>
<pre><code class="language-java">class Villain &#123;
  private String name;
  protected void set(String nm) &#123; name = nm; &#125;
  Villain(String name) &#123; this.name = name; &#125;
  @Override public String toString() &#123;
    return &quot;I'm a Villain and my name is &quot; + name;
  &#125;
&#125;

public class Orc extends Villain &#123;
  private int orcNumber;
  public Orc(String name, int orcNumber) &#123;
    super(name);
    this.orcNumber = orcNumber;
  &#125;
  public void change(String name, int orcNumber) &#123;
    set(name); // 这里change函数可以调用set,因为set是protected型的
    this.orcNumber = orcNumber;
  &#125;
  @Override public String toString() &#123;
    return &quot;Orc &quot; + orcNumber + &quot;: &quot; + super.toString();
  &#125;
  public static void main(String[] args) &#123;
    Orc orc = new Orc(&quot;Limburger&quot;, 12);
    System.out.println(orc);
    orc.change(&quot;Bob&quot;, 19);
    System.out.println(orc);
  &#125;
&#125;
/* Output:
Orc 12: I'm a Villain and my name is Limburger
Orc 19: I'm a Villain and my name is Bob
*/
</code></pre>
<h3 id="8.7-%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B" tabindex="-1">8.7 向上转型</h3>
<ul>
<li>继承最重要的是可以表达新类和基类的关系:<strong>新类是现有类的一种类型</strong></li>
<li>这种描述可以直接由语言支持,如下面的例子,乐器类Instrument为基类,Wind为子类,乐器类有一个play方法,那么Wind乐器也会有,即Wind乐器是一种乐器</li>
<li>以下代码中,tune()方法接受一个Instrument引用,当传入一个Wind引用时,实际Wind类就是一种Instrument类,而且tune()方法调用的Instrument对象的所有属性和方法Wind均具有.因此代码可以正常运行.这种将子类引用转换为基类引用的行为称为<strong>向上转型(upcasting)</strong></li>
</ul>
<pre><code class="language-java">class Instrument &#123;
 public void play() &#123;&#125;
 static void tune(Instrument i) &#123;
 // ...
 i.play();
 &#125;
&#125;
// Wind 对象也是 instrument，因为它们有相同的接口：
public class Wind extends Instrument &#123;
 public static void main(String[] args) &#123;
 Wind flute = new Wind();
 Instrument.tune(flute); // 向上转型
 &#125;
&#125;
</code></pre>
<ul>
<li>确定使用继承或组合的方法:新类是否要向上转型到基类</li>
</ul>
<h3 id="8.8-final%E5%85%B3%E9%94%AE%E5%AD%97" tabindex="-1">8.8 final关键字</h3>
<ul>
<li>final:表示无法更改的</li>
<li>使用final出于两个原因:设计或效率,这两个原因差距很大,因此final可能被误用</li>
</ul>
<h4 id="8.8.1-final-%E6%95%B0%E6%8D%AE" tabindex="-1">8.8.1 final 数据</h4>
<ul>
<li>
<p>许多编程语言有常量的定义,标识某个数据是恒定的,有以下两个原因</p>
<ul>
<li>
<ol>
<li>它是一个永远不会改变的<strong>编译时常量</strong>:编译器可以将常量值&quot;折叠&quot;在计算中,即计算在编译时进行,节省运行开销.Java中使用final进行修饰,一个既是static也是final字段指挥分配一块不能改变的存储空间</li>
</ol>
</li>
<li>
<ol start="2">
<li>它可以使在运行时初始化的值,而你不希望被更改</li>
</ol>
</li>
</ul>
</li>
<li>
<p>final对于基本类型,使得其值更定不变;</p>
</li>
<li>
<p>对于对象引用,final使得<strong>引用</strong>恒定不变,一旦引用被初始化一个对象,它就不能再指其它对象了,但对象本身是可以修改的.</p>
<ul>
<li>Java没有提供使对象恒定不变的方法,但用户可以自己编写类实现</li>
</ul>
</li>
</ul>
<ol>
<li>空白final: 指没有初始化的final字段,编译器会保证在使用该字段前初始化该final字段</li>
<li>final参数: 传递给方法的参数可以声明为final,这意味着你无法在方法中更改参数引用所指向的对象</li>
</ol>
<h4 id="8.8.2-final-%E6%96%B9%E6%B3%95" tabindex="-1">8.8.2 final 方法</h4>
<ul>
<li>使用final方法的原因
<ul>
<li>
<ol>
<li>把方法锁定,以防任何继承类修改它的含义</li>
</ol>
</li>
<li>
<ol start="2">
<li>效率:编译器在遇到final方法调用时会转为<strong>内嵌调用(inline call)</strong>,因此final方法调用的效率更高</li>
</ol>
<ul>
<li>具体:编译器会将final方法的代码复制到调用该方法的地方,而不是进行一次方法调用</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="8.8.3-final-%E7%B1%BB" tabindex="-1">8.8.3 final 类</h4>
<ul>
<li>final类不能被继承,没有类可以继承final类的任何特性</li>
<li>原因:
<ul>
<li>
<ol>
<li>设计:类的创建者不希望有人继承它</li>
</ol>
</li>
<li>
<ol start="2">
<li>安全:不希望其有子类,因为它的行为可能会被子类修改,而这可能会破坏原来的类</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="8.9-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD" tabindex="-1">8.9 初始化和类的加载</h3>
<ol>
<li>运行Java代码时,首先会加载类;加载类时,会先加载其基类,然后才是自身,即从根基类开始加载
<ol>
<li>首先加载静态变量</li>
<li>然后是静态代码块</li>
</ol>
</li>
<li>创建对象时,也会从根基类开始创建,然后到自身
<ol>
<li>首先创建实例变量(非静态)</li>
<li>然后是执行实例代码块</li>
<li>调用构造函数进行对象的初始化</li>
</ol>
</li>
</ol>
<h2 id="9-%E5%A4%9A%E6%80%81" tabindex="-1">9 多态</h2>
<ul>
<li>跟随 数据抽象,继承,多态是面向对象编程语言的第三个基本特征</li>
</ul>
<h3 id="9.1-%E5%86%8D%E8%AE%BA%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B" tabindex="-1">9.1 再论向上转型</h3>
<ul>
<li>例子:乐器类Instrument为基类,Wind为子类,乐器类有一个play方法,那么Wind乐器也会有,即Wind乐器是一种乐器</li>
<li>以下代码中,tune()方法接受一个Instrument引用,当传入一个Wind引用时,实际Wind类就是一种Instrument类,而且tune()方法调用的Instrument对象的所有属性和方法Wind均具有.因此代码可以正常运行.这种将子类引用转换为基类引用的行为称为<strong>向上转型(upcasting)</strong></li>
</ul>
<pre><code class="language-java">class Instrument &#123;
 public void play(Note n) &#123;
 System.out.println(&quot;Instrument.play()&quot;);
 &#125;
&#125;
// Wind 对象也是 instrument，因为它们有相同的接口：
public class Wind extends Instrument &#123;
 // 重新定义接口方法：
 @Override public void play(Note n) &#123;
  System.out.println(&quot;Wind.play() &quot; + n);
 &#125;
 public static void main(String[] args) &#123;
  Wind flute = new Wind();
  Instrument.tune(flute); // 向上转型
 &#125;
&#125;

public class Music &#123;
 public static void tune(Instrument i) &#123;
 // ...
 i.play(Note.MIDDLE_C);
 &#125;
 public static void main(String[] args) &#123;
 Wind flute = new Wind();
 tune(flute); // 向上转型
 &#125;
&#125;

</code></pre>
<ul>
<li>如果有多个继承类,编写一个以基类为参数的方法,而不用担心特定子类,即忘记子类,只与基类的代码打交道,这正是多态实现的目标</li>
</ul>
<h3 id="9.2-%E9%9A%BE%E7%82%B9" tabindex="-1">9.2 难点</h3>
<ul>
<li>在mucis.java中 Music.tune()方法接受一个Instrument引用,但是传入的是Wind引用,这是如何实现的呢?
<ul>
<li>此时需要了解<strong>绑定</strong>这个主题</li>
</ul>
</li>
</ul>
<h4 id="9.2.1-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E7%BB%91%E5%AE%9A" tabindex="-1">9.2.1 方法调用绑定</h4>
<ul>
<li>绑定:将一个方法调用和一个方法体实现关联起来称为绑定</li>
<li>前期绑定:在程序运行之前执行绑定(编译器和连接程序都可以执行前期绑定,因此有时也称为静态绑定)
<ul>
<li>面向过程语言中,大多数方法调用都是前期绑定</li>
</ul>
</li>
<li>后期绑定(也称动态绑定,运行时绑定):在运行时根据对象的类型进行绑定
<ul>
<li>多态的实现就是后期绑定</li>
<li>Java的所有方法都是后期绑定的,除非明确指定final,static或private</li>
</ul>
</li>
</ul>
<h4 id="9.2.2-%E4%BA%A7%E7%94%9F%E6%AD%A3%E7%A1%AE%E7%9A%84%E8%A1%8C%E4%B8%BA" tabindex="-1">9.2.2 产生正确的行为</h4>
<ul>
<li>例子:Instrument类中的play()方法,在Wind类中被覆盖,当调用tune()方法时,传入的是Wind引用,但是调用的是Instrument类中的play()方法,这是如何实现的呢?
<ul>
<li>
<ol>
<li>传入Wind引用时,会将Wind引用向上转型为Instrument引用</li>
</ol>
</li>
<li>
<ol start="2">
<li>调用Instrument类中的play()方法,此时会调用Wind类中的play()方法,因为Wind类中覆盖了Instrument类中的play()方法</li>
</ol>
</li>
<li>
<ol start="3">
<li>由于是后期绑定,因此会调用Wind类中的play()方法,而不是Instrument类中的play()方法</li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="9.2.3-%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7" tabindex="-1">9.2.3 可扩展性</h4>
<ul>
<li>例子:如果需要添加一个新的乐器,只需要继承Instrument类,并覆盖play()方法即可,不需要修改任何其他代码,即tune方法的参数一直是Instrument类,但是传入的是新的乐器引用,此时调用的是新乐器的play()方法,这就是多态的可扩展性</li>
</ul>
<h4 id="9.2.4-%E9%99%B7%E9%98%B1%3A%22%E9%87%8D%E5%86%99%22private%E6%96%B9%E6%B3%95" tabindex="-1">9.2.4 陷阱:&quot;重写&quot;private方法</h4>
<p><img src="/images/PL/OnJava8/9_2_4.png" alt></p>
<ul>
<li>private 方法为隐式的final,不能被覆盖,此时子类中的方法即为一个新的方法,因此子类中的方法和基类中的方法没有任何关系,此时调用的是基类中的方法</li>
<li>如果在子类中使用@Override注解,编译器会报错</li>
</ul>
<h4 id="9.2.5-%E9%99%B7%E9%98%B1%3A%E5%AD%97%E6%AE%B5%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95" tabindex="-1">9.2.5 陷阱:字段和静态方法</h4>
<ul>
<li>只用普通的方法调用可以是多态的,但是字段和静态方法不行
<ul>
<li>如果直接访问一个字段,该访问会在编译时解析</li>
<li>静态方法与类相关联,而不是与单个的对象相关联</li>
</ul>
</li>
</ul>
<h3 id="9.3-%E6%9E%84%E9%80%A0%E5%99%A8%E5%92%8C%E5%A4%9A%E6%80%81" tabindex="-1">9.3 构造器和多态</h3>
<h4 id="9.3.1-%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%84%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F" tabindex="-1">9.3.1 构造器的调用顺序</h4>
<ul>
<li>调用子类构造器,此时会递归调用子类的基类构造器,直到调用根基类构造器</li>
<li>如果没有在子类构造器代码中显式调用基类构造器,则会隐式的调用基类的无参构造器</li>
<li>一个复杂对象构造器的调用顺序
<ul>
<li>
<ol>
<li>调用基类构造器,此时会递归调用基类的基类构造器,直到调用根基类构造器.根类先被构造,随后到子类</li>
</ol>
</li>
<li>
<ol start="2">
<li>按声明顺序初始化成员</li>
</ol>
</li>
<li>
<ol start="3">
<li>调用子类构造器的主体</li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="9.3.2-%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B8%85%E7%90%86" tabindex="-1">9.3.2 继承与清理</h4>
<ul>
<li>通常由gc进行清理,如有自己清理的必要,需要自行创建dispose函数,并在子类中覆盖该函数,在子类中调用基类的dispose函数</li>
<li>清理的顺序是从子类到根基类</li>
</ul>
<h4 id="9.3.3-%E6%9E%84%E9%80%A0%E5%99%A8%E5%86%85%E9%83%A8%E7%9A%84%E5%A4%9A%E6%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E8%A1%8C%E4%B8%BA" tabindex="-1">9.3.3 构造器内部的多态方法的行为</h4>
<ul>
<li>
<p>普通方法中,动态绑定调用在运行时解析</p>
</li>
<li>
<p>过早其中中调用动态绑定方法,会调用该方法被重写后的定义,但被重写的方法可能会使用到子类中的成员变量,此时子类的成员变量还未被初始化,因此会出现错误</p>
</li>
<li>
<p>编写构造器的准则:</p>
<ul>
<li>用尽可能少的操作使对象进入正常状态</li>
<li>如果可以的话,避免调用其他方法,只有基类中final,private方法可以在构造器中被安全调用</li>
</ul>
</li>
</ul>
<h3 id="9.4-%E5%8D%8F%E5%8F%98%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B" tabindex="-1">9.4 协变返回类型</h3>
<ul>
<li>Java5中添加了 <strong>协变返回类型(covariant return type)<strong>重写方法时,返回类型可以是基类方法返回类型的</strong>子类型</strong></li>
<li>例子:process的返回类型:在WheatMill中process函数返回的是Wheat类型,而在Mill中返回的是Grain类型,此时Wheat是Grain的子类,因此可以使用协变返回类型</li>
</ul>
<pre><code class="language-java">class Grain &#123;
 @Override public String toString() &#123;
 return &quot;Grain&quot;;
 &#125;
&#125;
class Wheat extends Grain &#123;
 @Override public String toString() &#123;
 return &quot;Wheat&quot;;
 &#125;
&#125;
class Mill &#123;
 Grain process() &#123; return new Grain(); &#125;
&#125;
class WheatMill extends Mill &#123;
 @Override Wheat process() &#123;
 return new Wheat();
 &#125;
&#125;
</code></pre>
<h3 id="9.5-%E7%94%A8%E7%BB%A7%E6%89%BF%E8%BF%9B%E8%A1%8C%E8%AE%BE%E8%AE%A1" tabindex="-1">9.5 用继承进行设计</h3>
<ul>
<li>设计准则:使用继承表达行为间的差异,使用字段表达状态上的变化</li>
</ul>
<h4 id="9.5.1-%E6%9B%BF%E6%8D%A2%E5%92%8C%E6%89%A9%E5%B1%95" tabindex="-1">9.5.1 替换和扩展</h4>
<ul>
<li>
<p>纯粹的&quot;is-a&quot;关系,子类的接口与基类相同,但可以进行重写.例子:<br>
<img src="/images/PL/OnJava8/9_5_1.png" alt></p>
</li>
<li>
<p>&quot;is-like-a&quot;关系,子类的接口比基类更丰富,向上转型后,无法调用子类的新的方法.例子:<br>
<img src="/images/PL/OnJava8/9_5_1_1.png" alt></p>
</li>
</ul>
<h4 id="9.5.2-%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B%E5%92%8C%E5%8F%8D%E5%B0%84" tabindex="-1">9.5.2 向下转型和反射</h4>
<ul>
<li>
<p>向上转型会丢失特定类型的信息,自然可以通过向下转型重新获取类型信息</p>
</li>
<li>
<p>向上转型总是安全的,因为基类不可能会比有更多的接口,基类接口发送的信息子类总能接收,向下转型非也</p>
</li>
<li>
<p>某些语言(如C++)要执行特殊操作才能获得类型安全的向下转型,Java中每个转型都会被检查,如果转型是不合法的,则会抛出ClassCastException异常,这种运行时检查的行为是<strong>Java反射</strong>的一部分,例子:</p>
</li>
</ul>
<pre><code class="language-java">class Useful &#123;
 public void f() &#123;&#125;
 public void g() &#123;&#125;
&#125;
class MoreUseful extends Useful &#123;
 @Override public void f() &#123;&#125;
 @Override public void g() &#123;&#125;
 public void u() &#123;&#125;
 public void v() &#123;&#125;
 public void w() &#123;&#125;
&#125;
public class Reflect &#123;
 public static void main(String[] args) &#123;
 Useful[] x = &#123;
 new Useful(),
 new MoreUseful()
 &#125;;
 x[0].f();
 x[1].g();
 // 编译时错误：无法在 Useful 中发现方法 :
 //- x[1].u();
 ((MoreUseful)x[1]).u(); // 向下转型 / 反射
 ((MoreUseful)x[0]).u(); // 抛出异常
 &#125;
&#125;
</code></pre>
<h2 id="10-%E6%8E%A5%E5%8F%A3" tabindex="-1">10 接口</h2>
<h3 id="10.1-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95" tabindex="-1">10.1 抽象类和抽象方法</h3>
<ul>
<li>
<p>抽象类:介于普通类和接口之间的类,抽象类不能被实例化,只能被继承,抽象类中可以包含<strong>抽象方法</strong>,也可以没有,抽象方法只有声明,没有实现,抽象方法必须被子类实现</p>
</li>
<li>
<p>例子:Instrument可以称为抽象类,为所有的子类创建了一个共同的接口,但是Instrument类本身不能被实例化,因为它是抽象的,而且Instrument类中的play方法是抽象的,因此必须被子类实现</p>
</li>
</ul>
<pre><code class="language-java">abstract class Instrument &#123;
 private int i; 
 public abstract void play(Note n);
 public String what() &#123; return &quot;Instrument&quot;; &#125;
 public abstract void adjust();
&#125;
</code></pre>
<ul>
<li>可实例化类继承抽象类后,要为所有的抽象方法提供定义</li>
</ul>
<pre><code class="language-java">abstract class Uninstantiable &#123;
  abstract void f();
  abstract int g();
&#125;

public class Instantiable extends Uninstantiable &#123;
  @Override void f() &#123; System.out.println(&quot;f()&quot;); &#125;//@Override表示重写了基类的方法,如果该注解,其实编译器会自动判断抽象方法是否已经被实现,所以可以去掉
  @Override int g() &#123; return 22; &#125;
  public static void main(String[] args) &#123;
    Uninstantiable ui = new Instantiable();ui.f();
  &#125;
&#125;
</code></pre>
<ul>
<li>
<p>接口只允许有public方法,抽象类对访问权限没有限制(private方法除外,因为无法被继承)</p>
</li>
<li>
<p>抽象类和抽象方法很有用</p>
<ul>
<li>明确了类的抽象性,告诉用户和编译器自己的预期用途</li>
<li>有用的重构工具,让你轻松地将公共方法上移至抽象基类中,以便于在继承类中重用</li>
</ul>
</li>
</ul>
<h3 id="10.2-%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89" tabindex="-1">10.2 接口定义</h3>
<ul>
<li>
<p>interface关键字创建一个完全抽象的类,不代表任何实现,接口描述了一个类应该是什么样子和做什么的,而不是如何做.其确定了方法名,参数列表和返回类型,但不提供方法主体.</p>
</li>
<li>
<p>接口允许默认方法和静态方法,可以包含字段(隐式static和final)</p>
</li>
<li>
<p>接口和抽象类显著的区别是两者的惯用方式:</p>
<ul>
<li>接口通常暗示&quot;类的类型&quot;,作为形容词使用,如Comparable接口</li>
<li>抽象类通常表示&quot;类的成员&quot;,作为名词使用,如AbstractList类</li>
</ul>
</li>
<li>
<p>创建接口使用interface关键字,前面可以加public或默认包访问权限</p>
</li>
<li>
<p>创建符合接口的类,使用implements关键字,一个类可以实现多个接口,接口中的方法必须被实现,否则编译报错.同时方法默认为public,同时实现类中的方法也必须为public,加上@Override注解可以检查是否正确重写了接口中的方法</p>
</li>
</ul>
<pre><code class="language-java">interface Concept &#123; // 包访问
 void idea1();
 void idea2();
&#125;
class Implementation implements Concept &#123;
 @Override public void idea1() &#123;
 System.out.println(&quot;idea1&quot;);
 &#125;
 @Override public void idea2() &#123;
 System.out.println(&quot;idea2&quot;);
 &#125;
&#125;
</code></pre>
<h4 id="10.2.1-%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95" tabindex="-1">10.2.1 默认方法</h4>
<ul>
<li>接口中,允许使用default关键字创建一个方法体,实现该接口的类可以在不定义方法的情况下直接替换为该默认方法体</li>
</ul>
<pre><code class="language-java">interface InterfaceWithDefault &#123;
 void firstMethod();
 void secondMethod();
 default void newMethod() &#123;
 System.out.println(&quot;newMethod&quot;);
 &#125;
&#125;
public class Implementation2
implements InterfaceWithDefault &#123;
 @Override public void firstMethod() &#123;
 System.out.println(&quot;firstMethod&quot;);
 &#125;
 @Override public void secondMethod() &#123;
 System.out.println(&quot;secondMethod&quot;);
 &#125;
 public static void main(String[] args) &#123;
 InterfaceWithDefault i = new Implementation2();
 i.firstMethod();
 i.secondMethod();
 i.newMethod();
 &#125;
&#125;
</code></pre>
<ul>
<li>添加默认方法的原因:允许向现有接口中添加方法,而不会破坏已经在使用该接口的所有代码</li>
<li>默认方法也称 防御方法 或 虚拟扩展方法</li>
</ul>
<h4 id="10.2.2-%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF" tabindex="-1">10.2.2 多重继承</h4>
<ul>
<li>Java是严格的单继承语言,只能继承一个类(或抽象类)</li>
<li>但接口有多重继承的一些特性,即一个类可以实现多个接口,这样就可以实现多重继承的效果,只要所有基类方法都有不同的名称和参数列表,代码就能正常工作,否则会报错
<ul>
<li>如果两个接口中有相同的方法,可以通过在实现类中重写该方法来解决</li>
</ul>
</li>
</ul>
<pre><code class="language-java">interface Jim1 &#123;
 default void jim() &#123;
 System.out.println(&quot;Jim1::jim&quot;);
 &#125;
&#125;
interface Jim2 &#123;
 default void jim() &#123;
 System.out.println(&quot;Jim2::jim&quot;);
 &#125;
&#125;
public class Jim implements Jim1, Jim2 &#123;
 @Override public void jim() &#123;
 Jim2.super.jim();
 &#125;
 public static void main(String[] args) &#123;
 new Jim().jim();
 &#125;
&#125;
</code></pre>
<h4 id="10.2.3-%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95" tabindex="-1">10.2.3 接口中的静态方法</h4>
<ul>
<li>Java8允许在接口中包含静态方法,允许在接口里包含逻辑上属于它的实用程序
<ul>
<li>如 runOps()这种操作该接口的方法</li>
<li>show()通用工具</li>
</ul>
</li>
</ul>
<pre><code class="language-java">public interface Operation &#123;
  void execute();
  static void runOps(Operation... ops) &#123;
    for(Operation op : ops)
    op.execute();
  &#125;
  static void show(String msg) &#123;
    System.out.println(msg);
  &#125;
&#125;
class Heat implements Operation &#123;
  @Override public void execute() &#123;
    Operation.show(&quot;Heat&quot;);
  &#125;
&#125;
public class MetalWork &#123;
  public static void main(String[] args) &#123;
    // 必须在静态上下文中定义才能使用方法引用
    Operation twist = new Operation() &#123;
      public void execute() &#123;
        Operation.show(&quot;Twist&quot;);
      &#125;
    &#125;;
    Operation.runOps(
      new Heat(), // [1] 常规类 Heat
      new Operation() &#123; // [2] 匿名内部类
        public void execute() &#123;
          Operation.show(&quot;Hammer&quot;);
        &#125;
      &#125;,
      twist::execute, // [3] 方法引用
      () -&gt; Operation.show(&quot;Anneal&quot;) // [4] Lambda表达式
    );
  &#125;
&#125;
</code></pre>
<h3 id="10.3-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3" tabindex="-1">10.3 抽象类和接口</h3>
<table>
<tr><th>特性</th><th>接口</th><th>抽象类</th></tr>
<tr><td>组合</td><td>可以在新类中组合多个接口</td><td>只能继承一个抽象类</td></tr>
<tr><td>状态</td><td>不能包含字段(静态字段除外,但它们不支持对象状态)</td><td>可以包含字段,非抽象方法可以引用这些字段</td></tr>
<tr><td>默认方法和抽象方法</td><td>默认方法不需要在子类型里实现,它只能引用接口里的方法(字段不行)</td><td>抽象方法必须在子类型中实现</td></tr>
<tr><td>构造器</td><td>不能有构造器</td><td>可以有构造器</td></tr>
<tr><td>访问权限控制</td><td>隐式的public</td><td>可以为protected或包访问权限</td></tr>
</table>
<ul>
<li>在合理的范围内尽可能抽象.因此二者相比更偏向使用接口.大多数情况下,常规类就能解决问题</li>
</ul>
<h3 id="10.4-%E5%AE%8C%E5%85%A8%E8%A7%A3%E8%80%A6" tabindex="-1">10.4 完全解耦</h3>
<ul>
<li>
<p>方法与类配合使用时,只能使用该类或其子类;与接口配合时,可以使用任何实现了该接口的类</p>
</li>
<li>
<p>接口的一个重要特性是,它们与实现部分完全解耦,即使只修改接口,也不会影响现有的实现部分,因此接口是代码演化的关键</p>
</li>
<li>
<p>例子:Processor接口,可以被任何Processor实现类使用,而不需要知道Processor实现类的具体细节,只需要知道Processor实现类的接口即可,同时其他实现类也可以使用Processor接口,这就是完全解耦的好处</p>
</li>
</ul>
<pre><code class="language-java">interface Processor &#123;
  String name();
  Object process(Object input);
&#125;
class Upcase implements Processor &#123;
  @Override public String name() &#123; return getClass().getSimpleName(); &#125;
  @Override public String process(Object input) &#123;
    return ((String)input).toUpperCase();
  &#125;
&#125;
class Downcase implements Processor &#123;
  @Override public String name() &#123; return getClass().getSimpleName(); &#125;
  @Override public String process(Object input) &#123;
    return ((String)input).toLowerCase();
  &#125;
&#125;
class Splitter implements Processor &#123;
  @Override public String name() &#123; return getClass().getSimpleName(); &#125;
  @Override public String process(Object input) &#123;
    return Arrays.toString(((String)input).split(&quot; &quot;));
  &#125;
&#125;
public class Apply &#123;
  public static void process(Processor p, Object s) &#123;
    System.out.println(&quot;Using Processor &quot; + p.name());
    System.out.println(p.process(s));
  &#125;
  public static String s =
    &quot;Disagreement with beliefs is by definition incorrect&quot;;
  public static void main(String[] args) &#123;
    process(new Upcase(), s);
    process(new Downcase(), s);
    process(new Splitter(), s);
  &#125;
&#125;
class FilterAdapter implements Processor &#123;
  Filter filter;
  FilterAdapter(Filter filter) &#123;
    this.filter = filter;
  &#125;
  @Override
  public String name() &#123; return filter.name(); &#125;
  @Override
  public Waveform process(Object input) &#123;
    return filter.process((Waveform)input);
  &#125;
&#125;
</code></pre>
<h3 id="10.5-%E7%BB%84%E5%90%88%E5%A4%9A%E4%B8%AA%E6%8E%A5%E5%8F%A3" tabindex="-1">10.5 组合多个接口</h3>
<ul>
<li>Java中,一个实现类只能继承自一个类,但可以继承自多个接口;代码中先使用extend关键字,再使用implements关键字</li>
</ul>
<pre><code class="language-java">interface CanFight &#123;
  void fight();
&#125;
interface CanSwim &#123;
  void swim();
&#125;
interface CanFly &#123;
  void fly();
&#125;
class ActionCharacter &#123;
  public void fight() &#123;&#125;
&#125;
class Hero extends ActionCharacter
  implements CanFight, CanSwim, CanFly &#123;
  @Override public void swim() &#123;&#125;
  @Override public void fly() &#123;&#125;
  //CanFight中的fight()方法已经在ActionCharacter中实现,因此Hero中不需要重写
&#125;
public class Adventure &#123;
  public static void t(CanFight x) &#123; x.fight(); &#125;
  public static void u(CanSwim x) &#123; x.swim(); &#125;
  public static void v(CanFly x) &#123; x.fly(); &#125;
  public static void w(ActionCharacter x) &#123; x.fight(); &#125;
  public static void main(String[] args) &#123;
    Hero h = new Hero();
    t(h); // 当作一个 CanFight 类型
    u(h); // 当作一个 CanSwim 类型
    v(h); // 当作一个 CanFly 类型
    w(h); // 当作一个 ActionCharacter 类型
  &#125;
&#125;
</code></pre>
<ul>
<li>
<p>使用接口的核心原因</p>
<ul>
<li>向上转型为多个基类型,以及由此带来的灵活性</li>
<li>防止客户端程序员创建该类的对象,并确保该类的实现己经具备了某些特定的行为</li>
</ul>
</li>
<li>
<p>使用接口还是抽象类?</p>
<ul>
<li>如果要创建不带任何方法定义和成员变量的基类,那么就应该选择接口而不是抽象类</li>
</ul>
</li>
</ul>
<h3 id="10.6-%E9%80%9A%E8%BF%87%E7%BB%A7%E6%89%BF%E6%89%A9%E5%B1%95%E6%8E%A5%E5%8F%A3" tabindex="-1">10.6 通过继承扩展接口</h3>
<ul>
<li>可以使用继承向接口里添加新的方法声明,也可以将多个接口组合成一个新接口</li>
</ul>
<pre><code class="language-java">interface Monster &#123;
 void menace();
&#125;
interface DangerousMonster extends Monster &#123;
 void destroy();
&#125;
interface Lethal &#123;
 void kill();
&#125;
interface Vampire extends DangerousMonster, Lethal &#123;
 void drinkBlood();
&#125;
</code></pre>
<ul>
<li>当接口组合在一起时,应避免使用相同的方法名,否则会出现歧义</li>
</ul>
<h3 id="10.7-%E9%80%82%E9%85%8D%E6%8E%A5%E5%8F%A3" tabindex="-1">10.7 适配接口</h3>
<ul>
<li>接口的常见用途:策略设计模式
<ul>
<li>
<ol>
<li>编写一个执行某些操作的方法,该方法指定某些接口作为参数</li>
</ol>
</li>
<li>
<ol start="2">
<li>该方法可以操作任何对象,只要该对象遵循我的接口</li>
</ol>
</li>
</ul>
</li>
<li>例子:Scanner类的构造器接受一个Readable接口作为参数,因此只要你创建的新类实现Readable接口,就可以将该类的对象传递给Scanner类的构造器</li>
</ul>
<pre><code class="language-java">import java.nio.*;
import java.util.*;
public class RandomStrings implements Readable &#123;
  private static Random rand = new Random(47);
  private static final char[] CAPITALS = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;.toCharArray();
  private static final char[] LOWERS = &quot;abcdefghijklmnopqrstuvwxyz&quot;.toCharArray();
  private static final char[] VOWELS = &quot;aeiou&quot;.toCharArray();
  private int count;
  public RandomStrings(int count) &#123;this.count = count;&#125;
  @Override public int read(CharBuffer cb) &#123;
    if(count-- == 0)
      return -1; // 表示输入已经结束
    cb.append(CAPITALS[rand.nextInt(CAPITALS.length)]);
    for(int i = 0; i &lt; 4; i++) &#123;
      cb.append(VOWELS[rand.nextInt(VOWELS.length)]);
      cb.append(LOWERS[rand.nextInt(LOWERS.length)]);
    &#125;
  cb.append(&quot; &quot;);
  return 10; // 添加的字符串
 &#125;
 public static void main(String[] args) &#123;
    Scanner s = new Scanner(new RandomStrings(10));
    while(s.hasNext()) System.out.println(s.next());
  &#125;
&#125;
</code></pre>
<ul>
<li>任何类都可以实现接口,因此可以使用适配器模式,将接口与你想要的任何类结合起来,适配器中的代码将接受你所拥有的接口,并产生你所需要的接口</li>
</ul>
<h3 id="10.8-%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E5%AD%97%E6%AE%B5" tabindex="-1">10.8 接口中的字段</h3>
<ul>
<li>接口中的字段默认为static和final,因此接口中的字段必须被初始化,且不能被修改,因此接口是一种很好的创建常量的方法,Java5之后有enum,因此不需要使用接口来创建常量
<ul>
<li>Java里具有常量初始值的 static final 字段的命名全部使用大写字母(用下划线分割单个标识符中的多个单词)</li>
</ul>
</li>
</ul>
<h3 id="10.9-%E5%B5%8C%E5%A5%97%E6%8E%A5%E5%8F%A3" tabindex="-1">10.9 嵌套接口</h3>
<ul>
<li>接口可以嵌套在类和其它接口中,嵌套在类中的接口自动是public和static的,嵌套在接口中的接口自动是public的</li>
</ul>
<pre><code class="language-java">class A &#123;
  interface B &#123;
    void f();
  &#125;
  public class BImp implements B &#123;
    @Override public void f() &#123;&#125;
  &#125;
  public class BImp2 implements B &#123;
    @Override public void f() &#123;&#125;
  &#125;
  public interface C &#123;
    void f();
  &#125;
  class CImp implements C &#123;
    @Override public void f() &#123;&#125;
  &#125;
  private class CImp2 implements C &#123;
    @Override public void f() &#123;&#125;
  &#125;
  private interface D &#123;
    void f();
  &#125;
  private class DImp implements D &#123;
    @Override public void f() &#123;&#125;
  &#125;
  public class DImp2 implements D &#123;
    @Override public void f() &#123;&#125;
  &#125;
  public D getD() &#123; return new DImp2(); &#125;
  private D dRef;
  public void receiveD(D d) &#123;
    dRef = d;
    dRef.f();
  &#125;
&#125;
interface E &#123;
  interface G &#123;
    void f();
  &#125;
// 1. 多余的 &quot;public&quot;,接口中的都是 public 的
  public interface H &#123;
    void f();
  &#125;
  void g();
// 2. 接口中不能使用private
  //- private interface I &#123;&#125;
&#125;
public class NestingInterfaces &#123;
  public class BImp implements A.B &#123;
    @Override public void f() &#123;&#125;
  &#125;
  class CImp implements A.C &#123;
    @Override public void f() &#123;&#125;
  &#125;
// 3. private 接口只能在定义的类中实现
  //- class DImp implements A.D &#123;
  //- public void f() &#123;&#125;
  //- &#125;
  class EImp implements E &#123;
    @Override public void g() &#123;&#125;
  &#125;
  class EGImp implements E.G &#123;
    @Override public void f() &#123;&#125;
  &#125;
  class EImp2 implements E &#123;
    @Override public void g() &#123;&#125;
    class EG implements E.G &#123;
      @Override public void f() &#123;&#125;
    &#125;
  &#125;
  public static void main(String[] args) &#123;
    A a = new A();
// 4. A.D 为A的私有接口,除了A之外,没有人能实现A.D接口:
    //- A.D ad = a.getD();
// 5. 只能返回A.D的引用,而且只能在A中使用:
    //- A.DImp2 di2 = a.getD();
// 6. 无法访问该接口的方法
    //- a.getD().f();
// 7. 只有另一个A才能接收处理A.D
    A a2 = new A();
    a2.receiveD(a.getD());
  &#125;
&#125;
</code></pre>
<ul>
<li>这些特性初步看是为了语法一致性,但之后肯定是有新的用法</li>
</ul>
<h3 id="10.10-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%B7%A5%E5%8E%82" tabindex="-1">10.10 接口和工厂</h3>
<ul>
<li>工厂方法设计模式:在接口中提供一个创建对象的方法,让实现类决定实例化对象的类型
<ul>
<li>这样代码和接口实现完全隔离,可以透明地将某个实现替换为另一个实现</li>
</ul>
</li>
<li>例子:</li>
</ul>
<pre><code class="language-java">interface Service &#123;
  void method1();
  void method2();
&#125;
interface ServiceFactory &#123;
  Service getService();
&#125;
class Service1 implements Service &#123;
  Service1() &#123;&#125; // Package access
  @Override public void method1() &#123;
    System.out.println(&quot;Service1 method1&quot;);
  &#125;
  @Override public void method2() &#123;
    System.out.println(&quot;Service1 method2&quot;);
  &#125;
&#125;
class Service1Factory implements ServiceFactory &#123;
  @Override public Service getService() &#123;
    return new Service1();
  &#125;
&#125;
class Service2 implements Service &#123;
  Service2() &#123;&#125; // Package access
  @Override public void method1() &#123;
    System.out.println(&quot;Service2 method1&quot;);
  &#125;
  @Override public void method2() &#123;
    System.out.println(&quot;Service2 method2&quot;);
  &#125;
&#125;
class Service2Factory implements ServiceFactory &#123;
  @Override public Service getService() &#123;
    return new Service2();
  &#125;
&#125;
public class Factories &#123;
  public static void
  serviceConsumer(ServiceFactory fact) &#123;
    Service s = fact.getService();
    s.method1();
    s.method2();
  &#125;
  public static void main(String[] args) &#123;
    serviceConsumer(new Service1Factory());
    // 服务完全可以互换
    serviceConsumer(new Service2Factory());
  &#125;
&#125;
/* Output:
Service1 method1
Service1 method2
Service2 method1
Service2 method2
*/
</code></pre>
<ul>
<li>代码中可以看出通过工厂这一中间接口,我们不必在代码中创建Service1和Service2的对象,而是通过工厂创建,这样就可以在不修改代码的情况下,将Service1替换为Service2</li>
<li>这种中间层相当于创建框架,当Service里代码很多时,我们可以很方便地进行复用</li>
</ul>
<h3 id="10.11-%E6%96%B0%E7%89%B9%E6%80%A7%3A%E6%8E%A5%E5%8F%A3%E7%9A%84private%E6%96%B9%E6%B3%95" tabindex="-1">10.11 新特性:接口的private方法</h3>
<ul>
<li>Java9之后,接口可以包含private方法,这样就可以在接口中提供方法的实现,而不是在实现类中提供方法的实现</li>
<li>此后,default方法和static方法都可以使用private方法,这样就可以避免代码重复
<ul>
<li>default方法:接口中具有默认实现的方法.默认方法允许在接口中添加新的方法，而不会破坏已有的实现类。实现类可以选择保留默认方法的实现，也可以重写默认方法来提供自己的实现。</li>
<li>static方法:静态方法与接口相关联，而不是与实现类的实例相关联。它们可以通过接口名直接调用，无需实例化接口。</li>
<li>private方法:私有方法只能在接口内部被调用，用于封装和重用代码块。私有方法可以被默认方法或静态方法调用，以提供共享的实现逻辑。</li>
</ul>
</li>
</ul>
<h3 id="10.12-%E6%96%B0%E7%89%B9%E6%80%A7%3A%E5%AF%86%E5%B0%81%E7%B1%BB%E5%92%8C%E5%AF%86%E5%B0%81%E6%8E%A5%E5%8F%A3" tabindex="-1">10.12 新特性:密封类和密封接口</h3>
<ul>
<li>从JDK17开始引入密封(sealed)类和密封接口,可以限制类或接口的继承关系,只允许特定的类或接口继承或实现该类或接口</li>
</ul>
<pre><code class="language-java">sealed class Base permits D1, D2 &#123;&#125;
final class D1 extends Base &#123;&#125;
final class D2 extends Base &#123;&#125;
// 非法：
// final class D3 extends Base &#123;&#125;
sealed interface Ifc permits Imp1, Imp2 &#123;&#125;
final class Imp1 implements Ifc &#123;&#125;
final class Imp2 implements Ifc &#123;&#125;
sealed abstract class AC permits X &#123;&#125;
final class X extends AC &#123;&#125;
</code></pre>
<ul>
<li><strong>permits</strong>关键字允许我们在单独的文件夹中定义子类,如果所有子类在同一文件夹中可不带permits关键字</li>
<li>一个sealed类需要至少有一个子类</li>
<li><strong>sealed</strong>的子类只能通过以下修饰符定义
<ul>
<li>final:不允许有进一步的子类</li>
<li>sealed:允许有一组密封子类</li>
<li>non-sealed:允许有任意子类</li>
</ul>
</li>
</ul>
<pre><code class="language-java">//sealed类的层次结构
sealed class Bottom permits Level1 &#123;&#125;
sealed class Level1 extends Bottom permits Level2 &#123;&#125;
sealed class Level2 extends Level1 permits Level3 &#123;&#125;
final class Level3 extends Level2 &#123;&#125;
//sealed类的子类可以接触密封
sealed class Super permits Sub1, Sub2 &#123;&#125;
final class Sub1 extends Super &#123;&#125;
non-sealed class Sub2 extends Super &#123;&#125;
class Any1 extends Sub2 &#123;&#125;
class Any2 extends Sub2 &#123;&#125;
</code></pre>
<h2 id="11-%E5%86%85%E9%83%A8%E7%B1%BB" tabindex="-1">11 内部类</h2>
<h3 id="11.1-%E5%88%9B%E5%BB%BA%E5%86%85%E9%83%A8%E7%B1%BB" tabindex="-1">11.1 创建内部类</h3>
<ul>
<li>把类定义放在另一个类中,这就是内部类,内部类可以访问外部类的所有成员,而不需要任何特殊条件,内部类就像是一个独立的实体,与外部类有着密切的联系,但是又可以独立于外部类的实例存在</li>
<li>普遍的使用情况:外部类有一个方法返回指向内部类的引用,或者外部类的方法接受内部类的引用作为参数,这样就可以在外部类的方法中使用内部类的方法和字段</li>
</ul>
<pre><code class="language-java">public class Parcel2 &#123;
  class Contents &#123;
    private int i = 11;
    public int value() &#123; return i; &#125;
  &#125;
  class Destination &#123;
    private String label;
    Destination(String whereTo) &#123;
      label = whereTo;
    &#125;
    String readLabel() &#123; return label; &#125;
  &#125;
  public Destination to(String s) &#123;
    return new Destination(s);
  &#125;
  public Contents contents() &#123;
    return new Contents();
  &#125;
  public void ship(String dest) &#123;
    Contents c = contents();
    Destination d = to(dest);
    System.out.println(d.readLabel());
  &#125;
  public static void main(String[] args) &#123;
    Parcel2 p = new Parcel2();
    p.ship(&quot;Tasmania&quot;);
    Parcel2 q = new Parcel2();
    // 返回内部类的引用
    Parcel2.Contents c = q.contents();
    Parcel2.Destination d = q.to(&quot;Borneo&quot;);
  &#125;
&#125;
</code></pre>
<h3 id="11.2-%E5%88%B0%E5%A4%96%E9%83%A8%E7%B1%BB%E7%9A%84%E9%93%BE%E6%8E%A5" tabindex="-1">11.2 到外部类的链接</h3>
<ul>
<li>当创建一个内部类时,这个内部类的对象会隐含一个链接,指向用于创建该对象的外围对象.通过该链接,无需任何条件,内部类对象可以访问外围对象的成员.内部类用用对外围对象所有元素的访问权</li>
<li>当内部类非static时,内部类对象和外部类对象关联创建</li>
</ul>
<h3 id="11.3-%E4%BD%BF%E7%94%A8.this%E5%92%8C.new" tabindex="-1">11.3 使用.this和.new</h3>
<ul>
<li>当内部类字段和外部类同名时,可以使用this字段.例如，如果内部类为InnerClass，外部类为OuterClass，并且它们都有一个名为field的字段，可以使用OuterClass.this.field来引用外部类的字段。</li>
<li>创建内部类对象时,使用.new关键字;同时必须使用外部类的实例来创建内部类的实例,因为内部类对象会暗暗地连接到创建它的外部类对象上,但是如果创建的是静态内部类,则不需要外部类的实例</li>
</ul>
<pre><code class="language-java">public class OuterClass &#123;
    private int field = 10;
    public class InnerClass &#123;
        private int field = 20;
        public void printFields() &#123;
            System.out.println(&quot;Inner field: &quot; + this.field); // 内部类的字段
            System.out.println(&quot;Outer field: &quot; + OuterClass.this.field); // 外部类的字段
        &#125;
    &#125;
    public static void main(String[] args) &#123;
        OuterClass outer = new OuterClass();
        OuterClass.InnerClass inner = outer.new InnerClass();
        inner.printFields();
    &#125;
&#125;
</code></pre>
<h3 id="11.4-%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B" tabindex="-1">11.4 内部类和向上转型</h3>
<ul>
<li>用private内部类进行接口实现,可以完全隐藏实现的细节,并且完全不用关心接口的实现是否需要修改,因为内部类完全被封装在了外部类中,所以可以很方便地修改内部类的实现,而不会影响到外部类的使用</li>
<li>private内部类也不会被上下转型到,因为只有外部类才能够访问内部类</li>
</ul>
<h3 id="11.5-%E5%9C%A8%E6%96%B9%E6%B3%95%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%AD%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB" tabindex="-1">11.5 在方法和作用域中的内部类</h3>
<ul>
<li>
<p>内部类可以在任意的作用域内定义类,理由如下</p>
<ul>
<li>
<ol>
<li>实现某种接口,以便返回或创建一个引用</li>
</ol>
</li>
<li>
<ol start="2">
<li>作为辅助类,不想公开</li>
</ol>
</li>
</ul>
</li>
<li>
<p>内部类仅在作用域内有效,这种类叫做<strong>局部内部类</strong></p>
</li>
</ul>
<pre><code class="language-java">public class Parcel6 &#123;
  private void internalTracking(boolean b) &#123;
    if(b) &#123;
      class TrackingSlip &#123;
        private String id;
        TrackingSlip(String s) &#123;
          id = s;
        &#125;
        String getSlip() &#123; return id; &#125;
      &#125;
      TrackingSlip ts = new TrackingSlip(&quot;slip&quot;);
      String s = ts.getSlip();
    &#125;
    // 超出作用域范围,不可使用TrackingSlipl类
    //- TrackingSlip ts = new TrackingSlip(&quot;x&quot;);
  &#125;
  public void track() &#123; internalTracking(true); &#125;
  public static void main(String[] args) &#123;
    Parcel6 p = new Parcel6();
    p.track();
  &#125;
&#125;
</code></pre>
<h3 id="11.6-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB" tabindex="-1">11.6 匿名内部类</h3>
<ul>
<li>匿名内部类:没有名字的内部类,可以在定义一个类的同时实例化该类,这样可以省去编写一个完整的类的步骤,但是匿名内部类不能有构造器,因为它连名字都没有,只能使用一次,用完就不能再用了</li>
</ul>
<pre><code class="language-java">public class Parcel7 &#123;
  public Contents contents() &#123;
    return new Contents() &#123; // 插入内部类定义
      private int i = 11;
      @Override public int value() &#123; return i; &#125;
    &#125;; // 分号不能省略
  &#125;
  public static void main(String[] args) &#123;
    Parcel7 p = new Parcel7();
    Contents c = p.contents();
  &#125;
&#125;
//如果不使用匿名内部类,就要创建一个完整的类,如下
public class Parcel7b &#123;
  class MyContents implements Contents &#123;
    private int i = 11;
    @Override public int value() &#123; return i; &#125;
  &#125;
  public Contents contents() &#123;
    return new MyContents();
  &#125;
  public static void main(String[] args) &#123;
    Parcel7b p = new Parcel7b();
    Contents c = p.contents();
  &#125;
&#125;
//有参构造时写法如下
public class Parcel8 &#123;
  public Wrapping wrapping(int x) &#123;
    // Base constructor call:
    return new Wrapping(x) &#123;          // [1]将适当的参数传给基类构造器。
      @Override public int value() &#123;
        return super.value() * 47;
      &#125;
    &#125;;                                // [2]标记表达式结束,语法完备性
  &#125;
  public static void main(String[] args) &#123;
    Parcel8 p = new Parcel8();
    Wrapping w = p.wrapping(10);
  &#125;
&#125;
</code></pre>
<ul>
<li>匿名类使用匿名类之外定义的对象时,需保证对象引用是用final修饰的</li>
<li>匿名类没有构造器,可以借助<strong>实例初始化</strong>来达到类似构造器的作用,但只能初始化一次</li>
</ul>
<pre><code class="language-java">public class Parcel10 &#123;
  public Destination
  destination(final String dest, final float price) &#123;//匿名类中的外部引用必须是final的
    return new Destination() &#123;
      private int cost;
      // 匿名类的实例初始化,达到构造器的小狗
      &#123;
        cost = Math.round(price);
        if(cost &gt; 100)
          System.out.println(&quot;Over budget!&quot;);
      &#125;
      private String label = dest;
      @Override
      public String readLabel() &#123; return label; &#125;
    &#125;;
  &#125;
  public static void main(String[] args) &#123;
    Parcel10 p = new Parcel10();
    Destination d = p.destination(&quot;Tasmania&quot;, 101.395F);
  &#125;
&#125;
</code></pre>
<ul>
<li>与普通类相比,匿名类有着局限性,要么是扩展一个类,要么实现一个接口,但是不能两者兼备</li>
<li>同时匿名类不能是抽象类,因为匿名类没有名字,所以无法提供给其他代码</li>
<li>实现接口时,也只能实现一个</li>
</ul>
<h3 id="11.7-%E5%B5%8C%E5%A5%97%E7%B1%BB" tabindex="-1">11.7 嵌套类</h3>
<ul>
<li>
<p>如果不需要内部类和外部类之间的链接,可以将内部类设置为static,此时称之为<strong>嵌套类</strong>,这意味着</p>
<ul>
<li>
<ol>
<li>不需要一个外部类的对象来创建嵌套类对象</li>
</ol>
</li>
<li>
<ol start="2">
<li>无法从嵌套类的对象中访问非静态的外部类对象</li>
</ol>
</li>
<li>
<ol start="3">
<li>二者之间更像是一种命名空间的关系,内部类在外部类这个命名空间下</li>
</ol>
</li>
</ul>
</li>
<li>
<p>普通内部类和嵌套类也有不同:普通内部类中不能有static字段和方法,嵌套类可以</p>
<ul>
<li>因为普通内部类是依附于外部类的实例的,但static应该依附于类,这与static定义矛盾,编译器会禁止这一行为</li>
<li>而嵌套类不依赖于外部类的实例,因此可以使用static</li>
</ul>
</li>
</ul>
<h4 id="11.7.1-%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E7%B1%BB" tabindex="-1">11.7.1 接口中的类</h4>
<ul>
<li>接口中的任何类都是public和static的,因此接口嵌套类自动是public和static的,可以在接口内部创建嵌套类</li>
<li>当要创建接口的所有实现都要公用的代码时,可以使用接口内部的嵌套类,这样就可以隐藏实现细节,并将代码置于接口的内部.
<ul>
<li>例子:可以用一个嵌套类存放测试代码,这样就可以很方便地测试接口的各种实现</li>
</ul>
</li>
</ul>
<h4 id="11.7.2-%E4%BB%8E%E5%A4%9A%E5%B1%82%E5%B5%8C%E5%A5%97%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB%E4%B8%AD%E8%AE%BF%E9%97%AE%E5%A4%96%E9%83%A8%E6%88%90%E5%91%98" tabindex="-1">11.7.2 从多层嵌套的内部类中访问外部成员</h4>
<ul>
<li>一个内部类可以被嵌套人亦曾,可以访问任意层次的外部类的所有成员,但是外部类不能访问内部类的成员</li>
</ul>
<pre><code class="language-java">class MNA &#123;
  private void f() &#123;&#125;
  class A &#123;
    private void g() &#123;&#125;
    public class B &#123;
      void h() &#123;
        g();
        f();
      &#125;
    &#125;
  &#125;
&#125;
public class MultiNestingAccess &#123;
  public static void main(String[] args) &#123;
    MNA mna = new MNA();
    MNA.A mnaa = mna.new A();
    MNA.A.B mnaab = mnaa.new B();
    mnaab.h();
  &#125;
&#125;
</code></pre>
<h3 id="11.8-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%86%85%E9%83%A8%E7%B1%BB" tabindex="-1">11.8 为什么需要内部类</h3>
<ul>
<li>
<p>内部类最吸引人的原因:每个内部类都能独立地继承自一个(接口的)实现,所以无论外部类是否已经继承了某个(接口的)实现,对于内部类都没有影响</p>
<ul>
<li>内部类完善了多重继承问题的解决方法,每个内部类都能独立继承具体类或抽象类或接口</li>
</ul>
</li>
<li>
<p>考虑情况</p>
<ul>
<li>
<ol>
<li>在一个类需要实现两个接口,那么可以用两种方法,二者无太大区别,可以从问题本质进行选择</li>
</ol>
<ul>
<li>
<ol>
<li>创建一个类实现两个接口</li>
</ol>
</li>
<li>
<ol start="2">
<li>创建一个类实现一个接口,同时创建一个内部类,让内部类实现另一个接口</li>
</ol>
</li>
</ul>
</li>
<li>
<ol start="2">
<li>如果一个类要继承两个抽象类或具体类,那么只能使用内部类</li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="11.8.1-%E9%97%AD%E5%8C%85%E5%92%8C%E5%9B%9E%E8%B0%83" tabindex="-1">11.8.1 闭包和回调</h4>
<ul>
<li>
<p>闭包(closure):一个可调用的对象,它记录了一些信息,这些信息来自于创建它的作用域,可以在任何时刻使用这些信息来调用该对象</p>
<ul>
<li>从该定义看出,内部类是面向外部类对象的闭包,因为它不仅包含外部类对象(创建内部类的作用域),还自动拥有一个指向此外部类对象的引用,并且可以访问其所有成员</li>
</ul>
</li>
<li>
<p>回调:回调是一种常见的程序设计模式,可以在不改变代码的情况下,让某个特定的方法在特定的时刻被调用</p>
<ul>
<li>例子:事件驱动的GUI程序设计,当用户单击按钮时,按钮对象就会调用程序员预先定义好的方法,这种方法就叫做回调方法</li>
<li>如果回调通过指针实现,只能寄希望于程序员操作正确,而Java更为谨慎,语言中没有指针,而内部类提供了同样的解决方案,但更加安全,因为内部类可以完全访问外部类的成员</li>
</ul>
</li>
</ul>
<pre><code class="language-java">interface Incrementable &#123;
  void increment();
&#125;
// 接口的简单实现
class Callee1 implements Incrementable &#123;
  private int i = 0;
  @Override public void increment() &#123;
    i++;
    System.out.println(i);
  &#125;
&#125;
class MyIncrement &#123;
  public void increment() &#123;
    System.out.println(&quot;Other operation&quot;);
  &#125;
  static void f(MyIncrement mi) &#123; mi.increment(); &#125;
&#125;

// 当callee2继承MyIncrement时,increment()方法重载了父类的方法
//此时如果实现Incrementable接口,则Incrementable接口的increment()方法调用与父类矛盾,,因此需要使用内部类
class Callee2 extends MyIncrement &#123;
  private int i = 0;
  @Override public void increment() &#123;
    super.increment();
    i++;
    System.out.println(i);
  &#125;
  //内部类Closure实现了Incrementable接口,并且调用了外部类的increment()方法,提供了一个指向Callee2的引用,但该引用只能访问increment方法,相当于回调,但是更加安全
  private class Closure implements Incrementable &#123;
    @Override public void increment() &#123;
      Callee2.this.increment();
    &#125;
  &#125;
  Incrementable getCallbackReference() &#123;
    return new Closure();
  &#125;
&#125;

class Caller &#123;//Caller的构造器接收一个Incrementable的引用,并且在以后的某个时刻,可以使用此引用回调Incrementable的increment()方法
  private Incrementable callbackReference;
  Caller(Incrementable cbh) &#123;
    callbackReference = cbh;
  &#125;
  void go() &#123; callbackReference.increment(); &#125;
&#125;

public class Callbacks &#123;
  public static void main(String[] args) &#123;
    Callee1 c1 = new Callee1();
    Callee2 c2 = new Callee2();
    MyIncrement.f(c2);
    Caller caller1 = new Caller(c1);
    Caller caller2 =
      new Caller(c2.getCallbackReference());
    caller1.go();
    caller1.go();
    caller2.go();
    caller2.go();
  &#125;
&#125;
</code></pre>
<ul>
<li>回调的价值在于灵活性:可以在运行时动态地决定调用哪些方法
<ul>
<li>简单来说就是把一个对象传递给另一个对象,以便后者在合适的时候调用前者的方法</li>
<li>回调主要是通过回调函数,回调函数是一个作为参数传递给其他函数的函数，它能够被异步调用以处理某些事件或完成某些任务。</li>
</ul>
</li>
</ul>
<h4 id="11.8.2-%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E6%8E%A7%E5%88%B6%E6%A1%86%E6%9E%B6" tabindex="-1">11.8.2 内部类和控制框架</h4>
<ul>
<li>
<p><strong>应用框架</strong>:是一种被设计用来解决某一类特定问题的类和接口的集合,它们的功能被加以通用化,可以应用于多种不同的问题</p>
</li>
<li>
<p>应用框架提供了通用的解决方案,我们在重写方法代码后可以通过定制解决特定的问题,这就是<strong>模板方法</strong>设计模式</p>
</li>
<li>
<p>控制框架:是一种特殊类型的应用框架,主要是为了满足对事件做出响应的需求.</p>
<ul>
<li>主要对事件做出响应的系统也叫做<strong>事件驱动</strong>系统,事件驱动系统通常包含一个或多个事件监听器,用来监听某些特定的事件,并且定义了在事件发生时所采取的动作</li>
<li>内部类可以简化控制框架的创建和使用</li>
</ul>
</li>
<li>
<p>考虑一个控制框架,其工作是当事件就绪时执行相应事件,下面给出一个简单的控制框架</p>
<ul>
<li>事件类Event来记录事件的状态,action函数为事件发生时所采取的动作</li>
<li>Controller类是一个控制框架,addEvent()方法用来添加事件,run()方法用来运行准备好的事件</li>
</ul>
</li>
</ul>
<pre><code class="language-java">import java.time.*; // Java 8 time classes
public abstract class Event &#123;
  private Instant eventTime;
  protected final Duration delayTime;
  public Event(long millisecondDelay) &#123;
    delayTime = Duration.ofMillis(millisecondDelay);
    start();
  &#125;
  public void start() &#123; // Allows restarting
    eventTime = Instant.now().plus(delayTime);
  &#125;
  public boolean ready() &#123;
    return Instant.now().isAfter(eventTime);
  &#125;
  public abstract void action();
&#125;


import java.util.*;

public class Controller &#123;
  private List&lt;Event&gt; eventList = new ArrayList&lt;&gt;();
  public void addEvent(Event c) &#123; eventList.add(c); &#125;
  public void run() &#123;
    while(eventList.size() &gt; 0)
      for(Event e : new ArrayList&lt;&gt;(eventList)/*这里创建了列表的副本,防止删除元素影响遍历*/)
        if(e.ready()) &#123;
          System.out.println(e);
          e.action();
          eventList.remove(e);
        &#125;
  &#125;
&#125;
</code></pre>
<ul>
<li>对于每一个Event,我们都需要创建一个新的子类,并且覆盖action()方法,这样就可以定制自己的Event,接下来我们就可以使用内部类
<ul>
<li>
<ol>
<li>控制框架的整个实现是在一个单独的类中,通过内部类我们可以封装不同的事件,用内部类表达不同的action()</li>
</ol>
</li>
<li>
<ol start="2">
<li>内部类可以访问外部类的成员,因此可以很方便地修改事件列表,避免代码实现复杂</li>
</ol>
</li>
</ul>
</li>
<li>下面给出一个具体的例子,例子中
<ul>
<li>Bell和Restart比较特殊,用到了外部类的EventList,因此需要使用外部类的引用,这里使用了this关键字</li>
</ul>
</li>
</ul>
<pre><code class="language-java">public class GreenhouseControls extends Controller &#123;
  private boolean light = false;
  public class LightOn extends Event &#123;
    public LightOn(long delayTime) &#123;
      super(delayTime);
    &#125;
    @Override public void action() &#123;
      light = true;
    &#125;
    @Override public String toString() &#123;
      return &quot;Light is on&quot;;
    &#125;
  &#125;
  public class LightOff extends Event &#123;
    public LightOff(long delayTime) &#123;
      super(delayTime);
    &#125;
    @Override public void action() &#123;
      light = false;
    &#125;
    @Override public String toString() &#123;
      return &quot;Light is off&quot;;
    &#125;
  &#125;
  private boolean water = false;
  public class WaterOn extends Event &#123;
    public WaterOn(long delayTime) &#123;
      super(delayTime);
    &#125;
    @Override public void action() &#123;
      water = true;
    &#125;
    @Override public String toString() &#123;
      return &quot;Greenhouse water is on&quot;;
    &#125;
  &#125;
  public class WaterOff extends Event &#123;
    public WaterOff(long delayTime) &#123;
      super(delayTime);
    &#125;
    @Override public void action() &#123;
      water = false;
    &#125;
    @Override public String toString() &#123;
      return &quot;Greenhouse water is off&quot;;
    &#125;
  &#125;
  private String thermostat = &quot;Day&quot;;
  public class ThermostatNight extends Event &#123;
    public ThermostatNight(long delayTime) &#123;
      super(delayTime);
    &#125;
    @Override public void action() &#123;
      thermostat = &quot;Night&quot;;
    &#125;
    @Override public String toString() &#123;
      return &quot;Thermostat on night setting&quot;;
    &#125;
  &#125;
  public class ThermostatDay extends Event &#123;
    public ThermostatDay(long delayTime) &#123;
      super(delayTime);
    &#125;
    @Override public void action() &#123;
      thermostat = &quot;Day&quot;;
    &#125;
    @Override public String toString() &#123;
      return &quot;Thermostat on day setting&quot;;
    &#125;
  &#125;
  public class Bell extends Event &#123;
    public Bell(long delayTime) &#123;
      super(delayTime);
    &#125;
    @Override public void action() &#123;
      addEvent(new Bell(delayTime.toMillis()));
    &#125;
    @Override public String toString() &#123;
      return &quot;Bing!&quot;;
    &#125;
  &#125;
  public class Restart extends Event &#123;
    private Event[] eventList;
    public
    Restart(long delayTime, Event[] eventList) &#123;
      super(delayTime);
      this.eventList = eventList;
      for(Event e : eventList)
        addEvent(e);
    &#125;
    @Override public void action() &#123;
      for(Event e : eventList) &#123;
        e.start(); // Rerun each event
        addEvent(e);
      &#125;
      start(); // Rerun this Event
      addEvent(this);
    &#125;
    @Override public String toString() &#123;
      return &quot;Restarting system&quot;;
    &#125;
  &#125;
  public static class Terminate extends Event &#123;
    public Terminate(long delayTime) &#123;
      super(delayTime);
    &#125;
    @Override
    public void action() &#123; System.exit(0); &#125;
    @Override public String toString() &#123;
      return &quot;Terminating&quot;;
    &#125;
  &#125;
&#125;

// 运行控制框架
public class GreenhouseController &#123;
  public static void main(String[] args) &#123;
    GreenhouseControls gc = new GreenhouseControls();
    // 加入控制框架中不同的Event对象,这是命令设计模式的一个例子--eventList中的每个对象都是封装为对象的请求
    gc.addEvent(gc.new Bell(900));
    Event[] eventList = &#123;
      gc.new ThermostatNight(0),
      gc.new LightOn(200),
      gc.new LightOff(400),
      gc.new WaterOn(600),
      gc.new WaterOff(800),
      gc.new ThermostatDay(1400)
    &#125;;
    gc.addEvent(gc.new Restart(2000, eventList));
    gc.addEvent(
      new GreenhouseControls.Terminate(5000));
    gc.run();
  &#125;
&#125;
</code></pre>
<h3 id="11.9-%E7%BB%A7%E6%89%BF%E5%86%85%E9%83%A8%E7%B1%BB" tabindex="-1">11.9 继承内部类</h3>
<ul>
<li>因为内部类的构造器必须附加一个指向其包围类对象的引用,所以在继承内部类时,事情会变得有点复杂,必须有特殊的语法指明这种关联
<ul>
<li>下面代码中InheritInner继承了内部类,创建构造器时,不能使用默认构造器,需要传递一个指向外部类对象的引用,并且必须在构造器内使用语法<code>OuterClassName.super()</code>来调用基类构造器</li>
</ul>
</li>
</ul>
<pre><code class="language-java">class WithInner &#123;
  class Inner &#123;&#125;
&#125;

public class InheritInner extends WithInner.Inner &#123;
  //- InheritInner() &#123;&#125; // 默认构造器会编译失败
  InheritInner(WithInner wi) &#123;
    wi.super();
  &#125;
  public static void main(String[] args) &#123;
    WithInner wi = new WithInner();
    InheritInner ii = new InheritInner(wi);
  &#125;
&#125;
</code></pre>
<h3 id="11.10-%E5%86%85%E9%83%A8%E7%B1%BB%E5%8F%AF%E4%BB%A5%E8%A2%AB%E9%87%8D%E5%86%99%E5%90%97" tabindex="-1">11.10 内部类可以被重写吗</h3>
<ul>
<li>当继承外部类时,内部类没有特殊之处,因为这两个内部类是两个独立的实体,分别在自己的命名空间中</li>
<li>然而,显式地继承某个内部类是可行的</li>
</ul>
<pre><code class="language-java">class Egg2 &#123;
  protected class Yolk &#123;
    public Yolk() &#123;
      System.out.println(&quot;Egg2.Yolk()&quot;);
    &#125;
    public void f() &#123;
      System.out.println(&quot;Egg2.Yolk.f()&quot;);
    &#125;
  &#125;
  private Yolk y = new Yolk();
  Egg2() &#123; System.out.println(&quot;New Egg2()&quot;); &#125;
  public void insertYolk(Yolk yy) &#123; y = yy; &#125;
  public void g() &#123; y.f(); &#125;
&#125;
public class BigEgg2 extends Egg2 &#123;
  public class Yolk extends Egg2.Yolk &#123;
    public Yolk() &#123;
      System.out.println(&quot;BigEgg2.Yolk()&quot;);
    &#125;
    @Override public void f() &#123;
      System.out.println(&quot;BigEgg2.Yolk.f()&quot;);
    &#125;
  &#125;
  public BigEgg2() &#123; insertYolk(new Yolk()); &#125;
  public static void main(String[] args) &#123;
    Egg2 e2 = new BigEgg2();
    e2.g();
  &#125;
&#125;
/* Output:
Egg2.Yolk()
New Egg2()
Egg2.Yolk()
BigEgg2.Yolk()
BigEgg2.Yolk.f()
*/
</code></pre>
<h3 id="11.11-%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB" tabindex="-1">11.11　局部内部类</h3>
<ul>
<li>内部类也可以在代码块内创建,通常是在方法体中;</li>
<li>局部内部类不能使用访问权限修饰符,因为其不是外围类的组成部分,但是它可以访问当前代码块中的常量及外围类的所有成员</li>
<li>局部内部类可以和匿名内部类相互替代
<ul>
<li>但局部内部类可以创建多个该类对象,匿名内部类只能返回一个实例</li>
<li>局部内部类允许我们i当以具名的构造器和重载半杯,匿名类只能实例初始化</li>
</ul>
</li>
</ul>
<h3 id="11.12-%E5%86%85%E9%83%A8%E7%B1%BB%E6%A0%87%E8%AF%86%E7%AC%A6" tabindex="-1">11.12 内部类标识符</h3>
<ul>
<li>内部类标识符:在生成的.class文件中,内部类会被编译器重命名,以外部类名$内部类名的形式命名</li>
<li>如果内部类是匿名的，编译器会以数字作为内部类标识符。</li>
<li>如果内部类嵌套在其他内部类之内，它们的名字会被附加到其外围类标识符和 $ 之后</li>
</ul>
<h2 id="12-%E9%9B%86%E5%90%88" tabindex="-1">12 集合</h2>
<ul>
<li>java.until库有一组完整的<strong>集合类</strong>,基本的类型是List,Set,Queue,Map.这些类型也叫容器类</li>
<li>集合类中不能使用基本类型,要包装类型,但有自动装箱机制,我们不用担心</li>
</ul>
<h3 id="12.1-%E6%B3%9B%E5%9E%8B%E5%92%8C%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88" tabindex="-1">12.1 泛型和类型安全的集合</h3>
<ul>
<li>
<p>Java5之前的集合类,编译器允许向集合中插入不正确元素,但会引来很多问题,因此Java5引入了泛型,泛型的基本思想是参数化类型,也就是说所操作的数据类型被指定为一个参数</p>
</li>
<li>
<p>泛型的好处</p>
<ul>
<li>
<ol>
<li>类型安全,编译器会检查类型,不会出现向集合中插入错误类型的元素</li>
</ol>
</li>
<li>
<ol start="2">
<li>消除了强制类型转换,不需要强制类型转换</li>
</ol>
</li>
<li>
<ol start="3">
<li>代码更加简洁</li>
</ol>
</li>
</ul>
</li>
<li>
<p>定义泛型类实例</p>
</li>
</ul>
<pre><code class="language-java">//Java7 前前后都需要&lt;Apple&gt;,Java7后可以省略后面的&lt;Apple&gt;
ArrayList&lt;Apple&gt; apples = new ArrayList&lt;Apple&gt;();
ArrayList&lt;Apple&gt; apples = new ArrayList&lt;&gt;();
//在JDK10/11 加入了var关键字,可以自动推断类型,代码更加简洁,但后面&lt;&gt;内必须标明类型,否则默认Object类
var apples = new ArrayList&lt;Apple&gt;();
</code></pre>
<h3 id="12.2-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" tabindex="-1">12.2 基本概念</h3>
<ul>
<li>
<p>Java集合类库用来&quot;持有对象&quot;,从设计上有两个不同的概念,表现为库的两个基本接口</p>
<ul>
<li>
<ol>
<li>Collection:一个由单独元素组成的序列,这些元素都服从一条或多条规则.</li>
</ol>
<ul>
<li>List必须按照元素插入顺序保存他们;</li>
<li>Set中不能有重复元素;</li>
<li>Queue按照排队规则来确定对象产生的顺序</li>
</ul>
</li>
<li>
<ol start="2">
<li>Map:一组键值对象,使用键来查找值</li>
</ol>
<ul>
<li>ArrayList:使用一个数值查找某个元素,广义Map</li>
<li>Map:使用另一个对象来查找某个对象,也称关联数组或字典</li>
</ul>
</li>
</ul>
</li>
<li>
<p>我们编写的代码总是在和这些接口打交道</p>
</li>
</ul>
<pre><code class="language-java">//List为接口,ArrayList为实现类,这里相当于向上转型
List&lt;Apple&gt; apples = new ArrayList&lt;&gt;();
//我们可以替换实现类
List&lt;Apple&gt; apples = new LinkedList&lt;&gt;();
//但向上转型并不是总是可以,因为显现类会有自己的方法,而接口中没有
LinkedList&lt;Apple&gt; apples = new LinkedList&lt;&gt;();
</code></pre>
<ul>
<li>
<p>序列是持有一组对象的一种方式,Collection接口是序列概念的一般化</p>
</li>
<li>
<p>Java集合类库有着完整的体系结构,根接口即为Collection和Map</p>
</li>
</ul>
<p><img src="/images/PL/OnJava8/12_2.webp" alt></p>
<h3 id="12.3-%E6%B7%BB%E5%8A%A0%E4%B8%80%E7%BB%84%E5%85%83%E7%B4%A0" tabindex="-1">12.3 添加一组元素</h3>
<ul>
<li>java.util 中的 Arrays 和 Collections 类都包含了一些工具方法，用于向一个 Collection中添加一组元素
<ul>
<li>Arrays.asList() 方法:接受一个数组或是用逗号分隔的元素列表，并将其转换为一个 List 对象;底层为数组,无法修改大小</li>
<li>Collections.addAll() 方法:接受一个 Collection 对象，以及一个数组或是一个用逗号分隔的列表，然后将元素添加到 Collection 中</li>
</ul>
</li>
</ul>
<pre><code class="language-java">Collection&lt;Integer&gt; collection = new ArrayList&lt;&gt;(Arrays.asList(1, 2, 3, 4, 5));
Integer[] moreInts = &#123; 6, 7, 8, 9, 10 &#125;;
collection.addAll(Arrays.asList(moreInts));
// 运行快很多，但是我们无法以这种方式构建 Collection：
Collections.addAll(collection, 11, 12, 13, 14, 15);
Collections.addAll(collection, moreInts);
// 生成一个底层为数组的列表：
List&lt;Integer&gt; list = Arrays.asList(16,17,18,19,20);
list.set(1, 99); // OK——修改元素
 // list.add(21); // 运行时错误；底层的数组不能调整大小
</code></pre>
<h3 id="12.4-%E9%9B%86%E5%90%88%E6%89%93%E5%8D%B0" tabindex="-1">12.4 集合打印</h3>
<pre><code class="language-java">public class PrintingCollections &#123;
  static Collection
  fill(Collection&lt;String&gt; collection) &#123;
    collection.add(&quot;rat&quot;);
    collection.add(&quot;cat&quot;);
    collection.add(&quot;dog&quot;);
    collection.add(&quot;dog&quot;);
    return collection;
  &#125;
  static Map fill(Map&lt;String, String&gt; map) &#123;
    map.put(&quot;rat&quot;, &quot;Fuzzy&quot;);
    map.put(&quot;cat&quot;, &quot;Rags&quot;);
    map.put(&quot;dog&quot;, &quot;Bosco&quot;);
    map.put(&quot;dog&quot;, &quot;Spot&quot;);
    return map;
  &#125;
  public static void main(String[] args) &#123;
    System.out.println(fill(new ArrayList&lt;&gt;()));
    System.out.println(fill(new LinkedList&lt;&gt;()));
    System.out.println(fill(new HashSet&lt;&gt;()));
    System.out.println(fill(new TreeSet&lt;&gt;()));
    System.out.println(fill(new LinkedHashSet&lt;&gt;()));
    System.out.println(fill(new HashMap&lt;&gt;()));
    System.out.println(fill(new TreeMap&lt;&gt;()));
    System.out.println(fill(new LinkedHashMap&lt;&gt;()));
  &#125;
&#125;
/* Output:
[rat, cat, dog, dog]
[rat, cat, dog, dog]
[rat, cat, dog]
[cat, dog, rat]
[rat, cat, dog]
&#123;rat=Fuzzy, cat=Rags, dog=Spot&#125;
&#123;cat=Rags, dog=Spot, rat=Fuzzy&#125;
&#123;rat=Fuzzy, cat=Rags, dog=Spot&#125;
*/
</code></pre>
<ul>
<li>集合类可以很漂亮的进行打印,通过toString方法,Collection的内容用方括号包起来,Map的内容用花括号包起来,键值对用等号连接,并且按照键的升序排列</li>
<li>上述代码展示了Java集合类库的两种主要类型,区别是集合中每个&quot;槽&quot;(slot)内持有的条目数
<ul>
<li>Collection:每个槽只能持有一个元素
<ul>
<li>List:按照插入顺序保存元素
<ul>
<li>ArrayList和LinkedList</li>
</ul>
</li>
<li>Set:不能有重复元素
<ul>
<li>HashSet</li>
<li>TreeSet:以升序保存对象</li>
<li>LinkedHashSet:按照添加顺序来保存对象</li>
</ul>
</li>
<li>Queue:按照排队规则来确定对象产生的顺序</li>
</ul>
</li>
<li>Map:每个槽持有两个对象,一个是键,一个是值,键用来查找值
<ul>
<li>HashMap:保存顺序不同于插入顺序</li>
<li>TreeMap:按照键的升序来排序</li>
<li>LinkedHashMap:按照插入顺序来保存键，同时保留了 HashMap 的查找速度</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="12.5-list" tabindex="-1">12.5 List</h3>
<ul>
<li>
<p>List接口在Collection基础上增加方法,支持在List中间插入和删除元素,有两种基本类型的List</p>
<ul>
<li>基本的ArrayList,擅长随机访问元素,但在List中间插入和删除元素比较慢</li>
<li>LinkedList,提供了理想的顺序访问性能,在List中间插入和删除元素比较快,但随机访问元素比较慢</li>
</ul>
</li>
<li>
<p>List 方法</p>
<ul>
<li>contains(Object):判断是否包含某个对象</li>
<li>remove(Object):删除某个对象</li>
<li>indexOf(Object):返回某个对象的索引</li>
<li>equals(Object):判断是否相等,两个对象相等的条件是:1.类型相同 2.长度相同 3.每个位置的元素都相同,使用equals()方法判断,而不是==,因为==判断的是对象的引用</li>
<li>subList(int fromIndex, int toIndex):返回一个子列表,包含fromIndex到toIndex之间的元素,不包含toIndex,即左闭右开</li>
<li>containsAll(Collection):判断是否包含某个集合中的所有元素</li>
<li>addAll(Collection):添加某个集合中的所有元素</li>
<li>removeAll(Collection):删除某个集合中的所有元素</li>
<li>retainAll(Collection):删除不在某个集合中的所有元素,即取交集</li>
<li>clear():删除所有元素</li>
<li>isEmpty():判断是否为空</li>
<li>toArray():返回一个包含所有元素的数组</li>
<li>set(int index, E element):将index位置的元素替换为element</li>
</ul>
</li>
<li>
<p>Collectons静态方法</p>
<ul>
<li>Collections.shuffle(List):随机打乱List中的元素</li>
<li>Collections.sort(List):按照自然顺序排序</li>
</ul>
</li>
</ul>
<h3 id="12.6-iterator" tabindex="-1">12.6 Iterator</h3>
<ul>
<li>迭代器(也是一种设计模式)的概念实现了一种抽象的接口,用来遍历容器中的元素,迭代器提供了一种通用的方式来遍历容器中的所有元素,并且不需要关心容器的具体类型</li>
<li>Java迭代器只能向一个方向移动,有以下几点
<ul>
<li>
<ol>
<li>使用iterator()方法让Collection返回一个Iterator对象,该迭代器准备返回序列中的第一个元素</li>
</ol>
</li>
<li>
<ol start="2">
<li>使用next()方法获得序列中的下一个元素</li>
</ol>
</li>
<li>
<ol start="3">
<li>使用hasNext()方法检查序列中是否还有元素</li>
</ol>
</li>
<li>
<ol start="4">
<li>使用remove()方法将迭代器新返回的元素删除</li>
</ol>
</li>
</ul>
</li>
</ul>
<pre><code class="language-java">public class SimpleIteration &#123;
  public static void main(String[] args) &#123;
    List&lt;Pet&gt; pets = new PetCreator().list(12);
    Iterator&lt;Pet&gt; it = pets.iterator();
    while(it.hasNext()) &#123;
      Pet p = it.next();
      System.out.print(p.id() + &quot;:&quot; + p + &quot; &quot;);
    &#125;
    System.out.println();
    // 迭代器更简单的写法
    for(Pet p : pets)
      System.out.print(p.id() + &quot;:&quot; + p + &quot; &quot;);
    System.out.println();
    // 迭代器删除元素
    it = pets.iterator();
    for(int i = 0; i &lt; 6; i++) &#123;
      it.next();
      it.remove();
    &#125;
    System.out.println(pets);
  &#125;
&#125;
</code></pre>
<ul>
<li>迭代器<strong>统一了对集合的访问</strong>;使用Iterable接口,我们可以编写能够<strong>作用于任何Collection对象</strong>的方法
<ul>
<li>例子:下面的display()方法可以接受任何实现了Iterable接口的对象</li>
</ul>
</li>
</ul>
<pre><code class="language-java">public static void display(Iterable&lt;Pet&gt; ip) &#123;
    Iterator&lt;Pet&gt; it = ip.iterator();
    while(it.hasNext()) &#123;
      Pet p = it.next();
      System.out.print(p.id() + &quot;:&quot; + p + &quot; &quot;);
    &#125;
    System.out.println();
&#125;
public static void main(String[] args) &#123;
  List&lt;Pet&gt; pets = new PetCreator().list(8);
  LinkedList&lt;Pet&gt; petsLL = new LinkedList&lt;&gt;(pets);
  HashSet&lt;Pet&gt; petsHS = new HashSet&lt;&gt;(pets);
  TreeSet&lt;Pet&gt; petsTS = new TreeSet&lt;&gt;(pets);
  display(pets);
  display(petsLL);
  display(petsHS);
  display(petsTS);
&#125;
</code></pre>
<ul>
<li>ListIterator
<ul>
<li>ListIterator是Iterator的子类型,只能用于各种List类的访问,可以双向移动</li>
<li>nextIndex(),previousIndex() 可以产生相对于迭代器在列表中指向的当前位置的前一个和后一个元素的索引</li>
<li>set()方法替换它访问过的最后一个元素</li>
<li>add()方法在它访问过的位置插入一个元素</li>
<li>listIterator(n):生成一个指向列表中索引为 n 的元素处的 ListIterator</li>
</ul>
</li>
</ul>
<pre><code class="language-java">public class ListIteration &#123;
  public static void main(String[] args) &#123;
    List&lt;Pet&gt; pets = new PetCreator().list(8);
    ListIterator&lt;Pet&gt; it = pets.listIterator();
    while(it.hasNext())
      System.out.print(it.next() +
        &quot;, &quot; + it.nextIndex() +
        &quot;, &quot; + it.previousIndex() + &quot;; &quot;);
  /*
    1. 这里输出中函数调用顺序是从左到右
    2. 这里需要对next实现理解,首先it.next()返回的是当前元素,然后指针向后移动一位,指向下一个元素,所以it.nextIndex()返回的其实是当前指针指向元素的索引
    public E next() &#123;
        if (!hasNext()) &#123;
            throw new NoSuchElementException();
        &#125;
        E value = currentNode.getValue();
        currentNode = currentNode.getNext();
        return value;
    &#125;
  */
    System.out.println();
    // 反向:
    while(it.hasPrevious())
      System.out.print(it.previous().id() + &quot; &quot;);
    System.out.println();
    System.out.println(pets);
    it = pets.listIterator(3);
    while(it.hasNext()) &#123;
      it.next();
      it.set(new PetCreator().get());
    &#125;
    System.out.println(pets);
  &#125;
&#125;
/* Output:
Rat, 1, 0; Manx, 2, 1; Cymric, 3, 2; Mutt, 4, 3; Pug,
5, 4; Cymric, 6, 5; Pug, 7, 6; Manx, 8, 7;
7 6 5 4 3 2 1 0
[Rat, Manx, Cymric, Mutt, Pug, Cymric, Pug, Manx]
[Rat, Manx, Cymric, Rat, Rat, Rat, Rat, Rat]
*/
</code></pre>
<h3 id="12.7-linkedlist" tabindex="-1">12.7 LinkedList</h3>
<ul>
<li>LinkedList是一个双向链表,可以快速地在List中间插入和删除元素,但随机访问元素比较慢,其实现了基本的List接口,也添加了一些可以用于栈,队列或双端队列的方法
<ul>
<li>
<ol>
<li>getFirst(),element():返回列表的第一个元素,但不删除;如果列表为空,抛出NoSuchElementException;peek():返回列表的第一个元素,但不删除;如果列表为空,返回null</li>
</ol>
</li>
<li>
<ol start="2">
<li>removeFirst(),remove():返回列表的第一个元素,并删除;如果列表为空,抛出NoSuchElementException;poll():返回列表的第一个元素,并删除;如果列表为空,返回null</li>
</ol>
</li>
<li>
<ol start="3">
<li>addFirst():将元素插入到列表的前面;</li>
</ol>
</li>
<li>
<ol start="4">
<li>addLast(),offer(),add():将元素添加到列表的末尾</li>
</ol>
</li>
<li>
<ol start="5">
<li>removeLast():返回列表的最后一个元素,并删除;</li>
</ol>
</li>
<li>上述方法都有些微小差别,需要在使用时注意</li>
</ul>
</li>
</ul>
<h3 id="12.8-stack" tabindex="-1">12.8 Stack</h3>
<ul>
<li>Java1.0 提供了Stack类,但实现很糟糕,不过因为要向后兼容,所以一直保留了下来,但是不建议使用</li>
<li>Java6 加入了ArrayDeque,提供了直接实现栈功能的方法</li>
<li>总之,Java中java.util.Stack的栈方法不建议使用,而是使用java.util.ArrayDeque或其他方法模拟栈</li>
</ul>
<h3 id="12.9-set" tabindex="-1">12.9 Set</h3>
<ul>
<li>Set是一种不保存重复元素的Collection,Set接口没有提供额外的方法,只是限制了Collection中不能有重复元素
<ul>
<li>HashSet使用Hash提升速度,输出的顺序没有规律</li>
<li>TreeSet使用红黑树实现,按照升序保存对象</li>
<li>LinkedHashSet按照添加顺序保存对象,也是用哈希表实现的,但是同时维护了一个链表,因此性能略低于HashSet,但是迭代访问Set中的元素时,性能比HashSet好</li>
</ul>
</li>
</ul>
<h3 id="12.10-map" tabindex="-1">12.10 Map</h3>
<ul>
<li>Map是一种关联数组,也称为字典或者是键值对,Map中的每个元素都包含一个键对象和一个值对象,每个键只能出现一次,但是可以多次出现相同的值;因此Map可以方便的扩展到多维
<ul>
<li>Boolean containsKey(Object):判断是否包含某个键</li>
<li>Boolean containsValue(Object):判断是否包含某个值</li>
<li>V get(Object):返回某个键对应的值</li>
<li>V put(K key, V value):添加键值对</li>
<li>V remove(Object):删除某个键值对</li>
<li>int size():返回键值对的个数</li>
<li>void clear():删除所有键值对</li>
<li>boolean isEmpty():判断是否为空</li>
<li>Set<K> keySet():返回所有键组成的Set</K></li>
<li>Collection<V> values():返回所有值组成的Collection</V></li>
<li>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet():返回所有键值对组成的Set</li>
<li>Map.Entry&lt;K, V&gt;:是Map中的一个内部接口,表示一个键值对,包含getKey(),getValue(),setValue()方法</li>
</ul>
</li>
<li>遍历Map的最佳方法,使用<code>for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet())</code>
<ul>
<li>
<ol>
<li>效率高</li>
</ol>
</li>
<li>
<ol start="2">
<li>简单易读</li>
</ol>
</li>
<li>
<ol start="3">
<li>支持键值对操作</li>
</ol>
</li>
<li>但该方法返回的集合视图不可修改,修改或删除需要使用Map接口提供的其他方法</li>
</ul>
</li>
</ul>
<pre><code class="language-java">for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;
    String key = entry.getKey();
    Integer value = entry.getValue();
    System.out.println(&quot;Key: &quot; + key + &quot;, Value: &quot; + value);
&#125;
</code></pre>
<h3 id="12.11-%E6%96%B0%E7%89%B9%E6%80%A7%3A%E8%AE%B0%E5%BD%95(record)%E7%B1%BB%E5%9E%8B" tabindex="-1">12.11 新特性:记录(record)类型</h3>
<ul>
<li>
<p>Map使用的障碍:键的对象必须要定义两个函数:hashCode()和equals(),这两个函数必须要一致</p>
</li>
<li>
<p>JDK16 新增 record关键字.record定义的是希望称为<strong>数据传输对象</strong>(也叫<strong>数据载体</strong>)的类,使用record时,编译器自动生成</p>
<ul>
<li>
<ol>
<li>私有的final字段,用来保存每个组件的状态</li>
</ol>
</li>
<li>
<ol start="2">
<li>公共的构造器,用来初始化每个组件的状态</li>
</ol>
</li>
<li>
<ol start="3">
<li>公共的访问器方法,用来访问每个组件的状态</li>
</ol>
</li>
<li>
<ol start="4">
<li>equals()方法,用来比较两个记录是否相等</li>
</ol>
</li>
<li>
<ol start="5">
<li>hashCode()方法,用来生成记录的哈希码</li>
</ol>
</li>
<li>
<ol start="6">
<li>toString()方法,用来生成记录的字符串表示形式</li>
</ol>
</li>
</ul>
</li>
<li>
<p>例子:</p>
</li>
</ul>
<pre><code class="language-java">
import java.util.*;
record Employee(String name, int id) &#123;&#125;

public class BasicRecord &#123;
  public static void main(String[] args) &#123;
    var bob = new Employee(&quot;Bob Dobbs&quot;, 11);
    var dot = new Employee(&quot;Dorothy Gale&quot;, 9);
    // bob.id = 12; // 错误:
    // id 在 Employee 中的访问权限为 private
    System.out.println(bob.name()); // 访问器
    System.out.println(bob.id()); // 访问器
    System.out.println(bob); // toString()
    //  Employee 可以用做 Map 中的键：
    var map = Map.of(bob, &quot;A&quot;, dot, &quot;B&quot;);
    System.out.println(map);
  &#125;
&#125;
/* Output:
Bob Dobbs
11
Employee[name=Bob Dobbs, id=11]
&#123;Employee[name=Dorothy Gale, id=9]=B, Employee[name=Bob Dobbs, id=11]=A&#125;
*/
</code></pre>
<ul>
<li>record只需要名字和参数即可
<ul>
<li>
<ol>
<li>参数自动变为 private final 的字段</li>
</ol>
</li>
<li>
<ol start="2">
<li>不能再record内部定义字段,但可以加入静态的字段,初始值</li>
</ol>
</li>
<li>
<ol start="3">
<li>可以定义方法,但只能使用参数,不能修改,因为参数是final的</li>
</ol>
</li>
</ul>
</li>
<li>record不能继承或者被继承,其隐含为final的,但可以实现接口
<ul>
<li>例子:编译器会强制我们实现density()方法,但不会因为brightness()方法而报错,因为brightness()方法在record<strong>自动生成</strong>的访问器中已经实现了</li>
</ul>
</li>
</ul>
<pre><code class="language-java">interface Star &#123;
 double brightness();
 double density();
&#125;
record RedDwarf(double brightness) implements Star &#123;
 @Override public double density() &#123; return 100.0; &#125;
&#125;
</code></pre>
<ul>
<li>record可以被嵌套和局部使用,此时record都是静态的</li>
<li>record会自动创建一个规范的构造器,但我们可以使用**紧凑构造器(compact)**来添加构造器行为
<ul>
<li>紧凑构造器的参数必须是record的参数,且必须在record的参数之后</li>
<li>紧凑构造器常用来验证参数,或者是对参数进行修改,也可以调用外部函数</li>
<li>例子:下面的紧凑构造器会将id的值加1</li>
</ul>
</li>
</ul>
<pre><code class="language-java">record Employee(String name, int id) &#123;
  Employee &#123;
    if (id &lt; 1) throw new IllegalArgumentException();
    id++;
  &#125;
&#125;
</code></pre>
<ul>
<li>也可以使用普通构造器语法替换掉自动生成的构造器,构造器必须精确复制这个 record 的签名,但是必须使用this()调用自动生成的构造器,</li>
</ul>
<pre><code class="language-java">record Employee(String name, int id) &#123;
  Employee(String name) &#123;
    this.name = name;
  &#125;
&#125;
</code></pre>
<h3 id="12.12-queue" tabindex="-1">12.12 Queue</h3>
<ul>
<li>
<p>Queue是一个典型的先进先出(FIFO)的容器,Queue接口继承了Collection接口,并添加了一些额外的方法</p>
<ul>
<li>
<ol>
<li>add():将元素插入到队尾,如果插入成功,返回true,否则抛出异常</li>
</ol>
</li>
<li>
<ol start="2">
<li>offer():将元素插入到队尾,如果插入成功,返回true,否则返回false</li>
</ol>
</li>
<li>
<ol start="3">
<li>remove():返回队头元素,如果队列为空,抛出异常</li>
</ol>
</li>
<li>
<ol start="4">
<li>poll():返回队头元素,如果队列为空,返回null</li>
</ol>
</li>
<li>
<ol start="5">
<li>element():返回队头元素,如果队列为空,抛出异常</li>
</ol>
</li>
<li>
<ol start="6">
<li>peek():返回队头元素,如果队列为空,返回null</li>
</ol>
</li>
</ul>
</li>
<li>
<p>LinkedList实现了Queue接口,因此可以直接使用LinkedList来实现队列</p>
</li>
</ul>
<pre><code class="language-java">public class QueueDemo &#123;
  public static void printQ(Queue queue) &#123;
    while(queue.peek() != null)
      System.out.print(queue.remove() + &quot; &quot;);
    System.out.println();
  &#125;
  public static void main(String[] args) &#123;
    Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
    Random rand = new Random(47);
    for(int i = 0; i &lt; 10; i++)
      queue.offer(rand.nextInt(i + 10));
    printQ(queue);
    Queue&lt;Character&gt; qc = new LinkedList&lt;&gt;();
    for(char c : &quot;Brontosaurus&quot;.toCharArray())
      qc.offer(c);
    printQ(qc);
  &#125;
&#125;
</code></pre>
<h4 id="priorityqueue" tabindex="-1">PriorityQueue</h4>
<ul>
<li>Java5中添加PriorityQueue,为Queue的优先队列的实现,其内部使用堆来实现,可以使用Comparator来控制元素的排序</li>
</ul>
<pre><code class="language-java">PriorityQueue&lt;Integer&gt; priorityQueue = new PriorityQueue&lt;&gt;();
priorityQueue = new PriorityQueue&lt;&gt;(Arrays.asList(1, 2, 3, 4, 5, 6, 7));
priorityQueue = new PriorityQueue&lt;&gt;(size, Collections.reverseOrder());//这里即使用了Comparator,使用了Collections.reverseOrder()来反转排序
priorityQueue = new PriorityQueue&lt;&gt;(comparator);//使用自己定义的比较器
Comparator&lt;Integer&gt; comparator = new Comparator&lt;Integer&gt;() &#123;
  @Override public int compare(Integer o1, Integer o2) &#123;
    return o2 - o1;
  &#125;
&#125;;
</code></pre>
<h3 id="12.13-collection%E5%92%8Citerator" tabindex="-1">12.13 Collection和Iterator</h3>
<ul>
<li>
<p>Collection接口是所有Collection类的根接口,它提供了一组标准的集合操作,包括添加,删除,查找,遍历等;此外,java.util.AbstractCollection类提供了Collection接口的默认实现,以减少实现Collection接口所需的工作量</p>
</li>
<li>
<p>C<ins>标准库中的集合类没有公共基类,集合之间共性通过迭代器实现,Java也遵循C</ins>的方式,但Java中Collection接口继承了Iterable接口,所以Java中实现Collection也就意味着有了Iterator()方法</p>
</li>
</ul>
<pre><code class="language-java">public static &lt;T&gt; void display(Iterator&lt;T&gt; it) &#123;
  while(it.hasNext()) &#123;
    T obj = it.next();
    System.out.print(obj.toString() + &quot; &quot;);
  &#125;
  System.out.println();
&#125;

public static &lt;T&gt; void display(Collection&lt;T&gt; collection) &#123;
  for(T obj : collection)
    System.out.print(obj.toString() + &quot; &quot;);
  System.out.println();
&#125;

</code></pre>
<ul>
<li>上面两个版本的display()方法都可以接受任何Collection对象,但是第一个版本使用了Iterator,因此可以用于任何实现了Iterable接口的对象,而第二个版本只能用于Collection对象</li>
<li>当有一个不是Collection的外部类时,我们可以让它实现Iterable接口,这样就可以使用适合Iterable接口的语法了
<ul>
<li>生成一个Iterator, 是将序列与处理序列的方法连接起来的耦合性最低的方式，与实现 Collection 相比，这样做对序列类的约束要少得多。</li>
</ul>
</li>
</ul>
<pre><code class="language-java">class PetSequence &#123;
  protected Pet[] pets = new PetCreator().array(8);
&#125;

public class NonCollectionSequence extends PetSequence &#123;
  public Iterator&lt;Pet&gt; iterator() &#123;
    return new Iterator&lt;Pet&gt;() &#123;
      private int index = 0;
      @Override public boolean hasNext() &#123;
        return index &lt; pets.length;
      &#125;
      @Override
      public Pet next() &#123; return pets[index++]; &#125;
      @Override
      public void remove() &#123; // Not implemented
        throw new UnsupportedOperationException();
      &#125;
    &#125;;
  &#125;
  public static void main(String[] args) &#123;
    NonCollectionSequence nc =
      new NonCollectionSequence();
    InterfaceVsIterator.display(nc.iterator());
  &#125;
&#125;
</code></pre>
<h3 id="12.14-for-in%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8" tabindex="-1">12.14 for-in与迭代器</h3>
<ul>
<li>for-in使用Iterable接口来遍历Collection,因此所有实现Iterable接口的类都可以使用for-in来遍历. 数组可以通过Arrays.asList()方法转换为List,从而可以使用for-in来遍历数组.</li>
</ul>
<pre><code class="language-java">public class IterableClass implements Iterable&lt;String&gt; &#123;
  protected String[] words = (&quot;And that is how &quot; +
    &quot;we know the Earth to be banana-shaped.&quot;
    ).split(&quot; &quot;);
  @Override public Iterator&lt;String&gt; iterator() &#123;
    return new Iterator&lt;String&gt;() &#123;
      private int index = 0;
      @Override public boolean hasNext() &#123;
        return index &lt; words.length;
      &#125;
      @Override
      public String next() &#123; return words[index++]; &#125;
      @Override
      public void remove() &#123; // Not implemented
        throw new UnsupportedOperationException();
      &#125;
    &#125;;
  &#125;
  public static void main(String[] args) &#123;
    for(String s : new IterableClass())
      System.out.print(s + &quot; &quot;);
  &#125;
&#125;

public class ArrayIsNotIterable &#123;
  static &lt;T&gt; void test(Iterable&lt;T&gt; ib) &#123;
    for(T t : ib)
      System.out.print(t + &quot; &quot;);
  &#125;
  public static void main(String[] args) &#123;
    test(Arrays.asList(1, 2, 3));
    String[] strings = &#123; &quot;A&quot;, &quot;B&quot;, &quot;C&quot; &#125;;
    // An array works in for-in, but it's not Iterable:
    //- test(strings);
    // You must explicitly convert it to an Iterable:
    test(Arrays.asList(strings));
  &#125;
&#125;
</code></pre>
<h4 id="%E9%80%82%E9%85%8D%E5%99%A8%E6%96%B9%E6%B3%95" tabindex="-1">适配器方法</h4>
<ul>
<li>如何在实现Iterable接口后,让这个类有不止一种方式用在for-in语句中
<ul>
<li>使用**适配器方法(Adapter Method)**的惯用法,即在类中添加一个返回Iterable的方法,这个方法可以用于for-in语句中</li>
<li>例子:下面的ReversibleArrayList类,实现了Iterable接口,并且添加了一个适配器方法,可以返回一个Iterable对象,这个对象可以用于for-in语句中;</li>
<li>适配器方法其实相当于给原本的方法套一个匿名内部类的皮,这个匿名内部类实现了Iterable接口,并且返回了一个Iterator对象,外部类的适配器方法返回的就是这个匿名内部类对象</li>
</ul>
</li>
</ul>
<pre><code class="language-java">public class MultiIterableClass extends IterableClass &#123;
  public Iterable&lt;String&gt; reversed() &#123;
    return new Iterable&lt;String&gt;() &#123;
      public Iterator&lt;String&gt; iterator() &#123;
        return new Iterator&lt;String&gt;() &#123;
          int current = words.length - 1;
          @Override public boolean hasNext() &#123;
            return current &gt; -1;
          &#125;
          @Override public String next() &#123;
            return words[current--];
          &#125;
          @Override
          public void remove() &#123; // Not implemented
            throw new UnsupportedOperationException();
          &#125;
        &#125;;
      &#125;
    &#125;;
  &#125;
  public Iterable&lt;String&gt; randomized() &#123;
    return new Iterable&lt;String&gt;() &#123;
      public Iterator&lt;String&gt; iterator() &#123;
        List&lt;String&gt; shuffled =
          new ArrayList&lt;&gt;(Arrays.asList(words));
        Collections.shuffle(shuffled, new Random(47));
        return shuffled.iterator();
      &#125;
    &#125;;
  &#125;
  public static void main(String[] args) &#123;
    MultiIterableClass mic = new MultiIterableClass();
    for(String s : mic.reversed())
      System.out.print(s + &quot; &quot;);
    System.out.println();
    for(String s : mic.randomized())
      System.out.print(s + &quot; &quot;);
    System.out.println();
    for(String s : mic)
      System.out.print(s + &quot; &quot;);
  &#125;
&#125;
</code></pre>
<h3 id="12.15-%E6%80%BB%E7%BB%93" tabindex="-1">12.15 总结</h3>
<p>Java提供了很多持有对象的方式</p>
<ol>
<li>数组将数字索引和对象关联起来.数组的效率最高,但是容量固定</li>
<li>Collection保存单个对象,而Map保存关联的键值对;</li>
</ol>
<ul>
<li>利用Java泛型可以指定保存在集合中的对象的类型</li>
<li>Collection和Map都可以自动调整大小</li>
<li>集合不能保存基本数据类型,但是可以使用基本数据类型的包装器类</li>
</ul>
<ol start="3">
<li>类似数组,List也可以将数字索引和对象关联起来,但是List可以自动调整大小</li>
<li>如果要执行大量随机访问,使用ArrayList;如果要在列表中间执行大量删除和插入,使用LinkedList</li>
<li>队列和栈的行为都是通过LinkedList来实现的</li>
<li>Map将对象而非整型值和其他对象关联起来</li>
</ol>
<ul>
<li>HashMap提供了最快的查找技术</li>
<li>TreeMap将键有序保存,不如HashMap快</li>
<li>LinkedMap按照元素插入的顺序保存键,但通过Hash提供了快速访问能力</li>
</ul>
<ol start="7">
<li>对于相同元素,Set只保存一个</li>
</ol>
<ul>
<li>HashSet提供了最快的查找技术</li>
<li>TreeSet将键有序保存</li>
<li>LinkedSet按照元素插入的顺序保存键</li>
</ul>
<ol start="8">
<li>不要在新代码中使用Vector,HashTable和Stack等遗留类</li>
</ol>
<ul>
<li>
<p>Java集合类的简化图(没有抽象类或遗留组件),只包含常见接口和类</p>
<ul>
<li>虚线框表示接口,实现框为实现类,最常用集合边框加粗</li>
<li>箭头表示继承关系,实现类实现了接口</li>
<li>带有&quot;Produces&quot;的箭头标明一个类可以生成箭头所指类的对象<br>
<img src="/images/PL/OnJava8/12_15.png" alt></li>
</ul>
</li>
<li>
<p>从面向对象的层次结构看，这种组织方式有点奇怪。然而随着你对 java.util 中的集合类有了更深入的了解,会有更多的问题,而不只是奇怪的继承结构.设计集合类库总是存在各种困难，我们要满足往往存在冲突的不同诉求。所以要准备好在这里或那里做出一些妥协</p>
</li>
</ul>
<h2 id="13-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B" tabindex="-1">13 函数式编程</h2>
<ul>
<li>早期,为了让程序适应有限的内存,程序员会在<strong>程序执行时</strong>修改内存中的代码,来节省代码空间.这就是<strong>自修改代码技术</strong></li>
<li>然而随着程序越来复杂,代码需要更加一致和易懂,并且硬件越来便宜,自修改代码的方法已经落后.然而代码操纵其它代码的思想依然很吸引人,但需要更安全的实现</li>
<li>这就是<strong>函数式编程</strong>(functional programming,FP)的意义所在,它是一种编程范式,可以将计算机运算视为数学函数的计算,避免了状态和可变数据,强调函数的<strong>运算结果</strong>而非<strong>运算过程</strong>,以及<strong>函数之间的调用关系</strong>来解决问题</li>
<li><strong>面向对象编程抽象数据,函数式编程抽象行为</strong></li>
<li><strong>纯函数式语言</strong>要求所有数据是<strong>不可变的</strong>,函数接收值,然后产生新值,而不是修改参数的值,因此纯函数式语言中的函数没有副作用,也就是说,函数不会修改外部的状态,也不会依赖外部的状态,函数的输出只依赖于输入,这样的函数称为<strong>纯函数</strong>(pure function)</li>
</ul>
<h3 id="13.1-%E6%96%B0%E6%96%B9%E5%BC%8F%E5%92%8C%E6%97%A7%E6%96%B9%E5%BC%8F" tabindex="-1">13.1 新方式和旧方式</h3>
<ul>
<li>旧方式:创建一个对象,让其一个方法包含所需行为,然后将这个对象传递给另一个方法,这个方法可以调用对象的方法来执行所需的行为</li>
<li>Java8的新方式:方法引用和lambda表达式</li>
</ul>
<h3 id="13.2-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F" tabindex="-1">13.2 lambda表达式</h3>
<ul>
<li><strong>lambda表达式</strong>是使用尽可能少的语法编写的函数定义</li>
<li>在JVM中,所有都是对象,所以lambda也是一个对象,所以使用lambda表达式时,实际上是创建了一个对象,这个对象是一个函数式接口的实例</li>
<li>lambda表达式基础语法
<ul>
<li>
<ol>
<li>参数</li>
</ol>
</li>
<li>
<ol start="2">
<li>后面跟 -&gt; ,可以称作&quot;产生&quot;(produces)</li>
</ol>
</li>
<li>
<ol start="3">
<li>-&gt;后都是方法体</li>
</ol>
</li>
</ul>
</li>
</ul>
<pre><code class="language-java">interface Description &#123;
  String brief();
&#125;
interface Body &#123;
  String detailed(String head);
&#125;
interface Multi &#123;
  String twoArg(String head, Double d);
&#125;
public class LambdaExpressions &#123;

  static Body bod = h -&gt; h + &quot; No Parens!&quot;;      // [1]

  static Body bod2 = (h) -&gt; h + &quot; More details&quot;; // [2]

  static Description desc = () -&gt; &quot;Short info&quot;;  // [3]

  static Multi mult = (h, n) -&gt; h + n;           // [4]

  static Description moreLines = () -&gt; &#123;         // [5]
    System.out.println(&quot;moreLines()&quot;);
    return &quot;from moreLines()&quot;;
  &#125;;

  public static void main(String[] args) &#123;
    System.out.println(bod.detailed(&quot;Oh!&quot;));
    System.out.println(bod2.detailed(&quot;Hi!&quot;));
    System.out.println(desc.brief());
    System.out.println(mult.twoArg(&quot;Pi! &quot;, 3.14159));
    System.out.println(moreLines.brief());
  &#125;
&#125;
/* Output:
Oh! No Parens!
Hi! More details
Short info
Pi! 3.14159
moreLines()
from moreLines()
*/
</code></pre>
<ul>
<li>上述代码中,[1] 到 [5]的lambda实现了接口中的方法
<ul>
<li>[1] [2] 只有一个参数,可以省略参数的括号,但为了一致性,最好加上</li>
<li>[3] 没有参数,需要使用括号</li>
<li>[4] 有多个参数,需要使用括号,且用&quot;,&quot;隔开,需要注意参数类型的一致性</li>
<li>[1]到[4]的方法体只有一行,此时方法式中表达式的结果会自动成为lambda表达式的返回值,此处使用return关键字非法,</li>
<li>[5] 如果lambda表达式需要多行代码,此时必须将代码放在花括号中,此时需要使用return关键字来返回值</li>
</ul>
</li>
</ul>
<h4 id="%E9%80%92%E5%BD%92" tabindex="-1">递归</h4>
<ul>
<li>Java中可以编写递归的lambda表达式,但此时该lambda表达式必须给赋值给一个静态变量或一个实例变量,否则会出现编译错误</li>
<li>例子:此处主函数里fact是一个静态InCall变量,需要注意的是,这里不能直接使用lambda表达式,而是需要先声明一个变量,然后再使用lambda表达式赋值给这个变量,因为lambda表达式是一个对象,而不是一个方法</li>
</ul>
<pre><code class="language-java">interface IntCall &#123;
  int call(int arg);
&#125;
public class RecursiveFactorial &#123;
  static IntCall fact;
  // static IntCall fact = n -&gt; n == 0 ? 1 : n * fact.call(n - 1); 这样会编译错误,对Java编译器太过复杂
  public static void main(String[] args) &#123;
    fact = n -&gt; n == 0 ? 1 : n * fact.call(n - 1);
    for(int i = 0; i &lt;= 10; i++)
      System.out.println(fact.call(i));
  &#125;
&#125;
</code></pre>
<h3 id="13.3-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8" tabindex="-1">13.3 方法引用</h3>
<ul>
<li>方法引用是用 类名或对象名后跟 ::,然后方法名</li>
</ul>
<pre><code class="language-java">interface Callable &#123;                        // [1] 是一个包含一个方法的接口
  void call(String s);
&#125;
class Describe &#123;
  void show(String msg) &#123;                   // [2] show的**签名**(参数类型和返回类型) 和Callable中call()的签名一致
    System.out.println(msg);
  &#125;
&#125;
public class MethodReferences &#123;
  static void hello(String name) &#123;          // [3] hello()的签名和Callable中call()的签名一致
    System.out.println(&quot;Hello, &quot; + name);
  &#125;
  static class Description &#123;
    String about;
    Description(String desc) &#123; about = desc; &#125;
    void help(String msg) &#123;                 // [4] help()的签名和Callable中call()的签名一致,为静态内部类的非静态方法
      System.out.println(about + &quot; &quot; + msg);
    &#125;
  &#125;
  static class Helper &#123;
    static void assist(String msg) &#123;        // [5] assist()的签名和Callable中call()的签名一致,为静态内部类的静态方法
      System.out.println(msg);
    &#125;
  &#125;
  public static void main(String[] args) &#123;
    Describe d = new Describe();
    Callable c = d::show;                   // [6]将show方法的引用赋给一个Callable对象,此时相当于show方法为Callable接口的call方法的实现
    c.call(&quot;call()&quot;);                       // [7]调用call()方法,实际上是调用了show()方法,因为Java将call映射到了show上

    c = MethodReferences::hello;            // [8] 静态方法可以不创建实例
    c.call(&quot;Bob&quot;);

    c = new Description(&quot;valuable&quot;)::help;  // [9] 这是[6]的另一个实现,需要创建实例
    c.call(&quot;information&quot;);

    c = Helper::assist;                     // [10] 静态内部类的静态方法
    c.call(&quot;Help!&quot;);
  &#125;
&#125;
/* Output:
call()
Hello, Bob
valuable information
Help!
*/
</code></pre>
<h4 id="13.3.1-runnable%E6%8E%A5%E5%8F%A3" tabindex="-1">13.3.1 Runnable接口</h4>
<ul>
<li>Runnable接口在Java.lang包中,不需要import,它只有一个run()方法,没有参数,也没有返回值,因此可以使用lambda表达式或方法引用来实现</li>
<li>例子:Tread对象接收一个Runnable对象作为其构造器,其有一个start方法会调用run()方法,因此可以使用lambda表达式或方法引用来实现</li>
</ul>
<pre><code class="language-java">class Go &#123;
  static void go() &#123;
    System.out.println(&quot;Go::go()&quot;);
  &#125;
&#125;
public class RunnableMethodReference &#123;
  public static void main(String[] args) &#123;
    new Thread(new Runnable() &#123;
      public void run() &#123;
        System.out.println(&quot;Anonymous&quot;);
      &#125;
    &#125;).start();
    new Thread(
      () -&gt; System.out.println(&quot;lambda&quot;)
    ).start();
    new Thread(Go::go).start();
  &#125;
&#125;
</code></pre>
<h4 id="13.3.2-%E6%9C%AA%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8" tabindex="-1">13.3.2 未绑定方法引用</h4>
<ul>
<li><strong>未绑定方法引用</strong>（unbound method reference）指的是尚未关联到某个对象的普通（非<br>
静态）方法。对于未绑定引用，必须先提供对象，然后才能使用</li>
</ul>
<pre><code class="language-java">class X &#123;
  String f() &#123; return &quot;X::f()&quot;; &#125;
&#125;
interface MakeString &#123;
  String make();
&#125;
interface TransformX &#123;
  String transform(X x);
&#125;
public class UnboundMethodReference &#123;
  public static void main(String[] args) &#123;
    // MakeString ms = X::f; // [1]
    TransformX sp = X::f;
    X x = new X();
    System.out.println(sp.transform(x)); // [2]
    System.out.println(x.f()); // 效果相同
  &#125;
&#125;
</code></pre>
<ul>
<li>
<p>[1] 处编译器会报错,提示 无效方法引用”（invalid method reference）,即使make()的签名和f()相同,这里需要重点理解:</p>
<ul>
<li>这里涉及一个隐藏的参数:this,如果没有可以附着的X对象,就无法调用f(),因此,X::f是一个未绑定的方法引用,其没有绑定到某个对象,因此无法调用</li>
<li>所以我们的接口还需要一个额外的参数,如TransformX接口中的transform()方法,其需要一个X对象作为参数,那么我们就可以使用X::f来实现这个接口</li>
<li>即在未绑定引用的情况下,<strong>函数式方法</strong>(接口中的单一方法)的签名和方法引用的签名不再完全匹配,此时我们需要一个对象,让方法在其上调用</li>
</ul>
</li>
<li>
<p>[2]处因为接受了未绑定引用,然后调用了transform()方法,传入了一个X对象,因此可以正常运行,即Java知道它需要接收第一个参数,即this指针,然后调用f()方法</p>
</li>
<li>
<p>综上所述,未绑定方法的引用,其X::f的第一个参数是其this指针,即需要额外传入一个对象,然后才能调用f()方法,下面为有参数的情况</p>
</li>
</ul>
<pre><code class="language-java">class This &#123;
  void two(int i, double d) &#123;&#125;
  void three(int i, double d, String s) &#123;&#125;
  void four(int i, double d, String s, char c) &#123;&#125;
&#125;
//下面为函数式方法,第一个参数都是this指针,意味着使用该方法时需要额外传入对象
interface TwoArgs &#123;
  void call2(This athis, int i, double d);
&#125;

interface ThreeArgs &#123;
  void call3(This athis, int i, double d, String s);
&#125;

interface FourArgs &#123;
  void call4(
    This athis, int i, double d, String s, char c);
&#125;

public class MultiUnbound &#123;
  public static void main(String[] args) &#123;
    TwoArgs twoargs = This::two;
    ThreeArgs threeargs = This::three;
    FourArgs fourargs = This::four;
    This athis = new This();
    twoargs.call2(athis, 11, 3.14);
    threeargs.call3(athis, 11, 3.14, &quot;Three&quot;);
    fourargs.call4(athis, 11, 3.14, &quot;Four&quot;, 'Z');
  &#125;
&#125;
</code></pre>
<h4 id="13.3.3-%E6%9E%84%E9%80%A0%E5%99%A8%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8" tabindex="-1">13.3.3 构造器方法引用</h4>
<pre><code class="language-java">class Dog &#123;
  String name;
  int age = -1; // For &quot;unknown&quot;
  Dog() &#123; name = &quot;stray&quot;; &#125;
  Dog(String nm) &#123; name = nm; &#125;
  Dog(String nm, int yrs) &#123; name = nm; age = yrs; &#125;
&#125;

interface MakeNoArgs &#123;
  Dog make();
&#125;

interface Make1Arg &#123;
  Dog make(String nm);
&#125;

interface Make2Args &#123;
  Dog make(String nm, int age);
&#125;

public class CtorReference &#123;
  public static void main(String[] args) &#123;
    MakeNoArgs mna = Dog::new;        // [1]
    Make1Arg m1a = Dog::new;          // [2]
    Make2Args m2a = Dog::new;         // [3]

    Dog dn = mna.make();
    Dog d1 = m1a.make(&quot;Comet&quot;);
    Dog d2 = m2a.make(&quot;Ralph&quot;, 4);
  &#125;
&#125;
</code></pre>
<ul>
<li>上述代码中,Dog有三个构造器,分别为无参构造器,一个参数的构造器,两个参数的构造器</li>
<li>这三个构造器只有一个名字new,但可以通过接口来判断是那个构造器</li>
</ul>
<h3 id="13.4-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3" tabindex="-1">13.4 函数式接口</h3>
<ul>
<li>方法引用和lambda表达式都要赋值,赋值就需要类型信息</li>
<li>如何确定方法的参数类型呢,为此Java8引入包含一组接口的Java.util.function,这些接口时lambda表达式和方法引用的目标类型,每个接口只包含一个抽象方法,叫做<strong>函数式方法</strong>
<ul>
<li>当编写接口时,这种&quot;函数式方法&quot;可以使用@FunctionalInterface注解来强制编译器只接受函数式接口</li>
</ul>
</li>
<li>例子: @FunctionalInterface注解的使用
<ul>
<li>@FunctionalInterface注解 是可选的,一旦出现,该接口只能拥有一个函数式方法,否则编译器会报错</li>
<li>使用了 @FunctionalInterface 注解的接口也叫作<strong>单一抽象方法</strong>（Single Abstract Method, SAM）类型</li>
</ul>
</li>
<li>我们可以将方法直接赋给<strong>函数式接口</strong>,这是Java8增加的魔法:如果我们将一个方法引用或lambda表达式赋值给某个函数式接口(而且类型可以匹配),那么Java会调整这个赋值，使其匹配目标接口。而在底层，Java 编译器会创建一个实现了目标接口的类的实例，并将我们的方法引用或 lambda 表达式包裹在其中
<ul>
<li>这种魔法使得语法更好,更简单</li>
</ul>
</li>
</ul>
<pre><code class="language-java">@FunctionalInterface
interface Functional &#123;
  String goodbye(String arg);
&#125;

interface FunctionalNoAnn &#123;
  String goodbye(String arg);
&#125;

/*
@FunctionalInterface
interface NotFunctional &#123;
  String goodbye(String arg);
  String hello(String arg);
&#125;
产生报错信息：
NotFunctional is not a functional interface
multiple non-overriding abstract methods
found in interface NotFunctional
*/

public class FunctionalAnnotation &#123;
  public String goodbye(String arg) &#123;
    return &quot;Goodbye, &quot; + arg;
  &#125;
  public static void main(String[] args) &#123;
    FunctionalAnnotation fa =
      new FunctionalAnnotation();
    Functional f = fa::goodbye;
    FunctionalNoAnn fna = fa::goodbye;
    // Functional fac = fa; // Incompatible
    Functional fl = a -&gt; &quot;Goodbye, &quot; + a;
    FunctionalNoAnn fnal = a -&gt; &quot;Goodbye, &quot; + a;
  &#125;
&#125;
</code></pre>
<ul>
<li>java.util.function 旨在创建一套足够完备的目标接口，这样一般情况下我们就不需要定义自己的接口了。然后由于基本类型的缘故,接口很多,但我们可以通过理解其命名规则知道特定接口. 这里不多赘述,用时再查
<ul>
<li>使用java.util.function的函数式接口时,名字并不重要,重要的只有参数类型和返回类型,Java会将我们的函数自动映射到函数式接口中的方法上,需要调用函数式接口里的函数<br>
<img src="/images/PL/OnJava8/13_4_0.png" alt></li>
</ul>
</li>
</ul>
<h4 id="13.4.1-%E5%B8%A6%E6%9C%89%E6%9B%B4%E5%A4%9A%E5%8F%82%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3" tabindex="-1">13.4.1 带有更多参数的函数式接口</h4>
<pre><code class="language-java">@FunctionalInterface
public interface TriFunction&lt;T, U, V, R&gt; &#123;
 R apply(T t, U u, V v);
&#125;
public class TriFunctionTest &#123;
  static int f(int i, long l, double d) &#123; return 99; &#125;
  public static void main(String[] args) &#123;
    TriFunction&lt;Integer, Long, Double, Integer&gt; tf =
      TriFunctionTest::f;
      tf = (i, l, d) -&gt; 12;
  &#125;
&#125;
</code></pre>
<h4 id="13.4.2-%E8%A7%A3%E5%86%B3%E7%BC%BA%E4%B9%8F%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E7%9A%84%E9%97%AE%E9%A2%98" tabindex="-1">13.4.2 解决缺乏基本类型函数式接口的问题</h4>
<ul>
<li>因为基本类型设计自动装箱和拆箱,因此会有性能问题,因此Java8基本类型的函数式接口缺失,但我们可以自己定义</li>
</ul>
<h3 id="13.5-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0" tabindex="-1">13.5 高阶函数</h3>
<ul>
<li><strong>高阶函数</strong>只是一个能接受函数作为参数或能把函数当返回值的函数。</li>
</ul>
<pre><code class="language-java">interface FuncSS extends Function&lt;String, String&gt; &#123;&#125;   // [1] 使用继承为专门的接口起一个别名

public class ProduceFunction &#123;
  static FuncSS produce() &#123;//该函数可以返回一个函数
    return s -&gt; s.toLowerCase();             
  &#125;
  public static void main(String[] args) &#123;
    FuncSS f = produce();
    System.out.println(f.apply(&quot;YELLING&quot;));
  &#125;
&#125;
</code></pre>
<ul>
<li>接收使用函数时需要主要正确描述函数的类型,同时在函数中可以生成一个新的函数</li>
<li>下面例子中,transform()接受一个方法同时也生成一个方法
<ul>
<li>这里使用了Function 接口中的一个叫作andThen()的默认（default）方法，该方法<br>
是为操作函数而设计。andThen()会在in函数调用<strong>之后</strong>调用(还有一个compose的方法,可以在in函数之前应用新函数)</li>
</ul>
</li>
</ul>
<pre><code class="language-java">class I &#123;
  @Override public String toString() &#123; return &quot;I&quot;; &#125;
&#125;
class O &#123;
  @Override public String toString() &#123; return &quot;O&quot;; &#125;
&#125;
public class TransformFunction &#123;
  static Function&lt;I,O&gt; transform(Function&lt;I,O&gt; in) &#123;
    return in.andThen(o -&gt; &#123;
      System.out.println(o);
      return o;
    &#125;);
  &#125;
  public static void main(String[] args) &#123;
    Function&lt;I,O&gt; f2 = transform(i -&gt; &#123;
      System.out.println(i);
      return new O();
    &#125;);
    O o = f2.apply(new I());
  &#125;
&#125;
/* Output:
I
O
*/
</code></pre>
<h3 id="13.6-%E9%97%AD%E5%8C%85" tabindex="-1">13.6 闭包</h3>
<ul>
<li>当lambda表达式使用了其函数作用域之外的变量时,会发生什么?
<ul>
<li>这就是<strong>闭包</strong>的概念,如果语言能解决这个问题,称这个语言是支持闭包的,也可以称之为支持<strong>语法作用域</strong></li>
<li>这里同时也有一个<strong>变量捕获</strong>的术语,即lambda表达式捕获了其作用域之外的变量</li>
</ul>
</li>
</ul>
<pre><code class="language-java">public class Closure1 &#123;
 int i;
 IntSupplier makeFun(int x) &#123;
 return () -&gt; x + i++;
 &#125;
&#125;
</code></pre>
<ul>
<li>Closure1中,因为变量i位于对象中,随意遍历makeFun返回的函数中,i可以指向正确的位置,因此会有多个函数全部共享i的存储空间</li>
</ul>
<pre><code class="language-java">public class Closure2 &#123;
 IntSupplier makeFun(int x) &#123;
 int i = 0;
 return () -&gt; x + i;
 &#125;
&#125;

public class Closure3 &#123;
 IntSupplier makeFun(int x) &#123;
 int i = 0;
 // x++ 或 i++ 都不可以：
 return () -&gt; x++ + i++;
 &#125;
&#125;
error:
local variables referenced from a lambda
expression must be final or effectively final
</code></pre>
<ul>
<li>Closure3中,i为临时变量,函数返回后x和i都无法找到正确的内存位置,会发生报错</li>
<li>而在Closuer2中,没有报错:因为i没有发生变化,实际上这里是<strong>实际上的最终变量(effective final)</strong>,该术语由Java 8 创建,其意思是我们虽然没有显式地将一个变量声明为最终变量,但是仍然可以用最终变量地方式看待它,只要不改变其值即可. <code>如果一个局部变量的初始值从不改变,它就是实际上的最终变量</code></li>
</ul>
<pre><code class="language-java">public class Closure6 &#123;
 IntSupplier makeFun(int x) &#123;
 int i = 0;
 i++;
 x++;
 final int iFinal = i;/*这里的final可以去掉,因之后未改变,已经构成&quot;实际上的最终变量&quot;*/
 final int xFinal = x;
 return () -&gt; xFinal + iFinal;
 &#125;
&#125;
</code></pre>
<ul>
<li>
<p>如果非要使用变化的临时变量,我们可以用final变量进行中继</p>
</li>
<li>
<p>以上讨论都在基本类型中,下面讨论在对象中的情况</p>
</li>
</ul>
<pre><code class="language-java">public class Closure8 &#123;
  Supplier&lt;List&lt;Integer&gt;&gt; makeFun() &#123;
    final List&lt;Integer&gt; ai = new ArrayList&lt;&gt;();/*这里的final可以去掉,因之后未改变,已经构成&quot;实际上的最终变量&quot;*/
    ai.add(1);
    return () -&gt; ai;
  &#125;
  public static void main(String[] args) &#123;
    Closure8 c7 = new Closure8();
    List&lt;Integer&gt;
      l1 = c7.makeFun().get(),
      l2 = c7.makeFun().get();
    System.out.println(l1);
    System.out.println(l2);
    l1.add(42);
    l2.add(96);
    System.out.println(l1);
    System.out.println(l2);
  &#125;
&#125;
/* Output:
[1]
[1]
[1, 42]
[1, 96]
*/
</code></pre>
<ul>
<li>上述代码运行成功了,可能你们会感到疑惑,但这里需要提醒的是,对于<strong>final修饰的对象引用,说明该对象引用不能被重新赋值</strong>,所以该引用指向的对象是可以发生变化的,但不能被另一个新的对象赋值,所以Closure8中,ai的final去掉也不会出现问题,因为构成了&quot;实际上的最终变量&quot;</li>
<li>但是如果我们将ai重新赋值,就会出现问题,如下:</li>
</ul>
<pre><code class="language-java">// 无法通过编译
import java.util.*;
import java.util.function.*;
public class Closure9 &#123;
 Supplier&lt;List&lt;Integer&gt;&gt; makeFun() &#123;
 List&lt;Integer&gt; ai = new ArrayList&lt;&gt;();
 ai = new ArrayList&lt;&gt;(); // Reassignment
 return () -&gt; ai;
 &#125;
&#125;
</code></pre>
<ul>
<li>
<p>综上,lambda使用的变量</p>
<ul>
<li>可以是&quot;实际上的最终变量&quot;,即该变量不能被重新赋值,但是可以修改其指向的对象</li>
<li>也可以是某对象的一个字段,因为其有独立的生命周期,不需要任何的捕获,因此可以被lambda使用</li>
</ul>
</li>
<li>
<p>内部类中的闭包,与高级函数类似,所以实际上,只要有内部类,就会出现闭包的概念(Java 8只是让闭包的实现变简单了). Java8之前没有&quot;实际上的最终变量&quot;,都需要显式声明</p>
</li>
</ul>
<h3 id="13.7-%E5%87%BD%E6%95%B0%E7%BB%84%E5%90%88" tabindex="-1">13.7 函数组合</h3>
<ul>
<li><strong>函数组合</strong>:将多个函数结合使用以创建新的函数,这是函数式编程的基本技术之一</li>
<li>java.util.function提供的函数组合方法
<ul>
<li><code>andThen(argument)</code>:先执行原始操作,再执行参数操作</li>
<li><code>compose(argument)</code>:先执行参数操作,再执行原始操作</li>
<li><code>and(argument)</code>:对原始谓词和参数谓词执行逻辑与操作</li>
<li><code>or(argument)</code>:对原始谓词和参数谓词执行逻辑或操作</li>
<li><code>negate(argument)</code>:对所得谓词进行逻辑取反</li>
</ul>
</li>
</ul>
<pre><code class="language-java">f4 = f1.compose(f2).andThen(f3);//执行顺序:f2,f1,f3
f4 = f1.compose(f3).compose(f1).compose(f2);//执行顺序 f2,f1,f3,f1 倒序执行
f4 = f1.andThen(f3).andThen(f1).andThen(f2);//执行顺序 f1,f3,f1,f2 顺序执行
f4 = f1.andThen(f3).compose(f1).andThen(f2).compose(f2);//执行顺序 f2,f1,f1,f3,f2
</code></pre>
<h3 id="13.8-%E6%9F%AF%E9%87%8C%E5%8C%96%E5%92%8C%E9%83%A8%E5%88%86%E6%B1%82%E5%80%BC" tabindex="-1">13.8 柯里化和部分求值</h3>
<ul>
<li><strong>柯里化</strong>(currying)是一种将具备多个参数的函数转换成一系列使用一个参数的函数的技术</li>
<li>Java中实现:定义多层函数,每层函数都是单一参数,每层函数返回下一层函数,最后一层函数返回结果</li>
</ul>
<pre><code class="language-java">public class CurryingAndPartials &#123;
   // 未柯里化:
   static String uncurried(String a, String b) &#123;
      return a + b;
   &#125;
   public static void main(String[] args) &#123;
      // 柯里化函数
      Function&lt;String, Function&lt;String, String&gt;&gt; sum =
         a -&gt; b -&gt; a + b;                         

      System.out.println(uncurried(&quot;Hi &quot;, &quot;Ho&quot;));

      Function&lt;String, String&gt;
        hi = sum.apply(&quot;Hi &quot;);                    
      System.out.println(hi.apply(&quot;Ho&quot;));

      // 应用
      Function&lt;String, String&gt; sumHi =
        sum.apply(&quot;Hup &quot;);
      System.out.println(sumHi.apply(&quot;Ho&quot;));
      System.out.println(sumHi.apply(&quot;Hey&quot;));
   &#125;
&#125;
/* Output:
Hi Ho
Hi Ho
Hup Ho
Hup Hey
*/
public class Curry3Args &#123;//3个函数的柯里化
   public static void main(String[] args) &#123;
      Function&lt;String,
        Function&lt;String,
          Function&lt;String, String&gt;&gt;&gt; sum =
            a -&gt; b -&gt; c -&gt; a + b + c;
      Function&lt;String,
        Function&lt;String, String&gt;&gt; hi =
          sum.apply(&quot;Hi &quot;);
      Function&lt;String, String&gt; ho =
        hi.apply(&quot;Ho &quot;);
      System.out.println(ho.apply(&quot;Hup&quot;));
   &#125;
&#125;
/* Output:
Hi Ho Hup
*/
</code></pre>
<h3 id="13.9-%E7%BA%AF%E5%87%BD%E6%95%B0%E5%BC%8F%E5%8F%98%E6%88%90%2613.10-%E6%80%BB%E7%BB%93" tabindex="-1">13.9 纯函数式变成&amp;13.10 总结</h3>
<ul>
<li>因为Java<strong>并不是不可变语言</strong>,所以我们需要仔细设计,让所有内容都是final的,确保方法和函数没有副作用</li>
<li>lambda表达式和方法引用不是将Java变成函数式语言,而是提供了对函数式编程风格的更多支持</li>
</ul>
<h2 id="14-%E6%B5%81" tabindex="-1">14 流</h2>
<ul>
<li>流的核心优点:使得程序更小,同时可以充分发挥lambda表达式和方法引用的威力</li>
<li><strong>声明式编程</strong>:是一种编程风格,我们说明想要完成<strong>什么what</strong>,而不是指明<strong>怎么做how</strong></li>
<li>流具有<strong>惰性求值</strong>:只有在绝对必要时才会被求值,这种方式可以避免不必要的计算,同时可以提高性能</li>
</ul>
<h3 id="14.1-java8-%E5%AF%B9%E6%B5%81%E7%9A%84%E6%94%AF%E6%8C%81" tabindex="-1">14.1 Java8 对流的支持</h3>
<ul>
<li>Java系列是需要保留之前的一切的,为此需要考虑如何将流加入库中,而不会破坏之前的代码</li>
<li>而问题的最大挑战在使用了接口的库,不能轻易给接口增加新方法,因为这会破坏之前的代码,所以Java8使用了<strong>默认方法</strong>来解决这个问题,将流方法添加到了接口中,但是这些方法都是默认方法,因此不会破坏之前的代码,方法可分为三种类型
<ul>
<li>创建流</li>
<li>修改流元素(<strong>中间操作</strong>)</li>
<li>消费流元素(<strong>终结操作</strong>):其意味着收集一个流的元素</li>
</ul>
</li>
</ul>
<h3 id="14.2-%E6%B5%81%E7%9A%84%E5%88%9B%E5%BB%BA" tabindex="-1">14.2 流的创建</h3>
<ul>
<li>使用**Stream.of()**可以将一个条目变为一个流</li>
<li>每个<strong>Collection</strong>可以使用stream()方法生成一个流</li>
<li>IntStream 类提供了一个 <strong>range()</strong> 方法，可以生成一个流—由 int 值组成的序列</li>
</ul>
<pre><code class="language-java">for(int i : range(10, 20).toArray()) result += i;
</code></pre>
<ul>
<li>**generate()**方法是Java 8中Stream API中的一个方法，它用于生成一个无限的、连续的Stream。
<ul>
<li>具体来说，generate()方法接收一个Supplier接口类型的参数，这个参数是一个无限循环的生产者，它会不断地生产出一个新的元素，并将其放入Stream中</li>
<li>我们可以通过limit限制产生个数</li>
</ul>
</li>
</ul>
<pre><code class="language-java">public class Generator implements Supplier&lt;String&gt; &#123;
  Random rand = new Random(47);// 设置随机种子
  char[] letters =
    &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;.toCharArray();
  @Override public String get() &#123; 
    return &quot;&quot; + letters[rand.nextInt(letters.length)];//返回限制的数字大小
  &#125;
  public static void main(String[] args) &#123;
    String word = Stream.generate(new Generator())
      .limit(30)//限制个数
      .collect(Collectors.joining());
    System.out.println(word);
  &#125;
&#125;
/* Output:
YNZBRNYGCFOWZNTCQRGSEGZMMJMROE
*/
</code></pre>
<ul>
<li><strong>iterate()</strong>:Stream.iterate()从第一个参数开始,然后将其传给第二个参数引用的方法,结果被添加到流上,并且保存下来作为下一次 iterate()调用的第一个参数,以此类推
<ul>
<li>例子:生成FIB数列</li>
</ul>
</li>
</ul>
<pre><code class="language-java">public class Fibonacci &#123;
  int x = 1;
  Stream&lt;Integer&gt; numbers() &#123;
    return Stream.iterate(0, i -&gt; &#123;
      int result = x + i;
      x = i;
      return result;
    &#125;);
  &#125;
  public static void main(String[] args) &#123;
    new Fibonacci().numbers()
      .skip(20) // 跳过前20个
      .limit(10) // 取10个
      .forEach(System.out::println);
  &#125;
&#125;
/* Output:
6765
10946
17711
28657
46368
75025
121393
196418
317811
514229
*/
</code></pre>
<ul>
<li><strong>流生成器</strong>:生成器设计模式中,创建一个生成器对象,为其提供多段构造信息,最后执行&quot;生成&quot;动作</li>
</ul>
<pre><code class="language-java">public class FileToWordsBuilder &#123;
  Stream.Builder&lt;String&gt; builder = Stream.builder();//创建一个builder,可以向其中添加对象
  public FileToWordsBuilder(String filePath)
  throws Exception &#123;
    Files.lines(Paths.get(filePath))
      .skip(1) // 跳过第一行
      .forEach(line -&gt; &#123;
        for(String w : line.split(&quot;[ .?,]+&quot;))
          builder.add(w);
      &#125;);
  &#125;
  Stream&lt;String&gt; stream() &#123; return builder.build(); &#125;
  public static void
  main(String[] args) throws Exception &#123;
    new FileToWordsBuilder(&quot;Cheese.dat&quot;).stream()
      .limit(7)
      .map(w -&gt; w + &quot; &quot;)
      .forEach(System.out::print);
  &#125;
&#125;
</code></pre>
<ul>
<li><strong>Arrays类</strong>使用stream()是可以指定流的区间
<ul>
<li>下面代码中,选择区间[3,6) 进行输出</li>
</ul>
</li>
</ul>
<pre><code class="language-java">Arrays.stream(new int[] &#123; 1, 3, 5, 7, 15, 28, 37 &#125;, 3, 6)
      .forEach(n -&gt; System.out.format(&quot;%d &quot;, n));
//output:7 15 28
</code></pre>
<h3 id="14.3-%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C" tabindex="-1">14.3 中间操作</h3>
<ul>
<li><strong>1 调试与跟踪:peek()</strong>:用来辅助调试,允许查看流对象进行操作但不能不修改</li>
</ul>
<pre><code class="language-java">class Peeking  &#123;
  public static void
  main(String[] args) throws Exception &#123;
    FileToWords.stream(&quot;Cheese.dat&quot;)
      .skip(21)
      .limit(4)
      .map(w -&gt; w + &quot; &quot;)
      .peek(System.out::print)
      .map(String::toUpperCase)
      .peek(System.out::print)
      .map(String::toLowerCase)
      .forEach(System.out::print);
  &#125;
&#125;
/* Output:
Well WELL well it IT it s S s so SO so
*/
</code></pre>
<ul>
<li><strong>2 对流元素及逆行排序:sorted()</strong>:进行排序,同时也有接收Comparator参数,或函数引用的sorted类型</li>
</ul>
<pre><code class="language-java">public class SortedComparator &#123;
  public static void
  main(String[] args) throws Exception &#123;
    FileToWords.stream(&quot;Cheese.dat&quot;)
      .skip(10)
      .limit(10)
      .sorted(Comparator.reverseOrder())
      .map(w -&gt; w + &quot; &quot;)
      .forEach(System.out::print);
  &#125;
&#125;
</code></pre>
<ul>
<li><strong>3 移除元素</strong>
<ul>
<li><strong>distinct()</strong>:移除流中的重复元素</li>
<li><strong>filter(Predicate)</strong>:保留符合条件的元素,也就是传给参数(即过滤函数),结果未true的元素</li>
</ul>
</li>
</ul>
<pre><code class="language-java">public class Prime &#123;
  public static boolean isPrime(long n) &#123;
    return rangeClosed(2, (long)Math.sqrt(n))//左闭右闭
      .noneMatch(i -&gt; n % i == 0);
  &#125;
  public LongStream numbers() &#123;
    return iterate(2, i -&gt; i + 1)
      .filter(Prime::isPrime);
  &#125;
  public static void main(String[] args) &#123;
    new Prime().numbers()
      .limit(10)
      .forEach(n -&gt; System.out.format(&quot;%d &quot;, n));
    System.out.println();
    new Prime().numbers()
      .skip(90)
      .limit(10)
      .forEach(n -&gt; System.out.format(&quot;%d &quot;, n));
  &#125;
&#125;
/* Output:
2 3 5 7 11 13 17 19 23 29
467 479 487 491 499 503 509 521 523 541
*/
</code></pre>
<ul>
<li>
<p><strong>4 将函数应用于每个流元素</strong></p>
<ul>
<li><strong>map(Function)</strong>:将Function应用于每个元素,并将结果放入流中</li>
<li>mapToInt(ToIntFunction)：同上，不过结果放在一个 IntStream 中</li>
<li>mapToLong(ToLongFunction)：同上，不过结果放在一个 LongStream 中</li>
<li>mapToDouble(ToDoubleFunction)：同上，不过结果放在一个 DoubleStream 中。</li>
</ul>
</li>
<li>
<p><strong>5 在应用map期间使用组合流</strong>:map函数生成的是一个流,我们有时需要将流展开为元素</p>
<ul>
<li><strong>flatMap(Function)</strong>:当Function生成为一个流时使用</li>
<li>flatMapToInt(ToIntFunction)：同上，不过结果放在一个 IntStream 中</li>
<li>flatMapToLong(ToLongFunction)：同上，不过结果放在一个 LongStream 中</li>
<li>flatMapToDouble(ToDoubleFunction)：同上，不过结果放在一个 DoubleStream 中。</li>
</ul>
</li>
</ul>
<pre><code class="language-java">public class StreamOfStreams &#123;
  public static void main(String[] args) &#123;
    Stream.of(1, 2, 3)
      .map(i -&gt; Stream.of(&quot;Gonzo&quot;, &quot;Kermit&quot;, &quot;Beaker&quot;))
      .map(e-&gt; e.getClass().getName())
      .forEach(System.out::println);
  &#125;
&#125;
/* Output:
java.util.stream.ReferencePipeline$Head
java.util.stream.ReferencePipeline$Head
java.util.stream.ReferencePipeline$Head
*/
public class FlatMap &#123;
  public static void main(String[] args) &#123;
    Stream.of(1, 2, 3)
      .flatMap(
        i -&gt; Stream.of(&quot;Gonzo&quot;, &quot;Fozzie&quot;, &quot;Beaker&quot;))
      .forEach(System.out::println);
  &#125;
&#125;
/* Output:
Gonzo
Fozzie
Beaker
Gonzo
Fozzie
Beaker
Gonzo
Fozzie
Beaker
*/
</code></pre>
<h3 id="14.4-optional" tabindex="-1">14.4 Optional</h3>
<ul>
<li>
<p>标准流操作会返回一个Optional对象,因为它们不能确保所要的结果一定存在。这些流操作列举如下。</p>
<ul>
<li><strong>findFirst()</strong>:返回包含第一个元素的Optional对象，如果流为空则返回Optional.empty()</li>
<li><strong>findAny()</strong>:返回包含任意元素的Optional对象，如果流为空则返回Optional.empty()</li>
<li><strong>max(),min()</strong>:返回包含最大值或最小值的Optional对象，如果流为空则返回Optional.empty()</li>
<li><strong>reduce()</strong>:使用BinaryOperator和Optional组合起来，将流中的元素反复结合起来，得到一个值，返回包含该值的Optional对象，如果流为空则返回Optional.empty()
<ul>
<li>例子</li>
</ul>
<pre><code class="language-java">  OptionalInt reduced =
    IntStream.range(0, 10)
      .reduce((a, b) -&gt; a + b);
  System.out.println(reduced.getAsInt());
</code></pre>
</li>
<li><strong>average()</strong>:对于数值化的流 IntStream、LongStream 和DoubleStream，average() 操作将其结果包在一个 Optional 中，以防流为空的情况</li>
</ul>
</li>
<li>
<p>空流使用<code>Stream.&lt;String&gt;empty()</code>创建</p>
</li>
</ul>
<h4 id="14.4.1-%E4%BE%BF%E6%8D%B7%E5%87%BD%E6%95%B0" tabindex="-1">14.4.1 便捷函数</h4>
<ul>
<li>便捷函数用于或去Optional中的数据,简化了&quot;先检查再处理所包含对象&quot;的过程
<ul>
<li><strong>ifPresent(Consumer)</strong>:如果Optional对象包含值，则对该值调用Consumer，否则不进行任何操作</li>
<li><strong>orElse(other)</strong>:如果Optional对象包含值，则返回该值，否则返回other</li>
<li><strong>orElseGet(Supplier)</strong>:如果Optional对象包含值，则返回该值，否则返回Supplier获得的值</li>
<li><strong>orElseThrow(Supplier)</strong>:如果Optional对象包含值，则返回该值，否则抛出由Supplier 继续生成的异常</li>
</ul>
</li>
</ul>
<pre><code class="language-java">public class Optionals &#123;
  static void basics(Optional&lt;String&gt; optString) &#123;
    if(optString.isPresent())
      System.out.println(optString.get());
    else
      System.out.println(&quot;Nothing inside!&quot;);
  &#125;
  static void ifPresent(Optional&lt;String&gt; optString) &#123;
    optString.ifPresent(System.out::println);
  &#125;
  static void orElse(Optional&lt;String&gt; optString) &#123;
    System.out.println(optString.orElse(&quot;Nada&quot;));
  &#125;
  static void orElseGet(Optional&lt;String&gt; optString) &#123;
    System.out.println(
      optString.orElseGet(() -&gt; &quot;Generated&quot;));
  &#125;
  static void orElseThrow(Optional&lt;String&gt; optString) &#123;
    try &#123;
      System.out.println(optString.orElseThrow(
        () -&gt; new Exception(&quot;Supplied&quot;)));
    &#125; catch(Exception e) &#123;
      System.out.println(&quot;Caught &quot; + e);
    &#125;
  &#125;
  static void test(String testName,
    Consumer&lt;Optional&lt;String&gt;&gt; cos) &#123;
    System.out.println(&quot; === &quot; + testName + &quot; === &quot;);
    cos.accept(Stream.of(&quot;Epithets&quot;).findFirst());
    cos.accept(Stream.&lt;String&gt;empty().findFirst());
  &#125;
  public static void main(String[] args) &#123;
    test(&quot;basics&quot;, Optionals::basics);
    test(&quot;ifPresent&quot;, Optionals::ifPresent);
    test(&quot;orElse&quot;, Optionals::orElse);
    test(&quot;orElseGet&quot;, Optionals::orElseGet);
    test(&quot;orElseThrow&quot;, Optionals::orElseThrow);
  &#125;
&#125;
/* Output:
 === basics ===
Epithets
Nothing inside!
 === ifPresent ===
Epithets
 === orElse ===
Epithets
Nada
 === orElseGet ===
Epithets
Generated
 === orElseThrow ===
Epithets
Caught java.lang.Exception: Supplied
*/
</code></pre>
<h4 id="14.4.2-%E5%88%9B%E5%BB%BAoptional" tabindex="-1">14.4.2 创建Optional</h4>
<ul>
<li>要自己编写生成Optional的代码时,有以下三种静态方法可以使用
<ul>
<li><strong>empty()</strong>:生成一个空的Optional对象</li>
<li><strong>of(value)</strong>:将一个非空值包装到Optional里,如果值为空,则抛出NullPointerException异常</li>
<li><strong>ofNullable(value)</strong>:如果不知道这个 value 是不是 null，使用这个方法。如果value 为 null，它会自动返回 Optional.empty，否则会将这个 value 包在一个Optional 中</li>
</ul>
</li>
</ul>
<pre><code class="language-java">class CreatingOptionals &#123;
  static void
  test(String testName, Optional&lt;String&gt; opt) &#123;
    System.out.println(&quot; === &quot; + testName + &quot; === &quot;);
    System.out.println(opt.orElse(&quot;Null&quot;));
  &#125;
  public static void main(String[] args) &#123;
    test(&quot;empty&quot;, Optional.empty());
    test(&quot;of&quot;, Optional.of(&quot;Howdy&quot;));
    try &#123;
      test(&quot;of&quot;, Optional.of(null));
    &#125; catch(Exception e) &#123;
      System.out.println(e);
    &#125;
    test(&quot;ofNullable&quot;, Optional.ofNullable(&quot;Hi&quot;));
    test(&quot;ofNullable&quot;, Optional.ofNullable(null));
  &#125;
&#125;
/* Output:
 === empty ===
Null
 === of ===
Howdy
java.lang.NullPointerException
 === ofNullable ===
Hi
 === ofNullable ===
Null
*/
</code></pre>
<h4 id="14.4.3-optional%E5%AF%B9%E8%B1%A1%E4%B8%8A%E7%9A%84%E6%93%8D%E4%BD%9C" tabindex="-1">14.4.3 Optional对象上的操作</h4>
<ul>
<li>
<p>有三种方法支持对Optional进行事后处理,数值化的Optional没有以上操作</p>
<ul>
<li><strong>map(Function)</strong>:如果Optional对象包含值，则对该值执行提供的mapping函数调用，返回一个Optional对象;否则返回Optional.empty()</li>
<li><strong>flatMap(Function)</strong>:和 map() 类似，但是所提供的映射函数会将结果包在 Optional中，这样 flatMap() 最后就不会再做任何包装了</li>
<li><strong>filter(Predicate)</strong>:：将 Predicate 应用于 Optional 的内容，并返回其结果。如果Optional 与 Predicate 不匹配，则将其转换为 empty。如果 Optional 本身已经是empty，则直接传回。</li>
</ul>
</li>
<li>
<p><strong>filter操作</strong>:对于普通流的filter操作,如果Predicate返回false,会将元素从流中删除;但是对于Optional的filter操作,如果Predicate返回false,会将Optional变为Optional.empty</p>
</li>
</ul>
<pre><code class="language-java">class OptionalFilter &#123;
  static String[] elements = &#123;
    &quot;Foo&quot;, &quot;&quot;, &quot;Bar&quot;, &quot;Baz&quot;, &quot;Bingo&quot;
  &#125;;
  static Stream&lt;String&gt; testStream() &#123;
    return Arrays.stream(elements);
  &#125;
  static void
  test(String descr, Predicate&lt;String&gt; pred) &#123;
    System.out.println(&quot; ---( &quot; + descr + &quot; )---&quot;);
    for(int i = 0; i &lt;= elements.length; i++) &#123;
      System.out.println(
        testStream()
          .skip(i)
          .findFirst()
          .filter(pred));
    &#125;
  &#125;
  public static void main(String[] args) &#123;
    test(&quot;true&quot;, str -&gt; true);
    test(&quot;false&quot;, str -&gt; false);
    test(&quot;str != \&quot;\&quot;&quot;, str -&gt; str != &quot;&quot;);
    test(&quot;str.length() == 3&quot;, str -&gt; str.length() == 3);
    test(&quot;startsWith(\&quot;B\&quot;)&quot;,
         str -&gt; str.startsWith(&quot;B&quot;));
  &#125;
&#125;
/* Output:
 ---( true )---
Optional[Foo]
Optional[]
Optional[Bar]
Optional[Baz]
Optional[Bingo]
Optional.empty
 ---( false )---
Optional.empty
Optional.empty
Optional.empty
Optional.empty
Optional.empty
Optional.empty
 ---( str != &quot;&quot; )---
Optional[Foo]
Optional.empty
Optional[Bar]
Optional[Baz]
Optional[Bingo]
Optional.empty
 ---( str.length() == 3 )---
Optional[Foo]
Optional.empty
Optional[Bar]
Optional[Baz]
Optional.empty
Optional.empty
 ---( startsWith(&quot;B&quot;) )---
Optional.empty
Optional.empty
Optional[Bar]
Optional[Baz]
Optional[Bingo]
Optional.empty
*/
</code></pre>
<ul>
<li><strong>flatMap操作</strong>:适用函数必须已经包装在Optional中,否则会报错</li>
</ul>
<pre><code class="language-java">  static void test(String descr,
    Function&lt;String, Optional&lt;String&gt;&gt; func) &#123;
    System.out.println(&quot; ---( &quot; + descr + &quot; )---&quot;);
    for(int i = 0; i &lt;= elements.length; i++) &#123;
      System.out.println(
        testStream()
          .skip(i)
          .findFirst()
          .flatMap(func));
    &#125;
  &#125;
</code></pre>
<h4 id="14.4.4-%E7%94%B1optional%E7%BB%84%E6%88%90%E7%9A%84%E6%B5%81" tabindex="-1">14.4.4 由Optional组成的流</h4>
<ul>
<li>下面代码中实现了一个Optional的流,并展示如何从中得到值(使用<strong>get()函数</strong>)</li>
</ul>
<pre><code class="language-java">public class Signal &#123;
  private final String msg;
  public Signal(String msg) &#123; this.msg = msg; &#125;
  public String getMsg() &#123; return msg; &#125;
  @Override public String toString() &#123;
    return &quot;Signal(&quot; + msg + &quot;)&quot;;
  &#125;
  static Random rand = new Random(47);
  public static Signal morse() &#123;
    switch(rand.nextInt(4)) &#123;
      case 1: return new Signal(&quot;dot&quot;);
      case 2: return new Signal(&quot;dash&quot;);
      default: return null;
    &#125;
  &#125;
  public static Stream&lt;Optional&lt;Signal&gt;&gt; stream() &#123;
    return Stream.generate(Signal::morse)
      .map(signal -&gt; Optional.ofNullable(signal));
  &#125;
&#125;
public class StreamOfOptionals &#123;
  public static void main(String[] args) &#123;
    Signal.stream()
      .limit(10)
      .forEach(System.out::println);
    System.out.println(&quot; ---&quot;);
    Signal.stream()
      .limit(10)
      .filter(Optional::isPresent)
      .map(Optional::get)
      .forEach(System.out::println);
  &#125;
&#125;
/* Output:
Optional[Signal(dash)]
Optional[Signal(dot)]
Optional[Signal(dash)]
Optional.empty
Optional.empty
Optional[Signal(dash)]
Optional.empty
Optional[Signal(dot)]
Optional[Signal(dash)]
Optional[Signal(dash)]
 ---
Signal(dot)
Signal(dot)
Signal(dash)
Signal(dash)
*/
</code></pre>
<h3 id="14.5-%E7%BB%88%E7%BB%93%E6%93%8D%E4%BD%9C" tabindex="-1">14.5 终结操作</h3>
<ol>
<li>将流转换为一个数组</li>
</ol>
<ul>
<li><strong>toArray()</strong>:将流转换为一个数组,如果流为空,返回一个长度为0的数组</li>
<li><strong>toArray(generator)</strong>:返回一个由generator函数生成的数组</li>
</ul>
<ol start="2">
<li>在每个流元素上应用某个终结操作</li>
</ol>
<ul>
<li><strong>forEach(Consumer)</strong>:对每个元素应用Consumer函数(可以以任何顺序操作元素,但只有在引入多cpu运行时才有效)</li>
<li><strong>forEachOrdered(Consumer)</strong>:对每个元素应用Consumer函数,并且按照原始流顺序执行</li>
</ul>
<pre><code class="language-java">public class ForEach &#123;
  static final int SZ = 14;
  public static void main(String[] args) &#123;
    rands().limit(SZ)
      .forEach(n -&gt; System.out.format(&quot;%d &quot;, n));
    System.out.println();
    rands().limit(SZ)
      .parallel()
      .forEach(n -&gt; System.out.format(&quot;%d &quot;, n));
    System.out.println();
    rands().limit(SZ)
      .parallel()
      .forEachOrdered(n -&gt; System.out.format(&quot;%d &quot;, n));
  &#125;
&#125;
/* Output:
258 555 693 861 961 429 868 200 522 207 288 128 551 589
551 589 861 555 288 128 429 207 693 200 258 522 868 961
258 555 693 861 961 429 868 200 522 207 288 128 551 589
*/
</code></pre>
<ol start="3">
<li>收集操作</li>
</ol>
<ul>
<li><strong>collect(Collector)</strong>:将流中的元素收集到一个容器中
<ul>
<li><code>.collect(Collectors.toCollection(TreeSet::new));</code></li>
</ul>
</li>
<li><strong>collect(Supplier, BiConsumer, BiConsumer)</strong>:和上面类似,但是Supplier 会创建一个新的结果集合，第一个 BiConsumer 是用来将下一个元素包含到结果中的函数，第二个 BiConsumer 用于将两个值组合起来(较少用到 )</li>
</ul>
<ol start="4">
<li>组合所有流元素</li>
</ol>
<ul>
<li><strong>reduce(BinaryOperator)</strong>:使用 BinaryOperator 来组合所有的流元素。因为这个流可能为空，所以返回的是一个 Optional</li>
<li><strong>reduce(identity, BinaryOperator)</strong>:和上面一样，但是将 identity 用作这个组合的初始值。因此，即使这个流是空的，我们仍然能得到 identity 作为结果</li>
</ul>
<pre><code class="language-java">class Frobnitz &#123;
  int size;
  Frobnitz(int sz) &#123; size = sz; &#125;
  @Override public String toString() &#123;
    return &quot;Frobnitz(&quot; + size + &quot;)&quot;;
  &#125;
  // 生成器:
  static Random rand = new Random(47);
  static final int BOUND = 100;
  static Frobnitz supply() &#123;
    return new Frobnitz(rand.nextInt(BOUND));
  &#125;
&#125;

public class Reduce &#123;
  public static void main(String[] args) &#123;
    Stream.generate(Frobnitz::supply)
      .limit(10)
      .peek(System.out::println)
      .reduce((fr0, fr1) -&gt; fr0.size &lt; 50 ? fr0 : fr1)
      .ifPresent(System.out::println);
  &#125;
&#125;
</code></pre>
<ul>
<li>上述代码中,reduce()方法中使用了lambda表达式,其中fr0表示上次调用reduce()时的结果,第二个fr1是当前来自流中的新值.
<ul>
<li>所以在第一次调用reduce()时,会返回Optional.empty(),因此需要使用ifPresent()来检查是否有值</li>
</ul>
</li>
</ul>
<ol start="5">
<li>匹配</li>
</ol>
<ul>
<li><strong>anyMatch(Predicate)</strong>:如果流中的任何一个元素成功匹配 Predicate，返回 true,遇到第一个true就会返回</li>
<li><strong>allMatch(Predicate)</strong>:如果流中的所有元素都成功匹配 Predicate，返回 true,遇到第一个false就会返回</li>
<li><strong>noneMatch(Predicate)</strong>:如果流中的所有元素都不成功匹配 Predicate，返回 true,遇到第一个true就会返回</li>
</ul>
<ol start="6">
<li>选择一个元素</li>
</ol>
<ul>
<li><strong>findFirst()</strong>:返回流中的第一个元素的 Optional，如果流为空则返回 Optional.empty</li>
<li><strong>findAny()</strong>:返回流中的任意元素的 Optional，如果流为空则返回 Optional.empty,findAny对于非并行的流也会选择第一个</li>
<li>如果要选择流的最后一个元素,可以使用reduce()方法<code>Stream.of(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;).reduce((n1, n2) -&gt; n2);</code></li>
</ul>
<ol start="7">
<li>获得流相关的信息</li>
</ol>
<ul>
<li><strong>count()</strong>:返回流中元素的个数</li>
<li><strong>max(Comparator)</strong>:返回流中最大值</li>
<li><strong>min(Comparator)</strong>:返回流中最小值</li>
<li>数值化流的信息
<ul>
<li><strong>average()</strong>:返回流中元素的平均值</li>
<li><strong>sum()</strong>:返回流中元素的总和</li>
<li><strong>summaryStatistics()</strong>:返回一个包含流中元素各种统计值的对象,如最大值,最小值,平均值,总和,个数</li>
</ul>
</li>
</ul>
<h3 id="14.6-%E5%B0%8F%E7%BB%93" tabindex="-1">14.6 小结</h3>
<ul>
<li>流改变Java编程的本质,带来了极大的提升</li>
<li>同时防止了很多Java程序员转向Kotlin和Scala等函数式的JVM语言</li>
</ul>
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2023/08/16/web/redis/" title="Redis学习（未完）"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: Redis学习（未完）</span></a><a class="button is-default" href="/2023/08/16/PL/On%20java8%E5%9F%BA%E7%A1%80%E5%8D%B71-7/" title="On java 8 基础卷（1-7章）"><span class="has-text-weight-semibold">Next: On java 8 基础卷（1-7章）</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="Haojen/Claudia-theme-blog" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/Mrcold2002"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Mr_cold 2024</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>
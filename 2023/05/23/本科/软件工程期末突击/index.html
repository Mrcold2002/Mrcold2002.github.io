<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>软件工程期末突击</title><meta name="description" content="菜"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="[toc]
第一章 从程序到软件
1 何为程序及程序的质量要求
（1）何为程序

程序（Program）是由程序设计语言所描述的、能为计算机所理解和处理的一组语句序列
程序严格遵循程序设计语言的各项语法和语义规定
程序代码可表现为二种形式

源代码（Source Code）：用程序设计语言所描述的代码
可执行代码（Executable Code）：可执行的二进制或中间码



（2） 程序组成

语句：声明、定义、控制、计算等；实现特定的功能；
模块：包，类，方法；每个模块实现特定功能

（3）程序的二类利益相关者

用户：

程序的运行展示 功能和性能
满足和实现用户的需求


程序员

编写，阅读维护程序
发现和修改程序中的缺陷


用户和程序员对程序有这不同的质量需求

（4）程序质量的内在和外在体现.."><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Mr_cold's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">软件工程期末突击</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E4%BB%8E%E7%A8%8B%E5%BA%8F%E5%88%B0%E8%BD%AF%E4%BB%B6"><span class="toc-text">第一章 从程序到软件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%95%E4%B8%BA%E7%A8%8B%E5%BA%8F%E5%8F%8A%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%B4%A8%E9%87%8F%E8%A6%81%E6%B1%82"><span class="toc-text">1 何为程序及程序的质量要求</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E4%BD%95%E4%B8%BA%E7%A8%8B%E5%BA%8F"><span class="toc-text">（1）何为程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89-%E7%A8%8B%E5%BA%8F%E7%BB%84%E6%88%90"><span class="toc-text">（2） 程序组成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%BA%8C%E7%B1%BB%E5%88%A9%E7%9B%8A%E7%9B%B8%E5%85%B3%E8%80%85"><span class="toc-text">（3）程序的二类利益相关者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E7%A8%8B%E5%BA%8F%E8%B4%A8%E9%87%8F%E7%9A%84%E5%86%85%E5%9C%A8%E5%92%8C%E5%A4%96%E5%9C%A8%E4%BD%93%E7%8E%B0"><span class="toc-text">（4）程序质量的内在和外在体现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%A8%8B%E5%BA%8F%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81%E6%96%B9%E6%B3%95"><span class="toc-text">2 程序质量保证方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E7%A8%8B%E5%BA%8F%E8%B4%A8%E9%87%8F%E7%9A%84%E8%AF%AD%E6%B3%95%E5%92%8C%E8%AF%AD%E4%B9%89%E4%BD%93%E7%8E%B0"><span class="toc-text">（1）程序质量的语法和语义体现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E9%81%B5%E5%BE%AA%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC"><span class="toc-text">（2）遵循编码风格</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E9%87%87%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95"><span class="toc-text">（3）采用程序设计方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8"><span class="toc-text">（4）代码重用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B"><span class="toc-text">（5）结对编程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%A8%8B%E5%BA%8F%E8%B4%A8%E9%87%8F%E7%9A%84%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95"><span class="toc-text">3 程序质量的分析方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%A0%81%E4%B8%AD%E6%BD%9C%E5%9C%A8%E7%9A%84%E8%B4%A8%E9%87%8F%E9%97%AE%E9%A2%98"><span class="toc-text">（1）程序代码中潜在的质量问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E4%BA%BA%E5%B7%A5%E5%AE%A1%E6%9F%A5%E4%BB%A3%E7%A0%81%EF%BC%88code-review%EF%BC%89"><span class="toc-text">（2）人工审查代码（Code Review）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7%E5%AE%A1%E6%9F%A5-%E4%BB%A3%E7%A0%81%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90"><span class="toc-text">（3）自动化工具审查-代码静态分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%8A%80%E6%9C%AF"><span class="toc-text">（4）软件测试技术</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BD%95%E4%B8%BA%E8%BD%AF%E4%BB%B6%E5%8F%8A%E8%BD%AF%E4%BB%B6%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">4 何为软件及软件的特点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E4%BD%95%E4%B8%BA%E8%BD%AF%E4%BB%B6"><span class="toc-text">（1）何为软件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E8%BD%AF%E4%BB%B6%E6%A6%82%E5%BF%B5%E7%BB%99%E6%88%91%E4%BB%AC%E7%9A%84%E5%90%AF%E7%A4%BA"><span class="toc-text">（2）软件概念给我们的启示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">（3）软件生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E8%BD%AF%E4%BB%B6%E7%89%B9%E7%82%B9"><span class="toc-text">（4）软件特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">5 软件的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">（1）软件的分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E9%97%AD%E6%BA%90%E8%BD%AF%E4%BB%B6"><span class="toc-text">（2）闭源软件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6"><span class="toc-text">（3）开源软件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E6%89%98%E7%AE%A1%E5%B9%B3%E5%8F%B0"><span class="toc-text">（4）开源软件托管平台</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-text">（5）开源软件的优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%886%EF%BC%89%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8"><span class="toc-text">（6）开源软件的利用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F"><span class="toc-text">6 软件质量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="toc-text">第二章 软件工程概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%BA%A7%E7%94%9F%E8%83%8C%E6%99%AF"><span class="toc-text">1 软件工程产生背景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E8%BD%AF%E4%BB%B6%E5%8D%B1%E6%9C%BA%E7%9A%84%E5%87%BA%E7%8E%B0"><span class="toc-text">（1）软件危机的出现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%A6%82%E4%BD%95%E6%9D%A5%E8%A7%A3%E5%86%B3%E8%BD%AF%E4%BB%B6%E5%8D%B1%E6%9C%BA?"><span class="toc-text">（2）如何来解决软件危机?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E6%9C%AC%E5%86%85%E6%B6%B5"><span class="toc-text">2 软件工程基本内涵</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E4%BD%95%E4%B8%BA%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B"><span class="toc-text">（1）何为软件工程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="toc-text">（2）软件工程三要素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BE%85%E5%8A%A9%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B"><span class="toc-text">（3）计算机辅助软件工程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-text">（4）软件开发的本质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="toc-text">（5）软件工程的目标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%886%EF%BC%89%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%8E%9F%E5%88%99"><span class="toc-text">（6）软件工程原则</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%92%8C%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95"><span class="toc-text">第三章 软件工程和开发方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%95%E4%B8%BA%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">1 何为软件过程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B"><span class="toc-text">（1）软件过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">（2）软件过程模型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9C%89%E5%93%AA%E4%BA%9B%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">2 有哪些软件过程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B"><span class="toc-text">（1）瀑布模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%A2%9E%E9%87%8F%E6%A8%A1%E5%9E%8B"><span class="toc-text">（2）增量模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E8%BF%AD%E4%BB%A3%E6%A8%A1%E5%9E%8B(iterative-model)"><span class="toc-text">（3）迭代模型(Iterative Model)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%9E%8B(prototype-model)"><span class="toc-text">（4）原型模型(Prototype Model)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E8%9E%BA%E6%97%8B%E6%A8%A1%E5%9E%8B(spiral-model)"><span class="toc-text">（5）螺旋模型(Spiral Model)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%886%EF%BC%89%E4%B8%8D%E5%90%8C%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">（6）不同软件过程模型的特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A6%82%E4%BD%95%E6%9D%A5%E9%80%89%E6%8B%A9%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">3 如何来选择软件过程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-text">（1）软件过程模型的选择</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E4%BC%A0%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%89%B9%E7%82%B9%E5%92%8C%E4%B8%8D%E8%B6%B3"><span class="toc-text">（2）传统软件过程模型的特点和不足</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95%E6%A6%82%E8%BF%B0"><span class="toc-text">4 软件开发方法概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89parnas%E6%96%B9%E6%B3%95"><span class="toc-text">（1）Parnas方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E7%BB%93%E6%9E%84%E5%8C%96%E6%96%B9%E6%B3%95"><span class="toc-text">（2）结构化方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">（3）面向对象的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E5%9F%BA%E4%BA%8E%E6%9E%84%E4%BB%B6%E7%9A%84%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95"><span class="toc-text">（4）基于构件的开发方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95"><span class="toc-text">（5）敏捷开发方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%886%EF%BC%89%E7%BE%A4%E4%BD%93%E5%8C%96%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95"><span class="toc-text">（6）群体化软件开发方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E8%AE%A1%E5%88%92%E7%AE%A1%E7%90%86"><span class="toc-text">第四章 软件计划管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%BD%AF%E4%BB%B6%E8%AE%A1%E5%88%92"><span class="toc-text">1 软件计划</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E8%BD%AF%E4%BB%B6%E8%AE%A1%E5%88%92%E6%A6%82%E8%BF%B0"><span class="toc-text">（1）软件计划概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E8%BD%AF%E4%BB%B6%E8%BF%9B%E5%BA%A6%E5%AE%89%E6%8E%92"><span class="toc-text">（2）软件进度安排</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E8%AE%A1%E5%88%92%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-text">（3）计划的优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="toc-text">2 软件管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">（1）软件管理的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86%E5%86%85%E5%AE%B9"><span class="toc-text">（2）软件管理内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">（3）软件管理的方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90"><span class="toc-text">第五章 需求分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80"><span class="toc-text">1 需求分析基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E9%9C%80%E6%B1%82%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">（1）需求的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B"><span class="toc-text">（2）需求工程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%9C%80%E6%B1%82%E8%8E%B7%E5%8F%96"><span class="toc-text">2 需求获取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%88%86%E6%9E%90%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82"><span class="toc-text">3 分析软件需求</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%88%86%E6%9E%90%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E6%A6%82%E8%BF%B0"><span class="toc-text">（1）分析软件需求概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%88%86%E6%9E%90%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E8%BF%87%E7%A8%8B"><span class="toc-text">（2）分析软件需求过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E6%96%87%E6%A1%A3%E5%8F%8A%E8%AF%84%E5%AE%A1"><span class="toc-text">（3）软件需求文档及评审</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1"><span class="toc-text">第六章 软件设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0"><span class="toc-text">1 软件设计概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80"><span class="toc-text">（1）软件设计基础</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95"><span class="toc-text">（2）软件设计方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-text">2 软件体系结构设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80"><span class="toc-text">（1）软件体系结构基础</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B"><span class="toc-text">（2）软件体系结构设计过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1"><span class="toc-text">3 用户界面设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E5%9F%BA%E7%A1%80"><span class="toc-text">（1）用户界面基础</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B"><span class="toc-text">（2）用户界面设计过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%BD%AF%E4%BB%B6%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1"><span class="toc-text">4 软件详细设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E8%BD%AF%E4%BB%B6%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80"><span class="toc-text">（1）软件详细设计基础</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E8%BD%AF%E4%BB%B6%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1%E6%B4%BB%E5%8A%A8"><span class="toc-text">（2）软件详细设计活动</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%95%B4%E5%90%88%E3%80%81%E9%AA%8C%E8%AF%81%E5%8F%8A%E8%AF%84%E5%AE%A1"><span class="toc-text">5 软件设计整合、验证及评审</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0%E5%92%8C%E6%B5%8B%E8%AF%95"><span class="toc-text">第七章 软件实现和测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0"><span class="toc-text">1 软件实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%A6%82%E8%BF%B0"><span class="toc-text">（1）软件实现概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%92%8C%E9%80%89%E6%8B%A9"><span class="toc-text">（2）编程语言的类型和选择</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BC%96%E7%A0%81"><span class="toc-text">2 编码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E7%BC%96%E7%A0%81%E6%A6%82%E8%BF%B0"><span class="toc-text">（1）编码概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E7%BC%96%E7%A0%81%E8%BF%87%E7%A8%8B"><span class="toc-text">（2）编码过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E7%BC%BA%E9%99%B7"><span class="toc-text">（3）缺陷</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95"><span class="toc-text">3 软件测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%B5%8B%E8%AF%95%E6%A6%82%E8%BF%B0"><span class="toc-text">（1）测试概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1"><span class="toc-text">（2）测试用例设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E7%AD%96%E7%95%A5"><span class="toc-text">（3）软件测试的过程和策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95"><span class="toc-text">（4）面向对象软件测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E9%9D%9E%E5%8A%9F%E8%83%BD%E6%80%A7%E6%B5%8B%E8%AF%95"><span class="toc-text">（5）非功能性测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%BD%AF%E4%BB%B6%E8%B0%83%E8%AF%95"><span class="toc-text">4 软件调试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4%E5%92%8C%E6%BC%94%E5%8C%96"><span class="toc-text">第八章 软件维护和演化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1.-%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4%E4%B8%8E%E6%BC%94%E5%8C%96"><span class="toc-text">1. 软件维护与演化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4"><span class="toc-text">（1）软件维护</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E8%BD%AF%E4%BB%B6%E6%BC%94%E5%8C%96"><span class="toc-text">（2）软件演化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2.-%E8%BD%AF%E4%BB%B6%E9%80%BB%E8%BE%91%E8%80%81%E5%8C%96"><span class="toc-text">2. 软件逻辑老化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E9%80%BB%E8%BE%91%E8%80%81%E5%8C%96%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">（1）逻辑老化的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E8%A7%A3%E5%86%B3%E9%80%BB%E8%BE%91%E8%80%81%E5%8C%96%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">（2）解决逻辑老化的方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3.-%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%8E%E6%8A%80%E6%9C%AF"><span class="toc-text">3. 软件维护的过程与技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4%E6%8A%80%E6%9C%AF"><span class="toc-text">（1）软件维护技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4%E8%BF%87%E7%A8%8B"><span class="toc-text">（2）软件维护过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9"><span class="toc-text">复习重点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95"><span class="toc-text">结构化需求分析方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95"><span class="toc-text">面向对象需求分析方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E4%BE%8B%E5%9B%BE%E6%8F%8F%E8%BF%B0"><span class="toc-text">用例图描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#uml%E4%BA%A4%E4%BA%92%E5%9B%BE"><span class="toc-text">UML交互图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9B%BE"><span class="toc-text">类图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E5%92%8C%E5%BB%BA%E7%AB%8B%E7%94%A8%E4%BE%8B%E7%9A%84%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%9E%8B"><span class="toc-text">分析和建立用例的交互模型</span></a></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B"><i class="tag post-item-tag">软件工程</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">软件工程期末突击</h1><time class="has-text-grey" datetime="2023-05-23T08:56:49.648Z">2023-05-23</time><article class="mt-2 post-content"><p>[toc]</p>
<h2 id="%E7%AC%AC%E4%B8%80%E7%AB%A0-%E4%BB%8E%E7%A8%8B%E5%BA%8F%E5%88%B0%E8%BD%AF%E4%BB%B6" tabindex="-1">第一章 从程序到软件</h2>
<h3 id="1-%E4%BD%95%E4%B8%BA%E7%A8%8B%E5%BA%8F%E5%8F%8A%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%B4%A8%E9%87%8F%E8%A6%81%E6%B1%82" tabindex="-1">1 何为程序及程序的质量要求</h3>
<h4 id="%EF%BC%881%EF%BC%89%E4%BD%95%E4%B8%BA%E7%A8%8B%E5%BA%8F" tabindex="-1">（1）何为程序</h4>
<ul>
<li>程序（Program）是由程序设计语言所描述的、能为计算机所理解和处理的一组语句序列</li>
<li>程序严格遵循程序设计语言的各项语法和语义规定</li>
<li>程序代码可表现为二种形式
<ul>
<li>源代码（Source Code）：用程序设计语言所描述的代码</li>
<li>可执行代码（Executable Code）：可执行的二进制或中间码</li>
</ul>
</li>
</ul>
<h4 id="%EF%BC%882%EF%BC%89-%E7%A8%8B%E5%BA%8F%E7%BB%84%E6%88%90" tabindex="-1">（2） 程序组成</h4>
<ul>
<li>语句：声明、定义、控制、计算等；实现特定的功能；</li>
<li>模块：包，类，方法；每个模块实现特定功能</li>
</ul>
<h4 id="%EF%BC%883%EF%BC%89%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%BA%8C%E7%B1%BB%E5%88%A9%E7%9B%8A%E7%9B%B8%E5%85%B3%E8%80%85" tabindex="-1">（3）程序的二类利益相关者</h4>
<ul>
<li>用户：
<ul>
<li>程序的运行展示 <strong>功能和性能</strong></li>
<li>满足和实现用户的<strong>需求</strong></li>
</ul>
</li>
<li>程序员
<ul>
<li>编写，阅读维护程序</li>
<li>发现和修改程序中的缺陷</li>
</ul>
</li>
<li>用户和程序员对程序有这不同的质量需求</li>
</ul>
<h4 id="%EF%BC%884%EF%BC%89%E7%A8%8B%E5%BA%8F%E8%B4%A8%E9%87%8F%E7%9A%84%E5%86%85%E5%9C%A8%E5%92%8C%E5%A4%96%E5%9C%A8%E4%BD%93%E7%8E%B0" tabindex="-1">（4）程序质量的内在和外在体现</h4>
<ul>
<li>外在(External)质量
<ul>
<li>用户视点</li>
<li>对外可展示，用户可直接感触到、所关心的</li>
<li>使用流畅性、响应速度、界面美观、操作简易性、运行可靠性等</li>
</ul>
</li>
<li>内在(Internal)质量
<ul>
<li>程序员视点</li>
<li>体现在程序的内在方面，程序员可以感触到的、所关心的</li>
<li>易于理解、结构清晰、易于修改、可重用好等</li>
</ul>
</li>
</ul>
<h3 id="2-%E7%A8%8B%E5%BA%8F%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81%E6%96%B9%E6%B3%95" tabindex="-1">2 程序质量保证方法</h3>
<ul>
<li>程序质量保证方法
<ul>
<li>遵循编码风格</li>
<li>采用程序设计方法</li>
<li>开展代码重用</li>
<li>进行结对编程</li>
<li></li>
</ul>
</li>
</ul>
<h4 id="%EF%BC%881%EF%BC%89%E7%A8%8B%E5%BA%8F%E8%B4%A8%E9%87%8F%E7%9A%84%E8%AF%AD%E6%B3%95%E5%92%8C%E8%AF%AD%E4%B9%89%E4%BD%93%E7%8E%B0" tabindex="-1">（1）程序质量的语法和语义体现</h4>
<ul>
<li>代码风格规范-语法
<ul>
<li>语法和结构层次</li>
<li>明确如何来规范程序的书写</li>
<li>表现为是否易于阅读和理解</li>
</ul>
</li>
<li>代码设计规范-语义
<ul>
<li>语义和内涵层次，外在的</li>
<li>明确如何来组织和封装程序语句</li>
<li>表现为良好的结构和易于重用</li>
</ul>
</li>
</ul>
<h4 id="%EF%BC%882%EF%BC%89%E9%81%B5%E5%BE%AA%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC" tabindex="-1">（2）遵循编码风格</h4>
<ul>
<li>良好的编程行为：对代码符号进行良好的组织、合理的命名、提供必要的注释，那么将可增强代码的可读性和可理解性，进而提高代码的可维护性和可重用性，提升代码的内部质量</li>
<li>编码风格：程序员在编码时要遵循特定的样式及要求，以规范程序员的编程行为以及所产生程序代码的样式</li>
<li>编写代码的基本原则
<ul>
<li>易懂，一看就懂</li>
<li>简明，降低复杂度</li>
<li>易改，便于维护</li>
<li>无二义，不产生歧义</li>
</ul>
</li>
<li>代码风格举例：
<ul>
<li>代码布局：缩进，大括号换行</li>
<li>代码组织：按字母顺序说明对象，单入口单出口</li>
<li>命名规范：一看就懂，望文生义；小驼峰，大驼峰</li>
<li>代码注释：有效、必要、简洁的注释；注解位置</li>
</ul>
</li>
</ul>
<h4 id="%EF%BC%883%EF%BC%89%E9%87%87%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95" tabindex="-1">（3）采用程序设计方法</h4>
<ul>
<li>语句设计
<ul>
<li>单入口单出口，少用goto语句</li>
<li>加强对异常处理
<ul>
<li>将更多的时间和精力放在处理异常代码上</li>
</ul>
</li>
</ul>
</li>
<li>模块化设计
<ul>
<li>模块是逻辑上相对独立、具有良定义接口的编程单位</li>
<li>模块可表现为函数、过程、方法、类、程序包等</li>
</ul>
</li>
<li>高内聚低耦合原则
<ul>
<li>高内聚：模块内各要素紧密相关，仅实现单一功能，否则再进行拆分</li>
<li>低耦合：模块间的关系应设计的非常松散</li>
</ul>
</li>
</ul>
<h4 id="%EF%BC%884%EF%BC%89%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8" tabindex="-1">（4）代码重用</h4>
<p>定义：在编写代码过程中，充分利用已有和现成的代码，并将其集成到程序之中，从而来实现程序功能<br>
好处：由于被重用的代码经过多次反复的使用，代码质量得到充分检验，因而代码重用不仅可极大提高编程效率，而且还可有效提高程序质量</p>
<ul>
<li>重用代码片段</li>
<li>重用函数、类和软构件</li>
<li>重用开源代码</li>
</ul>
<h4 id="%EF%BC%885%EF%BC%89%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B" tabindex="-1">（5）结对编程</h4>
<h3 id="3-%E7%A8%8B%E5%BA%8F%E8%B4%A8%E9%87%8F%E7%9A%84%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95" tabindex="-1">3 程序质量的分析方法</h3>
<ul>
<li>人工审查方法</li>
<li>自动化分析方法</li>
<li>程序测试方法</li>
</ul>
<h4 id="%EF%BC%881%EF%BC%89%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%A0%81%E4%B8%AD%E6%BD%9C%E5%9C%A8%E7%9A%84%E8%B4%A8%E9%87%8F%E9%97%AE%E9%A2%98" tabindex="-1">（1）程序代码中潜在的质量问题</h4>
<ul>
<li>质量问题
<ul>
<li>编写不合理 – 没有遵循编码规范</li>
<li>设计不合理 – 没有遵循设计规范</li>
<li>代码有错误 – 代码编写的不正确</li>
</ul>
</li>
</ul>
<h4 id="%EF%BC%882%EF%BC%89%E4%BA%BA%E5%B7%A5%E5%AE%A1%E6%9F%A5%E4%BB%A3%E7%A0%81%EF%BC%88code-review%EF%BC%89" tabindex="-1">（2）人工审查代码（Code Review）</h4>
<ul>
<li>方法描述:阅读和理解代码；发现缺陷和问题；提出改进的建议</li>
<li>方法特点：人工审查效率低；难以发现一些深层次问题；难以全面地进行系统分析</li>
<li>审查方面：
<ul>
<li>代码是否符合编程规范</li>
<li>代码中是否存在缺陷</li>
<li>从质量的角度哪些代码需要改进</li>
</ul>
</li>
</ul>
<h4 id="%EF%BC%883%EF%BC%89%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7%E5%AE%A1%E6%9F%A5-%E4%BB%A3%E7%A0%81%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90" tabindex="-1">（3）自动化工具审查-代码静态分析</h4>
<ul>
<li>
<p>由计算机软件来自动完成代码审查</p>
<ul>
<li>无需运行被测代码，仅通过分析或检查程序的语法、结构、过程、接口等来检查程序</li>
<li>30% - 70% 的代码缺陷可通过静态分析发现</li>
</ul>
</li>
<li>
<p>分析什么</p>
<ul>
<li>找出代码隐藏的错误和缺陷，如参数不匹配，有歧义的嵌套语句，错误的递归，非法计算，可能出现的空指针引用等等</li>
<li>程序遵循编码规范的程度</li>
</ul>
</li>
<li>
<p>特点：快速定位、有效发现隐藏的错误和缺陷</p>
</li>
<li>
<p>自动化代码分析工具：SonarQube</p>
<ul>
<li>基于Web、用于管理程序代码质量的代码分析工具</li>
<li><a target="_blank" rel="noopener" href="http://www.sonarqube.org">www.sonarqube.org</a></li>
<li>能以插件的形式集成到众多的软件开发环境（如Eclipse）</li>
</ul>
</li>
</ul>
<h4 id="%EF%BC%884%EF%BC%89%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%8A%80%E6%9C%AF" tabindex="-1">（4）软件测试技术</h4>
<ul>
<li>程序本质上是对数据的处理</li>
<li>设计数据(测试用例) -&gt; 运行测试用例(程序来处理数据) -&gt; 判断运行结果(是否符合预期结果)</li>
</ul>
<h3 id="4-%E4%BD%95%E4%B8%BA%E8%BD%AF%E4%BB%B6%E5%8F%8A%E8%BD%AF%E4%BB%B6%E7%9A%84%E7%89%B9%E7%82%B9" tabindex="-1">4 何为软件及软件的特点</h3>
<h4 id="%EF%BC%881%EF%BC%89%E4%BD%95%E4%B8%BA%E8%BD%AF%E4%BB%B6" tabindex="-1">（1）何为软件</h4>
<ul>
<li>软件是指在计算机系统的支持下，能够完成特定功能与性能的<strong>程序、数据和文档</strong>
<ul>
<li>文档：记录软件开发活动和阶段性成果、软件配置及变更的阐述性资料
<ul>
<li>定义和理解软件</li>
<li>记录软件开发成果</li>
<li>辅助不同人员间的交流</li>
</ul>
</li>
<li>数据：程序的加工处理对象和结果
<ul>
<li>数据形式：用户，订单，交易，日志</li>
<li>数据处理：表示，获取，存储，检索，分析</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="%EF%BC%882%EF%BC%89%E8%BD%AF%E4%BB%B6%E6%A6%82%E5%BF%B5%E7%BB%99%E6%88%91%E4%BB%AC%E7%9A%84%E5%90%AF%E7%A4%BA" tabindex="-1">（2）软件概念给我们的启示</h4>
<ul>
<li>软件<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≠</mo><mrow></mrow></mrow><annotation encoding="application/x-tex">\not ={}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span></span><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0em;"></span><span class="mord"></span></span></span></span></eq>程序
<ul>
<li>软件涉及更多制品</li>
<li>这些制品间有关联、相互依赖</li>
</ul>
</li>
<li>开发软件   <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≠</mo><mrow></mrow></mrow><annotation encoding="application/x-tex">\not ={}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span></span><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0em;"></span><span class="mord"></span></span></span></span></eq>      编写程序
<ul>
<li>软件开发需要做更多事情</li>
<li>对软件提出更高的要求</li>
</ul>
</li>
<li>软件的规模和复杂性意味着要采用行之有效的方法—工程方法</li>
</ul>
<h4 id="%EF%BC%883%EF%BC%89%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" tabindex="-1">（3）软件生命周期</h4>
<ul>
<li>a 需求分析</li>
<li>b 软件设计</li>
<li>c 编码实现</li>
<li>d 软件测试</li>
<li>e 部署运行</li>
<li>f 使用维护</li>
<li>转a</li>
</ul>
<h4 id="%EF%BC%884%EF%BC%89%E8%BD%AF%E4%BB%B6%E7%89%B9%E7%82%B9" tabindex="-1">（4）软件特点</h4>
<ul>
<li>逻辑性：逻辑产品，逻辑思维（非物理活动）的结果、不会磨损和老化</li>
<li>设计开发：是设计开发而成的，不是生产制造而成的，而是一系列以设计为核心的软件开发活动</li>
<li>易变性：需求经常变、难以把控，影响软件的制品即开发过程；产品难以成熟</li>
<li>复杂性：规模大；运行复杂；环境复杂；</li>
<li>缺陷的隐蔽性：缺陷隐藏在逻辑代码中，不像硬件系统那样直观显现，很难被人们所发现和排除</li>
</ul>
<h3 id="5-%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%88%86%E7%B1%BB" tabindex="-1">5 软件的分类</h3>
<h4 id="%EF%BC%881%EF%BC%89%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%88%86%E7%B1%BB" tabindex="-1">（1）软件的分类</h4>
<ul>
<li>
<p>应用软件</p>
<ul>
<li>面向特定应用领域的专用软件。它们针对相关行业和领域的特定问题，为其提供基于计算的新颖解决方案。</li>
<li>示例：淘宝、12306、携程、微信、QQ等软件</li>
</ul>
</li>
<li>
<p>系统软件</p>
<ul>
<li>对计算机资源进行管理，为应用软件的运行提供基础设施和服务的一类软件。从计算服务的视角，系统软件介于计算机硬件和应用软件之间。</li>
<li>示例：操作系统、数据库管理系统、编译软件、软件中间件等</li>
</ul>
</li>
<li>
<p>支撑软件</p>
<ul>
<li>辅助软件开发和运维，帮助开发人员完成软件开发和维护工作的一类软件</li>
<li>示例：SonarQube、Visual Studio、Eclipse等</li>
</ul>
</li>
<li>
<p>通用软件产品</p>
<ul>
<li>由软件开发组织开发的，在市场上公开销售，可以独立使用的软件.</li>
<li>关于产品应该做什么的规格说明由开发者确定，相关的变更决策也由开发者做出.</li>
</ul>
</li>
<li>
<p>定制化软件产品</p>
<ul>
<li>受特定客户委托，由软件开发商针对特定客户需求专门设计和实现的软件.</li>
<li>关于产品应该做什么的规格说明由客户给出，相关的变更需求也由客户提出.</li>
</ul>
</li>
</ul>
<h4 id="%EF%BC%882%EF%BC%89%E9%97%AD%E6%BA%90%E8%BD%AF%E4%BB%B6" tabindex="-1">（2）闭源软件</h4>
<ul>
<li>何为闭源软件
<ul>
<li>软件代码不对用户开放的一类软件，购买软件时只提供可运行软件或服务，没有提供源代码</li>
<li>以许可证（License）的方式授权用户使用软件</li>
</ul>
</li>
<li>闭源软件带来的问题
<ul>
<li>无法掌握软件内部实现情况（如是否存在安全漏洞和恶意代码），也无法对软件进行修改和完善，极大影响了开发者的创新自由</li>
</ul>
</li>
<li>示例
<ul>
<li>微软的Windows、Office软件，</li>
<li>典型企业：微软、IBM、Oracle等</li>
</ul>
</li>
</ul>
<h4 id="%EF%BC%883%EF%BC%89%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6" tabindex="-1">（3）开源软件</h4>
<ul>
<li>何为开源软件
<ul>
<li>一种源代码可以自由获取和传播的计算机软件，其拥有者通过开源许可证赋予被许可人对软件进行使用、修改和传播</li>
</ul>
</li>
<li>开源软件的好处
<ul>
<li>源代码可自由传播</li>
<li>激发创作者的热情</li>
<li>免费使用降低成本</li>
</ul>
</li>
<li>示例：开源软件
<ul>
<li>Linux, Ubuntu</li>
<li>Apache, Jboss, Tomcat</li>
</ul>
</li>
</ul>
<h4 id="%EF%BC%884%EF%BC%89%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E6%89%98%E7%AE%A1%E5%B9%B3%E5%8F%B0" tabindex="-1">（4）开源软件托管平台</h4>
<ul>
<li>Github：全球最有影响力的开源软件托管平台</li>
<li>SourceForge：一个有影响力的开源软件开发平台和仓库，为开源软件提供存储、协作和发布的支持</li>
<li>Gitee：中国的开源软件托管平台</li>
<li>Stack Overflow：全球最大的软件开发知识分享平台，它支持开发者交流和讨论软件开发问题、分享软件开发经验和知识，进而促进相关开发问题的解决，推动开源软件的开发</li>
</ul>
<h4 id="%EF%BC%885%EF%BC%89%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E7%9A%84%E4%BC%98%E5%8A%BF" tabindex="-1">（5）开源软件的优势</h4>
<ul>
<li>
<p>采购和开发的成本更低</p>
<ul>
<li>开源软件通常是免费的，即使要付费，其费用也非常低廉</li>
</ul>
</li>
<li>
<p>软件质量更高、更安全</p>
<ul>
<li>核心代码都在公众的视野之中，代码问题（如缺陷、安全漏洞等）很容易被人发现</li>
</ul>
</li>
<li>
<p>软件研制和交付的更快</p>
<ul>
<li>基于开源软件的项目开发可以更为快速地给用户交付软件产品</li>
</ul>
</li>
<li>
<p>软件功能更为强大</p>
<ul>
<li>大量的软件开发者不仅参与软件开发，贡献他们的代码，而且还参与软件的创新，提出和构思软件需求，不断完善软件功能</li>
</ul>
</li>
<li>
<p>开源软件许可证</p>
<ul>
<li>何为开源许可证
<ul>
<li>声明获得开源代码后拥有的权利，界定对别人的开源作品进行何种操作、何种操作是被禁止的，规范开源软件的使用要求和约束</li>
<li>开发者虽然可自由地获取开源软件的源代码，但在如何使用开源软件方面还需要遵循相关的开源软件协议</li>
</ul>
</li>
<li>二类许可证
<ul>
<li>宽松式开源许可证：三方面特点：代码使用没有任何限制；用户自担代码质量的风险；用户使用开源软件时须披露原始作者</li>
<li>Copyleft式开源许可证：更多限制，带有许多条件和要求，比如分发二进制代码时须提供源代码，修改后的开源软件须与之前保持一致的许可证等</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="%EF%BC%886%EF%BC%89%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8" tabindex="-1">（6）开源软件的利用</h4>
<ul>
<li>学习开源软件
<ul>
<li>不仅反映了核心开发者的软件技术和功能创意，而且还蕴含了高水平的软件开发技能，如架构设计、编码风格、模块封装等</li>
</ul>
</li>
<li>重用开源代码
<ul>
<li>开源软件构成了支撑软件开发的可重用软件资源库，可实现更大粒度的软件重用</li>
</ul>
</li>
<li>参与开源建设，掌握开源技术，理解开源文化
<ul>
<li>包括反馈软件缺陷、提出软件需求、讨论问题的解决、贡献程序代码等等</li>
</ul>
</li>
<li>重用和集成开源软件来快速搭建高质量的系统</li>
</ul>
<h3 id="6-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F" tabindex="-1">6 软件质量</h3>
<ul>
<li>软件质量是指软件满足给定需求的程度，它是产品生命线</li>
<li>正确性（Correctness）：软件满足规格说明和用户要求的程度，即在预定环境下能正确地完成预期功能和非功能需求的程度。</li>
<li>可靠性（Reliability）：在规定条件下、限定时间范围内，软件系统完成预期功能、不引起系统故障的能力。</li>
<li>健壮性（Robustness）：在计算环境发生故障、输入无效数据或操作错误等意外情况下，软件仍能做出适当响应的程度。</li>
<li>有效性（Efficiency）：软件利用计算资源和存储资源以实现其功能的能力</li>
<li>安全性：包括系统安全（Safety）和信息安全（Security），系统安全是指软件能及时有效地避免给人员、设施、环境、经济等造成损害，信息安全是指软件能有效防控各类的非法获取、传播和使用</li>
<li>可维护性（Maintainability）：是否易于对其进行修改以更正错误、增强功能、适应新运行环境</li>
<li>可移植性（Portability）：把软件从一种运行环境转移到另一种运行环境下运行的难易程度</li>
<li>可重用性（Reusability）：软件模块、构件、设计方案等在其他软件开发中被再次使用程度</li>
<li>可理解性（Comprehensibility）：软件开发者或用户理解该软件系统的容易程度</li>
<li>可信性（Dependability）：采取有效措施确认软件满足人们的要求和期望</li>
<li>持续性（Sustainability）：面对各种突发异常事件，仍能提供令人满意的服务的能力</li>
<li>可用性（Usability）：使用和操作软件系统难以程度</li>
<li>互操作性（Interoperability）：软件系统与其他的系统进行交换信息、协同工作的能力</li>
</ul>
<h2 id="%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%BF%B0" tabindex="-1">第二章 软件工程概述</h2>
<h3 id="1-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%BA%A7%E7%94%9F%E8%83%8C%E6%99%AF" tabindex="-1">1 软件工程产生背景</h3>
<h4 id="%EF%BC%881%EF%BC%89%E8%BD%AF%E4%BB%B6%E5%8D%B1%E6%9C%BA%E7%9A%84%E5%87%BA%E7%8E%B0" tabindex="-1">（1）软件危机的出现</h4>
<ul>
<li>进度经常延迟</li>
<li>质量无法保证</li>
<li>成本超出预算</li>
<li>软件维护困难</li>
<li>失败风险很大</li>
</ul>
<h4 id="%EF%BC%882%EF%BC%89%E5%A6%82%E4%BD%95%E6%9D%A5%E8%A7%A3%E5%86%B3%E8%BD%AF%E4%BB%B6%E5%8D%B1%E6%9C%BA%3F" tabindex="-1">（2）如何来解决软件危机?</h4>
<ul>
<li>软件危机根源
<ul>
<li>对软件这样一类复杂和特殊系统的认识不清：软件是新生事物，对其特点、规律性和复杂性认识不够</li>
<li>没有找到支持软件系统开发的有效方法：基础理论、关键技术、开发过程、支撑工具等</li>
<li>缺乏成功软件开发实践以及相应的开发经验：系统总结、认真分析、充分借鉴、吸取教训</li>
</ul>
</li>
<li>软件开发迫切需要理论和方法指导，软件工程应运而生</li>
</ul>
<h3 id="2-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E6%9C%AC%E5%86%85%E6%B6%B5" tabindex="-1">2 软件工程基本内涵</h3>
<h4 id="%EF%BC%881%EF%BC%89%E4%BD%95%E4%B8%BA%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B" tabindex="-1">（1）何为软件工程</h4>
<ul>
<li>
<p>将系统的、规范的、可量化的方法应用于软件的开发、运行和维护的过程；以及上述方法的研究</p>
<ul>
<li>系统化：提供完整和全面的解决方法，包括目标、原则、过程模型、开发活动、开发方法和技术等</li>
<li>规范化：支持各类软件系统的开发，包括语言标准、质量标准、编程标准、方法标准、能力极其改进标准等</li>
<li>可量化：工作量、成本、进度、质量等要素可以量化，基于定量的数据支持开发和管理，确保科学性和可行性</li>
</ul>
</li>
<li>
<p>软件工程对软件开发的新认识</p>
<ul>
<li>软件是产品(Product)：面向用户，存在质量、成本、利润等特征</li>
<li>软件开发是一项工程(Project)：存在约束，需要质量保证，进行组织管理，…</li>
<li>要按工程化方法来组织软件生产
<ul>
<li>分阶段分步骤来实施</li>
<li>按计划开展开发活动</li>
<li>进行各种形式质量保证</li>
<li>采用行之有效的方法</li>
<li>借助各种工具的支持…</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="%EF%BC%882%EF%BC%89%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%89%E8%A6%81%E7%B4%A0" tabindex="-1">（2）软件工程三要素</h4>
<p><img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/2_3_0.jpg" alt></p>
<ul>
<li>过程
<ul>
<li>从管理的视角，回答软件开发、运行和维护需要开展哪些工作、按照什么样的步骤和次序来开展工作</li>
<li>对软件开发过程所涉及的人、制品、质量、成本、计划等进行有效和可量化的管理</li>
<li>典型成果
<ul>
<li>过程模型，如瀑布模型、增量模型、原型模型、迭代模型、螺旋模型等等</li>
<li>方法，如敏捷开发方法、群体化开发方法、DevOps方法</li>
<li>管理，如配置管理、质量管理、团队组织等</li>
</ul>
</li>
</ul>
</li>
<li>方法学(Methodology)
<ul>
<li>从技术的视角，回答软件开发、运行和维护如何做的问题</li>
<li>为软件开发过程中的各项开发和维护活动提供系统性、规范性的技术支持
<ul>
<li>如何理解和认识软件模型是什么</li>
<li>如何用不同抽象层次的模型来描述软件制品</li>
<li>采用什么样的建模语言来描述软件模型等等</li>
</ul>
</li>
<li>典型成果
<ul>
<li>结构化软件开发方法学</li>
<li>面向对象软件开发方法学</li>
<li>基于构件的软件开发方法学</li>
</ul>
</li>
</ul>
</li>
<li>工具
<ul>
<li>从工具辅助的视角，主要回答如何借助工具来辅助软件开发、运行和维护的问题</li>
<li>帮助软件开发人员更为高效地运用软件开发方法学来完成软件开发过程中的各项工作，提高软件开发效率和质量，加快软件交付进度。
<ul>
<li>如需求分析、软件设计、编码实现、软件测试、部署运行、软件维护、项目管理、质量保证等，简化软件开发任务，</li>
</ul>
</li>
<li>典型成果：SonarQube、Eclipse等</li>
</ul>
</li>
</ul>
<h4 id="%EF%BC%883%EF%BC%89%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BE%85%E5%8A%A9%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B" tabindex="-1">（3）计算机辅助软件工程</h4>
<ul>
<li>什么是计算机辅助软件工程(Computer-Aided Software Engineering, CASE)
<ul>
<li>在软件工程活动中，开发人员按照软件工程的方法和原则，借助于计算机及其软件的帮助来开发、维护和管理软件产品的过程</li>
</ul>
</li>
<li>CASE工具：支持CASE的软件工具，如编辑器、编译器等</li>
<li>CASE环境：
<ul>
<li>将CASE工具按统一标准和接口组装起来，使工具间、人员间、各个过程间能方便交互的集成环境</li>
<li>如Visual Studio将编辑、编译、调试、界面设计、安装程序生成等等集成在一起</li>
</ul>
</li>
<li>代码编写，项目管理，软件建模，软件测试，软件运维</li>
</ul>
<h4 id="%EF%BC%884%EF%BC%89%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9A%84%E6%9C%AC%E8%B4%A8" tabindex="-1">（4）软件开发的本质</h4>
<ul>
<li>软件开发 = 软件创作 + 软件生产</li>
<li>软件创作：基于软件开发者的经验和技能，借助于智慧，进行自由创新，如软件设计、编码实现等</li>
<li>软件生产：基于工程化的手段，遵循约束和规范，开展软件生产，如遵循过程、按照标准、质量保证等</li>
</ul>
<h4 id="%EF%BC%885%EF%BC%89%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%9A%84%E7%9B%AE%E6%A0%87" tabindex="-1">（5）软件工程的目标</h4>
<p>在成本、进度等约束下，指导软件开发和运维，开发出满足用户要求的足够好软件</p>
<h4 id="%EF%BC%886%EF%BC%89%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%8E%9F%E5%88%99" tabindex="-1">（6）软件工程原则</h4>
<ul>
<li>抽象与建模
<ul>
<li>抽象：将与相关开发活动所关注的要素提取出来，不关心的要素扔掉，形成与该开发活动相关的软件要素</li>
<li>建模：基于特定的抽象，借助于建模语言（如数据流图、UML等），建立起基于这些抽象的软件模型，进而促进对软件系统的准确理解</li>
</ul>
</li>
<li>模块化
<ul>
<li>将软件系统的功能分解和实现为若干个模块，每个模块具有独立的功能，模块之间通过接口进行调用和访问。</li>
</ul>
</li>
<li>软件重用
<ul>
<li>在软件开发过程中尽可能利用已有的软件资源和资产（如函数库、类库、构件库、开源软件、代码片段等）来实现软件系统</li>
<li>努力开发出可被再次重用的软件资源（如函数、类、构件等）</li>
<li>有助于提高软件开发效率，降低软件开发成本，满足开发工程约束，得到高质量的软件产品</li>
</ul>
</li>
<li>信息隐藏
<ul>
<li>模块内部信息（如内部的语句、变量等）对外不可见或不可访问，模块间仅仅交换那些为完成系统功能所必需交换的信息（如接口）</li>
<li>模块设计时只对外提供可见的接口，不提供内部实现细节。信息隐藏原则可提升模块的独立性，减少错误向外传播，支持模块的并行开发</li>
</ul>
</li>
<li>关注点分离</li>
<li>分而治之</li>
<li>双向追踪原则
<ul>
<li>当某个软件制品发生变化时，一方面要追踪这种变化会对那些软件制品产生影响，进而指导相关的开发和维护工作，此为正向追踪；另一方面要追踪产生这种变化的来源，或者说是什么因素导致了该软件制品的变化，明确软件制品发生变化的原因及其合理性，此为反向追踪。</li>
</ul>
</li>
<li>工具辅助</li>
</ul>
<h2 id="%E7%AC%AC%E4%B8%89%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%92%8C%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95" tabindex="-1">第三章 软件工程和开发方法</h2>
<h3 id="1-%E4%BD%95%E4%B8%BA%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B" tabindex="-1">1 何为软件过程模型</h3>
<h4 id="%EF%BC%881%EF%BC%89%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B" tabindex="-1">（1）软件过程</h4>
<ul>
<li>过程(Process)
<ul>
<li>活动：明确要做哪些事情，包括具体的活动</li>
<li>关系：活动间存在逻辑关系，如依赖和先后次序</li>
</ul>
</li>
<li>软件过程：
<ul>
<li>按照项目进度、成本和质量要求，遵循用户需求，开发和维护软件、管理软件项目的一系列有序软件开发活动</li>
<li>软件开发活动：技术活动和管理活动</li>
</ul>
</li>
</ul>
<h4 id="%EF%BC%882%EF%BC%89%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B" tabindex="-1">（2）软件过程模型</h4>
<ul>
<li>定义了软件开发的具体活动以及活动间的逻辑关系</li>
<li>描述包括：
<ul>
<li>过程中的活动以及这些活动的顺序</li>
<li>产品交付物：软件过程活动的产出物;</li>
<li>角色：反映了参与过程的人在其中的职责;</li>
<li>前置条件和后置条件：在一个过程活动执行之前和之后，或者产品生产之前和之后必须满足的条件。</li>
<li>工具</li>
<li>资源</li>
</ul>
</li>
</ul>
<h3 id="2-%E6%9C%89%E5%93%AA%E4%BA%9B%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B" tabindex="-1">2 有哪些软件过程模型</h3>
<ul>
<li>瀑布模型</li>
<li>增量模型</li>
<li>迭代模型</li>
<li>原型模型</li>
<li>螺旋模型</li>
<li>基于构件的过程模型</li>
<li>UP模型</li>
</ul>
<h4 id="%EF%BC%881%EF%BC%89%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B" tabindex="-1">（1）瀑布模型</h4>
<ul>
<li>步骤
<ol>
<li><strong>需求分析</strong></li>
</ol>
<ul>
<li>活动
<ul>
<li>任务：定义软件需求，包括功能、非功能需求</li>
<li>层次和视角：用户角度，仅描述问题和需求</li>
</ul>
</li>
<li>方法
<ul>
<li>依据：用户的期望和要求</li>
<li>不断与用户进行交流和商讨，抽象、问题分解、多视点等技术</li>
</ul>
</li>
<li>产出：软件需求模型；软件需求文档；软件确认测试计划；</li>
</ul>
<ol start="2">
<li><strong>概要设计</strong></li>
</ol>
<ul>
<li>活动
<ul>
<li>任务：建立软件总体架构、制定集成测试计划</li>
<li>层次和视角：宏观、全局、整体、战略性</li>
</ul>
</li>
<li>方法
<ul>
<li>依据：软件需求文档</li>
<li>自顶向下, 逐步求精,  抽象, 模块化, 局部化，信息隐藏</li>
</ul>
</li>
<li>产出：软件概要设计模型、软件概要设计文档、软件集成测试计划</li>
</ul>
<ol start="3">
<li><strong>详细设计</strong></li>
</ol>
<ul>
<li>活动
<ul>
<li>任务：设计模块内部细节(算法、数据结构)，制订单元测试计划</li>
<li>层次和视角：微观、局部、细节性</li>
</ul>
</li>
<li>方法
<ul>
<li>依据：概要设计文档、软件需求文档</li>
<li>高质量的软件设计原则，如单入口单出口</li>
</ul>
</li>
<li>产出：软件详细设计模型、软件详细设计文档、单元测试计划</li>
</ul>
<ol start="4">
<li><strong>编码实现</strong></li>
</ol>
<ul>
<li>活动
<ul>
<li>任务：编写程序代码并进行单元测试和调试</li>
<li>层次和视角：最终的实现代码</li>
</ul>
</li>
<li>方法
<ul>
<li>依据：软件概要和详细设计文档、单元测试计划</li>
<li>采用某种程序设计语言(如C、C++、Java)</li>
</ul>
</li>
<li>产出：经过单元测试的源程序代码</li>
</ul>
<ol start="5">
<li><strong>集成测试</strong></li>
</ol>
<ul>
<li>活动
<ul>
<li>任务：组装软件模块并进行测试以发现问题</li>
<li>层次和视角：系统结构、接口</li>
</ul>
</li>
<li>方法
<ul>
<li>依据：软件概要设计文档、软件集成测试计划</li>
<li>软件集成测试工具</li>
</ul>
</li>
<li>产出：经过集成测试、修复缺陷的源程序代码，集成测试报告</li>
</ul>
<ol start="6">
<li><strong>确认测试</strong></li>
</ol>
<ul>
<li>活动
<ul>
<li>任务：测试软件是否满足用户需求</li>
<li>层次和视角：从用户角度，聚焦需求是否得以正确实现</li>
</ul>
</li>
<li>方法
<ul>
<li>依据：软件确认测试计划、软件需求文档</li>
<li>软件测试支撑工具</li>
</ul>
</li>
<li>产出：经过确认测试、修复缺陷后的代码，软件确认测试报告</li>
</ul>
</li>
<li>特点：
<ul>
<li>与软件生命周期相互一致</li>
<li>每个活动结束后需要评审</li>
<li>相邻活动间存在因果关系</li>
</ul>
</li>
<li>优点：简单，一目了然，易理解、掌握、应用和管理</li>
<li>缺点：违背现实</li>
<li>适用于需求易于定义、不易变动的软件系统</li>
<li>改进的瀑布模型：带反馈和回溯</li>
</ul>
<h4 id="%EF%BC%882%EF%BC%89%E5%A2%9E%E9%87%8F%E6%A8%A1%E5%9E%8B" tabindex="-1">（2）增量模型</h4>
<p><img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/3_2_4.jpg" alt></p>
<ul>
<li>优点：渐进快速交付，并行开发，提高效率</li>
<li>不足：
<ul>
<li>要求一开始完整确定需求，建立系统架构的要求更高</li>
<li>管理复杂，增量开发，要保持多个版本的制品一致性</li>
<li>产品是慢慢成熟的，跟办事规程不匹配</li>
</ul>
</li>
</ul>
<h4 id="%EF%BC%883%EF%BC%89%E8%BF%AD%E4%BB%A3%E6%A8%A1%E5%9E%8B(iterative-model)" tabindex="-1">（3）迭代模型(Iterative Model)</h4>
<p><img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/3_2_5.jpg" alt></p>
<ul>
<li>优点：
<ul>
<li>每次迭代是一完整过程</li>
<li>体现了小步快跑的开发理念，降低风险</li>
<li>适合需求难导出、不甚明确且持续变动的软件</li>
</ul>
</li>
<li>不足
<ul>
<li>迭代多少次不确定</li>
<li>管理较为复杂</li>
<li>高素质管理者和团队</li>
</ul>
</li>
</ul>
<h4 id="%EF%BC%884%EF%BC%89%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%9E%8B(prototype-model)" tabindex="-1">（4）原型模型(Prototype Model)</h4>
<p><img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/3_2_6.jpg" alt></p>
<ul>
<li>软件原型:用户界面+执行流程</li>
<li>特点
<ul>
<li>软件原型作为交流载体和媒介</li>
<li>支持用户参与到软件开发中</li>
<li>持续、渐进地导出用户要求</li>
</ul>
</li>
<li>适合于需求难导出、模糊且不易确定的软件</li>
</ul>
<h4 id="%EF%BC%885%EF%BC%89%E8%9E%BA%E6%97%8B%E6%A8%A1%E5%9E%8B(spiral-model)" tabindex="-1">（5）螺旋模型(Spiral Model)</h4>
<p><img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/3_2_7.jpg" alt></p>
<ul>
<li>优点：
<ul>
<li>集成迭代模型和原型模型</li>
<li>引入风险分析，风险驱动</li>
<li>适合于需求不明确、开发风险高、开发过程中需求变更大的内部软件项目</li>
</ul>
</li>
<li>不足：风险驱动、管理复杂</li>
</ul>
<h4 id="%EF%BC%886%EF%BC%89%E4%B8%8D%E5%90%8C%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%89%B9%E7%82%B9" tabindex="-1">（6）不同软件过程模型的特点</h4>
<p><img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/3_2_8.jpg" alt></p>
<h3 id="3-%E5%A6%82%E4%BD%95%E6%9D%A5%E9%80%89%E6%8B%A9%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B" tabindex="-1">3 如何来选择软件过程模型</h3>
<h4 id="%EF%BC%881%EF%BC%89%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%80%89%E6%8B%A9" tabindex="-1">（1）软件过程模型的选择</h4>
<ul>
<li>
<p>考虑软件项目的特点</p>
</li>
<li>
<p>软件开发团队的水平</p>
</li>
<li>
<p>分析软件过程模型特点</p>
</li>
<li>
<p>互联网应用软件的开发过程模型</p>
<ul>
<li>特点：软件需求不确定且快速变化</li>
<li>如：12306 APP软件，微信软件，淘宝软件</li>
<li>选用瀑布模型不合适，迭代模型较为合适</li>
</ul>
</li>
<li>
<p>装备软件的开发过程模型</p>
<ul>
<li>特点：软件需求确定且较为稳定</li>
<li>如：飞行控制软件</li>
<li>可考虑选用瀑布模型，用迭代模型不是很合适</li>
</ul>
</li>
</ul>
<h4 id="%EF%BC%882%EF%BC%89%E4%BC%A0%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%89%B9%E7%82%B9%E5%92%8C%E4%B8%8D%E8%B6%B3" tabindex="-1">（2）传统软件过程模型的特点和不足</h4>
<ul>
<li>软件开发和运维的大量工作用于撰写软件文档，而非去编写程序代码</li>
<li>软件开发过程中会花费大量时间和精力用于软件文档的评审，以确保软件质量</li>
<li>一旦软件需求发生变化，开发人员需要修改软件需求文档，并据此来调整其他的一系列文档，最后再修改程序代码</li>
<li>等较长时间才能得到可运行软件系统</li>
<li><strong>以文档为中心的重型软件开发方法，非常笨重</strong></li>
</ul>
<h3 id="4-%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95%E6%A6%82%E8%BF%B0" tabindex="-1">4 软件开发方法概述</h3>
<ul>
<li>Parnas方法</li>
<li>结构化方法</li>
<li>面向对象方法</li>
<li>给予构件的开发方法</li>
<li>敏捷开发方法</li>
<li>群体化开发方法</li>
</ul>
<h4 id="%EF%BC%881%EF%BC%89parnas%E6%96%B9%E6%B3%95" tabindex="-1">（1）Parnas方法</h4>
<ul>
<li>出发点：可靠性，可维护性</li>
<li>策略
<ul>
<li>信息隐蔽：在设计时仅列出将来可能发生变化的因素，并在模块划分时将这些因素局部化</li>
<li>意外故障处理：软件的非连续性，小错误会引发严重的事故，所以必须加强防范</li>
</ul>
</li>
<li>特点：Parnas对软件开发提出了深刻的见解，但没有明确的流程，不能独立使用</li>
</ul>
<h4 id="%EF%BC%882%EF%BC%89%E7%BB%93%E6%9E%84%E5%8C%96%E6%96%B9%E6%B3%95" tabindex="-1">（2）结构化方法</h4>
<ul>
<li>出发点：清晰的程序结构，可理解性。</li>
<li>求解复杂问题的一般办法：分而治之（模块化）</li>
<li>策略：模块化，自顶向下、逐步求精；SA+SD+SP（系统分析（System Analysis），系统设计（System Design），软件编程（Software Programming））</li>
<li>程序=数据+算法，分为：
<ul>
<li>面向数据流的结构化方法</li>
<li>面向数据结构的结构化方法</li>
</ul>
</li>
<li>特点：
<ul>
<li>数据和行为分开——鸿沟</li>
<li>难开发、难理解、不安全、可维护性低</li>
</ul>
</li>
</ul>
<h4 id="%EF%BC%883%EF%BC%89%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95" tabindex="-1">（3）面向对象的方法</h4>
<ul>
<li>出发点：对问题领域的实体特征直接自然模拟，更易于理解和开发，结构更稳定。
<ul>
<li>程序=对象+消息</li>
</ul>
</li>
<li>策略：
<ul>
<li>通过一组对象的交互来完成系统的功能，对象是领域实体的软件抽象</li>
<li>OOA+OOD+OOP 面向对象分析（Object-Oriented Analysis）、面向对象设计（Object-Oriented Design）和面向对象编程（Object-Oriented Programming）</li>
<li>自顶向下和自底向上相结合</li>
</ul>
</li>
<li>特点：
<ul>
<li>对象把数据和操作封装在一起</li>
<li>更稳定、更安全、提高了可维护性和可重用性</li>
</ul>
</li>
</ul>
<h4 id="%EF%BC%884%EF%BC%89%E5%9F%BA%E4%BA%8E%E6%9E%84%E4%BB%B6%E7%9A%84%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95" tabindex="-1">（4）基于构件的开发方法</h4>
<ul>
<li>出发点：提高软件开发效率和质量的基本途径是复用，用大块编程取代，程序=构件+连接件</li>
<li>策略：
<ul>
<li>有目的地开发可复用的构件（develop for reuse）</li>
<li>管理已有的构件 （management for reuse）</li>
<li>复用已有的构件开发新软件（development by reuse）</li>
</ul>
</li>
<li>特点：
<ul>
<li>降低开发和维护成本</li>
<li>提升开发效率和质量</li>
</ul>
</li>
</ul>
<h4 id="%EF%BC%885%EF%BC%89%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95" tabindex="-1">（5）敏捷开发方法</h4>
<ul>
<li>
<p>定义：一种轻量级软件开发方法（相对于重量级的软件开发方法而言）</p>
</li>
<li>
<p>主张软件开发要以代码为中心，快速、轻巧和主动应对需求变化，持续、及时交付可运行的软件系统</p>
</li>
<li>
<p>敏捷开发方法的基本观点</p>
<ul>
<li>较之于过程和工具，应更加重视人和交互的价值</li>
<li>较之于面面俱到文档，应更加重视可运行软件系统的价值</li>
<li>较之于合同谈判，应更加重视客户合作的价值</li>
<li>较之于遵循计划，应更加重视响应用户需求变化的价值</li>
</ul>
</li>
<li>
<p>敏捷方法体现的思想</p>
<ul>
<li>强化可运行的软件，弱化文档：以可运行软件为中心来开展软件开发</li>
<li>以适应变化为目的来推进开发：针对变化不断进行优化和调整任务、产品和计划等</li>
<li>以人为本：敏捷软件开发是面向人的而不是面向过程的，让方法、技术、工具、过程等来适应人，而不是让人来适应它们</li>
</ul>
</li>
<li>
<p><strong>敏捷开发方法是一大类方法的统称，它们遵循敏捷思想</strong></p>
</li>
<li>
<p>支持敏捷软件开发的技术</p>
<ul>
<li>极限编程</li>
<li>测试驱动开发
<ul>
<li>在开发程序代码之前，先确定和编写测试</li>
<li>程序员首先要思考如何对某个功能进行测试，设计好相应的测试用例，编写好相关的测试代码，然后编写相应的程序代码以通过软件测试</li>
</ul>
</li>
<li>Scrum方法：旨在通过增量或迭代的方式加强软件项目的管理
<ul>
<li>首先，产品拥有者需创建软件产品订单库即“Backblog”
<ul>
<li>描述软件产品需提供的功能需求以及它们的优先级排序</li>
</ul>
</li>
<li>其次，筛选出最应该实现的软件需求，
<ul>
<li>Scrum主人基于“Backblog”中各项软件需求及其优先级，形成待实现的软件产品冲刺订单库，即“SprintLog”</li>
</ul>
</li>
<li>然后，软件开发将进入冲刺“Sprint”周期
<ul>
<li>以实现选定软件订单，每个冲刺就是一次增量开发，一般持续1到4周</li>
</ul>
</li>
<li>最后，共同开展Scrum评审
<ul>
<li>一次冲刺完成后，每个团队成员演示自己的开发成果，大家共同审查成果是否高质量地实现了既定功能，并就其中的问题进行反思，以指导和改进下一次冲刺</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="%EF%BC%886%EF%BC%89%E7%BE%A4%E4%BD%93%E5%8C%96%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95" tabindex="-1">（6）群体化软件开发方法</h4>
<ul>
<li>
<p>依托互联网平台来吸引、汇聚、组织和管理互联网上的大规模软件开发人员，通过竞争、合作、协商等多种自主协同方式，让他们参与软件开发、分享软件开发知识和成果、贡献智慧和力量的一种新颖软件开发方法</p>
</li>
<li>
<p>群体化软件开发是一种基于社区的软件开发模式<br>
<img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/3_4_1.jpg" alt></p>
</li>
<li>
<p>群体化软件开发方法的支撑关键技术</p>
<ul>
<li>基于社区的群体化组织
<ul>
<li>开源软件社区将核心开发人员与外围开发人员有机地结合在一起，依托软件仓库进行分布式协同开发</li>
</ul>
</li>
<li>基于Issue的任务管理
<ul>
<li>开发任务的二类形式：修复软件缺陷、功能实现需求</li>
<li>创建Issue，提出软件开发任务</li>
<li>讨论Issue，分析开发任务的意义和价值</li>
<li>指派Issue，安排人员来完成Issue</li>
<li>掌控Issue，掌握Issue解决的进展状况</li>
</ul>
</li>
<li>基于Git的分布式版本管理</li>
<li>基于Pull/Request的分布式协同开发
<ul>
<li>每个开发人员在本地完成编程工作后，不是直接向中心仓库推送代码，而是通过发送一个P/R合并请求，将原始代码库的克隆库推荐合并到中心仓库之中</li>
<li>接收到合并请求后，软件项目管理团队和开发人员群体需要对P/R进行审查</li>
</ul>
</li>
<li>基于群智的知识分享</li>
</ul>
</li>
</ul>
<h2 id="%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E8%AE%A1%E5%88%92%E7%AE%A1%E7%90%86" tabindex="-1">第四章 软件计划管理</h2>
<h3 id="1-%E8%BD%AF%E4%BB%B6%E8%AE%A1%E5%88%92" tabindex="-1">1 软件计划</h3>
<h4 id="%EF%BC%881%EF%BC%89%E8%BD%AF%E4%BB%B6%E8%AE%A1%E5%88%92%E6%A6%82%E8%BF%B0" tabindex="-1">（1）软件计划概述</h4>
<ul>
<li>软件计划是对软件实施所涉及的目标、任务、活动、资源、进度等进行规划</li>
<li>合同和策划阶段
<ul>
<li>制定初步软件开发计划</li>
<li>软件项目计划分发到各个开发成员</li>
<li>每个成员准确了解各自任务和工作以及实施进度要求</li>
</ul>
</li>
<li>项目实施过程
<ul>
<li>根据软件开发的具体计划有序实施项目</li>
<li>发现项目实施中存在的问题：如进度滞后</li>
<li>出现偏差后调整软件项目计划</li>
</ul>
</li>
<li>项目完成之后
<ul>
<li>总结项目计划实施情况</li>
<li>分析原因，指导后续其他项目的计划制定</li>
</ul>
</li>
</ul>
<h4 id="%EF%BC%882%EF%BC%89%E8%BD%AF%E4%BB%B6%E8%BF%9B%E5%BA%A6%E5%AE%89%E6%8E%92" tabindex="-1">（2）软件进度安排</h4>
<ul>
<li>
<p>两种途径</p>
<ul>
<li>项目、资源 → 制定计划、交付日期</li>
<li>从后往前安排 ← 最后期限</li>
</ul>
</li>
<li>
<p>进度管理中要妥善处理的2个问题</p>
<ul>
<li>识别任务之间的并行、依赖关系</li>
<li>资源的分配和优化</li>
</ul>
</li>
<li>
<p>甘特图</p>
<ul>
<li>优点：简单，醒目，能动态地反映开发进展</li>
<li>缺点：不表示活动之间的依赖关系</li>
</ul>
</li>
<li>
<p>计划网络图</p>
<ul>
<li>反映任务间的顺序、并行依赖关系</li>
</ul>
</li>
<li>
<p>软件进度计划的任务</p>
<ul>
<li>确定每个活动的最早（最迟）开始时间和完成时间。</li>
<li>在开发方已有的资源投入下求解该软件项目的交付日期（工期），或给定工期（投资方要求）条件下来安排各活动的开始时间和结束时间。</li>
<li>确定关键活动、重点监管关键线路。所谓<strong>关键活动</strong>是指由于这些活动完成的耽误或更改，将直接影响项目工期目标完成。全部由关键活动组成的线路或者线路长度最长的线路称为关键线路。</li>
<li>根据给定的工期目标和已有项目各活动时长的条件下，对进度进行调整和优化</li>
</ul>
</li>
</ul>
<h4 id="%EF%BC%883%EF%BC%89%E8%AE%A1%E5%88%92%E7%9A%84%E4%BC%98%E5%8C%96" tabindex="-1">（3）计划的优化</h4>
<ul>
<li>工期优化
<ul>
<li>若网络计划图的计算工期大于要求的工期时，必须根据要求计划的进度，缩短工程项目的完工工期。主要从两个方面考虑：
<ul>
<li>优化活动间的逻辑关系，串行到并行</li>
<li>采取技术措施，提高开发效率，缩短关键工序的持续时间。</li>
<li>采取组织措施，充分利用非关键工序的机动时间，合理调配人力、物力和资金等，增加对关键工序的投入，以便缩短关键工序的持续时间</li>
</ul>
</li>
</ul>
</li>
<li>资源优化
<ul>
<li>在项目工期不变的条件下，合理地利用资源。具体包括：
<ul>
<li>优先安排关键工序所需的资源</li>
<li>利用非关键工序的机动时间，错开各工序的开始时间，避开在同一时区内集中使用同一资源以免出现高峰</li>
<li>在确实受到资源制约，或在考虑综合经济效益的条件下，在许可时也可适当推迟工期，实现错开高峰的目的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86" tabindex="-1">2 软件管理</h3>
<h4 id="%EF%BC%881%EF%BC%89%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86%E7%9A%84%E7%89%B9%E7%82%B9" tabindex="-1">（1）软件管理的特点</h4>
<ul>
<li>目标性: 获得预期的结果</li>
<li>进度性: 在限定期间完成</li>
<li>约束性: 具有有限的资源（如人员、经费、工具等）</li>
<li>多方性: 涉及多个不同人与组织</li>
<li>独立性: 无重复性</li>
<li>不确定性: 项目的实施及其结果不确定性</li>
</ul>
<h4 id="%EF%BC%882%EF%BC%89%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86%E5%86%85%E5%AE%B9" tabindex="-1">（2）软件管理内容</h4>
<p><img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/4_2_2.jpg" alt></p>
<ul>
<li>
<p>何为软件项目管理?</p>
<ul>
<li>对软件项目所涉及的过程、人员、产品、成本和进度等要素进行度量、分析、规划、组织和控制的过程，以确保软件项目按照预定的成本、进度、质量要求顺利完成</li>
<li>人员：团队建设和管理纪律和激励机制</li>
<li>过程：过程定义，软件度量，项目计划，项目跟踪</li>
<li>产品：软件产品质量管理，软件产品配置管理，软件产品需求管理</li>
</ul>
</li>
<li>
<p>过程管理</p>
<ul>
<li>
<ol>
<li>过程定义：定义、文档化软件开发过程、明确软件开发活动，得到一个良定义、全面、灵活、简洁和可供剪裁的软件开发过程</li>
</ol>
</li>
<li>
<ol start="2">
<li>软件度量：对软件项目的过程、产品、资源的属性的定量描述，如软件项目的规模、成本、工作量、质量等</li>
</ol>
</li>
<li>
<ol start="3">
<li>项目计划</li>
</ol>
</li>
<li>
<ol start="4">
<li>项目跟踪：随时掌握软件项目的实际开发情况，提供项目实施情况的可视性，保证计划的适时调整</li>
</ol>
</li>
<li>
<ol start="5">
<li>风险管理：对软件开发过程中各种风险进行识别、分析、预测、评估、监控的过程</li>
</ol>
</li>
</ul>
</li>
<li>
<p>产品管理</p>
<ul>
<li>软件质量保证：为软件产品的质量提供某种可视性，知道哪些地方有质量问题，便于改进方法和措施，提高软件产品的质量</li>
<li>软件配置管理：对软件基线产品进行标识、存储、更动和发放，记录和报告其状态，确保软件产品的正确性和一致性，并对上述工作的审计的过程</li>
<li>软件需求管理：获取、文档化和评审用户需求，对用户需求变更进行控制和管理</li>
</ul>
</li>
<li>
<p>人员管理</p>
<ul>
<li>软件项目团队：确定开发团体的结构、明确人员的角色和任务、加强人员间的交流与合作，结构合理、任务明确、团结协作、交流顺畅</li>
<li>纪律激励机制：制定和实施纪律约束团体，通过激励机制激发人员的激情，严格的纪律，饱满的激情</li>
</ul>
</li>
</ul>
<h4 id="%EF%BC%883%EF%BC%89%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86%E7%9A%84%E6%96%B9%E6%B3%95" tabindex="-1">（3）软件管理的方法</h4>
<ul>
<li>人员组织方式
<ul>
<li>民主制程序员组</li>
<li>主程序员组</li>
<li>现代程序员组：实际的“主程序员”应该由两个人共同担任：  一个技术负责人，负责小组的技术活动；一个行政负责人，负责所有非技术性事务的管理决策。</li>
</ul>
</li>
</ul>
<h2 id="%E7%AC%AC%E4%BA%94%E7%AB%A0-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90" tabindex="-1">第五章 需求分析</h2>
<h3 id="1-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80" tabindex="-1">1 需求分析基础</h3>
<ul>
<li>需求的概念：分类、特点、质量要求、重要性</li>
<li>需求工程
<ul>
<li>需求工程的一般过程</li>
<li>需求工程的常用方法
<ul>
<li>结构化需求分析方法</li>
<li>面向对象需求分析方法</li>
</ul>
</li>
</ul>
</li>
<li>需求工程的输出、评审和管理</li>
</ul>
<h4 id="%EF%BC%881%EF%BC%89%E9%9C%80%E6%B1%82%E7%9A%84%E6%A6%82%E5%BF%B5" tabindex="-1">（1）需求的概念</h4>
<ul>
<li>
<p>软件开发的本质<br>
<img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/5_1_1.jpg" alt></p>
</li>
<li>
<p>何为利益相关方(stakeholder)</p>
<ul>
<li>从软件系统中受益或与软件系统相关的人、组织或者系统</li>
<li>受益：使用、获益、盈利</li>
<li>相关：发生操作和交互、存在关联性</li>
</ul>
</li>
<li>
<p>软件利益相关方的表现形式</p>
<ul>
<li>用户：最终使用软件的人</li>
<li>客户：从中获取利益的组织</li>
<li>系统：与待开发系统进行交互的系统</li>
<li>开发者：负责开发软件系统的人</li>
<li>示例：空巢老人看护软件利益相关方
<ul>
<li>用户：老人，家属，医生</li>
<li>客户：投资方</li>
<li>系统：机器人</li>
</ul>
</li>
</ul>
</li>
<li>
<p>何为软件需求(Software Requirement)?</p>
<ul>
<li>从软件本身的角度，软件需求是指软件用于解决现实世界问题时所表现出的功能和性能等方面的要求</li>
<li>从软件利益相关方的角度，软件需求是指软件系统的利益相关方对软件系统的功能和质量，以及软件运行环境、交付进度等方面提出的期望和要求</li>
</ul>
</li>
<li>
<p>软件需求的类别</p>
<ul>
<li>软件功能性需求(Functional)
<ul>
<li>能够完成的功能及在某些场景下可展现的外部可见行为或效果</li>
</ul>
</li>
<li>软件质量方面的需求(Quality)
<ul>
<li>外部质量属性，外部可展现的，用户、客户等会非常关心，如运行性能、可靠性、易用性等</li>
<li>内部质量属性，隐藏在内部的，软件开发工程师会非常关心，如可扩展性、可维护性、可理解性</li>
</ul>
</li>
<li>软件开发约束性需求(Constraint)
<ul>
<li>开发成本、交付进度、技术选型、遵循标准等方面提出的要求</li>
</ul>
</li>
<li>软件需求示例：空巢老人看护软件
<ul>
<li>功能性需求：自主跟随老人、获取老人图像和视频信息、检测老人是否摔倒等</li>
<li>质量方面的需求：始终保持在2米的安全距离，对机器人的控制在2秒内响应等</li>
<li>约束性需求：成本不能超出50万元，要求半年内交付使用等等</li>
</ul>
</li>
</ul>
</li>
<li>
<p>软件需求的重要性</p>
<ul>
<li>软件的价值所在</li>
<li>软件开发的基础和前提</li>
<li>软件验收的标准和依据</li>
</ul>
</li>
</ul>
<h4 id="%EF%BC%882%EF%BC%89%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B" tabindex="-1">（2）需求工程</h4>
<ul>
<li>
<p>旨在用工程的理念和方法来指导软件需求实践，它提供了一系列的过程、策略、方法学和工具，帮助需求工程师加强对业务或领域问题及其环境的理解、获取和分析软件需求，指导软件需求的文档化和评审，以尽可能获得准确、一致和完整的软件需求，产生软件需求的相关软件制品<br>
<img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/5_1_2.jpg" alt></p>
</li>
<li>
<p>需求工程的方法学</p>
<ul>
<li>抽象
<ul>
<li>20世纪70年代结构化数据和数据流抽象</li>
<li>20世纪90年代面向对象抽象</li>
</ul>
</li>
<li>建模
<ul>
<li>采用自然语言或结构化自然语言</li>
<li>图形化的需求建模语言</li>
</ul>
</li>
<li>分析
<ul>
<li>循序渐进地获得软件需求细节，进而逐步得到详细的软件需求</li>
</ul>
</li>
</ul>
</li>
<li>
<p>需求工程方法（详见复习重点）</p>
<ul>
<li>结构化需求分析方法</li>
<li>面向对象需求分析方法</li>
</ul>
</li>
<li>
<p>需求工程的输出</p>
<ul>
<li>软件需求模型</li>
<li>软件需求文档</li>
<li>软件原型</li>
<li>修正的软件开发计划</li>
<li>验收测试计划</li>
</ul>
</li>
</ul>
<h3 id="2-%E9%9C%80%E6%B1%82%E8%8E%B7%E5%8F%96" tabindex="-1">2 需求获取</h3>
<ul>
<li>
<p>获取软件需求是指得到或产生软件需求</p>
</li>
<li>
<p>明确问题和基于软件的解决方案</p>
</li>
<li>
<p>导出和构思初步软件需求</p>
</li>
<li>
<p>描述初步软件需求</p>
<ul>
<li>自然语言描述</li>
<li>软件原型模式</li>
<li><strong>用例图描述</strong>（详见复习重点）</li>
</ul>
</li>
<li>
<p>用例的进一步详细描述</p>
<ul>
<li>用例名：用户登录</li>
<li>用例标识： UC-UserLogin</li>
<li>主要执行者：家属、医生</li>
<li>目标：通过合法身份登录系统以获得操作权限</li>
<li>范围：空巢老人看护软件</li>
<li>前置条件：使用App软件之时</li>
<li>交互动作：
<ul>
<li>用户输入账号和密码</li>
<li>系统验证用户账号和密码的正确性和合法性</li>
<li>验证正确和合法则意味着登录成功</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-%E5%88%86%E6%9E%90%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82" tabindex="-1">3 分析软件需求</h3>
<h4 id="%EF%BC%881%EF%BC%89%E5%88%86%E6%9E%90%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E6%A6%82%E8%BF%B0" tabindex="-1">（1）分析软件需求概述</h4>
<ul>
<li>
<p>基于初步软件需求，进一步精化和分析软件需求，确定软件需求优先级，建立软件需求模型，发现和解决软件需求缺陷，形成高质量的软件需求模型和软件需求规格说明书</p>
</li>
<li>
<p>用例视角</p>
<ul>
<li>具有哪些功能、功能间有何关系、功能与利益相关方有何关系</li>
<li>UML提供了用例图来分析和描述用例视角的软件需求模型</li>
</ul>
</li>
<li>
<p>行为视角</p>
<ul>
<li>用例是如何通过业务领域中一组对象以及它们间的交互来达成的</li>
<li>UML提供了交互图、状态图来描述行为视角的软件需求模型</li>
</ul>
</li>
<li>
<p>结构视角</p>
<ul>
<li>业务领域有哪些重要的领域概念以及它们之间具有什么样的关系</li>
<li>UML提供了类图来描述和分析业务领域的概念模型</li>
</ul>
</li>
<li>
<p><strong>UML交互图</strong> 详见重点</p>
</li>
<li>
<p><strong>类图</strong> 详见重点</p>
</li>
<li>
<p><strong>对象图</strong></p>
<ul>
<li>类图在系统的运行过程中某个时刻点上或某一时间段内的实例化样本
<ul>
<li>类图中的一个类在对象图中可表现为多个活跃的对象实例</li>
<li>对象图的链接边是类图中关联边的实例化</li>
<li>类图中的其他边，如继承、依赖等在对象图中则无从表现</li>
</ul>
</li>
<li>示例：<img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/%E5%AF%B9%E8%B1%A1%E5%9B%BE%E7%A4%BA%E4%BE%8B.jpg" alt></li>
<li>不常用</li>
</ul>
</li>
<li>
<p><strong>状态图</strong></p>
<ul>
<li>功效
<ul>
<li>描述实体（对象、系统）在事件刺激下的反应式动态行为及其导致的状态变化</li>
<li>刻画了实体的可能状态、每个状态下可响应事件、响应动作、状态迁移</li>
</ul>
</li>
<li>图的构成
<ul>
<li>节点：状态</li>
<li>边：迁移，即状态间因事件刺激而触发的状态变化</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="%EF%BC%882%EF%BC%89%E5%88%86%E6%9E%90%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E8%BF%87%E7%A8%8B" tabindex="-1">（2）分析软件需求过程</h4>
<ol>
<li>分析和确定软件需求优先级
<ul>
<li>分析软件需求重要性</li>
<li>分析软件需求优先级</li>
<li>确定用例分析和实现的次序</li>
</ul>
</li>
<li>分析和确定软件需求模型<br>
<img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/%E5%BB%BA%E7%AB%8B%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E6%A8%A1%E5%9E%8B%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4.jpg" alt><br>
<strong>分析和建立用例的交互模型</strong>见重点
<ul>
<li>分析和建立分析类模型
<ul>
<li>确定分析类</li>
<li>确定分析类的职责</li>
<li>确定分析类的属性</li>
<li>确定分析类之间的关系</li>
<li>绘制分析类图</li>
</ul>
</li>
<li>分析和建立软件需求的状态模型
<ul>
<li>用UML的状态图来描述这些对象的状态模型，以刻画对象拥有哪些状态、对象的状态如何受事件的影响而发生变化</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="%EF%BC%883%EF%BC%89%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E6%96%87%E6%A1%A3%E5%8F%8A%E8%AF%84%E5%AE%A1" tabindex="-1">（3）软件需求文档及评审</h4>
<h2 id="%E7%AC%AC%E5%85%AD%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1" tabindex="-1">第六章 软件设计</h2>
<h3 id="1-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0" tabindex="-1">1 软件设计概述</h3>
<h4 id="%EF%BC%881%EF%BC%89%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80" tabindex="-1">（1）软件设计基础</h4>
<ul>
<li>
<p>软件设计：针对软件需求，综合考虑各种制约因素，探究软件实现的解决方案</p>
</li>
<li>
<p>设计前提：软件需求</p>
<ul>
<li>定义了要做什么样的软件</li>
</ul>
</li>
<li>
<p>设计考虑：制约因素</p>
<ul>
<li>资源：时间、人力、财力、开发辅助工具</li>
<li>技术：技术平台，如DBMS还是文件系统<br>
<img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B.jpg" alt></li>
</ul>
</li>
<li>
<p>软件设计过程</p>
<ul>
<li>软件结构设计
<ul>
<li>从全局和宏观视角、站在最高抽象层次来设计软件系统</li>
</ul>
</li>
<li>用户界面设计
<ul>
<li>设计软件对外展示以及与用户进行交互的界面，关注软件如何与用户进行交互</li>
</ul>
</li>
<li>软件详细设计
<ul>
<li>对体系结构设计和人机交互设计成果进行细化和精化，获得高质量的、充分细化的软件设计模型</li>
<li>数据设计；接口设计；类设计；算法设计；</li>
</ul>
</li>
</ul>
</li>
<li>
<p>软件设计元素</p>
<ul>
<li>设计类：类既是最基本的设计单元，也是最基本的模块单元<br>
软构件</li>
<li>软构件
<ul>
<li>可分离、可单独重用、可独立部署和执行的一类设计元素</li>
<li>如动态链接库（.DLL）、可运行的Java JAR包、微服务镜像等就属于软构件</li>
</ul>
</li>
<li>子系统
<ul>
<li>完成特定功能、逻辑上相互关联的一组模块集合</li>
<li>有助于管理软件系统的复杂度，简化软件设计和实现</li>
</ul>
</li>
</ul>
</li>
<li>
<p>软件设计基本原则</p>
<ul>
<li>抽象原则</li>
<li>模块化、高内聚度和低耦合度原则</li>
<li>信息隐藏原则</li>
<li>关注点分离原则</li>
<li>软件重用原则</li>
</ul>
</li>
</ul>
<h4 id="%EF%BC%882%EF%BC%89%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95" tabindex="-1">（2）软件设计方法</h4>
<ul>
<li>结构化方法
<ul>
<li>
<ol>
<li>复审并精化数据流图</li>
</ol>
</li>
<li>
<ol start="2">
<li>确定输入流和输出流的边界</li>
</ol>
</li>
<li>
<ol start="3">
<li>第一级分解方法</li>
</ol>
</li>
<li>
<ol start="4">
<li>第二级分解方法</li>
</ol>
</li>
<li>
<ol start="5">
<li>软件结构求精</li>
</ol>
</li>
</ul>
</li>
<li>面向对象方法
<ul>
<li><img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B.jpg" alt></li>
<li>用包图表示的软件系统的结构设计</li>
<li>用交互图来表示用户界面设计</li>
</ul>
</li>
</ul>
<h3 id="2-%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1" tabindex="-1">2 软件体系结构设计</h3>
<h4 id="%EF%BC%881%EF%BC%89%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80" tabindex="-1">（1）软件体系结构基础</h4>
<ul>
<li>
<p>软件体系结构设计元素</p>
<ul>
<li>构件/组件(Component)：构成体系结构的基本功能部件
<ul>
<li>软件系统中的物理模块，具有特定的功能和精确定义的对外接口，外界可通过接口来访问它</li>
<li>例：.dll,.jar文件</li>
</ul>
</li>
<li>连接件：组件之间的连接和交互关系
<ul>
<li>每个软构件并非孤立，它们之间通过连接进行交互</li>
<li>交互的目的是为了交换数据、获得服务</li>
<li>例：接口，端口</li>
</ul>
</li>
<li>约束</li>
</ul>
</li>
<li>
<p>软件体系结构设计视图</p>
<ul>
<li>逻辑视图</li>
<li>开发视图</li>
<li>部署视图</li>
<li>运行视图</li>
</ul>
</li>
<li>
<p>软件体系结构建模</p>
<ul>
<li>包图</li>
<li>构件图</li>
<li>部署图<br>
软件体系结构风格<br>
分层风格、管道过滤器风格、黑板风格、MVC风格、SOA风格、消息总线风格</li>
</ul>
</li>
<li>
<p>软件设计模式：以设计重用为目的，采用一种良定义的、正规的、一致的方式记录的软件设计经验</p>
</li>
<li>
<p>常用软件体系结构风格</p>
<ul>
<li>分层风格
<ul>
<li>层次间的关系
<ul>
<li>每层为其紧邻上层提供服务，使用紧邻下层所提供的服务</li>
<li>上层向下层发出服务请求，下层为上层反馈服务结果</li>
<li>下层向上层提供事件信息，上层对下层通知做出处理</li>
</ul>
</li>
<li>特点：松耦合，可替换，可复用，标准化</li>
</ul>
</li>
<li>管道与过滤器风格
<ul>
<li>构件
<ul>
<li>将软件功能实现为一系列处理步骤，每个步骤封装在一个过滤器构件中</li>
</ul>
</li>
<li>连接子
<ul>
<li>相邻过滤器间以管道连接，一个过滤器的输出数据借助管道流向后续过滤器，作为其输入数据</li>
</ul>
</li>
<li>编译器采用的就是一个典型的管道/过滤器风格</li>
</ul>
</li>
<li>黑板风格：将软件系统划分为黑板、知识源和控制器三类构件
<ul>
<li>黑板：负责保存问题求解过程中的状态数据，并提供这些数据的读写服务</li>
<li>知识源：负责根据黑板中存储的问题求解状态评价其自身的可应用性，进行部分问题求解工作，并将此工作的结果数据写入黑板</li>
<li>控制器：负责监视黑板中不断更新的状态数据，安排（多个）知识源的活动</li>
</ul>
</li>
<li>MVC风格
<ul>
<li>模型构件：负责存储业务数据并提供业务逻辑处理功能</li>
<li>视图构件：负责向用户呈现模型中的数据</li>
<li>控制器：在接获模型的业务逻辑处理结果后，负责选择适当的视图作为软件系统对用户的界面动作的响应</li>
<li>步骤：
<ul>
<li>创建视图，视图对象从模型中获取数据并呈现用户界面</li>
<li>控制器将用户界面事件转换为业务逻辑处理功能的调用</li>
<li>模型进行业务逻辑处理，将处理结果回送给控制器，必要时还需将业务数据变化事件通知给所有视图</li>
</ul>
</li>
</ul>
</li>
<li>SOA风格
<ul>
<li>将软件系统的软构件抽象为一个个的服务（Service），每个服务封装了特定的功能并提供了对外可访问的接口</li>
<li>任何一个服务既可以充当服务的提供方，接受其他服务的访问请求；也可充当服务的请求方，请求其他服务为其提供功能</li>
<li>任何服务需要向服务注册中心进行注册登记，描述其可提供的服务以及访问方式，才可对外提供服务</li>
</ul>
</li>
<li>总线风格：包含了一组软构件和一条称为“消息总线”的连接件来连接各个软构件</li>
</ul>
</li>
</ul>
<h4 id="%EF%BC%882%EF%BC%89%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B" tabindex="-1">（2）软件体系结构设计过程</h4>
<ul>
<li>
<p>软件体系结构设计的原则</p>
<ul>
<li>高层抽象和组织</li>
<li>模块化</li>
<li>信息隐藏</li>
<li>软件重用</li>
<li>多视点分离<br>
<img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B.jpg" alt></li>
</ul>
</li>
<li>
<p>设计初步的软件体系结构</p>
<ul>
<li>任务：基于功能性和非功能性软件需求，参考业界已有的软件体系结构设计风格，设计出目标软件系统的初始体系结构，明确每个构件的职责以及构件间的通信和协作关系</li>
<li>输出：初步的软件体系结构<br>
<img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/%E4%B8%8D%E5%90%8C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E9%A3%8E%E6%A0%BC%E9%80%82%E5%90%88%E7%9A%84%E5%BA%94%E7%94%A8.jpg" alt></li>
</ul>
</li>
<li>
<p>重用开源软件及已有软件资产</p>
<ul>
<li>可直接使用的软件资产
<ul>
<li>清晰地定义它们与当前软件系统间的交互接口</li>
<li>包括数据交换的格式、互操作协议等</li>
</ul>
</li>
<li>不可直接使用但具复用潜力的设计资产
<ul>
<li>采用接口重构、适配器等方法将其引入到当前体系结构中</li>
<li>接口重构是指，调整当前体系结构中面向可复用设计资产的调用接口，使之与其提供的服务接口相匹配</li>
</ul>
</li>
</ul>
</li>
<li>
<p>精化软件体系结构</p>
<ul>
<li>选择软件体系结构所依赖的公共基础设施：如操作系统、软件中间件、数据库管理系统、软件开发框架、安全服务等</li>
<li>确定软件体系结构中的设计元素：包括子系统、软构件和关键设计类等，明确其职责和接口，从而为开展详细设计奠定基础</li>
</ul>
</li>
<li>
<p>设计部署模型：刻画软件系统的各个子系统、软构件如何部署到计算节点上运行的，描述它们的部署和运行环境</p>
</li>
</ul>
<h3 id="3-%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1" tabindex="-1">3 用户界面设计</h3>
<h4 id="%EF%BC%881%EF%BC%89%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E5%9F%BA%E7%A1%80" tabindex="-1">（1）用户界面基础</h4>
<ul>
<li>
<p>人机交互的关键</p>
<ul>
<li>用户的满意度</li>
<li>方便输入</li>
<li>直观输出</li>
</ul>
</li>
<li>
<p>用户界面元素及实现方式</p>
<ul>
<li>静态元素</li>
<li>动态元素</li>
<li>用户输入元素</li>
<li>用户命令元素</li>
</ul>
</li>
<li>
<p>用UML类图表示用户界面元素</p>
<ul>
<li>窗口或对话框 -&gt; 对象类</li>
<li>静态和动态元素 -&gt; 类属性</li>
<li>输入元素 -&gt; 类属性</li>
<li>命令元素 -&gt; 类方法</li>
</ul>
</li>
</ul>
<h4 id="%EF%BC%882%EF%BC%89%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B" tabindex="-1">（2）用户界面设计过程</h4>
<ul>
<li>
<p>用户界面设计的任务</p>
<ul>
<li>根据软件需求及其操作流程，为其设计出与用户进行交互的界面，支持用户对软件的操作和使用</li>
</ul>
</li>
<li>
<p>用户界面设计的原则</p>
<ul>
<li>直观性</li>
<li>易操作性</li>
<li>反应性</li>
<li>一致性</li>
<li>容错性</li>
<li>人性化</li>
</ul>
</li>
<li>
<p>用户界面设计的过程<img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B.jpg" alt></p>
</li>
<li>
<p>用户界面初步设计</p>
<ul>
<li>根据需求确定用户界面</li>
<li>确定用户界面的设计元素（属性和操作）</li>
</ul>
</li>
<li>
<p>建立用户界面间的跳转关系</p>
<ul>
<li>用UML图来表示用户界面的跳转关系
<ul>
<li>交互图：表示特定场景下的跳转及跳转发生时的消息传递</li>
<li>类图：表示界面间所有可能发生的跳转及跳转的原因</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-%E8%BD%AF%E4%BB%B6%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1" tabindex="-1">4 软件详细设计</h3>
<h4 id="%EF%BC%881%EF%BC%89%E8%BD%AF%E4%BB%B6%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80" tabindex="-1">（1）软件详细设计基础</h4>
<ul>
<li>详细设计的任务
<ul>
<li>输入：软件体系结构设计、用户界面设计、软件需求</li>
<li>任务：对体系结构设计和用户界面设计成果进行细化和精化，获得高质量、面向实现的设计模型</li>
</ul>
</li>
<li>软件详细设计UML模型（活动图）</li>
</ul>
<h4 id="%EF%BC%882%EF%BC%89%E8%BD%AF%E4%BB%B6%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1%E6%B4%BB%E5%8A%A8" tabindex="-1">（2）软件详细设计活动</h4>
<ul>
<li>用例设计
<ul>
<li>任务：为需求模型中每个用例设计软件实现方案</li>
<li>原则：整体性、正确性、优化性等</li>
<li>输出：用例实现方案的交互图、设计类图</li>
</ul>
</li>
<li>类设计
<ul>
<li>任务
<ul>
<li>对界面类、关键设计类、设计类等进行设计优化和精化，</li>
<li>明确设计类的内部实现细节</li>
<li>精化到可以提交软件实现的程度</li>
</ul>
</li>
<li>结果
<ul>
<li>类图、状态图、活动图等</li>
</ul>
</li>
</ul>
</li>
<li>数据设计
<ul>
<li>任务
<ul>
<li>设计需要持久保存的数据以及这些数据之间的关系</li>
<li>数据组织方式（例如关系数据库中的表、关键字、外键等）之间进行映射</li>
<li>为提高数据存储、操作性能而设计持久存储机制优化设施</li>
</ul>
</li>
<li>设计与建模
<ul>
<li>设计数据的结构、存储、组织和访问</li>
<li>对数据设计的结果进行建模</li>
</ul>
</li>
</ul>
</li>
<li>子系统
<ul>
<li>任务
<ul>
<li>确定子系统内部结构，设置包含于其中的更小粒度子系统、构件和设计类，明确它们之间的协作关系</li>
<li>确保它们能够协同实现子系统接口规定的所有功能和行为</li>
</ul>
</li>
</ul>
</li>
<li>构件设计
<ul>
<li>任务
<ul>
<li>定义构件内部的设计元素及其协作方法</li>
<li>内部设计元素可以是子构件，也可以是粒度更细的类</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%95%B4%E5%90%88%E3%80%81%E9%AA%8C%E8%AF%81%E5%8F%8A%E8%AF%84%E5%AE%A1" tabindex="-1">5 软件设计整合、验证及评审</h3>
<ul>
<li>设计整合
<ul>
<li>汇总迄今获得的所有设计模型
<ul>
<li>包括体系结构模型、界面设计模型、用例设计模型、子系统/构件/类设计模型、数据模型等</li>
</ul>
</li>
<li>形成系统、完整的软件设计方案</li>
</ul>
</li>
<li>设计验证
<ul>
<li>验证整个设计的正确性、优化性和充分性等</li>
<li>验证设计模型之间的不一致性、冗余性等</li>
<li>发现设计方案中的问题并进行整改</li>
</ul>
</li>
</ul>
<h2 id="%E7%AC%AC%E4%B8%83%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0%E5%92%8C%E6%B5%8B%E8%AF%95" tabindex="-1">第七章 软件实现和测试</h2>
<h3 id="1-%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0" tabindex="-1">1 软件实现</h3>
<h4 id="%EF%BC%881%EF%BC%89%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%A6%82%E8%BF%B0" tabindex="-1">（1）软件实现概述</h4>
<ul>
<li>
<p>软件实现的任务</p>
<ul>
<li>根据软件设计模型（包括体系结构设计模型、用户界面设计模型和详细设计模型），采用编程语言编写出目标软件系统的程序代码，并对代码进行必要的测试，以发现和纠正代码存在中的缺陷，并将可运行的目标代码部署到目标计算机上运行<br>
<img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B.jpg" alt></li>
</ul>
</li>
<li>
<p>这三项工作均由程序员负责完成</p>
<ul>
<li>编码：基于软件设计模型和文档，采用选定的程序设计语言，编写出目标软件系统的程序代码</li>
<li>单元测试：对自己编写的各个基本模块进行单元测试，以发现模块单元中存在的缺陷和问题</li>
<li>调试：发现产生缺陷原因，定位缺陷位置，进而对代码缺陷进行修复</li>
</ul>
</li>
<li>
<p>软件测试由软件测试工程师完成</p>
</li>
</ul>
<h4 id="%EF%BC%882%EF%BC%89%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%92%8C%E9%80%89%E6%8B%A9" tabindex="-1">（2）编程语言的类型和选择</h4>
<ul>
<li>选择
<ul>
<li>软件的应用领域
<ul>
<li>不同应用领域的软件通常会选择不同的程序设计语言来加以实现</li>
<li>科学和工程计算领域选用Fortran、C等程序设计语言，数据库应用软件开发会选用Delphi、Visual Basic、SQL等程序设计语言，机器人等嵌入式应用选用C、C++、Python等程序设计语言，互联网应用开发选用Java、ASP等程序设计语言</li>
</ul>
</li>
<li>与遗留软件系统的交互</li>
<li>软件的特殊功能及需求
<ul>
<li>是否需要与底层的硬件系统进行交互，如果需要，可以考虑采用诸如C、汇编语言</li>
<li>是否需要丰富的软件库来支持功能的实现，如果需要，可以考虑具有丰富软件库的编程语言，如Python、Java等</li>
<li>是否需要对相关的知识进行表示和推理，如果需要，可以考虑选用描述性的程序设计语言，如Prolog、Lisp等</li>
</ul>
</li>
<li>软件的目标平台
<ul>
<li>如果目标软件系统需要部署在J2EE架构之上，那么就需要选择Java编程语言；如果需要借助于ROS来开发机器人软件，那么建议选择C、C++和Python等编程语言</li>
</ul>
</li>
<li>程序员的编程经验</li>
</ul>
</li>
</ul>
<h3 id="2-%E7%BC%96%E7%A0%81" tabindex="-1">2 编码</h3>
<h4 id="%EF%BC%881%EF%BC%89%E7%BC%96%E7%A0%81%E6%A6%82%E8%BF%B0" tabindex="-1">（1）编码概述</h4>
<ul>
<li>编码的原则
<ul>
<li>易读，一看就懂</li>
<li>易改，便于维护</li>
<li>降低代码的复杂度</li>
<li>尽可能地开展软件重用和编写可重用的程序代码</li>
<li>要有处理异常和提高代码的容错性</li>
<li>代码要与模型和文档相一致</li>
</ul>
</li>
<li>遵循编码风格</li>
</ul>
<h4 id="%EF%BC%882%EF%BC%89%E7%BC%96%E7%A0%81%E8%BF%87%E7%A8%8B" tabindex="-1">（2）编码过程</h4>
<ul>
<li>编写类代码
<ul>
<li>编写实现类的代码</li>
<li>编写实现类方法的代码</li>
<li>编写实现类间关联的代码</li>
<li>编写实现设计类间聚合和组合关系的代码</li>
<li>编写实现接口关系的代码</li>
<li>编写实现继承关系的程序代码</li>
<li>编写实现包的代码</li>
</ul>
</li>
<li>编写用户界面代码</li>
<li>代码片段的重用</li>
</ul>
<h4 id="%EF%BC%883%EF%BC%89%E7%BC%BA%E9%99%B7" tabindex="-1">（3）缺陷</h4>
<ul>
<li>软件缺陷是指软件制品中存在不正确的软件描述和实现</li>
</ul>
<h3 id="3-%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95" tabindex="-1">3 软件测试</h3>
<h4 id="%EF%BC%881%EF%BC%89%E6%B5%8B%E8%AF%95%E6%A6%82%E8%BF%B0" tabindex="-1">（1）测试概述</h4>
<ul>
<li>软件缺陷不可避免</li>
<li>如何应对缺陷？
<ul>
<li>预防缺陷</li>
<li>容忍缺陷</li>
<li>发现缺陷</li>
<li>修复缺陷</li>
</ul>
</li>
<li>何为软件测试
<ul>
<li>运行软件或模拟软件的执行，发现软件缺陷的过程——缺陷测试</li>
<li>向开发人员和客户展示软件的有效性——确认测试</li>
</ul>
</li>
<li>软件测试的原理
<ul>
<li>程序本质上是对数据的处理
<ul>
<li>设计数据(测试用例) -&gt; 运行测试用例(程序来处理数据) -&gt; 判断运行结果(是否符合预期结果)</li>
</ul>
</li>
</ul>
</li>
<li>测试执行的步骤
<ul>
<li>
<ol>
<li>明确待测试对象</li>
</ol>
</li>
<li>
<ol start="2">
<li>设计测试用例</li>
</ol>
</li>
<li>
<ol start="3">
<li>运行代码和测试用例</li>
</ol>
</li>
<li>
<ol start="4">
<li>分析运行结果</li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="%EF%BC%882%EF%BC%89%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1" tabindex="-1">（2）测试用例设计</h4>
<ul>
<li>
<p>测试用例是一个四元偶</p>
<ul>
<li>输入数据：交由待测试程序代码进行处理的数据</li>
<li>前置条件：程序处理输入数据的运行上下文，即要满足前置条件</li>
<li>测试步骤：程序代码对输入数据的处理可能涉及到一系列的步骤，其中的某些步骤需要用户的进一步输入</li>
<li>预期输出：程序代码的预期输出结果</li>
</ul>
</li>
<li>
<p>白盒测试技术：基于程序内部的执行流程来设计测试用例</p>
<ul>
<li>特点：必须了解程序的内部工作流程才能设计测试用例</li>
<li>基本路径测试
<ul>
<li>
<ol>
<li>根据程序逻辑画出流程图</li>
</ol>
</li>
<li>
<ol start="2">
<li>将流程图转换为流图</li>
</ol>
</li>
<li>
<ol start="3">
<li>确定基本路径集合</li>
</ol>
</li>
<li>
<ol start="4">
<li>针对测试路径设计测试用例</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>黑盒测试技术：基于程序的外在功能和接口来设计测试用例</p>
<ul>
<li>特点：
<ul>
<li>知道程序功能和性能，不必了解程序内部结构和处理细节</li>
<li>黑盒测试与软件如何实现无关，如果软件实现发生变化，测试用例仍然可以使用</li>
<li>黑盒测试用例的开发可以与软件开发并行进行，能够缩短软件开发周期</li>
</ul>
</li>
<li>方法：
<ul>
<li>等价分类法
<ul>
<li>思想
<ul>
<li>把程序的输入数据集合按输入条件划分为若干个等价类</li>
<li>每一个等价类对于输入条件而言是等价的</li>
<li>为每一个等价类设计一个测试用例，包括有效或无效的输入</li>
</ul>
</li>
<li>优点
<ul>
<li>可以滤掉同类数据，减少测试次数，不丢失发现错误的机会</li>
</ul>
</li>
</ul>
</li>
<li>边界值分析法</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="%EF%BC%883%EF%BC%89%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E7%AD%96%E7%95%A5" tabindex="-1">（3）软件测试的过程和策略</h4>
<p><img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%92%8C%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%85%B3%E7%B3%BB.jpg" alt></p>
<ul>
<li>
<p>单元测试</p>
<ul>
<li>测试对象
<ul>
<li>对软件基本模块单元进行测试</li>
<li>过程、函数、方法、类</li>
</ul>
</li>
<li>测试方法：大多采用白盒测试技术</li>
</ul>
</li>
<li>
<p>集成测试</p>
<ul>
<li>测试对象
<ul>
<li>对软件模块之间的接口进行测试</li>
<li>过程调用、函数调用、消息传递、远程过程调用</li>
</ul>
</li>
<li>测试技术：采用黑盒测试技术</li>
</ul>
</li>
<li>
<p>确认测试</p>
<ul>
<li>测试对象
<ul>
<li>对软件的功能和性能进行测试</li>
<li>判断目标软件系统是否满足用户需求</li>
</ul>
</li>
<li>依据和标准
<ul>
<li>软件需求规格说明书</li>
</ul>
</li>
<li>测试技术：采用黑盒测试技术</li>
</ul>
</li>
<li>
<p>α测试</p>
<ul>
<li>软件开发公司组织内部人员模拟各类用户行为对即将面市的软件产品（称为α版本、内部测试版）进行测试，发现错误并修正</li>
<li>尽可能逼真地模拟实际运行环境和用户对软件产品的操作，并尽最大努力涵盖所有可能的用户操作方式</li>
<li>经α测试并进行修改后的软件产品称为β版本（也称外部测试版）</li>
</ul>
</li>
<li>
<p>β测试</p>
<ul>
<li>软件开发公司组织各方面的典型用户在日常工作中实际使用β版本，或为对外进行宣传而将β版本免费赠送给典型用户（很多情况下，β版本可以通过Internet免费下载，也可以向软件公司索取），并要求用户报告异常情况、提出批评意见</li>
<li>β测试是在与开发者无法控制的环境下进行的软件现场应用</li>
</ul>
</li>
</ul>
<h4 id="%EF%BC%884%EF%BC%89%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95" tabindex="-1">（4）面向对象软件测试</h4>
<ul>
<li>OO软件的构成基础与传统结构化程序设计不同</li>
<li>需要开发测试驱动程序</li>
<li>采用白盒测试方法</li>
</ul>
<h4 id="%EF%BC%885%EF%BC%89%E9%9D%9E%E5%8A%9F%E8%83%BD%E6%80%A7%E6%B5%8B%E8%AF%95" tabindex="-1">（5）非功能性测试</h4>
<ul>
<li>性能测试</li>
<li>强度测试</li>
<li>配置和兼容性测试</li>
<li>安全性测试</li>
<li>可靠性测试</li>
<li>用户界面测试</li>
<li>本地化测试</li>
<li>Web测试</li>
<li>安装测试</li>
</ul>
<h3 id="4-%E8%BD%AF%E4%BB%B6%E8%B0%83%E8%AF%95" tabindex="-1">4 软件调试</h3>
<ul>
<li>软件调试就是要基于程序代码，确定软件缺陷的原因、定位缺陷的位置，从而知道那里错了、如何修复缺陷</li>
<li>目的
<ul>
<li>测试发现缺陷</li>
<li>调试定位缺陷</li>
<li>排错纠正错误</li>
</ul>
</li>
<li>独立性不同
<ul>
<li>测试由独立的测试小组进行</li>
<li>调试和排错由开发人员完成<br>
<img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/%E8%B0%83%E8%AF%95%E7%9A%84%E6%AD%A5%E9%AA%A4.jpg" alt></li>
</ul>
</li>
</ul>
<h2 id="%E7%AC%AC%E5%85%AB%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4%E5%92%8C%E6%BC%94%E5%8C%96" tabindex="-1">第八章 软件维护和演化</h2>
<h3 id="1.-%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4%E4%B8%8E%E6%BC%94%E5%8C%96" tabindex="-1">1. 软件维护与演化</h3>
<h4 id="%EF%BC%881%EF%BC%89%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4" tabindex="-1">（1）软件维护</h4>
<ul>
<li>
<p>软件变更和修改是不可避免的</p>
<ul>
<li>待修复的错误</li>
<li>需求的变更/新的需求</li>
<li>技术和商务环境变化</li>
<li>系统的性能或可靠性等需要改进</li>
<li>系统中增加了新的计算机和设备</li>
</ul>
</li>
<li>
<p>软件需要进行维护</p>
<ul>
<li>出故障，不可正常工作</li>
<li>服务变化，需要升级</li>
<li>运行环境变化，需要适应</li>
</ul>
</li>
<li>
<p>软件维护：软件在交付使用后，由于应用需求和环境变化以及自身问题，对软件系统进行改造和调整的过程</p>
</li>
<li>
<p>维护形式：</p>
<ul>
<li>纠正性维护：纠正软件中的缺陷和错误</li>
<li>完善性维护：对软件进行改造以增加新的功能、修改已有的功能</li>
<li>适应性维护：对软件进行改造以便适应新的运行环境和平台</li>
<li>预防性维护：对软件结构进行改造以便提高软件的可靠性和可维护性等</li>
</ul>
</li>
<li>
<p>软件维护工程师</p>
</li>
</ul>
<h4 id="%EF%BC%882%EF%BC%89%E8%BD%AF%E4%BB%B6%E6%BC%94%E5%8C%96" tabindex="-1">（2）软件演化</h4>
<ul>
<li>特点：软件演化与开发是一个集成的、完整的、增量式的过程，可以用螺旋模型表示。主要针对软件的大规模功能增强和结构调整，以实现变化的软件需求，或者提高软件系统的质量。</li>
</ul>
<table>
<thead>
<tr>
<th>概念</th>
<th>功能增强粒度</th>
<th>应对变化方式</th>
<th>持续性或间隔性</th>
<th>版本变化</th>
</tr>
</thead>
<tbody>
<tr>
<td>软件演化</td>
<td>粗粒度</td>
<td>主动</td>
<td>持续性</td>
<td>是</td>
</tr>
<tr>
<td>软件维护</td>
<td>细粒度</td>
<td>被动</td>
<td>间隔性</td>
<td>不一定</td>
</tr>
</tbody>
</table>
<ul>
<li>软件演化法则
<ul>
<li>持续变化法则</li>
<li>增加复杂性法则</li>
<li>自我调节法则</li>
<li>组织稳定性守恒法则</li>
<li>熟悉度守恒法则</li>
<li>功能持续增长法则</li>
<li>质量衰减法则</li>
<li>反馈系统法则</li>
</ul>
</li>
</ul>
<h3 id="2.-%E8%BD%AF%E4%BB%B6%E9%80%BB%E8%BE%91%E8%80%81%E5%8C%96" tabindex="-1">2. 软件逻辑老化</h3>
<h4 id="%EF%BC%881%EF%BC%89%E9%80%BB%E8%BE%91%E8%80%81%E5%8C%96%E7%9A%84%E7%89%B9%E7%82%B9" tabindex="-1">（1）逻辑老化的特点</h4>
<ul>
<li>何为逻辑老化
<ul>
<li>软件在维护和演化的过程中出现的用户满意度降低、质量逐渐下降、变更成本不断上升这样一种现象</li>
</ul>
</li>
<li>软件逻辑老化的现象
<ul>
<li>质量下降</li>
<li>变更成本增加</li>
<li>用户满意度降低</li>
</ul>
</li>
<li>软件逻辑老化的原因
<ul>
<li>缺乏变更</li>
<li>负面变更</li>
</ul>
</li>
</ul>
<h4 id="%EF%BC%882%EF%BC%89%E8%A7%A3%E5%86%B3%E9%80%BB%E8%BE%91%E8%80%81%E5%8C%96%E7%9A%84%E6%96%B9%E6%B3%95" tabindex="-1">（2）解决逻辑老化的方法</h4>
<p>逻辑老化软件的维护和升级将会收到预算、期限等多种因素的约束，因此维护团队需要对逻辑老化软件基于其质量（失效率和可维护性等）及其业务价值（系统的使用情况、支持的业务流程、系统的可靠性、输出的价值）进行评估，再做出适当决策。</p>
<h3 id="3.-%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%8E%E6%8A%80%E6%9C%AF" tabindex="-1">3. 软件维护的过程与技术</h3>
<h4 id="%EF%BC%881%EF%BC%89%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4%E6%8A%80%E6%9C%AF" tabindex="-1">（1）软件维护技术</h4>
<ul>
<li>代码重组：在不改变软件功能的前提下，对程序代码进行重新组织，使得重组后的代码具有更好的可维护性，能够有效支持对代码的变更</li>
<li>逆向工程：基于低抽象层次软件制品，通过对其进行理解和分析，产生高抽象层次的软件制品</li>
<li>设计重构</li>
<li>再工程</li>
</ul>
<h4 id="%EF%BC%882%EF%BC%89%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4%E8%BF%87%E7%A8%8B" tabindex="-1">（2）软件维护过程</h4>
<p><img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4%E8%BF%87%E7%A8%8B.jpg" alt></p>
<ul>
<li>软件维护需要解决的问题
<ul>
<li>人员的问题</li>
<li>软件制品的问题</li>
<li>维护副作用的问题</li>
<li>维护成本不断增加的问题</li>
</ul>
</li>
</ul>
<h2 id="%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9" tabindex="-1">复习重点</h2>
<h3 id="%E7%BB%93%E6%9E%84%E5%8C%96%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95" tabindex="-1">结构化需求分析方法</h3>
<ul>
<li>基本思想：数据主义认为，整个宇宙都是由数据流构成的，各个数据处理系统构成人类的社会</li>
<li>数据流图
<ul>
<li>Data Flow Diagram(简称DFD)：描述输入数据流到输出数据流的变换(即加工)过程，用于对系统的功能建模</li>
<li>基本元素<img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/5_1_2_1_1.jpg" alt></li>
</ul>
</li>
<li>画分层数据流图的步骤
<ul>
<li>
<ol>
<li>画系统的输入和输出</li>
</ol>
</li>
<li>
<ol start="2">
<li>画系统内部</li>
</ol>
</li>
<li>
<ol start="3">
<li>画加工内部</li>
</ol>
</li>
<li>
<ol start="4">
<li>根据自顶向下逐层分解的思想，重复第3步，继续分解加工，直至每个尚未分解的加工都足够简单(即不必再分解)</li>
</ol>
</li>
</ul>
</li>
<li>分层数据流图示例——空巢老人看护系统
<ul>
<li>确定源或宿：老人、家属、医生、机器人和时钟
<ul>
<li>除了时钟外，都既是源又是宿</li>
</ul>
</li>
<li>顶层图唯一的加工：软件系统(空巢老人看护系统)</li>
<li>确定数据流：系统的输入/输出信息
<ul>
<li>输入数据流：老人的呼叫、家属和医生的控制命令、老人的图像和视频、定时器</li>
<li>输出数据流：家属和医生的语音和视频、异常状态和警告信息、机器人执行指令</li>
</ul>
</li>
<li>顶层图通常没有文件<br>
<img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/%E8%BD%AF%E5%B7%A5%E9%A1%B6%E5%B1%82%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE.jpg" alt><br>
<img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/%E8%BD%AF%E5%B7%A5%E6%80%BB%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE.jpg" alt></li>
</ul>
</li>
</ul>
<h3 id="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95" tabindex="-1">面向对象需求分析方法</h3>
<ul>
<li>
<p>基本思想:现实世界（应用问题）还是计算机世界（软件系统），它们都是由多样化的对象所构成的，每个对象都有其状态并可提供功能和服务，不同对象之间通过交互来开展协作来实现功能和提供服务</p>
</li>
<li>
<p>面向对象软件工程提供对象、类、属性、操作、消息、继承等概念来抽象表示现实世界的应用，分析其软件需求特征，建立起软件需求模型，描述软件需求</p>
</li>
<li>
<p>面向对象建模语言</p>
<ul>
<li>概念:基于面向对象的概念和抽象，提供图形化的图符，用来表示软件系统的一种语言</li>
<li>示例：<img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/%E9%A1%BA%E5%BA%8F%E5%9B%BE.jpg" alt></li>
</ul>
</li>
<li>
<p>UML: Unified Modeling Language</p>
<ul>
<li>Unified(统一)
<ul>
<li>提取不同方法中最好建模技术，如OMT(James Rumbaugh)，Booch method(Grady Booch )和OOSE(Ivar Jacobson)</li>
<li>采用统一、标准化的表示方式</li>
</ul>
</li>
<li>Modeling(建模)
<ul>
<li>对现实系统和软件系统进行可视化建模</li>
<li>建立系统模型</li>
</ul>
</li>
<li>Language(语言)
<ul>
<li>图形化语言：语法、语义和语用
<ul>
<li>包括规则，约束 扩展机制</li>
</ul>
</li>
</ul>
</li>
<li>UML用途：用来可视化(visualize) 、描述(specify)、构造(construct)和文档化(document)软件密集型系统的各种产品</li>
</ul>
</li>
<li>
<p>多视点建模</p>
<ul>
<li>结构视点（Structural View）
<ul>
<li>用于描述系统的构成</li>
<li>UML提供了包图（Package Diagram）、类图（Class Diagram）、对象图（Object Diagram）和构件图（Component Diagram），从不同的抽象层次来表示系统的静态组织及结构</li>
</ul>
</li>
<li>行为视点（Behavioral View）
<ul>
<li>刻画系统的行为</li>
<li>UML提供了交互图（Interaction Diagram）、状态图（Statechart Diagram）与活动图（Activity Diagram），以从不同侧面刻画系统的动态行为。</li>
</ul>
</li>
<li>部署视点（Deployment View）
<ul>
<li>刻画目标软件系统的软件制品及其运行环境</li>
<li>UML提供了部署图（Deployment Diagram）来描述软件系统的部署模型</li>
</ul>
</li>
<li>用例视点（Use Case View）
<ul>
<li>刻画系统的功能</li>
<li>UML提供了用例图（Use Case Diagram）以描述系统的用例及其与外部执行者之间的关系。<br>
<img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%BB%BA%E6%A8%A1%E8%AF%95%E7%82%B9%E5%9B%BE.jpg" alt></li>
</ul>
</li>
</ul>
</li>
<li>
<p>面向对象需求分析步骤</p>
<ul>
<li>明确问题边界，获取软件需求，建立用例模型</li>
<li>开展用例分析，精化软件需求，建立分析模型</li>
<li>汇总需求模型，撰写需求文档，评审软件需求</li>
</ul>
</li>
</ul>
<h3 id="%E7%94%A8%E4%BE%8B%E5%9B%BE%E6%8F%8F%E8%BF%B0" tabindex="-1">用例图描述</h3>
<ul>
<li>
<p>用例图用来描述初步软件需求</p>
</li>
<li>
<p>图的构成</p>
<ul>
<li>执行者
<ul>
<li>系统之外的实体，他们使用软件系统功能、与软件系统交换信息</li>
<li>可以是一类用户，也可以是其他软件系统或物理设备</li>
</ul>
</li>
<li>用例
<ul>
<li>表示执行者为达成一项相对独立、完整的业务目标而要求软件系统完成的功能</li>
</ul>
</li>
<li>边：执行者与用例间、用例之间、执行者之间的关系<br>
<img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/%E6%89%A7%E8%A1%8C%E8%80%85%E4%B8%8E%E7%94%A8%E4%BE%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.jpg" alt></li>
</ul>
</li>
<li>
<p>用例间的关系</p>
<ul>
<li>用例间的关系-包含关系
<ul>
<li>如果用例B是用例A的某项子功能，则称用例A包含用例B</li>
</ul>
</li>
<li>用例间的关系-扩展关系
<ul>
<li>如果用例A与B相似，但A的功能较B多，A的动作序列是在B的动作序列中的某些执行点上插入附加动作序列而构成的，则称用例A扩展用例B</li>
</ul>
</li>
<li>用例间的关系-继承
<ul>
<li>如果A与B相似，但A的动作序列是通过改写B的部分动作或者扩展B的动作而获得的，则称用例A继承用例B<br>
<img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/%E7%94%A8%E4%BE%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.jpg" alt></li>
</ul>
</li>
<li>边界框
<ul>
<li>表示整个软件系统或子系统的边界<br>
<img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/%E7%A9%BA%E5%B7%A2%E8%80%81%E4%BA%BA%E7%9C%8B%E6%8A%A4%E8%BD%AF%E4%BB%B6%E7%94%A8%E4%BE%8B%E5%9B%BE.jpg" alt></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="uml%E4%BA%A4%E4%BA%92%E5%9B%BE" tabindex="-1">UML交互图</h3>
<ul>
<li>
<p>作用：刻画对象间的消息传递，分析如何通过交互协作完成功能</p>
<ul>
<li>用例的功能实现方式</li>
<li>软件系统在某种使用场景下对象间的交互协作流程</li>
<li>软件系统的某个复杂操作的逻辑实现模型</li>
</ul>
</li>
<li>
<p>二类交互图</p>
<ul>
<li>顺序图(Sequence Diagram)：强调消息传递的时间序</li>
<li>通信图(Communication Diagram)：突出对象间的合作</li>
<li>顺序图和通信图语义上等价，没必要针对同一建模目标同时创建这二个图</li>
</ul>
</li>
<li>
<p>顺序图：描述对象间的消息交互序列</p>
<ul>
<li>纵向：时间轴，对象及其生命线(虚线)，活跃期(长条矩形)</li>
<li>横向：对象间的消息传递<br>
<img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/%E4%BA%A4%E4%BA%92%E5%9B%BE%E4%B9%8B%E9%A1%BA%E5%BA%8F%E5%9B%BE.jpg" alt></li>
</ul>
</li>
</ul>
<h3 id="%E7%B1%BB%E5%9B%BE" tabindex="-1">类图</h3>
<ul>
<li>功效：描述系统的类构成，刻画系统的静态组成结构</li>
<li>图的构成
<ul>
<li>结点：表示系统中的类（或接口）及其属性和操作</li>
<li>边：类之间的关系</li>
</ul>
</li>
<li>类的表示<img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/%E7%B1%BB%E7%9A%84%E8%A1%A8%E7%A4%BA.jpg" alt></li>
<li>属性的表示：
<ul>
<li>[可见性] 名称 [: 类型] [多重性] [= 初值]  [{约束特性}]</li>
<li>可见性
<ul>
<li>公开(+): 所有对象均可访问</li>
<li>保护(#): 所在类及子类对象均可访问</li>
<li>私有(-): 仅所在类的对象才可访问</li>
</ul>
</li>
<li>多重性：属性取值数量, 如1，0…1，0…* ，1…<em>，</em></li>
<li>约束特性
<ul>
<li changeable>可更改性：{readOnly}表示只读，缺省为</li>
<li unordered>顺序性： {ordered}表示属性取值是有序的，缺省为</li>
<li>唯一性： {bag}表示属性取值元素允许出现重复元素（缺省）</li>
<li>静态性：{static}表示静态属性，属性值由类所有实例对象共享</li>
</ul>
</li>
</ul>
</li>
<li>方法的表示
<ul>
<li>[可见性]  名称[(参数表)] [: 返回类型] [{约束特性}]</li>
<li>操作的约束特性
<ul>
<li>查询操作： {isQuery = true}表示查询操作，{ isQuery = false}表示修改操作，缺省为修改操作。</li>
<li>多态性：{isPolymorphic = true}表示本操作允许多态，即可被子类中相同定义形式的操作所覆盖</li>
<li>并发性：{concurrency = sequential} 任一时刻只有一个对象调用可执行。{concurrency = guarded} 并行线程可同时调用多个对象的本操作，但同一时刻只允许一个调用执行。{concurrency = concurrent} 并行线程可以同时调用多个对象的本操作且这些调用可并发执行</li>
<li>异常：操作在执行过程中可能引发异常</li>
</ul>
</li>
</ul>
</li>
<li>接口
<ul>
<li>一种不包含操作实现部分的特殊类</li>
<li>接口的形式
<ul>
<li>供给接口: 对外提供的接口</li>
<li>需求接口: 需要使用的接口</li>
</ul>
</li>
</ul>
</li>
<li>类间的关系
<ul>
<li>关联</li>
<li>依赖</li>
<li>集成</li>
<li>实现</li>
<li>聚合</li>
<li>组成</li>
</ul>
</li>
<li>类图注意事项
<ul>
<li>用单数名词来描述类名，少用缩写</li>
<li>按照方向表示类间关系
<ul>
<li>垂直方向表示继承关系</li>
<li>水平方向表示关联、聚合、组合、依赖、实现关系</li>
</ul>
</li>
<li>注意画图位置
<ul>
<li>关联名应位于关联边的居中位置</li>
<li>多重性、角色名、约束特性等应靠近关联端</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="%E5%88%86%E6%9E%90%E5%92%8C%E5%BB%BA%E7%AB%8B%E7%94%A8%E4%BE%8B%E7%9A%84%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%9E%8B" tabindex="-1">分析和建立用例的交互模型</h3>
<ul>
<li>
<p>任务:分析和描述用例是如何通过一组对象之间的交互来完成的</p>
</li>
<li>
<p>步骤</p>
<ul>
<li>分析和确定用例所涉及的对象及其类</li>
<li>分析和确定对象之间的消息传递</li>
<li>绘制用例的交互图</li>
</ul>
</li>
<li>
<p>软件需求用例的处理通常涉及三种不同类对象:边界类，控制类，实体类</p>
</li>
<li></li>
<li>
<p>边界类</p>
<ul>
<li>定义：由于这些类对象处于系统的边界，需与系统外的执行者进行交互，因而将这些对象所对应的类称之为边界类</li>
<li>作用
<ul>
<li>交互控制，处理外部执行者的输入数据，或者向外部执行者输出数据</li>
<li>外部接口，如果外部执行者表现为其他的系统或者设备，那么边界类对象需要与系统之外的其他系统或设备进行信息交互</li>
</ul>
</li>
</ul>
</li>
<li>
<p>控制类</p>
<ul>
<li>控制类对象作为完成用例任务的主要协调者</li>
<li>一般而言，控制类并不负责处理具体的任务细节，而是负责分解任务，并通过消息传递将任务分派给其他对象类来完成，协调这些对象之间的信息交互</li>
</ul>
</li>
<li>
<p>实体类</p>
<ul>
<li>用例所对应业务流程中的所有具体功能最终要交由具体的类对象来完成，这些类称之为实体类<br>
<img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/%E7%94%A8%E4%BE%8B%E7%9A%84%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%9E%8B.jpg" alt></li>
</ul>
</li>
<li>
<p>分析和确定对象之间的消息</p>
<ul>
<li>确定消息的名称
<ul>
<li>直接反映了对象间交互的意图，也体现了接收方对象所对应的类需承担的职责和任务</li>
<li>意图：请求、通知</li>
<li>一般地，消息名称用动名词来表示</li>
</ul>
</li>
<li>确定消息传递的信息
<ul>
<li>信息：通知和请求的内容</li>
<li>这些信息通常以消息参数的形式出现，也即一个对象在向另一个对象发送消息的过程中，需要提供必要的参数，以向目标对象提供相应的信息</li>
</ul>
</li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2023/06/03/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/P2PFaaS/" title="P2PFaaS"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: P2PFaaS</span></a><a class="button is-default" href="/2023/04/11/%E6%9C%AC%E7%A7%91/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86_%E8%AF%BE%E7%A8%8B/" title="编译原理"><span class="has-text-weight-semibold">Next: 编译原理</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="Haojen/Claudia-theme-blog" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/Mrcold2002"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Mr_cold 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>
<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>图解HTTP</title><meta name="description" content="菜"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="
本文章为阅读图解HTTP（上野宣）这一书籍的读书笔记
第一章 了解Web及网络基础

Web通过一种名为HTTP（HyperText Transfer Protocol，超文本传输协议）作为规范，完成客户端到服务器端的一系列运行流程

1 TCP/IP


TCP/IP协议族，分为4层

应用层：向用户提供应用服务时通信的活动。

协议：FTP（File Transfer Protocol，文件传输协议）和 DNS（Domain Name System，域名系统），HTTP


传输层：对上层应用层，提供处于网络连接中的两台计算机之间的数据传输

协议：TCP（Transmission Control Protocol，传输控制协议）和 UDP（User Data Protocol，用户数据报协议）


.."><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Mr_cold's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">图解HTTP</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E4%BA%86%E8%A7%A3web%E5%8F%8A%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80"><span class="toc-text">第一章 了解Web及网络基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-tcp/ip"><span class="toc-text">1 TCP&#x2F;IP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%8E-http-%E5%85%B3%E7%B3%BB%E5%AF%86%E5%88%87%E7%9A%84%E5%8D%8F%E8%AE%AE%EF%BC%9Aip%E3%80%81tcp-%E5%92%8C-dns"><span class="toc-text">2 与 HTTP 关系密切的协议：IP、TCP 和 DNS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-uri%E5%92%8Curl"><span class="toc-text">3 URI和URL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-rfc%EF%BC%88request-for-comments%EF%BC%8C%E5%BE%81%E6%B1%82%E4%BF%AE%E6%AD%A3%E6%84%8F%E8%A7%81%E4%B9%A6%EF%BC%89"><span class="toc-text">4 RFC（Request for Comments，征求修正意见书）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%AE%80%E5%8D%95%E7%9A%84http%E5%8D%8F%E8%AE%AE"><span class="toc-text">第二章 简单的HTTP协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-http%E6%8A%A5%E6%96%87%E5%86%85%E7%9A%84http%E4%BF%A1%E6%81%AF"><span class="toc-text">第三章 HTTP报文内的HTTP信息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84"><span class="toc-text">1 报文结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BC%96%E7%A0%81%E6%8F%90%E5%8D%87%E4%BC%A0%E8%BE%93%E6%95%88%E7%8E%87"><span class="toc-text">2 编码提升传输效率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8F%91%E9%80%81%E5%A4%9A%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A4%9A%E9%83%A8%E5%88%86%E5%AF%B9%E8%B1%A1%E9%9B%86%E5%90%88"><span class="toc-text">3 发送多种数据的多部分对象集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%8E%B7%E5%8F%96%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9%E7%9A%84%E8%8C%83%E5%9B%B4%E8%AF%B7%E6%B1%82"><span class="toc-text">4 获取部分内容的范围请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86%E8%BF%94%E5%9B%9E%E6%9C%80%E5%90%88%E9%80%82%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-text">5 内容协商返回最合适的内容</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E7%9A%84http%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-text">第四章 返回结果的HTTP状态码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2xx%E6%88%90%E5%8A%9F"><span class="toc-text">1 2XX成功</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3xx%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-text">2 3XX重定向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4xx%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%94%99%E8%AF%AF"><span class="toc-text">3 4XX客户端错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5xx%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%94%99%E8%AF%AF"><span class="toc-text">4 5XX服务器错误</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%B8%8Ehttp%E5%8D%8F%E4%BD%9C%E7%9A%84web%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">第五章 与HTTP协作的Web服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%94%A8%E5%8D%95%E5%8F%B0%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%E5%9F%9F%E5%90%8D"><span class="toc-text">1 用单台虚拟主机实现多个域名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%80%9A%E4%BF%A1%E6%95%B0%E6%8D%AE%E8%BD%AC%E5%8F%91%E7%A8%8B%E5%BA%8F%EF%BC%9A%E4%BB%A3%E7%90%86%EF%BC%8C%E7%BD%91%E5%85%B3%EF%BC%8C%E9%9A%A7%E9%81%93"><span class="toc-text">2 通信数据转发程序：代理，网关，隧道</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%90%86"><span class="toc-text">代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E5%85%B3"><span class="toc-text">网关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%A7%E9%81%93"><span class="toc-text">隧道</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BF%9D%E5%AD%98%E8%B5%84%E6%BA%90%E7%9A%84%E7%BC%93%E5%AD%98"><span class="toc-text">3 保存资源的缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%9A%84%E6%9C%89%E6%95%88%E6%9C%9F%E9%99%90"><span class="toc-text">缓存的有效期限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E7%BC%93%E5%AD%98"><span class="toc-text">客户端的缓存</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-http%E9%A6%96%E9%83%A8"><span class="toc-text">第六章 HTTP首部</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-http%E6%8A%A5%E6%96%87%E9%A6%96%E9%83%A8"><span class="toc-text">1 HTTP报文首部</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-http%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5"><span class="toc-text">2 HTTP首部字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-http/1.1-%E9%80%9A%E7%94%A8%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5"><span class="toc-text">3 HTTP&#x2F;1.1 通用首部字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%AF%B7%E6%B1%82%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5"><span class="toc-text">4 请求首部字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%93%8D%E5%BA%94%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5"><span class="toc-text">5 响应首部字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%AE%9E%E4%BD%93%E9%A6%96%E9%83%A8%E5%AD%97"><span class="toc-text">6 实体首部字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E4%B8%BAcookie%E6%9C%8D%E5%8A%A1%E7%9A%84%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5"><span class="toc-text">7 为Cookie服务的首部字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%85%B6%E4%BB%96%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5"><span class="toc-text">8 其他首部字段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%A1%AE%E4%BF%9Dweb%E5%AE%89%E5%85%A8%E7%9A%84-https"><span class="toc-text">第七章 确保Web安全的 HTTPS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7.1-http%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-text">7.1 HTTP的缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7.1.1-%E9%80%9A%E4%BF%A1%E4%BD%BF%E7%94%A8%E6%98%8E%E6%96%87%E5%8F%AF%E8%83%BD%E4%BC%9A%E8%A2%AB%E7%AA%83%E5%90%AC"><span class="toc-text">7.1.1 通信使用明文可能会被窃听</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7.1.2-%E4%B8%8D%E9%AA%8C%E8%AF%81%E9%80%9A%E4%BF%A1%E6%96%B9%E7%9A%84%E8%BA%AB%E4%BB%BD%E5%B0%B1%E5%8F%AF%E8%83%BD%E9%81%AD%E5%8F%97%E4%BC%AA%E8%A3%85"><span class="toc-text">7.1.2 不验证通信方的身份就可能遭受伪装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7.1.3-%E6%97%A0%E6%B3%95%E8%AF%81%E6%98%8E%E6%8A%A5%E6%96%87%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%EF%BC%8C%E5%8F%AF%E8%83%BD%E5%B7%B2%E9%81%AD%E7%AF%A1%E6%94%B9"><span class="toc-text">7.1.3 无法证明报文的完整性，可能已遭篡改</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7.2-http+%E5%8A%A0%E5%AF%86+%E8%AE%A4%E8%AF%81+%E5%AE%8C%E6%95%B4%E6%80%A7%E4%BF%9D%E6%8A%A4=https"><span class="toc-text">7.2 HTTP+加密+认证+完整性保护&#x3D;HTTPS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7.2.2-https%E6%98%AF%E8%BA%AB%E6%8A%ABssl%E5%A4%96%E5%A3%B3%E7%9A%84http"><span class="toc-text">7.2.2 HTTPS是身披SSL外壳的HTTP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7.2.3-%E7%9B%B8%E4%BA%92%E4%BA%A4%E4%BA%92%E5%AF%86%E9%92%A5%E7%9A%84%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF"><span class="toc-text">7.2.3 相互交互密钥的公开密钥加密技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7.2.4-%E8%AF%81%E6%98%8E%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E6%AD%A3%E7%A1%AE%E7%9A%84%E8%AF%81%E4%B9%A6"><span class="toc-text">7.2.4 证明公开密钥正确的证书</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7.2.5-https-%E7%9A%84%E5%AE%89%E5%85%A8%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6"><span class="toc-text">7.2.5 HTTPS 的安全通信机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E7%A1%AE%E8%AE%A4%E8%AE%BF%E9%97%AE%E7%94%A8%E6%88%B7%E5%9C%B0%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81"><span class="toc-text">第八章 确认访问用户地身份认证</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/web"><i class="tag post-item-tag">web</i></a><a href="/tags/HTTP"><i class="tag post-item-tag">HTTP</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">图解HTTP</h1><time class="has-text-grey" datetime="2023-06-18T08:09:17.551Z">2023-06-18</time><article class="mt-2 post-content"><p><img src="/images/web/%E5%9B%BE%E8%A7%A3HTTP/x_x.jpg" alt></p>
<p>本文章为阅读图解HTTP（上野宣）这一书籍的读书笔记</p>
<h2 id="%E7%AC%AC%E4%B8%80%E7%AB%A0-%E4%BA%86%E8%A7%A3web%E5%8F%8A%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80" tabindex="-1">第一章 了解Web及网络基础</h2>
<ul>
<li>Web通过一种名为HTTP（HyperText Transfer Protocol，超文本传输协议）作为规范，完成客户端到服务器端的一系列运行流程</li>
</ul>
<h3 id="1-tcp%2Fip" tabindex="-1">1 TCP/IP</h3>
<ul>
<li>
<p>TCP/IP协议族，分为4层</p>
<ul>
<li>应用层：向用户提供应用服务时通信的活动。
<ul>
<li>协议：FTP（File Transfer Protocol，文件传输协议）和 DNS（Domain Name System，域名系统），HTTP</li>
</ul>
</li>
<li>传输层：对上层应用层，提供处于网络连接中的两台计算机之间的数据传输
<ul>
<li>协议：TCP（Transmission Control Protocol，传输控制协议）和 UDP（User Data Protocol，用户数据报协议）</li>
</ul>
</li>
<li>网络层：用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。
<ul>
<li>该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。</li>
</ul>
</li>
<li>链路层（又名数据链路层，网络接口层）：用来处理连接网络的硬件部分。
<ul>
<li>包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在链路层的作用范围之内。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>TCP/IP通信传输流</p>
<ul>
<li><img src="/images/web/%E5%9B%BE%E8%A7%A3HTTP/1_1.jpg" alt></li>
<li>发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。</li>
<li>这种把数据信息包装起来的做法称为封装（encapsulate）</li>
</ul>
</li>
</ul>
<h3 id="2-%E4%B8%8E-http-%E5%85%B3%E7%B3%BB%E5%AF%86%E5%88%87%E7%9A%84%E5%8D%8F%E8%AE%AE%EF%BC%9Aip%E3%80%81tcp-%E5%92%8C-dns" tabindex="-1">2 与 HTTP 关系密切的协议：IP、TCP 和 DNS</h3>
<ul>
<li>
<p>负责传输的IP协议</p>
<ul>
<li>IP（Internet Protocol）网际协议位于网络层。</li>
<li>IP 协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件是 IP 地址和 MAC地址（Media Access Control Address）</li>
<li>IP 地址指明了节点被分配到的地址，MAC 地址是指网卡所属的固定地址。IP 地址可以和 MAC 地址进行配对。IP 地址可变换，但 MAC地址基本上不会更改</li>
<li>使用 ARP 协议凭借 MAC 地址进行通信：ARP 是一种用以解析地址的协议，根据通信方的 IP 地址就可以反查出对应的 MAC 地址。</li>
<li>在到达通信目标前的中转过程中，那些计算机和路由器等网络设备只能获悉很粗略的传输路线。这种机制称为路由选择（routing）</li>
</ul>
</li>
<li>
<p>确保可靠性的TPC协议</p>
<ul>
<li>TCP 位于传输层，提供可靠的字节流服务。
<ul>
<li>字节流服务（Byte Stream Service）是指，为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理。</li>
<li>可靠的传输服务是指，能够把数据准确可靠地传给对方。</li>
<li>为了准确无误地将数据送达目标处，TCP 协议采用了三次握手（three-way handshaking）策略。<img src="/images/web/%E5%9B%BE%E8%A7%A3HTTP/1_2.jpg" alt></li>
</ul>
</li>
</ul>
</li>
<li>
<p>负责域名解析的DNS服务</p>
<ul>
<li>应用层协议，提供域名到 IP 地址之间的解析服务。</li>
</ul>
</li>
<li>
<p>HTTP协议和各个协议的关系：<img src="/images/web/%E5%9B%BE%E8%A7%A3HTTP/1_3.jpg" alt></p>
</li>
</ul>
<h3 id="3-uri%E5%92%8Curl" tabindex="-1">3 URI和URL</h3>
<ul>
<li>
<p>URI（Uniform Resource Identifier，统一资源标识符）</p>
</li>
<li>
<p>URL（Uniform Resource Locator，统一资源定位符）</p>
</li>
<li>
<p>URL 是 URI 的子集</p>
</li>
<li>
<p>URI格式</p>
<ul>
<li>绝对URI格式：<img src="/images/web/%E5%9B%BE%E8%A7%A3HTTP/1_4.jpg" alt></li>
<li>协议方案名：
<ul>
<li>使用 http: 或 https: 等协议方案名获取访问资源时要指定协议类型。不区分字母大小写，最后附一个冒号。</li>
<li>也可使用 data: 或 javascript: 这类指定数据或脚本程序的方案名。</li>
</ul>
</li>
<li>登录信息（认证）：指定用户名和密码作为从服务器端获取资源时必要的登录信息（身份认证）。此项是可选项</li>
<li>服务器地址</li>
<li>服务器端口号</li>
<li>带层次的文件路径</li>
<li>查询字符串</li>
<li>片段标识符</li>
</ul>
</li>
</ul>
<h3 id="4-rfc%EF%BC%88request-for-comments%EF%BC%8C%E5%BE%81%E6%B1%82%E4%BF%AE%E6%AD%A3%E6%84%8F%E8%A7%81%E4%B9%A6%EF%BC%89" tabindex="-1">4 RFC（Request for Comments，征求修正意见书）</h3>
<p>RFC是互联网的设计文档，一般应用程序要遵照RFC确定的标准实现</p>
<h2 id="%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%AE%80%E5%8D%95%E7%9A%84http%E5%8D%8F%E8%AE%AE" tabindex="-1">第二章 简单的HTTP协议</h2>
<ul>
<li>
<p>HTTP 协议用于客户端和服务器端之间的通信</p>
</li>
<li>
<p>通过请求和响应的交换达成通信</p>
<ul>
<li>客户端发送请求报文</li>
<li>服务器返回相应报文</li>
</ul>
</li>
<li>
<p>HTTP是不保存状态的协议，即无状态（stateless）协议。</p>
<ul>
<li>HTTP/1.1 虽然是无状态协议，但为了实现期望的保持状态功能，于是引入了 Cookie 技术。有了 Cookie 再用 HTTP 协议通信，就可以管理状态了。</li>
</ul>
</li>
<li>
<p>请求URI定位资源</p>
<ul>
<li>HTTP 协议使用 URI 定位互联网上的资源。正是因为 URI 的特定功能，在互联网上任意位置的资源都能访问到。</li>
</ul>
</li>
<li>
<p>告知服务器意图的HTTP方法</p>
<ul>
<li>GET：获取资源</li>
<li>POST：传输实体主体</li>
<li>PUT：传输文件</li>
<li>HEAD：获得报文首部。HEAD 方法和 GET 方法一样，只是不返回报文主体部分。用于确认URI 的有效性及资源更新的日期时间</li>
<li>DELETE：删除文件</li>
<li>OPTIONS：询问支持的方法，OPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法。</li>
<li>TRACE：追踪路径，让 Web 服务器端将之前的请求通信环回给客户端的方法。</li>
<li>CONNECT：要求用隧道协议连接代理
<ul>
<li>CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。主要使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输</li>
</ul>
</li>
</ul>
</li>
<li>
<p>持久连接节省通信量</p>
<ul>
<li>持久连接的特点：只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</li>
<li>持久连接的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。</li>
<li>持久连接使得多数请求以流水线化（pipelining）方式发送成为可能。这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了。</li>
</ul>
</li>
<li>
<p>使用Cookie的状态管理</p>
<ul>
<li>Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。
<ul>
<li>Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。</li>
<li>服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="%E7%AC%AC%E4%B8%89%E7%AB%A0-http%E6%8A%A5%E6%96%87%E5%86%85%E7%9A%84http%E4%BF%A1%E6%81%AF" tabindex="-1">第三章 HTTP报文内的HTTP信息</h2>
<ul>
<li>用于 HTTP 协议交互的信息被称为 HTTP 报文。请求端（客户端）的HTTP 报文叫做请求报文，响应端（服务器端）的叫做响应报文。</li>
<li>HTTP 报文大致可分为报文首部和报文主体两块。两者由最初出现的空行（CR+LF）来划分。通常，并不一定要有报文主体。</li>
</ul>
<h3 id="1-%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84" tabindex="-1">1 报文结构</h3>
<p><img src="/images/web/%E5%9B%BE%E8%A7%A3HTTP/3_1.jpg" alt><br>
<img src="/images/web/%E5%9B%BE%E8%A7%A3HTTP/3_2.jpg" alt></p>
<ul>
<li>请求报文和响应报文的<strong>首部</strong>由以下数据组成
<ul>
<li>请求行：包含用于请求的方法，请求URI和HTTP的版本</li>
<li>状态行：包含表明响应结果的状态码，原因短语和HTTP版本</li>
<li>首部字段：包含表示请求和响应的各种条件和属性的各类首部
<ul>
<li>一般有4种首部：通用首部，请求首部，响应首部，实体首部</li>
</ul>
</li>
<li>其它：可能包含HTTP的RFC里未定义的首部（Cookie等）</li>
</ul>
</li>
</ul>
<h3 id="2-%E7%BC%96%E7%A0%81%E6%8F%90%E5%8D%87%E4%BC%A0%E8%BE%93%E6%95%88%E7%8E%87" tabindex="-1">2 编码提升传输效率</h3>
<ul>
<li>
<p>HTTP在传输数据时可以按照数据原貌进行直接传输，也可以通过在传输过程中编码提升传输效率</p>
</li>
<li>
<p>在传输时编码，可以处理大量访问请求，但编码解码需要CPU来完成，消耗更多CPU资源</p>
</li>
<li>
<p>报文：是HTTP通信种的基本单位，由8位组字节流则称，通过HTTP通信传输</p>
</li>
<li>
<p>实体：作为请求或响应的有效载荷数据被传输，其内容由实体首部和实体主体组成</p>
</li>
<li>
<p>HTTP报文的主体用于传输请求或响应主体，通常报文主体等于实体主体，但实体主体可能会进行编码操作</p>
<ul>
<li>常用内容编码：
<ul>
<li>gzip（GNU zip）</li>
<li>compress（UNIX 系统的标准压缩）</li>
<li>deflate（zlib）</li>
<li>identity（不进行编码）</li>
</ul>
</li>
</ul>
</li>
<li>
<p>分块传输编码：将实体主体分块传送</p>
</li>
</ul>
<h3 id="3-%E5%8F%91%E9%80%81%E5%A4%9A%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A4%9A%E9%83%A8%E5%88%86%E5%AF%B9%E8%B1%A1%E9%9B%86%E5%90%88" tabindex="-1">3 发送多种数据的多部分对象集合</h3>
<ul>
<li>发送邮件时，可以在邮件中写入文字并添加多份附件，这是因为采用了MIME（Multipurpose Internet Mail Extensions，多用途因特网邮件扩展）机制，其允许邮件处理文本，图片，视频等多个不同类型的数据</li>
<li>HTTP中也采纳了多部份对象集合，发送一份报文主体内可包含多类型实体
<ul>
<li>HTTP 报文中使用多部分对象集合时，需要在首部字段里加上Content-type。</li>
</ul>
</li>
</ul>
<h3 id="4-%E8%8E%B7%E5%8F%96%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9%E7%9A%84%E8%8C%83%E5%9B%B4%E8%AF%B7%E6%B1%82" tabindex="-1">4 获取部分内容的范围请求</h3>
<p>执行范围请求时，会使用首部字段Range来指定资源的byte范围</p>
<ul>
<li>
<p>5001-10000字节：Range: bytes=5001-10000</p>
</li>
<li>
<p>从5001字节之后：Range: bytes=5001-</p>
</li>
<li>
<p>从一开始到 3000 字节和 5000~7000 字节的多重范围：Range: bytes=-3000, 5000-7000</p>
</li>
<li>
<p>针对范围请求，响应会返回状态码为 206 Partial Content 的响应报文。另外，对于多重范围的范围请求，响应会在首部字段 Content-Type标明 multipart/byteranges 后返回响应报文。</p>
</li>
<li>
<p>如果服务器端无法响应范围请求，则会返回状态码 200 OK 和完整的实体内容。</p>
</li>
</ul>
<h3 id="5-%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86%E8%BF%94%E5%9B%9E%E6%9C%80%E5%90%88%E9%80%82%E7%9A%84%E5%86%85%E5%AE%B9" tabindex="-1">5 内容协商返回最合适的内容</h3>
<ul>
<li>内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。包含在请求报文中的某些首部字段（如下）就是判断的基准。
<ul>
<li>Accept</li>
<li>Accept-Charset</li>
<li>Accept-Encoding</li>
<li>Accept-Language</li>
<li>Content-Language</li>
</ul>
</li>
<li>内容协商技术有以下 3 种类型
<ul>
<li>服务器驱动协商（Server-driven Negotiation）
<ul>
<li>由服务器端进行内容协商。以请求的首部字段为参考，在服务器端自动处理。</li>
</ul>
</li>
<li>客户端驱动协商（Agent-driven Negotiation）
<ul>
<li>由客户端进行内容协商的方式。用户从浏览器显示的可选项列表中手动选择。还可以利用 JavaScript 脚本在 Web 页面上自动进行上述选择。比如按 OS 的类型或浏览器类型，自行切换成 PC 版页面或手机版页面。</li>
</ul>
</li>
<li>透明协商（Transparent Negotiation）
<ul>
<li>是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进行内容协商的一种方法。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E7%9A%84http%E7%8A%B6%E6%80%81%E7%A0%81" tabindex="-1">第四章 返回结果的HTTP状态码</h2>
<p>HTTP状态码负责表示客户端 HTTP请求的返回结果、标记服务器端的处理是否正常、通知出现的错误等工作。</p>
<table>
<thead>
<tr>
<th></th>
<th>类别</th>
<th>原因短语</th>
</tr>
</thead>
<tbody>
<tr>
<td>1XX</td>
<td>Informational(信息性状态码)</td>
<td>接受的请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td>Success（成功状态码）</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td>Redirection（重定向状态码）</td>
<td>需要进行附加操作以完成请求</td>
</tr>
<tr>
<td>4XX</td>
<td>Client Error（客户端错误状态码）</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td>Server Error（服务器错误状态码）</td>
<td>服务器处理请求错误</td>
</tr>
</tbody>
</table>
<h3 id="1-2xx%E6%88%90%E5%8A%9F" tabindex="-1">1 2XX成功</h3>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>200 OK</td>
<td>表示从客户端发来的请求在服务器端被正常处理了</td>
</tr>
<tr>
<td>204 No Content</td>
<td>该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分，即服务器没有资源可以返回。</td>
</tr>
<tr>
<td>206 Partial content</td>
<td>该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。</td>
</tr>
</tbody>
</table>
<h3 id="2-3xx%E9%87%8D%E5%AE%9A%E5%90%91" tabindex="-1">2 3XX重定向</h3>
<p>3XX响应结果表明浏览器需要执行某些特殊的处理以正确地处理请求</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>301 Moved Permanently</td>
<td>永久性重定向。该状态码表示请求的资源已被分配了新的URI，以后应该使用资源现在所指向的URI</td>
</tr>
<tr>
<td>302 Found</td>
<td>临时重定向。该状态码表示请求的资源已经被分配了新的URI，希望用户使用新的URI访问</td>
</tr>
<tr>
<td>303 See Other</td>
<td>该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET方法定向获取请求的资源。<br>303 状态码和 302 Found 状态码有着相同的功能，但 303 状态码明确表示客户端应当采用 GET 方法获取资源，这点与 302 状态码有区别。</td>
</tr>
<tr>
<td>304 Not Modified</td>
<td>该状态码表示客户端发送附带条件的请求 A 时，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关系。</td>
</tr>
<tr>
<td>307 Temporary Redirect</td>
<td>临时重定向。该状态码与 302 Found 有着相同的含义。尽管 302 标准禁止 POST 变换成 GET，但实际使用时大家并不遵守。307 会遵照浏览器标准，不会从 POST 变成 GET。但是，对于处理响应时的行为，每种浏览器有可能出现不同的情况</td>
</tr>
</tbody>
</table>
<h3 id="3-4xx%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%94%99%E8%AF%AF" tabindex="-1">3 4XX客户端错误</h3>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>400 Bad Request</td>
<td>该状态码表示请求报文中存在语法错误，当错误发生时，需修改请求的内容后再次发送请求</td>
</tr>
<tr>
<td>401 unauthorized</td>
<td>该状态码表示发送的请求需要有通过HTTP认证（BASIC认证，DIGEST认证）的认证信息。若之前已进行过一次请求，则表示用户认证失败<br>返回含有401的响应必须包含一个使用户被请求资源的WWW-Authenticate首部以质询（challenge）用户信息。当浏览器初次接收到401响应时，会弹出认证用的对话窗口</td>
</tr>
<tr>
<td>403 Forbidden</td>
<td>该状态码表示对请求资源的访问被服务器拒接了。服务器端没有必要给出拒绝的详细理由，但可以在实体的主体部分对原因进行描述。<br>未获得文件系统的访问权限，访问权限出现问题等情况都有可能发生403</td>
</tr>
<tr>
<td>404 Not Found</td>
<td>该状态码表示服务器上无法找到请求的资源，除此之外，也可以在服务器端拒绝请求且不想说明理由时使用</td>
</tr>
</tbody>
</table>
<h3 id="4-5xx%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%94%99%E8%AF%AF" tabindex="-1">4 5XX服务器错误</h3>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>500 Internal Server Error</td>
<td>改状态码表示服务器端在执行请求时发生了错误，可能是Web应用存在的bug或某些临时的故障</td>
</tr>
<tr>
<td>503 Service Unavailable</td>
<td>该状态码表示服务器暂时处于超负载或真正进行停机维护，现在无法处理请求。如果实现得知解决上述状况需要的时间，最好写入Retry-After首部字段再返回给客户端</td>
</tr>
</tbody>
</table>
<h2 id="%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%B8%8Ehttp%E5%8D%8F%E4%BD%9C%E7%9A%84web%E6%9C%8D%E5%8A%A1%E5%99%A8" tabindex="-1">第五章 与HTTP协作的Web服务器</h2>
<p>一台Web服务器可搭建多个独立域名的Web网站，也可作为通信路径上的中转服务器提升传输效率。</p>
<h3 id="1-%E7%94%A8%E5%8D%95%E5%8F%B0%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%E5%9F%9F%E5%90%8D" tabindex="-1">1 用单台虚拟主机实现多个域名</h3>
<ul>
<li>HTTP/1.1规范允许一台HTTP服务器搭建多个Web站点，比如提供Web托管服务的供应商，这里使用了虚拟主机(Virtual Host,又称虚拟服务器)功能</li>
<li>在相同的IP地址下，由于虚拟主机可以寄存多个不同的主机名和域名的Web网站，因此在HTTP请求中，必须在Host首部内完整指定主机名或域名的URI</li>
</ul>
<h3 id="2-%E9%80%9A%E4%BF%A1%E6%95%B0%E6%8D%AE%E8%BD%AC%E5%8F%91%E7%A8%8B%E5%BA%8F%EF%BC%9A%E4%BB%A3%E7%90%86%EF%BC%8C%E7%BD%91%E5%85%B3%EF%BC%8C%E9%9A%A7%E9%81%93" tabindex="-1">2 通信数据转发程序：代理，网关，隧道</h3>
<p>HTTP通信时，除客户端和服务器外，还有一些用于通信数据转发的应用程序，如代理，网关和隧道，其可以配合服务器工作</p>
<ul>
<li>代理：是一种具有转发功能的应用程序，扮演了服务器和客户端的“中间人”角色，接受客户端发送的请求并转发给服务器，同时也接收服务器返回的响应转发给客户端</li>
<li>网关：网关是转发其他服务器通信数据的服务器，接收从客户端发来的请求时，它将像自己拥有资源的源服务器一样对请求进行处理，有时客户端可能不会察觉自己的通信目标是一个网关</li>
<li>隧道：是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序</li>
</ul>
<h4 id="%E4%BB%A3%E7%90%86" tabindex="-1">代理</h4>
<p><img src="/images/web/%E5%9B%BE%E8%A7%A3HTTP/5_1.jpg" alt></p>
<ul>
<li>
<p>代理服务器的基本行为就是接受客户端发送的请求后转发给其它服务器，代理不改变请求URI，会直接发送给前方持有资源的目标服务器</p>
</li>
<li>
<p>持有资源实体的服务器称为源服务器，从源服务器返回的响应经过代理服务器后再传给客户端</p>
</li>
<li>
<p>在HTTP通信过程中，可以级联多台代理服务器，转发时，需要附加Via首部字段以标记出经过的主机信息</p>
</li>
<li>
<p>使用代理服务器的理由</p>
<ul>
<li>
<ol>
<li>利用缓存技术减少网络带宽的流量</li>
</ol>
</li>
<li>
<ol start="2">
<li>组织内部针对特定网络的访问控制</li>
</ol>
</li>
<li>
<ol start="3">
<li>以后去访问日志为主要目的等</li>
</ol>
</li>
</ul>
</li>
<li>
<p>代理方法基准分类：</p>
<ul>
<li>
<ol>
<li>是否使用缓存：缓存代理</li>
</ol>
<ul>
<li>代理转发响应时，缓存代理(Caching Proxy)会预先将资源的副本(缓存)保存在代理服务器上</li>
<li>当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将缓存的资源返回</li>
</ul>
</li>
<li>
<ol start="2">
<li>是否会修改报文：透明代理</li>
</ol>
<ul>
<li>转发请求或响应时，不对报文做任何加工的代理类型称为透明代理(Transparent Proxy)，反之称为非透明代理</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="%E7%BD%91%E5%85%B3" tabindex="-1">网关</h4>
<p><img src="/images/web/%E5%9B%BE%E8%A7%A3HTTP/5_2.jpg" alt></p>
<ul>
<li>网关的工作机制与代理相似，并且网关能使通信线路上的服务器提供非HTTP协议服务</li>
<li>利用网关可以提高通信的安全性，可以在客户端和网关之间的通信线路上加密以确保连接的安全。
<ul>
<li>例如：网关可以连接数据库，使用SQL语句查询数据</li>
</ul>
</li>
</ul>
<h4 id="%E9%9A%A7%E9%81%93" tabindex="-1">隧道</h4>
<ul>
<li>隧道可以按要求建立一条与其它服务器的通信线路，届时使用SSL等加密手段进行通信。</li>
<li>隧道的目的：确保客户端和服务器能进行安全的通信</li>
<li>隧道本身不会解析HTTP请求，隧道会在通信双方断开连接时结束</li>
</ul>
<h3 id="3-%E4%BF%9D%E5%AD%98%E8%B5%84%E6%BA%90%E7%9A%84%E7%BC%93%E5%AD%98" tabindex="-1">3 保存资源的缓存</h3>
<ul>
<li>缓存是指代理服务器或客户端本地磁盘内保存的资源副本。利用缓存可减少对源服务器的访问，节省了通信流量和通信时间</li>
<li>缓存服务器是代理服务器的一种，属于缓存代理类型</li>
</ul>
<h4 id="%E7%BC%93%E5%AD%98%E7%9A%84%E6%9C%89%E6%95%88%E6%9C%9F%E9%99%90" tabindex="-1">缓存的有效期限</h4>
<ul>
<li>当源服务器上的资源更新时，如果还是使用不变的缓存，只会返回旧资源</li>
<li>因此，即使存在缓存，也会因为客户端的要求，缓存的有效期等因素，向源服务器确认资源的有效性，如判断缓存失效，则重新获取</li>
</ul>
<h4 id="%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E7%BC%93%E5%AD%98" tabindex="-1">客户端的缓存</h4>
<ul>
<li>缓存不仅可以在缓存服务器中，也可以在客户端浏览器中</li>
<li>浏览器缓存如果有效，则不必再向服务器请求相同的资源，可以从本地磁盘直接读取</li>
</ul>
<h2 id="%E7%AC%AC%E5%85%AD%E7%AB%A0-http%E9%A6%96%E9%83%A8" tabindex="-1">第六章 HTTP首部</h2>
<h3 id="1-http%E6%8A%A5%E6%96%87%E9%A6%96%E9%83%A8" tabindex="-1">1 HTTP报文首部</h3>
<ul>
<li>首部内容为客户端和服务器分别处理请求和相应所提供的信息</li>
<li>在请求中，HTTP报文由方法，URI，HTTP版本，HTTP首部字段等部分构成<img src="/images/web/%E5%9B%BE%E8%A7%A3HTTP/6_1.jpg" alt></li>
<li>在响应中，HTTP报文由HTTP版本，状态码(数字和原因短语)，HTTP首部字段3部分组成<img src="/images/web/%E5%9B%BE%E8%A7%A3HTTP/6_2.jpg" alt></li>
</ul>
<h3 id="2-http%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5" tabindex="-1">2 HTTP首部字段</h3>
<ul>
<li>
<p>HTTP首部字段传递重要信息：给浏览器和服务器提供报文主体大小，所使用的语言，主体信息等内容</p>
</li>
<li>
<p>HTTP首部字段结构：由首部字段名和字段值构成，中间用冒号分隔</p>
<ul>
<li>例如：
<ul>
<li>Content-Type:text/html 该字段表示报文的主体对象类型</li>
<li>Keep-Alive : timeout=15,max=100 字段值可以有多个</li>
</ul>
</li>
</ul>
</li>
<li>
<p>4种HTTP首部字段类型</p>
<ul>
<li>通用首部字段 General Header Fields：请求报文和响应报文都会使用的首部</li>
<li>请求首部字段 Request Header Fields：从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容，客户端信息，相应内容相关优先级等信息</li>
<li>响应首部字段 Response Header Fields：从服务器端想客户端返回响应报文时使用的首部，补充了相应的附加内容，也会要求客户端附加额外的内容信息</li>
<li>实体首部字段 Entity Header Fields：针对请求报文和响应报文的实体部分使用的首部。补充了资源内容·更新时间等与实体有关的信息。</li>
</ul>
</li>
<li>
<p>HTTP/1.1首部字段一览，HTTP/1.1共定义了47种首部字段<br>
<img src="/images/web/%E5%9B%BE%E8%A7%A3HTTP/6_3.jpg" alt><br>
<img src="/images/web/%E5%9B%BE%E8%A7%A3HTTP/6_4.jpg" alt><br>
<img src="/images/web/%E5%9B%BE%E8%A7%A3HTTP/6_5.jpg" alt></p>
</li>
<li>
<p>在HTTP协议种使用的首部字段，不限于RFC2616中的47种，还有Cookie，Set-Cookie等使用频率很高的字段，这些非正式字段统一归纳在 RFC4229 HTTP Header Field Registrations 中</p>
</li>
</ul>
<h3 id="3-http%2F1.1-%E9%80%9A%E7%94%A8%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5" tabindex="-1">3 HTTP/1.1 通用首部字段</h3>
<ul>
<li>
<p>Cache-Control：操作缓存的机制</p>
<ul>
<li>指令的参数是可选的，多个指令之间用&quot;,&quot;隔开，具体指令查阅资料</li>
<li>响应时控制缓存的指令
<ul>
<li><code>Cache-Control:public</code> 表示所有用户都可以利用缓存</li>
<li><code>Cache-Control:private</code> 表示指定用户都可以利用缓存</li>
<li><code>Cache-Control:no-cache</code> 缓存服务器不能对资源进行缓存</li>
<li><code>Cache-Control:no-cache=Location</code> 客户端不能对资源进行缓存</li>
</ul>
</li>
<li>请求时控制缓存的指令
<ul>
<li><code>Cache-Control:no-cache</code> 表示请求时不要缓存过的，这样做可以防止过期资源</li>
<li><code>Cache-Control:max-age=604800(秒)</code>当缓存时间比设定时间小则接收缓存资源，当max-age=0时缓存服务器需要将请求转发给源服务器</li>
<li><code>min-fresh=60(单位：秒)</code>:要求缓存服务器返回至少还未过指定时间的缓存资源</li>
<li><code>max-stale</code>可指示缓存资源，即使过期也照常接收只要仍处于 max-stale 指定的时间内，仍旧会被客户端接收。</li>
<li><code>only-if-cached</code>表示客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回,如缓存服务器本地无缓存，返回504</li>
<li><code>must-revalidate</code>代理会向源服务器再次验证即将返回的响应缓存目前是否仍然有效</li>
</ul>
</li>
<li>共同意思
<ul>
<li><code>Cache-Control:no-store</code> 表示有机密消息，请求和响应都不能缓存</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Connection:该字段具有两个作用</p>
<ul>
<li>控制不再转发给代理的首部字段<code>Connection: 不再转发的首部字段名</code></li>
<li>管理持久连接<code>Connection: close</code> or <code>Connection: Keep-Alive</code></li>
</ul>
</li>
<li>
<p>Date</p>
<ul>
<li>首部字段Data表明创建HTTP报文的日期和时间</li>
<li>HTTP/1.1使用在RFC1123种规定的日期时间的格式，如下示例</li>
<li><code>Date: Tue, 03 Jul 2012 04:40:59 GMT</code></li>
</ul>
</li>
<li>
<p>Pragma</p>
<ul>
<li>Pragma 是 HTTP/1.1 之前版本的历史遗留字段，仅作为与 HTTP/1.0的向后兼容而定义。</li>
<li>规范定义的形式唯一<code>Pragma: no-cache</code>,与cache字段共用即可</li>
</ul>
</li>
<li>
<p>Trailer</p>
<ul>
<li>首部字段 Trailer 会事先说明在报文主体后记录了哪些首部字段。</li>
</ul>
</li>
<li>
<p>Transfer-Encoding:规定了传输报文主体时采用的编码方式</p>
<ul>
<li>HTTP/1.1 的传输编码方式仅对分块传输编码有效。</li>
</ul>
</li>
<li>
<p>Upgrade:用于检测 HTTP 协议及其他协议是否可使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议。</p>
</li>
<li>
<p>Via:追踪客户端与服务器之间的请求和响应报文的传输路径。</p>
</li>
<li>
<p>Warning:该首部通常会告知用户一些与缓存相关的问题的警告。</p>
<ul>
<li>格式:<code>Warning: [警告码][警告的主机:端口号]“[警告内容]”([日期时间])</code></li>
</ul>
</li>
</ul>
<h3 id="4-%E8%AF%B7%E6%B1%82%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5" tabindex="-1">4 请求首部字段</h3>
<ul>
<li>
<p>Accept：Accept 首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。 可使用 type/subtype 这种形式，一次指定多种媒体类型</p>
<ul>
<li><code>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</code></li>
</ul>
</li>
<li>
<p>Accept-Charset:通知服务器用户代理支持的字符集及字符集的相对优先顺序。</p>
<ul>
<li><code>Accept-Charset: iso-8859-5, unicode-1-1;q=0.8</code></li>
</ul>
</li>
<li>
<p>Accept-Encoding:用来告知服务器用户代理支持的内容编码及内容编码的优先级顺序。</p>
<ul>
<li><code>Accept-Encoding: gzip, deflate</code></li>
</ul>
</li>
<li>
<p>Accept-Language:告知服务器用户代理能够处理的自然语言集（指中文或英文等），以及自然语言集的相对优先级。可一次指定多种自然语言集。</p>
<ul>
<li><code>Accept-Language: zh-cn,zh;q=0.7,en-us,en;q=0.3</code></li>
</ul>
</li>
<li>
<p>Authorization:告知服务器，用户代理的认证信息（证书值）。</p>
</li>
<li>
<p>Expect:告知服务器，期望出现的某种特定行为</p>
</li>
<li>
<p>From:告知服务器使用用户代理的用户的电子邮件地址。</p>
</li>
<li>
<p>Host:告知服务器，请求的资源所处的互联网主机名和端口号。</p>
</li>
<li>
<p>If-xxx 这种样式的请求首部字段，都可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求</p>
</li>
</ul>
<h3 id="5-%E5%93%8D%E5%BA%94%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5" tabindex="-1">5 响应首部字段</h3>
<ul>
<li>
<p>Accept-Ranges 是用来告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资源。可指定的字段值有两种，可处理范围请求时指定其为 bytes，反之则指定其为 none</p>
</li>
<li>
<p>首部字段 Age 能告知客户端，源服务器在多久前创建了响应。字段值的单位为秒。</p>
</li>
<li>
<p>首部字段 ETag 能告知客户端实体标识。它是一种可将资源以字符串形式做唯一性标识的方式。服务器会为每份资源分配对应的 ETag 值。</p>
<ul>
<li>强 ETag 值，不论实体发生多么细微的变化都会改变其值。</li>
<li>弱 ETag 值只用于提示资源是否相同。</li>
</ul>
</li>
<li>
<p>使用首部字段 Location 可以将响应接收方引导至某个与请求 URI位置不同的资源。基本上，该字段会配合 3xx ：Redirection 的响应，提供重定向的URI。</p>
</li>
<li>
<p>首部字段 Retry-After 告知客户端应该在多久之后再次发送请求。主要配合状态码 503 Service Unavailable 响应，或 3xx Redirect 响应一起使用</p>
</li>
<li>
<p>首部字段 Server 告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息。不单单会标出服务器上的软件应用名称，还有可能包括版本号和安装时启用的可选项。<code>Server: Apache/2.2.6 (Unix) PHP/5.2.5</code></p>
</li>
<li>
<p>首部字段 WWW-Authenticate 用于 HTTP 访问认证。它会告知客户端适用于访问请求 URI 所指定资源的认证方案（Basic 或是 Digest）和带参数提示的质询（challenge）。状态码 401 Unauthorized 响应中，肯定带有首部字段 WWW-Authenticate</p>
</li>
</ul>
<h3 id="6-%E5%AE%9E%E4%BD%93%E9%A6%96%E9%83%A8%E5%AD%97" tabindex="-1">6 实体首部字</h3>
<ul>
<li>
<p>首部字段 Allow 用于通知客户端能够支持 Request-URI 指定资源的所有 HTTP 方法。当服务器接收到不支持的 HTTP 方法时，会以状态码405 Method Not Allowed 作为响应返回。与此同时，还会把所有能支持的 HTTP 方法写入首部字段 Allow 后返回。<code>Allow: GET, HEAD</code></p>
</li>
<li>
<p>首部字段 Content-Encoding 会告知客户端服务器对实体的主体部分<br>
选用的内容编码方式。内容编码是指在不丢失实体信息的前提下所进行<br>
的压缩。<code>Content-Encoding: gzip</code></p>
</li>
<li>
<p>首部字段 Content-Language 会告知客户端，实体主体使用的自然语<br>
言（指中文或英文等语言）。</p>
</li>
<li>
<p>首部字段 Content-Location 给出与报文主体部分相对应的 URI。和首部字段 Location 不同，Content-Location 表示的是报文主体返回资源对应的 URI。</p>
</li>
<li>
<p>首部字段 Content-MD5 是一串由 MD5 算法生成的值，其目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达。</p>
</li>
<li>
<p>针对范围请求，返回响应时使用的首部字段 Content-Range，能告知客户端作为响应返回的实体的哪个部分符合范围请求。字段值以字节为单位，表示当前发送部分及整个实体大小</p>
</li>
<li>
<p>首部字段 Content-Type 说明了实体主体内对象的媒体类型。和首部字段 Accept 一样，字段值用 type/subtype 形式赋值。</p>
</li>
<li>
<p>首部字段 Expires 会将资源失效的日期告知客户端。</p>
</li>
<li>
<p>首部字段 Last-Modified 指明资源最终修改的时间。</p>
</li>
</ul>
<h3 id="7-%E4%B8%BAcookie%E6%9C%8D%E5%8A%A1%E7%9A%84%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5" tabindex="-1">7 为Cookie服务的首部字段</h3>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
<th>首部类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>Set-Cookie</td>
<td>开始状态管理所使用的Cookie信息</td>
<td>响应首部字段</td>
</tr>
<tr>
<td>Cookie</td>
<td>服务器接收到的Cookie信息</td>
<td>请求首部字段</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>Set-Cookie：当服务器准备开始管理客户端的状态时，会事先告知各种信息。</p>
</li>
<li>
<p>set-Cookie字段的属性</p>
<ul>
<li>NAME=VALUE：赋予Cookie的名称和其值（必需项）</li>
<li>expires=DATE Cookie的有效期（若不明确指定则默认为浏览器关闭前为止）</li>
<li>path=PATH 将服务器上的文件目录作为Cookie的适用对象（若不指定则默认为文档所在的文件目录）</li>
<li>domain=域名 作为Cookie适用对象的域名 （若不指定则默认为创建Cookie的服务器的域名）</li>
<li>Secure 仅在HTTPS安全通信时才会发送Cookie</li>
<li>HttpOnly 加以限制，使Cookie不能被JavaScript脚本访问</li>
</ul>
</li>
<li>
<p>Cookie：首部字段 Cookie 会告知服务器，当客户端想获得 HTTP 状态管理支持时，就会在请求中包含从服务器接收到的 Cookie。接收到多个Cookie 时，同样可以以多个 Cookie 形式发送。</p>
</li>
</ul>
<h3 id="8-%E5%85%B6%E4%BB%96%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5" tabindex="-1">8 其他首部字段</h3>
<ul>
<li>
<p>首部字段 X-Frame-Options 属于 HTTP 响应首部，用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。其主要目的是为了防止点击劫持（clickjacking）攻击</p>
</li>
<li>
<p>首部字段 X-XSS-Protection 属于 HTTP 响应首部，它是针对跨站脚本攻击（XSS）的一种对策，用于控制浏览器 XSS 防护机制的开关。</p>
</li>
<li>
<p>首部字段 P3P 属于 HTTP 相应首部，通过利用 P3P（The Platform for Privacy Preferences，在线隐私偏好平台）技术，可以让 Web 网站上的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私的目的</p>
</li>
<li>
<p>协议中对 X- 前缀的废除</p>
<ul>
<li>在 HTTP 等多种协议中，通过给非标准参数加上前缀 X-，来区别于标准参数，并使那些非标准的参数作为扩展变成可能。但是这种简单粗暴的做法有百害而无一益，因此在“RFC 6648 - Deprecating the “X-” Prefix and Similar Constructs in Application Protocols”中提议停止该做法。</li>
<li>然而，对已经在使用中的 X- 前缀来说，不应该要求其变更。</li>
</ul>
</li>
</ul>
<h2 id="%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%A1%AE%E4%BF%9Dweb%E5%AE%89%E5%85%A8%E7%9A%84-https" tabindex="-1">第七章 确保Web安全的 HTTPS</h2>
<h3 id="7.1-http%E7%9A%84%E7%BC%BA%E7%82%B9" tabindex="-1">7.1 HTTP的缺点</h3>
<ul>
<li>HTTP的不足：
<ul>
<li>通信使用明文(不加密)，内容可能会被窃听</li>
<li>不验证对方通信身份，因此可能遭受伪装</li>
<li>无法证明报文的完整性，所以有可能已经遭到篡改</li>
</ul>
</li>
<li>以上问题不仅在HTTP上，其它未加密的协议也会有这类问题</li>
</ul>
<h4 id="7.1.1-%E9%80%9A%E4%BF%A1%E4%BD%BF%E7%94%A8%E6%98%8E%E6%96%87%E5%8F%AF%E8%83%BD%E4%BC%9A%E8%A2%AB%E7%AA%83%E5%90%AC" tabindex="-1">7.1.1 通信使用明文可能会被窃听</h4>
<p>由于HTTP本身不具备加密的功能，所以无法做到对通信整体（使用 HTTP 协议通信的请求和响应的内容）进行加密。即，HTTP 报文使用明文（指未经过加密的报文）方式发送</p>
<ul>
<li>
<p>TCP/IP 是可能被窃听的网络</p>
<ul>
<li>这是因为，按 TCP/IP协议族的工作机制，通信内容在所有的通信线路上都有可能遭到窥视<img src="/images/web/%E5%9B%BE%E8%A7%A3HTTP/7_1.jpg" alt></li>
<li>即使是已经通过加密的通信，也可以窥视到通信内容，只是收如果通信通过加密，就有尽可能让人无法破解报文信息</li>
</ul>
</li>
<li>
<p>窃听相同段上的信息并非难事。只需要手机在互联网上流动的数据（帧）即可，对于收集来的数据包的解析，可以使用抓包工具。</p>
</li>
<li>
<p>加密处理防止被窃听：目前研究如何防止窃听保护信息的对策中，加密技术最为普及</p>
<ul>
<li>通信的加密：HTTP协议种没有加密机制，但可以通过和SSL（Secure Socket Layer安全套接层）或TLS（Transport Layer Security安全层传输协议）的组合使用，加密HTTP的通信内容
<ul>
<li>与SSL组合使用高德HTTP称为HTTPS（HTTP Secure 超文本传输完全协议）</li>
</ul>
</li>
<li>内容的加密：HTTP协议中没有加密机制，南无我们可以把HTTP报文主体里所含的内容进行加密
<ul>
<li>此时要求客户端和服务端都具有加密和解密机制，但不同https，内容仍有被篡改的风险</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="7.1.2-%E4%B8%8D%E9%AA%8C%E8%AF%81%E9%80%9A%E4%BF%A1%E6%96%B9%E7%9A%84%E8%BA%AB%E4%BB%BD%E5%B0%B1%E5%8F%AF%E8%83%BD%E9%81%AD%E5%8F%97%E4%BC%AA%E8%A3%85" tabindex="-1">7.1.2 不验证通信方的身份就可能遭受伪装</h4>
<ul>
<li>
<p>HTTP协议中的请求和响应是不会对通信方进行确认的</p>
<ul>
<li>任何人都可以发起请求，此时存在隐患
<ul>
<li>
<ol>
<li>无法确定请求发送至目标的Web服务器是否是按照真实意图返回相应的那台服务器，有可能是伪装的Web服务器</li>
</ol>
</li>
<li>
<ol start="2">
<li>无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端。有可能是已伪装的客户端。</li>
</ol>
</li>
<li>
<ol start="3">
<li>无法确定正在通信的对方是否具备访问权限。因为某些 Web 服务器上保存着重要的信息，只想发给特定用户通信的权限</li>
</ol>
</li>
<li>
<ol start="4">
<li>无法判定请求是来自何方、出自谁手。</li>
</ol>
</li>
<li>
<ol start="5">
<li>即使是无意义的请求也会照单全收。无法阻止海量请求下的 DoS攻击（Denial of Service，拒绝服务攻击）</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>查明对方证书：虽然HTTP协议无法确定通信方，但SSL可以</p>
<ul>
<li>SSL不仅提供了加密处理，还提供了一种称为证书的手段<img src="/images/web/%E5%9B%BE%E8%A7%A3HTTP/7_2.jpg" alt></li>
<li>证书由值得信任的第三方机构办法，用以证明服务器和客户端是实际存在的，而伪造证书是一件很困难的事</li>
<li>通过证书，证明通信方就是想要的服务器，同时也减少了个人信息暴露的风险，另外客户端持有的证书既可以完成对个人身份的确认，也可以完成对Web网站的认证环节。</li>
</ul>
</li>
</ul>
<h4 id="7.1.3-%E6%97%A0%E6%B3%95%E8%AF%81%E6%98%8E%E6%8A%A5%E6%96%87%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%EF%BC%8C%E5%8F%AF%E8%83%BD%E5%B7%B2%E9%81%AD%E7%AF%A1%E6%94%B9" tabindex="-1">7.1.3 无法证明报文的完整性，可能已遭篡改</h4>
<ul>
<li>
<p>接收到的内容可能有误</p>
<ul>
<li>没有任何办法确认，发出的请求/响应和接收到的请求/响应是前后相同的</li>
<li>请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击，称为中间人攻击（Man-in-the-Middle attack，MITM）。</li>
</ul>
</li>
<li>
<p>如何防止篡改</p>
<ul>
<li>有使用HTTP协议确定报文完整新的方法，但并不可靠便捷。</li>
<li>常用的是MD5，SHA-1等散列值校验，但对需要操纵客户端的用户本人亲自检查验证下载的文件是否就是原来服务器上的文件，浏览器无法自动帮用户检查</li>
<li>同时，如果MD5本身被改写的话，用户是无法意识到的</li>
</ul>
</li>
</ul>
<h3 id="7.2-http%2B%E5%8A%A0%E5%AF%86%2B%E8%AE%A4%E8%AF%81%2B%E5%AE%8C%E6%95%B4%E6%80%A7%E4%BF%9D%E6%8A%A4%3Dhttps" tabindex="-1">7.2 HTTP+加密+认证+完整性保护=HTTPS</h3>
<ul>
<li>我们把添加了加密及认证机制的HTTP称为HTTPS(HTTP Secure)</li>
<li>使用HTTPS通信时，使用https://</li>
</ul>
<h4 id="7.2.2-https%E6%98%AF%E8%BA%AB%E6%8A%ABssl%E5%A4%96%E5%A3%B3%E7%9A%84http" tabindex="-1">7.2.2 HTTPS是身披SSL外壳的HTTP</h4>
<ul>
<li>HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用SSL（Secure Socket Layer）和 TLS（Transport Layer Security）协议代替而已。</li>
<li>通常，HTTP直接和TCP通信，当使用SSL时，则先和SSL通信，再由SSL和TCP通信<img src="/images/web/%E5%9B%BE%E8%A7%A3HTTP/7_3.jpg" alt></li>
<li>在使用SSL后，HTTP就拥有了HTTPS的加密，证书和完整性保护这些功能</li>
<li>SSL是独立于HTTP的协议，所以其他运行在应用层的协议都可以配合SSL协议的使用，可以收SSL是当今世界上应用最为广泛的网络安全技术</li>
</ul>
<h4 id="7.2.3-%E7%9B%B8%E4%BA%92%E4%BA%A4%E4%BA%92%E5%AF%86%E9%92%A5%E7%9A%84%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF" tabindex="-1">7.2.3 相互交互密钥的公开密钥加密技术</h4>
<ul>
<li>
<p>SSL采用一种公开密钥加密（Public-key cryptography）的加密处理方式</p>
<ul>
<li>近代加密方法中，算法是公开的，密钥是保密的</li>
<li>加密和解密都会用到密钥，如果密钥被攻击者所得，则加密失去意义</li>
</ul>
</li>
<li>
<p>共享密钥加密的困境</p>
<ul>
<li>加密和解密如果使用同一个密钥的方式称为共享密钥加密，也称为对称密钥加密</li>
<li>以共享密钥加密时必须将密钥也发送给对方，此时如果密钥落入攻击人之手，也失去了加密的意义</li>
</ul>
</li>
<li>
<p>使用两把密钥的公开密钥加密</p>
<ul>
<li>公开密钥加密使用一对非对称密钥，称为私有密钥和公开密钥</li>
<li>发送方使用对方公开密钥进行加密，接收方使用自己的私有密钥进行解密</li>
</ul>
</li>
<li>
<p>HTTPS采用混合加密机制，混合了共享密钥和公开密钥</p>
<ul>
<li>公开密钥可以实现安全交换，但公开密钥处理速度慢</li>
<li>因此可以二者结合，交换密钥环节使用公开密钥加密获得公共密钥，随后进行共享密钥加密<img src="/images/web/%E5%9B%BE%E8%A7%A3HTTP/7_4.jpg" alt></li>
</ul>
</li>
</ul>
<h4 id="7.2.4-%E8%AF%81%E6%98%8E%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E6%AD%A3%E7%A1%AE%E7%9A%84%E8%AF%81%E4%B9%A6" tabindex="-1">7.2.4 证明公开密钥正确的证书</h4>
<ul>
<li>
<p>存在问题：无法证明公开密钥本身是货真价实的公开密钥，可能在公开密钥传输过程中，真正的公开密钥已经被替换</p>
</li>
<li>
<p>解决问题：使用由数字证书认证机构(CA,Certificate Authority)和其相关机关办法的公开密钥证书</p>
</li>
<li>
<p>数字证书认证机构处于客户端和服务器端双方都信赖的第三方机构的立场上，其业务流程如下<img src="/images/web/%E5%9B%BE%E8%A7%A3HTTP/7_5.jpg" alt>[]</p>
</li>
<li>
<p>可证明组织真实性的EV SSL 证书：可确认服务器背后运营的企业是否真实存在</p>
</li>
<li>
<p>用以确定客户端的客户端的证书： 以客户端证书进行客户端认证，证明客户端服务器正在通信的对方是预料之内的客户端，作用跟服务器证书一样</p>
</li>
<li>
<p>认证机构信誉第一</p>
<ul>
<li>伪造证书可以骗过浏览器</li>
<li>虽然存在可将证书无效化的证书吊销列表（Certificate Revocation List，CRL）机制，以及从客户端删除根证书颁发机构（Root Certificate Authority，RCA）对策，但生效需要一段时间，这段时间里利益的损失就不得二至了</li>
</ul>
</li>
<li>
<p>由自认证机构办法的证书称为自签名证书</p>
<ul>
<li>如果使用OpenSSL 这套开源程序，每个人都可以构建一套属于自己的认证机构，从而自己给自己颁发服务器证书。</li>
<li>独立构建的认证机构叫做自认证机构，由自认证机构颁发的“无用”证书也被戏称为自签名证书。</li>
<li>浏览器访问该服务器时，会显示“无法确认连接安全性”或“该网站的安全证书存在问题”等警告消息。</li>
</ul>
</li>
<li>
<p>由自认证机构颁发的服务器证书之所以不起作用，是因为它无法消除伪装的可能性。值得信赖的第三方机构介入认证，才能让已植入在浏览器内的认证机构颁布的公开密钥发挥作用，并借此证明服务器的真实性。</p>
</li>
</ul>
<h4 id="7.2.5-https-%E7%9A%84%E5%AE%89%E5%85%A8%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6" tabindex="-1">7.2.5 HTTPS 的安全通信机制</h4>
<ul>
<li>
<p>HTTPS通信步骤<img src="/images/web/%E5%9B%BE%E8%A7%A3HTTP/7_6.jpg" alt></p>
</li>
<li>
<p>步骤 1： 客户端通过发送 Client Hello 报文开始 SSL 通信。报文中包含客户端支持的 SSL 的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。</p>
</li>
<li>
<p>步骤 2： 服务器可进行 SSL 通信时，会以 Server Hello 报文作为应答。和客户端一样，在报文中包含 SSL 版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。</p>
</li>
<li>
<p>步骤 3： 之后服务器发送 Certificate 报文。报文中包含公开密钥证书。</p>
</li>
<li>
<p>步骤 4： 最后服务器发送 Server Hello Done 报文通知客户端，最初阶段的 SSL 握手协商部分结束。</p>
</li>
<li>
<p>步骤 5： SSL 第一次握手结束之后，客户端以 Client Key Exchange报文作为回应。报文中包含通信加密中使用的一种被称为Pre-master secret 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密。</p>
</li>
<li>
<p>步骤 6： 接着客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器，在此报文之后的通信会采用 Pre-master secret密钥加密。</p>
</li>
<li>
<p>步骤 7： 客户端发送 Finished 报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。</p>
</li>
<li>
<p>步骤 8： 服务器同样发送 Change Cipher Spec 报文。</p>
</li>
<li>
<p>步骤 9： 服务器同样发送 Finished 报文。</p>
</li>
<li>
<p>步骤 10： 服务器和客户端的 Finished 报文交换完毕之后，SSL 连接就算建立完成。当然，通信会受到 SSL 的保护。从此处开始进行应用层协议的通信，即发送 HTTP 请求。</p>
</li>
<li>
<p>步骤 11： 应用层协议通信，即发送 HTTP 响应。</p>
</li>
<li>
<p>步骤 12： 最后由客户端断开连接。断开连接时，发送 close_notify</p>
</li>
<li>
<p>在以上流程中，应用层发送数据时会附加一种叫做MAC的报文摘要，能够查知报文是否遭到篡改，从而保护报文的完整性</p>
</li>
<li>
<p>HTTPS在使用SSL时，它的处理速度会变慢</p>
<ul>
<li>
<ol>
<li>通信慢：和使用HTTP相比，网络负载慢2到100倍，同时必须进行SSL通信，整体通信量不可避免地增加</li>
</ol>
</li>
<li>
<ol start="2">
<li>处理速度慢，消耗CPU内存等资源：SSL必须进行加密处理，在客户端和服务器端都要进行加密和解密地操作</li>
</ol>
</li>
</ul>
</li>
<li>
<p>针对这一问题，没有根本性地解决方案，但可以使用专用SSL加速器这种专用服务器硬件来改善</p>
</li>
</ul>
<h2 id="%E7%AC%AC%E5%85%AB%E7%AB%A0-%E7%A1%AE%E8%AE%A4%E8%AE%BF%E9%97%AE%E7%94%A8%E6%88%B7%E5%9C%B0%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81" tabindex="-1">第八章 确认访问用户地身份认证</h2>
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2023/06/18/web/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1/" title="微服务设计"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: 微服务设计</span></a><a class="button is-default" href="/2023/06/17/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/Balancing%20Layer%20and%20Chain%20Sharing%20in%20Industrial%20Microservice%20Deployment/" title="How to Share:Balancing Layer and Chain Sharing in Industrial Microservice Deployment"><span class="has-text-weight-semibold">Next: How to Share:Balancing Layer and Chain Sharing in Industrial Microservice Deployment</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="Haojen/Claudia-theme-blog" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/Mrcold2002"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Mr_cold 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>
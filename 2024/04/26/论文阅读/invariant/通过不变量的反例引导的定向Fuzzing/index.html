<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>通过不变量的反例引导的定向Fuzzing</title><meta name="description" content="菜"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="Counterexample-Guided Directed Fuzzing via Likely Invariant Inference

引用：Huang H, Zhou A, Payer M, et al. Everything is Good for Something: Counterexample-Guided Directed Fuzzing via Likely Invariant Inference[C], 2024 IEEE Symposium on Security and Privacy (SP). IEEE Computer Society, 2024: 142-142.
CCF A S&amp;amp;P , IEEE Symposium on Security and Privacy
.."><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Mr_cold's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">通过不变量的反例引导的定向Fuzzing</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#counterexample-guided-directed-fuzzing-via-likely-invariant-inference"><span class="toc-text">Counterexample-Guided Directed Fuzzing via Likely Invariant Inference</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%91%98%E8%A6%81"><span class="toc-text">1 摘要</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8A%A8%E6%9C%BA"><span class="toc-text">2 动机</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2.1-existing-directed-fuzzers"><span class="toc-text">2.1 Existing Directed Fuzzers</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2.1.1-sophisticated-seed-scheduling"><span class="toc-text">2.1.1 Sophisticated Seed Scheduling</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2.1.2-culling-infeasible-executions"><span class="toc-text">2.1.2 Culling Infeasible Executions</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2.2-example-and-key-challenges"><span class="toc-text">2.2 Example and Key Challenges</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#motivation"><span class="toc-text">Motivation</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-counterexample-guided-directed-fuzzing"><span class="toc-text">3  Counterexample-guided Directed Fuzzing</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3.1-intuition:-approximating-the-condition-with-dynamic-likely-invariant-inference"><span class="toc-text">3.1 intuition: Approximating the Condition with Dynamic Likely-Invariant Inference</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#preliminary-of-invariant-inference"><span class="toc-text">Preliminary of Invariant Inference</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#input-collection"><span class="toc-text">Input Collection</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#invariant-inference"><span class="toc-text">Invariant Inference</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#remark-1-%E8%AE%A8%E8%AE%BA1"><span class="toc-text">Remark 1 讨论1</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3.2-efficient-invariant-inference-with-distance-based-input-selection"><span class="toc-text">3.2 Efficient Invariant Inference with Distance-based Input Selection</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#how-to-select-inputs"><span class="toc-text">How to Select Inputs</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#how-many-inputs-selected"><span class="toc-text">How many Inputs Selected</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#remark-2"><span class="toc-text">Remark 2</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3.3.-effective-input-generation-with-similarity-based-invariant-selection"><span class="toc-text">3.3. Effective Input Generation with Similarity-based Invariant Selection</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#how-to-select-invariants"><span class="toc-text">How to Select Invariants</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#input-generation-with-adaptive-invariants"><span class="toc-text">Input Generation with Adaptive Invariants</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#renmark-3"><span class="toc-text">Renmark 3</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%AF%84%E4%BC%B0"><span class="toc-text">4 评估</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-discussion"><span class="toc-text">5 Discussion</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5.1-potentials"><span class="toc-text">5.1 Potentials</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5.2-limitations"><span class="toc-text">5.2 Limitations</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-related-work"><span class="toc-text">6 Related Work</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6.1-sophisticated-input-generation"><span class="toc-text">6.1 Sophisticated Input Generation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6.2-efficient-invariant-inference"><span class="toc-text">6.2 Efficient Invariant Inference</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-conclusion"><span class="toc-text">7 Conclusion</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93"><span class="toc-text">8 个人总结</span></a></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/Invariant"><i class="tag post-item-tag">Invariant</i></a><a href="/tags/Fuzzing"><i class="tag post-item-tag">Fuzzing</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">通过不变量的反例引导的定向Fuzzing</h1><time class="has-text-grey" datetime="2024-04-26T13:07:01.401Z">2024-04-26</time><article class="mt-2 post-content"><h2 id="counterexample-guided-directed-fuzzing-via-likely-invariant-inference" tabindex="-1">Counterexample-Guided Directed Fuzzing via Likely Invariant Inference</h2>
<ul>
<li>引用：Huang H, Zhou A, Payer M, et al. Everything is Good for Something: Counterexample-Guided Directed Fuzzing via Likely Invariant Inference[C], 2024 IEEE Symposium on Security and Privacy (SP). IEEE Computer Society, 2024: 142-142.</li>
<li>CCF A S&amp;P , IEEE Symposium on Security and Privacy</li>
<li><a target="_blank" rel="noopener" href="https://www.researchgate.net/profile/Heqing-Huang-14/publication/377767294_Everything_is_Good_for_Something_Counterexample-Guided_Directed_Fuzzing_via_Likely_Invariant_Inference/links/65b786ab1bed776ae3138790/Everything-is-Good-for-Something-Counterexample-Guided-Directed-Fuzzing-via-Likely-Invariant-Inference.pdf">链接</a></li>
</ul>
<h3 id="1-%E6%91%98%E8%A6%81" tabindex="-1">1 摘要</h3>
<ul>
<li>定向模糊有很多应用，如 补丁回归测试[1,2],漏洞重现[3,4],验证静态分析报告[5,6],为各种漏洞生成概念验证输入[7]</li>
<li>现有定向模糊测试输入许多都与目标无关，我们称为<strong>indirect input generation</strong>。
<ul>
<li>[10,12-16] 使用种子突变，产生95%的输入与目标无关</li>
<li>[17,18,19] 拒绝了一些输入，但仍然有大量无关输入</li>
</ul>
</li>
<li>本文提出一种高效的，定向灰盒fuzzing技术来解决<strong>indirect input generation</strong>。
<ul>
<li>关键见解是通从可达和不可达的执行输入中推断出可能的不变量，以限制后续输入生成的搜索空间并产生更多可达的输入。</li>
<li>此外，为了高效的产生输入满足目标状态，我们提出两种策略优化可能的不变量推理，
<ul>
<li>distance-based input selection，减少输入使得不变量推断更加高效</li>
<li>similarity-based invariant selection，消除不准确的不变量使得输入生成更加高效</li>
</ul>
</li>
</ul>
</li>
<li>我们在灰盒fuzzer Halo实现了我们这个输入限制的模糊测试方法
<ul>
<li>使用Magma[20]benchmark</li>
<li>4种SOTA directed fuzzers:AFLGO[10],Beacon[17],WindRanger[15],SelectFuzz[16]</li>
<li>4种SOTA non-directed fuzzers:AFL[21],AFL++[22],ParmeSan[23],SymCC[24]</li>
<li>结果现实，Halo6.2x产生可达输入，漏洞重现快15.3x,并检查出了更多的漏洞</li>
</ul>
</li>
<li>本文贡献总结
<ul>
<li>
<ol>
<li>提出利用已执行的输入动态推断可能的不变量，以限制后续输入生成的搜索空间，从而加速定向模糊测试中的漏洞重现过程</li>
</ol>
</li>
<li>
<ol start="2">
<li>设计了两种新颖的选择策略，以提高输入生成的效率，有效地减少了生成的不相关输入的比例</li>
</ol>
</li>
<li>
<ol start="3">
<li>我们提供了实证证据证明我们的方法比SOTA定向模糊器更高效，有效</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="2-%E5%8A%A8%E6%9C%BA" tabindex="-1">2 动机</h3>
<ul>
<li>2.1：现有工作的intuition及 justify 他们的弱点</li>
<li>2.2：陈述我们解决这些问题的动机</li>
</ul>
<h4 id="2.1-existing-directed-fuzzers" tabindex="-1">2.1 Existing Directed Fuzzers</h4>
<ul>
<li>定向模糊测试的主要目的：examine the program behaviors defined by the targets.</li>
<li>现在SOTA定向模糊测试中，主要有两种趋势
<ul>
<li>
<ol>
<li>通过选择promising seeds来接近目标</li>
</ol>
</li>
<li>
<ol start="2">
<li>消除无法达到目标的输入的不可达执行</li>
</ol>
</li>
</ul>
</li>
</ul>
<h5 id="2.1.1-sophisticated-seed-scheduling" tabindex="-1">2.1.1 Sophisticated Seed Scheduling</h5>
<ul>
<li>[10,12,13,14]致力于选择具有最高检测目标行为概率的种子,使用各种使用度函数衡量达到目标的可能性
<ul>
<li>AFLGO[10] 优先考虑与控制流图中目标的最小距离的种子</li>
<li>Hawkeye[13] 通过考虑从崩溃报告中获得的平均“call-trace-distance”来优化此距离度量</li>
<li>CAFL[12] 通过必要的指令来细化调用跟踪以触发崩溃</li>
<li>WindRanger[15] 通过仅收集从控制流偏移块到目标的距离来改进适应度</li>
<li>SelectFuzz[16] 通过数据依赖仅计算从变量和块到目标的距离。另一种方法是衡量达到目标的困难程度</li>
<li>MC2[14] 将定向模糊测试转换为蒙特卡罗计数模型，使用每个分支的执行频率来近似达到目标的困难程度，并优先考虑具有最低困难度的种子。</li>
</ul>
</li>
<li>尽管有许多基于优先级的方法帮助fuzzing更快地定位到目标，但主要的输入生成方法依赖随机突变，只有一小部分有限的种子输入，结果导致大量的无关输入被运行</li>
</ul>
<h5 id="2.1.2-culling-infeasible-executions" tabindex="-1">2.1.2 Culling Infeasible Executions</h5>
<ul>
<li>一些fuzzer-created inputs绝不会达到目标行为，为了减少这些运行，一些fuzzer会在清除知道不会达到目标的时候停止执行[17,18,19]
<ul>
<li>FuzzGuard[18] 使用机器学习模型预测是否可达</li>
<li>Beacon[17] 推断必要的达到目标的preconditions，如违反则停止执行</li>
<li>SieveFuzz[19] 提出根据动态反馈自适应地优化可以被除去的路径，减少不可达的执行</li>
</ul>
</li>
<li>尽管拒绝一些输入可以提高效率，但这仍然是一种补偿性措施，因为没有迹象表明可以直接生成针对目标的输入。</li>
</ul>
<h4 id="2.2-example-and-key-challenges" tabindex="-1">2.2 Example and Key Challenges</h4>
<p><img src="/images/%E8%AE%BA%E6%96%87/invariant/2_1.png" alt></p>
<ul>
<li>图1中，假设我们有三个种子
<ul>
<li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">)</mo><mo>:</mo><mo stretchy="false">(</mo><mn>15</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>10</mn><mo separator="true">,</mo><mn>10</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A(a,b,c,d):(15,5,10,10)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">15</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">10</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">10</span><span class="mclose">)</span></span></span></span></eq></li>
<li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">)</mo><mo>:</mo><mo stretchy="false">(</mo><mn>5</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>10</mn><mo separator="true">,</mo><mn>10</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">B(a,b,c,d):(5,5,10,10)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">10</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">10</span><span class="mclose">)</span></span></span></span></eq></li>
<li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">)</mo><mo>:</mo><mo stretchy="false">(</mo><mn>15</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>10</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C(a,b,c,d):(15,5,10,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">15</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">10</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span></eq></li>
</ul>
</li>
<li>现有fuzzer可以优先选择种子 B 而不是种子 A 和 C，因为种子 B 可以到达第 12 行，而种子 A 和 C 到达第 11 行，但是随机变异种子可能不会快速满足第 11-13 行的紧密路径条件，更不用说满足溢出条件 a + b + c &gt; sizeof(buf)</li>
<li>虽然种子 B 被优先考虑，但是模糊测试工具仍然可能生成大量违反路径条件的输入，导致探索与目标无关的程序，例如第 18 行的代码块。</li>
<li>另一方面，消除导致目标的不可行执行并不帮助生成朝向目标的输入。例如，Beacon [17] 可能根据可达性和路径条件终止执行。因此，一旦执行到达第 18 行，模糊测试工具可以停止执行输入。然而，模糊测试工具仍然缺乏如何生成满足第 11-14 行条件的输入的知识</li>
</ul>
<h5 id="motivation" tabindex="-1">Motivation</h5>
<ul>
<li>存在 <strong>indirect input generation</strong> 的问题的关键原因是输入生成对目标路径条件的无视。我们注意到，即使现有方法可以通过额外的反馈优化种子选择或消除不必要的执行，我们仍必须为 定向模糊测试 特化输入生成，以便更快地到达目标。</li>
<li>然而，到目前为止，现有方法错过了这个优化机会，具体来说，现有方法仅保留了执行种子时的少量反馈哦，仅占生成输出的一小部分，大多数输入在执行后被丢弃</li>
<li>例如，下表显示，SOTA AFLGO在Magma基准测试中仅保留了少于0.01%的执行输入反馈，因此在我们4.1AFLGo 不能有效地重现大多数目标（基准测试中的 138 个目标中的 19 个）<br>
<img src="/images/%E8%AE%BA%E6%96%87/invariant/2_2.png" alt></li>
<li>因此，我们的想法是利用执行的输入来近似目标条件，这可以限制后续输入生成的搜索空间。</li>
<li>我们使用图2说明我们的基本想法。输入可以视为从各种程序路径的分布中取样，这些路径的条件（谓语）是区分路径的边界。由于fuzz高效的输入生成速度，我们可以通过大量样本推断这些边界。
<ul>
<li>例如，通过观察上一个例子中对种子A，B，C中的a值进行变异生成的输入，我们可以近似认为达到目标的条件是a&lt;15,其是11行的否定条件的一个值，尽管还没有达到a&lt;10，但之后就不需要生成a&gt;=15的输入。此外，如果发现反例a=10，则可以进一步改进这个近似</li>
</ul>
</li>
<li>目前，有效地近似条件和生成输入面临两个主要挑战：</li>
<li><strong>Challenge 1. How to infer conditions from executed inputs efficiently?</strong>
<ul>
<li>为了实现高效性，模糊测试工具必须以尽可能少的输入准确推断条件。<br>
虽然模糊测试工具能够生成大量输入，但为每个输入记录反馈可能会带来显着的开销。<br>
因此，需要有效的输入选择策略，仅选择必要的输入进行条件推断，从而最大程度地减轻对模糊测试工具资源的负担。</li>
</ul>
</li>
<li><strong>Challenge 2. How to generate inputs constrained by conditions efficiently?</strong>
<ul>
<li>为了有效地重现目标，模糊测试工具应该使用推断的条件高效地生成受限制的输入，而不是持续调用昂贵的约束求解器。</li>
<li>然而，条件可能各不相同，而并非所有条件都同样有用；例如，条件 b &gt; 1 与条件 a &lt; 10 分别相比对变量 b,a 的搜索空间的约束可能不那么显著。</li>
<li>条件复杂化不仅可能减慢输入生成速度，还可能导致生成的输入未能达到目标。</li>
<li>因此，有效地确定推断条件的有用性对于提高输入生成的质量至关重要。</li>
</ul>
</li>
</ul>
<h3 id="3-counterexample-guided-directed-fuzzing" tabindex="-1">3  Counterexample-guided Directed Fuzzing</h3>
<ul>
<li>接下来介绍Halo，一个定向fuzzer可以有效的通过使用条件估计限制输入来生成导向目标的输入</li>
<li>如图3示，我们的核心功能是基于fuzzers生成的输入的运行来推断出一系列可以代表环境路径的不变量（Section3.1）. 为了有效地推断不变量（Chanllenge 1），我们通过选择具有代表性的可以准确推断不变量的输入，减少了推断引擎的输入数量（Section3.2）.为了更好地生成满足不变量地输出（Challenge 2），我们根据来自模糊测试的自适应执行反馈来降低那些不能精确描述路径条件的不变式的优先级，这样做是为了增加生成可行输入的概率<br>
<img src="/images/%E8%AE%BA%E6%96%87/invariant/2_4.png" alt></li>
</ul>
<h4 id="3.1-intuition%3A-approximating-the-condition-with-dynamic-likely-invariant-inference" tabindex="-1">3.1 intuition: Approximating the Condition with Dynamic Likely-Invariant Inference</h4>
<ul>
<li>算法如下图示
<ul>
<li>当fuzzer开始根据所选种子生成输入时，line 2</li>
<li>Halo通过基于一系列通过种子生成的输入估计导向目标的条件 line3-8</li>
</ul>
</li>
<li>直觉上，路径条件可以被视为一个满足多个输入的不变量，因此，我们的基本直觉是找到可以满足所有输入的不变量作为目标条件的估计。</li>
<li>根据这个直觉，我们提出了一种轻量级方法，灵感来自[25],不变量作为输入表示的目标路径条件的近似值，可以约束后续输入产生</li>
</ul>
<pre><code class="language-Java">Algorithm 1 Counterexample-guided Directed Fuzzing
Require: Seeds S, Target t
1: repeat
2:      s, I_use ← ChooseNext(S) //I_use为使用的不变量
3:      if I_use = ∅ or I_use is not effective then
4:          Sreach, Sunreach ← InputSelect(s, t) (§3.2)
5:          Ireach ← InvInfer(Sreach)
6:          Iunreach ← InvInfer(Sunreach)
7:          I_use ← InvSelect(Ireach, ¬Iunreach) (§3.3)
8:      end if
9:      Inputnew ← Sample(I_use)
10:     Tracing(Inputnew)
11:     Havoc&amp;Splice(s)
12: until Timeout is reached
</code></pre>
<h5 id="preliminary-of-invariant-inference" tabindex="-1">Preliminary of Invariant Inference</h5>
<ul>
<li>使用一系列输入 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span></eq>  ，推断引擎推断出一组不变量 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span></eq> ，对于 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>x</mi><mo>∈</mo><mi>S</mi><mo separator="true">,</mo><mi>x</mi><mi mathvariant="normal">∣</mi><mo>=</mo><mi>i</mi><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>i</mi><mo>∈</mo><mi>I</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall x \in S , x |= i,(i\in I)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord">∀</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mclose">)</span></span></span></span></eq> ，我们使用I来近似 达到目标所需的条件路径</li>
<li>现有的不变量推理方法[25,26,27]通过分治搜索来获得精确的肯呢个不变量，并保证算法的种植。具体来说，不变量推理从形式范围 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[min,max]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">min</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mclose">]</span></span></span></span></eq> 的过近似开始，对于一组不变量模板，<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mn>1</mn></msub><msub><mi>t</mi><mn>1</mn></msub><mo>+</mo><msub><mi>c</mi><mn>2</mn></msub><msub><mi>t</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msub><mi>c</mi><mi>n</mi></msub><msub><mi>t</mi><mi>n</mi></msub><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">c_1t_1+c_2t_2...+c_nt_n\geq 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.786em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></eq>,其中包含n的系数c，和关系t，由程序变量的多项式组成，用于近似路径条件</li>
<li>根据给定输入，推理引擎首先检查输入时候能够在执行时满足当前不变量，如果可以不发生任何变化。否则，算法会根据反例来缩小输入范围，同时，没有有效范围的模板不变量将被丢弃</li>
<li>因此，不变量推理的准确度取决于给定的输入和模板不变量。随着更多输入的提供，算法逐渐细化不变量得到更高的精度</li>
<li><strong>Example 3.1</strong>
<ul>
<li>假设推断引引擎从 $(-\infty,+\infty) $ 推断三个模板不变量 a,b,a+b,来估计图1中12行的状态</li>
<li>对于给定输入 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mn>5</mn><mo separator="true">,</mo><mi>b</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a=5,b=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></eq> , 推断引擎通过运行反馈发现其不能满足条，随后缩小不变量的范围 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mo stretchy="false">(</mo><mn>5</mn><mo separator="true">,</mo><mo>+</mo><mi mathvariant="normal">∞</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>b</mi><mo>∈</mo><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mo>+</mo><mi mathvariant="normal">∞</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo>∈</mo><mo stretchy="false">(</mo><mn>5</mn><mo separator="true">,</mo><mo>+</mo><mi mathvariant="normal">∞</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a\in(5,+\infty),b\in(0,+\infty),a+b\in(5,+\infty)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">+</span><span class="mord">∞</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">+</span><span class="mord">∞</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">+</span><span class="mord">∞</span><span class="mclose">)</span></span></span></span></eq> 来提高精确度</li>
</ul>
</li>
<li>本工作的目标不是改进不变量推理算法，而是明确地应用不变量推理改善定向模糊测试
<ul>
<li>具体来首，我们使用SOTA不变量推理引擎Dig[26]. 采用的模板不变式包括常数检查、涉及单个变量的下界检查以及多个变量之间的线性不等式依赖关系(这些在现有不变量推理技术中广泛被作为默认设置[25,26,28,29])</li>
</ul>
</li>
<li>值得注意的，选择理想的不变量模板仍是动态不变量推理的一个挑战，这不是我们的值嗯点，我们将在第5节提供更多工作细节</li>
</ul>
<h5 id="input-collection" tabindex="-1">Input Collection</h5>
<ul>
<li>通过fuzzing生成的大量测试用例，Halo可以推断不变量来促进更好的输入生成。</li>
<li>具体的，Halo记录input和他们到达目标的值（算法1中line 4）</li>
<li>我们使用执行反馈将输入分为两组：可达和不可达的输入，以便推断不变量。Section3.2描述了分组的相关细节</li>
<li><strong>Example 3.2</strong>
<ul>
<li>考虑图一中的程序有五个输入没有触发崩溃
<ul>
<li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">)</mo><mo>:</mo><mo stretchy="false">(</mo><mn>15</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>10</mn><mo separator="true">,</mo><mn>10</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A(a,b,c,d):(15,5,10,10)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">15</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">10</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">10</span><span class="mclose">)</span></span></span></span></eq></li>
<li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">)</mo><mo>:</mo><mo stretchy="false">(</mo><mn>6</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mn>10</mn><mo separator="true">,</mo><mn>10</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">B(a,b,c,d):(6,8,10,10)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">10</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">10</span><span class="mclose">)</span></span></span></span></eq></li>
<li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">)</mo><mo>:</mo><mo stretchy="false">(</mo><mn>12</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>30</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C(a,b,c,d):(12,5,30,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">12</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">30</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span></eq></li>
<li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">)</mo><mo>:</mo><mo stretchy="false">(</mo><mn>6</mn><mo separator="true">,</mo><mn>10</mn><mo separator="true">,</mo><mn>12</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">D(a,b,c,d):(6,10,12,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">10</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">12</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span></eq></li>
<li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">)</mo><mo>:</mo><mo stretchy="false">(</mo><mn>6</mn><mo separator="true">,</mo><mn>100</mn><mo separator="true">,</mo><mn>12</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E(a,b,c,d):(6,100,12,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">100</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">12</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span></eq></li>
</ul>
</li>
<li>Halo记录输入字节影响变量abc的及他们的值
<ul>
<li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mrow><mi>r</mi><mi>e</mi><mi>a</mi><mi>c</mi><mi>h</mi></mrow></msub><mo>=</mo><mi>B</mi><mo>:</mo><mo stretchy="false">(</mo><mn>6</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mn>10</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>D</mi><mo>:</mo><mo stretchy="false">(</mo><mn>6</mn><mo separator="true">,</mo><mn>10</mn><mo separator="true">,</mo><mn>12</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>E</mi><mo>:</mo><mo stretchy="false">(</mo><mn>6</mn><mo separator="true">,</mo><mn>100</mn><mo separator="true">,</mo><mn>12</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S_{reach} = B:(6,8,10),D:(6,10,12),E:(6,100,12)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">re</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">10</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">10</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">12</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">100</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">12</span><span class="mclose">)</span></span></span></span></eq></li>
<li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mrow><mi>u</mi><mi>n</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>c</mi><mi>h</mi></mrow></msub><mo>=</mo><mi>A</mi><mo>:</mo><mo stretchy="false">(</mo><mn>15</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>10</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>C</mi><mo>:</mo><mo stretchy="false">(</mo><mn>12</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>30</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S_{unreach} = A:(15,5,10),C:(12,5,30)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">re</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">15</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">10</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">12</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">30</span><span class="mclose">)</span></span></span></span></eq></li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="invariant-inference" tabindex="-1">Invariant Inference</h5>
<ul>
<li>
<p>通过分组的不变量，我们推断不变量 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mrow><mi>r</mi><mi>e</mi><mi>a</mi><mi>c</mi><mi>h</mi></mrow></msub><mo separator="true">,</mo><msub><mi>I</mi><mrow><mi>u</mi><mi>n</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>c</mi><mi>h</mi></mrow></msub></mrow><annotation encoding="application/x-tex">I_{reach},I_{unreach}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">re</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">re</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 为每个组的输入 （算法1 Line5-6）</p>
</li>
<li>
<p><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mrow><mi>r</mi><mi>e</mi><mi>a</mi><mi>c</mi><mi>h</mi></mrow></msub><mo separator="true">,</mo><msub><mi>I</mi><mrow><mi>u</mi><mi>n</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>c</mi><mi>h</mi></mrow></msub></mrow><annotation encoding="application/x-tex">I_{reach},I_{unreach}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">re</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">re</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 分别表示达到目标的可能条件和没有触发目标的条件，因此，我们新生成的不变量需要满足 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mrow><mi>r</mi><mi>e</mi><mi>a</mi><mi>c</mi><mi>h</mi></mrow></msub></mrow><annotation encoding="application/x-tex">I_{reach}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">re</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 并且满足 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mrow><mi>u</mi><mi>n</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>c</mi><mi>h</mi></mrow></msub></mrow><annotation encoding="application/x-tex">I_{unreach}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">re</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 的反面</p>
</li>
<li>
<p><strong>Example 3.3</strong></p>
<ul>
<li>
<section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>I</mi><mrow><mi>r</mi><mi>e</mi><mi>a</mi><mi>c</mi><mi>h</mi></mrow></msub><mo>=</mo><mi>a</mi><mo>&lt;</mo><mn>7</mn><mo separator="true">,</mo><mi>b</mi><mo>&gt;</mo><mn>7</mn><mo separator="true">,</mo><mi>c</mi><mo>≤</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">I_{reach} = a&lt;7,b&gt;7,c\leq 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">re</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10</span></span></span></span></span></eqn></section></li>
<li>
<section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>I</mi><mrow><mi>u</mi><mi>n</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>c</mi><mi>h</mi></mrow></msub><mo>=</mo><mi>a</mi><mo>&gt;</mo><mn>12</mn><mo separator="true">,</mo><mi>b</mi><mo>&lt;</mo><mn>6</mn><mo separator="true">,</mo><mi>c</mi><mo>≥</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">I_{unreach}=a&gt;12,b&lt;6,c\geq 20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">re</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">12</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">20</span></span></span></span></span></eqn></section></li>
<li>此时我们可以确定输入满足 <section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>a</mi><mo>&lt;</mo><mn>7</mn><mo separator="true">,</mo><mi>a</mi><mo>≤</mo><mn>12</mn><mo separator="true">,</mo><mi>b</mi><mo>&gt;</mo><mn>7</mn><mo separator="true">,</mo><mi>b</mi><mo>≥</mo><mn>7</mn><mo separator="true">,</mo><mi>c</mi><mo>≤</mo><mn>10</mn><mo separator="true">,</mo><mi>c</mi><mo>≤</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">a &lt; 7, a ≤ 12, b &gt; 7, b ≥ 7, c ≤ 10, c ≤ 20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">12</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">10</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">20</span></span></span></span></span></eqn></section></li>
</ul>
</li>
</ul>
<h5 id="remark-1-%E8%AE%A8%E8%AE%BA1" tabindex="-1">Remark 1 讨论1</h5>
<ul>
<li>与传统的通过符号执行推断精确的推断路径条件相比，推断不变量是一种轻量级的估计，尽管比实际路径条件要不准确一些</li>
<li>然而，通过可达不变量和不可达不变量，也足够用来高效的筛选不可达输入生成</li>
<li>仅利用执行反馈和输入，在处理复杂程序行为时（如循环）具有更好的延展性。</li>
<li>此外，与现有动态不变量推理方法不同，后者由于记录执行过程中的中间值而引入了显著的运行时开销，导致了可扩展性问题[26],我们只推断输入之间的关系以解决indirect input generation问题，从而减少了开销</li>
<li>尽管筛选推断出不变量过滤unreach输入是有效的，但在处理大的输入搜索空间且伴随 （1）爆炸性输入 （2）复杂关系时，使用不变量推理进行模糊测试仍十分困难</li>
<li>因此，我们的目标是最小化这两个因素在不变量推理中引起的维度爆炸，以提高模糊测试的可扩展性</li>
</ul>
<h4 id="3.2-efficient-invariant-inference-with-distance-based-input-selection" tabindex="-1">3.2 Efficient Invariant Inference with Distance-based Input Selection</h4>
<ul>
<li>尽管提升输入的数量可以提高不变量推理的准确性，但是这会导致不变量推理引擎的运行时间增加，同时会导致缺陷提升，因为生成的输入可能不会满足目标条件</li>
<li>为了高效的推断准确的不变量，我们的目标时使用最小化的代表性输入来准确的描绘目标条件。具体的，我们观察到每个输入对准确推断不变量的贡献不同，这将激励我们最小化不变量推断需要的输入集合</li>
<li><strong>Example 3.4</strong>
<ul>
<li>考虑 Example3.2中的输入，我们注意到输入 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span></eq> 没有改变推断结果因为其被 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span></eq> 包括了。因此我们不需要在推断中使用 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span></eq> ，这样可以减少不变量推理的开销</li>
</ul>
</li>
<li>然而，量化不变量推理中输入的有效性是一项具有挑战性的任务。为了解决这个问题，我们可以将输入分布视为数据聚类问题，只有接近条件边界的输入才能有助于推断不变量。原理边界的输入无法有效地描述目标条件。
<ul>
<li>例如，图4中红线所示额的范围之外的输入比红线内的输入更不可能产生精确的不变量。因此，我们可以根据输入距离条件边界的距离来选择输入<br>
<img src="/images/%E8%AE%BA%E6%96%87/invariant/2_5.png" alt></li>
</ul>
</li>
</ul>
<h5 id="how-to-select-inputs" tabindex="-1">How to Select Inputs</h5>
<ul>
<li>
<p>基于前面的灵感，我们设计了一种基于距离的输入选择策略来选择可以有效推断不变量的输入</p>
</li>
<li>
<p>距离维度描述了每个输入距离边界条件的接近程度</p>
</li>
<li>
<p>如图2示，路径条件可以视为一个函数 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></eq>, <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></eq> 为相关输入向量。 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f(x)=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></eq> 表示边界条件, <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|f(x)|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mord">∣</span></span></span></span></eq> 为到边界的距离，因此，我们可以通过计算 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|f(x)|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mord">∣</span></span></span></span></eq> 来选择输入</p>
</li>
<li>
<p>具体来说，在第一次突变种子之前，我们使用基于推理的污点分析 (inference-based taint analysis)[30-34]的过程，通过逐个字节地变异来获取影响到目标的输入。</p>
</li>
<li>
<p>We leave potential customization and fine-tuning of taint analysis as future work.</p>
</li>
<li>
<p>在分析过程中，我们还记录了这些相关字节和 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|f(x)|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mord">∣</span></span></span></span></eq></p>
</li>
<li>
<p>为了方便计算，我们使用未出现在循环中的分支条件的值作为 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></eq> 。因此，Halo可以保留一组接近目标且 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></eq> 较小的输入集</p>
</li>
<li>
<p><strong>Example 3.5</strong></p>
<ul>
<li>
<p>假设在图1的程序中，我们有三个输入 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">)</mo><mo>:</mo><mo stretchy="false">(</mo><mn>6</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mn>10</mn><mo separator="true">,</mo><mn>10</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">B(a,b,c,d):(6,8,10,10)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">10</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">10</span><span class="mclose">)</span></span></span></span></eq>, <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">)</mo><mo>:</mo><mo stretchy="false">(</mo><mn>6</mn><mo separator="true">,</mo><mn>10</mn><mo separator="true">,</mo><mn>12</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">B(a,b,c,d):(6,10,12,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">10</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">12</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span></eq>, <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">)</mo><mo>:</mo><mo stretchy="false">(</mo><mn>6</mn><mo separator="true">,</mo><mn>100</mn><mo separator="true">,</mo><mn>12</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C(a,b,c,d):(6,100,12,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">100</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">12</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span></eq>，我们可以结算 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></eq> 为，每个输入在 line 11-13 行条件判断的距离</p>
<ul>
<li>
<section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>f</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mo>=</mo><mn>20</mn><mo>−</mo><mn>12</mn><mo>+</mo><mn>14</mn><mo>−</mo><mn>10</mn><mo>+</mo><mn>20</mn><mo>−</mo><mn>10</mn><mo>=</mo><mn>22</mn></mrow><annotation encoding="application/x-tex">|f (B)| = 20 − 12 + 14 − 10 + 20 − 10 = 22</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">20</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">12</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">14</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">10</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">20</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">22</span></span></span></span></span></eqn></section></li>
<li>
<section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>f</mi><mo stretchy="false">(</mo><mi>D</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mo>=</mo><mn>20</mn><mo>−</mo><mn>12</mn><mo>+</mo><mn>16</mn><mo>−</mo><mn>10</mn><mo>+</mo><mn>20</mn><mo>−</mo><mn>12</mn><mo>=</mo><mn>22</mn></mrow><annotation encoding="application/x-tex">|f (D)| = 20 − 12 + 16 − 10 + 20 − 12 = 22</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mclose">)</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">20</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">12</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">16</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">10</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">20</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">12</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">22</span></span></span></span></span></eqn></section></li>
<li>
<section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>f</mi><mo stretchy="false">(</mo><mi>E</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mo>=</mo><mn>20</mn><mo>−</mo><mn>12</mn><mo>+</mo><mn>106</mn><mo>−</mo><mn>10</mn><mo>+</mo><mn>20</mn><mo>−</mo><mn>12</mn><mo>=</mo><mn>112</mn></mrow><annotation encoding="application/x-tex">|f (E)| = 20 − 12 + 106 − 10 + 20 − 12 = 112</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">20</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">12</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">106</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">10</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">20</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">12</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">112</span></span></span></span></span></eqn></section></li>
</ul>
</li>
<li>因为 E 的距离里边界最元，我们只选择B和D作为代表性的输入在不变量推断中</li>
</ul>
</li>
<li>然而，对于没有达到目标的输入，我们无法获得距离，因为 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></eq> 无法执行
<ul>
<li>因此，Hao根据是否达到目标来分离用于不变量推理的输入</li>
<li>在达到目标之前，Halo仅利用不可达的输入来推断所有输入字节的可能不变量，这表明可达输入不应该满足的条件</li>
<li>通过否定从不可达输入推断出的不变量，fuzzer仍然可以限制生成输入的搜索空间</li>
</ul>
</li>
<li><strong>Example 3.6</strong>
<ul>
<li>假设我们有不变量 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mrow><mi>u</mi><mi>n</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>c</mi><mi>h</mi></mrow></msub><mo>:</mo><mo stretchy="false">{</mo><mi>a</mi><mo>&gt;</mo><mn>12</mn><mo separator="true">,</mo><mi>b</mi><mo>&lt;</mo><mn>6</mn><mo separator="true">,</mo><mi>c</mi><mo>≤</mo><mn>20</mn><mo separator="true">,</mo><mi>d</mi><mo>&lt;</mo><mn>10</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">I_{unreach}:\{a&gt;12,b&lt;6,c\leq20,d&lt;10\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">re</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">12</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">20</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">10</span><span class="mclose">}</span></span></span></span></eq>,从Example3.2中不可达的输入中推断出</li>
<li>尽管我们可能无法在 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mrow><mn>10</mn><mo separator="true">,</mo><mn>11</mn><mo separator="true">,</mo><mn>12</mn></mrow></mrow><annotation encoding="application/x-tex">a∈{10,11,12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord">10</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">11</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">12</span></span></span></span></span></eq> 时使用否定不变量过滤可达输入，因为 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≤</mo><mn>12</mn></mrow><annotation encoding="application/x-tex">a≤12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">12</span></span></span></span></eq> 从 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span></eq> 中的 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>&gt;</mo><mn>12</mn></mrow><annotation encoding="application/x-tex">a&gt;12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">12</span></span></span></span></eq> 不可达，而 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>&lt;</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">a&lt;7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">7</span></span></span></span></eq> 在 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span></eq> 中可达，但模糊器仍然可以有效地过滤来自 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>&gt;</mo><mn>12</mn></mrow><annotation encoding="application/x-tex">a&gt;12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">12</span></span></span></span></eq> 和 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>&gt;</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">c&gt;20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">20</span></span></span></span></eq> 的输入。</li>
</ul>
</li>
</ul>
<h5 id="how-many-inputs-selected" tabindex="-1">How many Inputs Selected</h5>
<ul>
<li>我们基于计算需要的最小采样的统计理论决定选择多少输入来推断不变量[35]</li>
<li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mfrac><mrow><mn>4</mn><msup><mi>Z</mi><mn>2</mn></msup></mrow><msup><mi>ε</mi><mn>2</mn></msup></mfrac><mo>=</mo><mn>385</mn></mrow><annotation encoding="application/x-tex">n = \frac{4Z^2}{ε^2}=385</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3629em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0179em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ε</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">385</span></span></span></span></eq>, 其中 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span></span></span></span></eq> 是 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Z</mi><mo>−</mo><mi>s</mi><mi>c</mi><mi>o</mi><mi>r</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Z-score</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">score</span></span></span></span></eq> 决定错误 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ε</mi><mo>=</mo><mn>0.05</mn></mrow><annotation encoding="application/x-tex">ε=0.05</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ε</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.05</span></span></span></span></eq> 的概率，即 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>95</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">95\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">95%</span></span></span></span></eq> 的置信度</li>
</ul>
<h5 id="remark-2" tabindex="-1">Remark 2</h5>
<ul>
<li>不像现有定向模糊方法只通过种子存储临时变量，Halo通过从运行输入保留更多运行反馈来限制进一步的输入的搜索空间。</li>
<li>基于这一直觉，输入选择旨在在数据收集的额外时间成本和推断不变量的准确度之间取得平衡。</li>
<li>此外，利用从可达和不可达输入推断出不变量不仅提高了方法的可扩展性，而且从两个方向压缩近似搜索空间，有助于提高精确度</li>
</ul>
<h4 id="3.3.-effective-input-generation-with-similarity-based-invariant-selection" tabindex="-1">3.3. Effective Input Generation with Similarity-based Invariant Selection</h4>
<ul>
<li>
<p>虽然可能的不变量可以帮助约束后续输入生成的搜索空间，但推理引擎可能会提供多个具有不同精度的潜在不变量，这可能不能平等地过滤掉不可达的输入。</p>
</li>
<li>
<p>根据给定的输入，不变量可能会被过度约束。例如，仅从早期不可达输入推断出的不变量。</p>
</li>
<li>
<p>因此，使用所有不变量进行输入生成可能会引入显着的开销，而没有提供足够的精度。</p>
</li>
<li>
<p><strong>Example 3.7</strong></p>
<ul>
<li>Example 3.3中推断的不变量</li>
<li>与不变量 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>&lt;</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">c &lt; 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10</span></span></span></span></eq> 相比，<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>≤</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">c ≤ 20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">20</span></span></span></span></eq> 可以更精确地描述在第13行的路径条件 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>&lt;</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">c &lt; 20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">20</span></span></span></span></eq></li>
<li>不变量 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>&lt;</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">a &lt; 7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">7</span></span></span></span></eq> 过度约束，因为可达的 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mrow><mn>7</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mn>9</mn></mrow></mrow><annotation encoding="application/x-tex">a  ∈ {7, 8, 9}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">9</span></span></span></span></span></eq> 被过滤掉了。</li>
</ul>
</li>
<li>
<p>为了有效地生成受不变量约束的输入，我们的基本直觉是根据新的输入生成 adaptively 地选择和细化不变量。</p>
</li>
<li>
<p>如图5所示，理想情况下，由最精确的不变量生成的输入应始终满足路径条件。精度损失由在近似分布中找到的反例表示。更精确的不变量应生成更少的反例。<br>
<img src="/images/%E8%AE%BA%E6%96%87/invariant/2_6.png" alt></p>
</li>
<li>
<p>因此，我们利用生成的输入的执行反馈来估计哪个不变量更类似于原始路径条件。</p>
</li>
<li>
<p>相似性可以视为使用推断的不变量生成更多可达输入的概率。Halo根据在后续输入生成中发现的反例比率对推断的不变量进行优先选择。</p>
</li>
<li>
<p>因此，由选定不变量描述的相似搜索空间可以提高生成可达输入的效果。</p>
</li>
</ul>
<h5 id="how-to-select-invariants" tabindex="-1">How to Select Invariants</h5>
<ul>
<li>
<p>我们设计了一种基于相似度的不变量选择方法来自适应地选择生成可达输入最有效的不变量</p>
</li>
<li>
<p>每个不变量的相似度被用于fuzzer选择该不变量的概率，相似度越高越容易被选中。</p>
</li>
<li>
<p>我们用不变量生成可达输入的占比 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Φ</span></span></span></span></eq> 来衡量相似度 <section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>S</mi><mi>i</mi><mi>m</mi><mi>i</mi><mi>l</mi><mi>a</mi><mi>r</mi><mi>i</mi><mi>t</mi><mi>y</mi><mo stretchy="false">(</mo><mi mathvariant="normal">Φ</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mi>n</mi><mi>N</mi></mfrac></mrow><annotation encoding="application/x-tex">Similarity(\Phi)=\frac{n}{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">imi</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord">Φ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.7936em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1076em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></eqn></section> 其中 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></eq>和<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></eq>是生成的可达输入和总输入的数量</p>
</li>
<li>
<p><strong>Example 3.8</strong></p>
<ul>
<li>假设我们使用从 Example 3.3中获得的不变量生成输入。Halo可以迅速找到条件 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>≥</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">b\geq 7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">7</span></span></span></span></eq>,单这是对 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span></eq>的过度限制，因为根据图1Line12，其值与 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span></eq> 的值也有关系。</li>
<li>因此，Halo通过反例降低了该不变量的优先级，来避免生成不可达输入的反例</li>
</ul>
</li>
</ul>
<h5 id="input-generation-with-adaptive-invariants" tabindex="-1">Input Generation with Adaptive Invariants</h5>
<ul>
<li>直观地说，由于我们推断的不变量是线性的，它们可以形成一个多面体，描述了可达输入的搜索空间。</li>
<li>因此，我们使用了SOTA采样技术，Vaidya walk[36]，它可以在线性复杂度的基础上从在大量不变量组成的多面体中高效地采样生成输入。</li>
<li>此外，不变量的相似度基于后续的fuzzer输入生成不断地在更新.如果所有推断出的不变量都无法有效地生成优先级较高的可达输入，Halo会收集发现的反例，并推断出一组更具精度的新不变量，以保持输入生成的有效性。</li>
</ul>
<h5 id="renmark-3" tabindex="-1">Renmark 3</h5>
<ul>
<li>我们从搜索空间的角度来解决有向模糊测试中的输入生成问题，这使我们能够在不解决精确路径条件的情况下有效地对可达输入进行抽样。</li>
<li>同时，这种想法激励我们通过利用执行的输入作为回归来完善不精确的搜索空间</li>
<li>于不变量是实际路径条件的近似，精度的潜在损失可能会不准确地扩大或缩小近似的搜索空间，从而阻碍其在生成可达输入方面的有效性。</li>
<li>此外，与使用现有的不变量推断中的动态程序分析可能导致的潜在运行时开销相比[26]，[28]，[37]，[38]，我们利用模糊测试中可用的大量输入，这些输入近似于搜索空间的分布，作为选择精确不变量的轻量级预测器。因此，在模糊测试过程中，我们可以减少选择的不精确或多余的不变量的数量，从而更有效地生成可达输入</li>
</ul>
<h3 id="4-%E8%AF%84%E4%BC%B0" tabindex="-1">4 评估</h3>
<h3 id="5-discussion" tabindex="-1">5 Discussion</h3>
<h4 id="5.1-potentials" tabindex="-1">5.1 Potentials</h4>
<ul>
<li><strong>Assisting Dynamic Analysis with Fuzzing</strong>
<ul>
<li>动态分析已得广泛应用
<ul>
<li>污点分析[43,44]</li>
<li>程序合成[45,46]</li>
<li>特征生成[47,48]</li>
</ul>
</li>
<li>与传统的静态分析相比，动态分析可以通过执行反馈提供更精确的结果。</li>
<li>然而，对于动态分析，在没有足够数量的输入的情况下彻底分析程序具有挑战性[49]</li>
<li>Halo使用最先进的fuzzer生成足够的输入，以便动态分析来近似程序语义。此外，我们的输入选择策略可以有效地控制输入数量，实现更好的扩展性。</li>
<li>除了Halo中通过可能的不变量近似的路径条件来处理内存安全问题外，还可以考虑复杂语义，如状态机模型和部分顺序约束，以支持检测涉及逻辑正确性的漏洞。</li>
</ul>
</li>
<li><strong>Semantic Extraction from Inputs</strong>
<ul>
<li>虽然模糊测试的主要趋势之一是以不同的粒度提取目标程序的语义，例如使用符号执行来解决路径条件，但Halo中由执行输入推断的不变量指示了模糊测试的另一个潜在方向：利用观察到的不可达执行来防止模糊测试器不断探索无关的程序行为。</li>
<li>在Halo中，我们还根据不可达输入推断不变量，以约束后续输入生成的搜索空间，从而有效地接近目标漏洞。由于模糊测试器可以生成大量的输入来检查程序，因此除了覆盖范围之外，还可以从执行的输入中提取更多的语义，以引导模糊测试器探索程序。</li>
</ul>
</li>
</ul>
<h4 id="5.2-limitations" tabindex="-1">5.2 Limitations</h4>
<ul>
<li><strong>Scalability of the Invariant Inference</strong>
<ul>
<li>虽然动态的可能不变量推断优于符号执行，但其有效性仍可能受到可扩展性问题的影响，例如由于给定输入的过大或候选不变量过多</li>
<li>为了环节这些问题，Halo选择适当的输入样本进行推断，并声称精确的不变量以生成输入，然而我们尚未优化候选不变量的质量，以提高近似目标条件的精度。因此，Halo的性能在尚未评估的其它项目可能受影响。然而该问题与定向fuzzing无关，参见6.2相关工作</li>
</ul>
</li>
<li><strong>Solving Complex Path Conditions</strong>
<ul>
<li>Halo的强大之处在于可以用可达和不可达输入中的不变量来约束搜索空间</li>
<li>尽管我们在表4中展示了从不可达输入中推断处不变量的有效性，但与使用两类输入的不变量相比，其有效性较低。例如，达到目标的改进比例小于触发时间的改进比例</li>
<li>为此，可以将Halo与其它输入生成技术结合，例如混合模糊测试与符号执行，以更快地达到目标并收集两个类别的输入。同时，基于AFL++的Halo实现也使得与基于AFL的模糊测试框架集成成为可能。</li>
</ul>
</li>
<li><strong>Support to Rich Semantics</strong>
<ul>
<li>除了复杂的路径条件之外，漏洞可能涉及各种丰富的语义。例如，网络服务器中的逻辑错误可能需要程序执行满足特定协议的函数。<br>
然而，由于本文的主要重点是路径条件，Halo可能无法有效地复现这种类型的目标漏洞。尽管如此，我们仍然希望将这些问题总结为Halo解决的不同问题，并在今后的工作中讨论，如第5.1节所述。</li>
</ul>
</li>
</ul>
<h3 id="6-related-work" tabindex="-1">6 Related Work</h3>
<h4 id="6.1-sophisticated-input-generation" tabindex="-1">6.1 Sophisticated Input Generation</h4>
<ul>
<li><strong>Mutaing Relevant Bytes</strong>
<ul>
<li>优化突变的一个主要趋势是突变相关的输入偏移以满足未覆盖的分支条件。
<ul>
<li>除随机突变外，Fairfuzz [50]确定了不需要更改值的输入偏移，因此，最小化输入搜索空间提高了突变的效率。</li>
<li>ngora [51]采用字节级污点跟踪来发现目标条件的相关输入字节，然后应用基于梯度下降的搜索策略。</li>
<li>Redqueen [32]提出使用中间值作为反馈来修改输入中的值。</li>
<li>PATA [30]通过区分不同的路径和上下文来提高污点分析的精度。</li>
<li>Parmesan [23]利用从 santizers [39] 获取的标签来最小化需要被污点分析分析的分支数量。</li>
</ul>
</li>
<li>然而，这些方法都需要特定的分支来找到相关的字节。与基于覆盖引导的模糊测试不同，有向模糊测试无法选择分支，因为确定哪个分支可以更快地达到目标是具有挑战性的。有些分支甚至可能不满足目标的路径条件。因此，明确地为有向模糊测试调整这些方法是具有挑战性的，这也是为什么 Halo 只利用不变量推理来处理输入字节，而不是分析整个程序的原因。</li>
</ul>
</li>
<li><strong>Leveraging the Constraint Solver</strong></li>
</ul>
<h4 id="6.2-efficient-invariant-inference" tabindex="-1">6.2 Efficient Invariant Inference</h4>
<ul>
<li>不变量推理已经成为程序验证[57,58,59,60],软件测试[38,61,62,63]和属性检查[25,26,28,29,37,64,65,66] 中一种具有潜力的技术。其对于确保软件系统的正确性十分有效，因为不变量可以作为程序与其行为的形式规范。</li>
<li>不变量推理的主要目标是高效地推断适用于所有程序行为的精确不变量。
<ul>
<li>传统的基于验证的方法旨在准确检测不变量。现有工作的大多数努力[29,57,58,59,60,63]，使用抽象解释和符号执行来静态地逼近程序行为的固定点作为属性。古纳在他们在理论上很准确，但由于符号执行分析故有的扩展性问题，他们的效率受到限制。因此，他们的方法通常设计于具有假设的特定应用场景</li>
<li>动态不变量推理技术不追求对整个程序的精确假设，并根据给定的输入推断不变量。
<ul>
<li>从Daion[25,64]开始，现有文献监视执行跟踪以验证一组候选不变量并具体化系数和项</li>
<li>DIDUCE[66]放宽了不变量的假设，因为违规可能导致异常程序行为，并优先处理具有置信度的违规行为以进行故障定位。</li>
<li>由于推断得到的不变量的质量高度依赖于给定的输入和模板不变量，现有工作利用从执行中提取的更多程序语义来提高不变量的准确性。例如，
<ul>
<li>DySy [37] 利用共轭执行来推理潜在的模板不变量。</li>
<li>iDiscovery [28] 利用中间符号状态进行增量不变量推理以提高不变量的准确性。</li>
<li>MRI [38] 提出将推理过程建模为搜索问题，并使用基于挖掘的方法获得精确的不变量。</li>
<li>Dig [26] 依赖于来自反例的执行反馈来剪枝不变量的不可行范围，并逐渐提高精度。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Halo使用的不变量推理引擎使用了上述见解，以实现更好的效率。到目前未知，现有工作没有专注于优化给定输入的质量[28]，而这是影响不变量推理效果的关键因素之一。相反，Halo利用模糊测试工具作为输入生成器，以提高不变量的精度，从而最终增强fuzzer本身的输入生成能力</li>
</ul>
<h3 id="7-conclusion" tabindex="-1">7 Conclusion</h3>
<ul>
<li>我们提出了Halo，通过生成的输入推断出的动态不变量引导的自我优化定向模糊测试，以显著提高生成可触发目标漏洞的可达输入的效果。</li>
<li>动态不变量有助于限制Halo后续输入的生成的搜索空间，实证结果展示了我们设计的方法带来了显著的改进
<ul>
<li>Halo 在重现目标漏洞方面的速度提升了 15.3 倍<br>
生成的可达输入增加了 6.2 倍。<br>
此外，Halo 还发现了十个先前未发现的漏洞，涉及到七个以前漏洞的不完整修复，以及 Magma 基准测试中评估项目的最新修补版本的 CVE。</li>
</ul>
</li>
</ul>
<h3 id="8-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93" tabindex="-1">8 个人总结</h3>
<ul>
<li>提出一种SOTA定向方法，方法重点是通过 动态不变量方法 从 已有fuzzing生成的输入中推断出不变量，随后使用这些不变量来约束后续输入生成的搜索空间，从而提高生成可达输入的效果</li>
<li>本文体现了不变量作为约束条件的使用，对于测试用例生成技术，不变量可以约束生成的空间</li>
</ul>
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2024/05/28/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/SoftwareDebloating/Software%20Debloating%20%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB(12)/" title="Software Debloating 论文阅读 （12）UI Driven Andorid Application Reduction"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: Software Debloating 论文阅读 （12）UI Driven Andorid Application Reduction</span></a><a class="button is-default" href="/2024/04/26/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/invariant/%E4%B8%8D%E5%8F%98%E9%87%8F%E4%BD%9C%E4%B8%BAFuzzers%E7%9A%84%E5%8F%8D%E9%A6%88/" title="不变量作为fuzzers的反馈"><span class="has-text-weight-semibold">Next: 不变量作为fuzzers的反馈</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="Haojen/Claudia-theme-blog" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/Mrcold2002"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Mr_cold 2024</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>
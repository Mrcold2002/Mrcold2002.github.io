<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>基于程序不变量计算软件可靠性</title><meta name="description" content="菜"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="基于程序不变量计算软件可靠性

引用：周远, 丁佐华. 基于程序不变量计算软件可靠性[J]. 软件学报, 2015, 26(12): 3075-3087.

0 介绍

软件可靠性的计算依赖于可靠性模型的选取以及所获得的软件失效数据
失效数据的获取对可靠性及模型有非常大的影响[20]，因此我们必须考虑是小数据的质量和收集失效数据的方案
目前应用最广泛的针对各个开发阶段失效数据收集的方法是软件测试技术，软件测试包括 3 个要素:选择输入域、执行测试用例和比较输出[22].学者们提出了多种测试方法来获得软件失效数据[23],然而这些方法都是通过比较实际输出结果与期望输出结果得到诸如失效次数、失效用例等的失效数据,而忽略了软件的实时行为和内部结构,从而导致这些数据并不能真实反映软件的真实行为,如:



存在假性.."><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Mr_cold's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">基于程序不变量计算软件可靠性</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%A8%8B%E5%BA%8F%E4%B8%8D%E5%8F%98%E9%87%8F%E8%AE%A1%E7%AE%97%E8%BD%AF%E4%BB%B6%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="toc-text">基于程序不变量计算软件可靠性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0-%E4%BB%8B%E7%BB%8D"><span class="toc-text">0 介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%A4%B1%E6%95%88%E6%95%B0%E6%8D%AE%E7%9A%84%E8%8E%B7%E5%8F%96-%E5%8F%8A-%E5%8F%AF%E8%A1%8C%E6%80%A7%E5%88%86%E6%9E%90"><span class="toc-text">4 失效数据的获取  及 可行性分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%8F%AF%E9%9D%A0%E6%80%A7%E8%AE%A1%E7%AE%97%E5%92%8C%E7%BB%93%E6%9E%9C%E5%88%86%E6%9E%90"><span class="toc-text">5 可靠性计算和结果分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%8F%AF%E8%A1%8C%E6%80%A7%E5%88%86%E6%9E%90"><span class="toc-text">6 可行性分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E7%BB%93%E8%AE%BA"><span class="toc-text">8 结论</span></a></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/Invariant"><i class="tag post-item-tag">Invariant</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">基于程序不变量计算软件可靠性</h1><time class="has-text-grey" datetime="2024-03-18T17:22:57.662Z">2024-03-19</time><article class="mt-2 post-content"><h2 id="%E5%9F%BA%E4%BA%8E%E7%A8%8B%E5%BA%8F%E4%B8%8D%E5%8F%98%E9%87%8F%E8%AE%A1%E7%AE%97%E8%BD%AF%E4%BB%B6%E5%8F%AF%E9%9D%A0%E6%80%A7" tabindex="-1">基于程序不变量计算软件可靠性</h2>
<ul>
<li>引用：周远, 丁佐华. 基于程序不变量计算软件可靠性[J]. 软件学报, 2015, 26(12): 3075-3087.</li>
</ul>
<h3 id="0-%E4%BB%8B%E7%BB%8D" tabindex="-1">0 介绍</h3>
<ul>
<li>软件可靠性的计算依赖于可靠性模型的选取以及所获得的软件失效数据</li>
<li>失效数据的获取对可靠性及模型有非常大的影响[20]，因此我们必须考虑是小数据的质量和收集失效数据的方案</li>
<li>目前应用最广泛的针对各个开发阶段失效数据收集的方法是软件测试技术，软件测试包括 3 个要素:选择输入域、执行测试用例和比较输出[22].学者们提出了多种测试方法来获得软件失效数据[23],然而这些方法都是通过比较实际输出结果与期望输出结果得到诸如失效次数、失效用例等的失效数据,而忽略了软件的实时行为和内部结构,从而导致这些数据并不能真实反映软件的真实行为,如:
<ul>
<li>
<ol>
<li>存在假性正确现象：即偶然正确，如软件的输出结果与期望输出结果一致,但软件的内部结构和行为并不正确</li>
</ol>
</li>
<li>
<ol start="2">
<li>测试不能显示一个输入有多个错误的输出情况.</li>
</ol>
</li>
<li>
<ol start="3">
<li>不同测试方法会影响到失效数据的获取比例,从而影响可靠性的计算.</li>
</ol>
<ul>
<li>Chen 等人[24]通过实验指出,不同的测试方法(随机测试、功能测试、分块测试)获得的失效数据会产生不同的可靠性.作者认为:这是因为这样获得的失效数据并没有真正反映程序的内部信息,仅反映了在所选测试用例下粗糙的程序的信息,所以计算出来的可靠性也是不准确的,无法反映软件真实的可靠性.</li>
</ul>
</li>
</ul>
</li>
<li>因此，通过测试阶段的输入/输出所获取的失效数据并不充分，无法准确反映程序内部存在的问题，为此我们需要程序的内部数据来计算软件的可靠性，一个解决方案是：
<ul>
<li>通过观察和分析测试过程中程序的执行轨迹从中提取程序的内部信息(例如内部结构、动态行为)。这里使用Daikon工具提取不变量，从这些不好的不变量中获得不好的不变量，利用这些不好的不变量计算可靠性</li>
<li>在前人工作下，本文对使用不变量计算可靠性进行了可行性分析</li>
</ul>
</li>
<li>与现有的可靠性方法比较，两种方法差别很小，不依赖于对测试方法的选择，而进一步的方差说明：所提方法波动更小，更平稳，更接近系统的真实可靠性</li>
</ul>
<h3 id="4-%E5%A4%B1%E6%95%88%E6%95%B0%E6%8D%AE%E7%9A%84%E8%8E%B7%E5%8F%96-%E5%8F%8A-%E5%8F%AF%E8%A1%8C%E6%80%A7%E5%88%86%E6%9E%90" tabindex="-1">4 失效数据的获取  及 可行性分析</h3>
<ul>
<li>文章例子是改变程序中的数组，产生新的不变量，与原来的不变量进行比较，产生变化的不变量即失效数据</li>
<li>失效数据获取例子：
<ul>
<li>我们通过 3 种不同的方法来选取测试用例集 T1(随机选取)、T2(基于分块覆盖选取)、T3(基于分支覆盖选取).</li>
<li>分别运行正确版本程序 C 与 T1、C 与 T2、C 与 T3 得到程序不变量 TI1,TI2 和 TI3</li>
<li>运行错误版本程序 F 与 T1、F 与 T2、F 与 T3 得到程序不变量 FI1,FI2 和 FI3.</li>
<li>比较 TI1 与 FI1、TI2 与 FI2 以及 TI3 与 FI3 的不同,分别得到各自的失效数据.</li>
</ul>
</li>
<li>可行性分析：
<ul>
<li>每种方法所获得的失效数据百分比,可以发现不同方法获得的失效数据百分比基本相近,误差不大.</li>
<li>可以得到结论不同测试方法得到不同的不变量;但是就失效数据的百分比来说,它们之间相差较小,比较稳定.</li>
</ul>
</li>
</ul>
<h3 id="5-%E5%8F%AF%E9%9D%A0%E6%80%A7%E8%AE%A1%E7%AE%97%E5%92%8C%E7%BB%93%E6%9E%9C%E5%88%86%E6%9E%90" tabindex="-1">5 可靠性计算和结果分析</h3>
<ul>
<li>可靠性计算：使用Nelson模型计算，不好的不变量作为失效数据，不同方法法算出的可靠性虽然不一样,但相差较小；使用方差刻画，基于不变量的可靠性计算结果方差较小</li>
<li>综上所述
<ul>
<li>在不同测试方法下,由不变量计算出的可靠性不是完全相等,还有一定的误差,其原因是有些不好的</li>
<li>不变量之间还有一定的依赖性;</li>
</ul>
</li>
</ul>
<h3 id="6-%E5%8F%AF%E8%A1%8C%E6%80%A7%E5%88%86%E6%9E%90" tabindex="-1">6 可行性分析</h3>
<ul>
<li>
<p>用现有计算可靠性的方法计算7个程序的可靠性（Nelson模型），比较不便令计算出的可靠性和现有方法计算出的可靠性之间的差异</p>
<ul>
<li>二者在不同测试方法下差异不大</li>
<li>可靠性方差都不是太大;但是相比较而言,现有方法的可靠性波动远大于不变量计算出的可靠性波动
<ul>
<li>因为现有方法计算出的可靠性一定程度上依赖于测试方法,反映软件的局部行为计算出的可靠性是在该测试方法下的可靠性，所以在不同测试方法下,可靠性会有一定的波动；而不变量是整体的行为，,虽然不同的测试方法会产生不同的不变量,但这些不变量的合成效果却是一样的,都反映软件整体的行为,所以不变量计算出的可靠性是软件的整体可靠性,其波动产生的原因在于有些失效数据(不好的不变量)之间还有一定的相关性.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>综述所述:相对于现有的计算可靠性方法,我们还可以利用不变量来计算软件的可靠性;且利用不变量计算的可靠性更接近软件的实际可靠性</p>
</li>
</ul>
<h3 id="8-%E7%BB%93%E8%AE%BA" tabindex="-1">8 结论</h3>
<ul>
<li>
<p>本文说明可以使用程序不变量计算软件的可靠性</p>
<ul>
<li>
<ol>
<li>在同一测试方法下,不变量计算出的可靠性和现有方法计算出的可靠性相差不大</li>
</ol>
</li>
<li>
<ol start="2">
<li>在不同测试方法下,不变量计算出的可靠性波动较小,更接近软件的实际可靠性.</li>
</ol>
</li>
<li>
<ol start="3">
<li>从不变量的角度来刻画软件可靠性,使我们对软件的整体行为和软件可靠性有更深刻的认识,有利于软件可靠性的评估和预测.</li>
</ol>
</li>
</ul>
</li>
<li>
<p>未来工作：</p>
<ul>
<li>
<ol>
<li>针对不变量中的相关性：如果不好的不变量之间存在相关性,会增加失效数据,影响计算结果.我们应尽量去掉这种相关性,使得剩下的不变量尽可能独立.一种办法是建立数据流的依赖图</li>
</ol>
</li>
<li>
<ol start="2">
<li>在实际应用中,我们并不知道正确的程序,这样我们就不能通过比较来获得不好的不变量,而必须通过一定的方法,根据已有的测试用例信息和已获得的不变量信息来确定不好的不变量,这将是我们接下来要解决的关键问题之一.</li>
</ol>
</li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2024/03/21/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/SoftwareDebloating/Software%20Debloating%20%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB(6)/" title="Software Debloating 论文阅读 (6) DomGad"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: Software Debloating 论文阅读 (6) DomGad</span></a><a class="button is-default" href="/2024/03/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/invariant/%E4%B8%8D%E5%8F%98%E9%87%8F%E4%B8%8E%E7%A8%8B%E5%BA%8F%E4%BF%AE%E5%A4%8D%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/" title="不变量与程序修复相关论文"><span class="has-text-weight-semibold">Next: 不变量与程序修复相关论文</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="Haojen/Claudia-theme-blog" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/Mrcold2002"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Mr_cold 2024</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>
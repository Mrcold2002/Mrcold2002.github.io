<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>Software Debloating 论文阅读 (10)</title><meta name="description" content="菜"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="(10) OCCAM:Automated Software Winnowing·
Malecha G, Gehani A, Shankar N. Automated software winnowing[C],Proceedings of the 30th Annual ACM Symposium on Applied Computing. 2015: 1504-1511.
SAC’15 April 13-17, 2015, Salamanca, Spain
Symposium on Applied Computing 2015

0 摘要

为了解决代码膨胀问题,我们介绍一个OCCAM工具.

OCCAM结合了部分求值和类型理论的技术，旨在减少部署应用中的代码。
OCCAM可以在不对程序源代码进行注释或以.."><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Mr_cold's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Software Debloating 论文阅读 (10)</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#(10)-occam:automated-software-winnowing%C2%B7"><span class="toc-text">(10) OCCAM:Automated Software Winnowing·</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0-%E6%91%98%E8%A6%81"><span class="toc-text">0 摘要</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8D"><span class="toc-text">1 介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%9C%BA"><span class="toc-text">动机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%A1%E7%8C%AE"><span class="toc-text">贡献</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-winnowing"><span class="toc-text">2 winnowing</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2.1-%E6%A8%A1%E5%9D%97%E5%86%85%E7%B2%BE%E7%AE%80"><span class="toc-text">2.1 模块内精简</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2.2-%E6%A8%A1%E5%9D%97%E9%97%B4%E7%B2%BE%E7%AE%80"><span class="toc-text">2.2 模块间精简</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2.2.1-%E4%BE%9D%E8%B5%96%E8%AE%A1%E7%AE%97"><span class="toc-text">2.2.1 依赖计算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2.2.2-%E7%89%B9%E5%8C%96"><span class="toc-text">2.2.2 特化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2.2.3-%E9%87%8D%E5%86%99"><span class="toc-text">2.2.3 重写</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2.2.4-%E5%B0%81%E5%AD%98"><span class="toc-text">2.2.4 封存</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2.3-%E5%8A%A8%E6%80%81%E6%A3%80%E6%9F%A5"><span class="toc-text">2.3 动态检查</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2.3.1-%E9%87%8D%E5%86%99%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-text">2.3.1 重写客户端</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2.3.2-%E9%87%8D%E5%86%99%E5%BA%93"><span class="toc-text">2.3.2 重写库</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AE%9E%E7%8E%B0"><span class="toc-text">3 实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BE%8B%E5%AD%90%E7%A0%94%E7%A9%B6"><span class="toc-text">4 例子研究</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#nweb"><span class="toc-text">nweb</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#thttpd"><span class="toc-text">thttpd</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#php"><span class="toc-text">PHP</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%AF%84%E4%BC%B0"><span class="toc-text">5 评估</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD"><span class="toc-text">性能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%B0%8F"><span class="toc-text">代码大小</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%BB%93%E8%AE%BA"><span class="toc-text">6 结论</span></a></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/SoftwareEngineering"><i class="tag post-item-tag">SoftwareEngineering</i></a><a href="/tags/SoftwareDebloating"><i class="tag post-item-tag">SoftwareDebloating</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">Software Debloating 论文阅读 (10)</h1><time class="has-text-grey" datetime="2024-03-21T07:33:53.314Z">2024-03-21</time><article class="mt-2 post-content"><h2 id="(10)-occam%3Aautomated-software-winnowing%C2%B7" tabindex="-1">(10) OCCAM:Automated Software Winnowing·</h2>
<p>Malecha G, Gehani A, Shankar N. Automated software winnowing[C],Proceedings of the 30th Annual ACM Symposium on Applied Computing. 2015: 1504-1511.</p>
<p>SAC’15 April 13-17, 2015, Salamanca, Spain<br>
Symposium on Applied Computing 2015</p>
<p><img src="https://github.com/SRI-CSL/OCCAM" alt="开源地址"></p>
<h3 id="0-%E6%91%98%E8%A6%81" tabindex="-1">0 摘要</h3>
<ul>
<li>为了解决代码膨胀问题,我们介绍一个OCCAM工具.
<ul>
<li>OCCAM结合了部分求值和类型理论的技术，旨在减少部署应用中的代码。</li>
<li>OCCAM可以在不对程序源代码进行注释或以其他方式修改的情况下使用。</li>
<li>它利用配置时间信息生成一个根据将要部署的上下文进行专门定制的应用程序版本。</li>
</ul>
</li>
<li>我们介绍了我们的算法、实现和实验评估。</li>
</ul>
<h3 id="1-%E4%BB%8B%E7%BB%8D" tabindex="-1">1 介绍</h3>
<ul>
<li>模块化软件库 通过为图形,文件操作和网络提供 可复用功能,使得编写复杂应用更加容易,然而,为了实现通用性,库往往比应用程序所需要的功能更多
<ul>
<li>如 libpng[10]提供了复杂的接口进行图像转换,但许多都用不到</li>
</ul>
</li>
<li>这个问题也涉及了软件栈的多个层次,由跨层依赖引入的开销
<ul>
<li>如 miniblog[13]运行在PHP上,而PHP历来与libc,libc中许多函数仅被miniblog不使用的PHP代码使用. 这些函数包含在静态链接的二进制文件中,存储在磁盘中,执行期间需要内存,多余的代码甚至会被反向导向编程利用</li>
</ul>
</li>
<li>尽管大多数系统不是资源限制的,但 目前普遍的实现中,即使是 二进制文件中 不用的功能 和共享库也会影响性能,可靠性和安全.
<ul>
<li>为此,我们提出了一种将代码特化到实际使用中并简化掉未使用功能的方法</li>
</ul>
</li>
<li>我们提出了 winnnowing(筛选),一种使用部分求值的静态分析和代码特化工具
<ul>
<li>该过程保留了原始程序的正常语义,即原始程序在指定输入上的行为与精简程序的行为相同</li>
<li>无效的执行,如缓冲区溢出,会以不同方式执行</li>
</ul>
</li>
<li>在基本层次上,程序的功能对应于潜在的执行的适量,如C标准库中的socket函数</li>
</ul>
<pre><code class="language-C">int socket(int domain, int type, int protocol);
</code></pre>
<ul>
<li>该函数接收3个int值,有大量潜在行为,但大多数组合不会被特定程序使用.
<ul>
<li>如Web 服务器通常打开AF_INET和AF_INET6套接字，但不需要AF_APPLETALK或AF_ATMPVC套接字。</li>
<li>Winnowing的目标是从软件堆栈中删除未使用的行为,减少需要分析的代码,同时保留需要的功能</li>
</ul>
</li>
</ul>
<h4 id="%E5%8A%A8%E6%9C%BA" tabindex="-1">动机</h4>
<ul>
<li>
<p>筛选部署二进制文件的4个原因</p>
</li>
<li>
<p><strong>专用服务器</strong>:虚拟机的出现使得 高度专业化的服务器称为常态</p>
<ul>
<li>如Web服务器通常仅托管单个站点,而虚拟机中过于通用的库只会引入代码膨胀,即虚拟机之间的隔离破坏了共享代码的好处</li>
</ul>
</li>
<li>
<p><strong>自定义库</strong></p>
<ul>
<li>在嵌入式平台上,能够简化库,意味着开发人员可以通过删除不用的功能以使用更大更成熟的库.</li>
<li>许多应用程序在提供 编译时配置 来移除大块代码. 然而这种方法又开发者定义而不是使用者,因此对开发人员来说增加了维护不同构建配置的负担</li>
<li>上述方法也无法提供对应用程序获取内容的精确控制
<ul>
<li>如,即使是间接地使用大型组件中的单个函数,也需要整个组件的存在</li>
<li>此外,为管理员增加了工作量,因为他们必须及时更新系统,这会涉及与应用程序无关的补丁,因为很难确定应用程序是否使用了有缺陷的函数,尤其在使用动态语言时</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>简化分析</strong></p>
<ul>
<li>在安全重要的系统中,含有大型库是一种负担</li>
<li>更小的应用程序,较少的配置选项,更少更通用功能的库,更容易进行静态分析.</li>
<li>此外,部分估值的代码通常更简单,使得静态分析对上下文感知更有效</li>
</ul>
</li>
<li>
<p><strong>二进制多样性</strong></p>
<ul>
<li>专用库使得缓冲区溢出更难以利用</li>
<li>PHP等平台在可预测的地方包含相同的功能集</li>
<li>特化每个应用的部署实例,不仅可以移除不需要的功能,还可以移动和改变遗留的功能. 这对剩余功能的攻击更加困难</li>
</ul>
</li>
</ul>
<h4 id="%E8%B4%A1%E7%8C%AE" tabindex="-1">贡献</h4>
<ul>
<li>
<p>我们讨论了简化单个应用程序的思想和方法,我们的方法对所有同质的应用程序是相同的,即所有代码都可以编译成LLVM[7]位码格式的应用程序.</p>
</li>
<li>
<p>我们选择LLVM框架,因为该框架包括几种流行语言的前端,包括C,C++,Java,其有着明确的中间表示,支持静态和动态编译</p>
</li>
<li>
<p>我们的工作提供了以下内容</p>
<ul>
<li>一种用于大幅减少代码功能(包括库和应用程序)的工具. 可以用于实际的大型,工业程序中</li>
<li>一种将外部信息纳入简化过程的模块化方法. 这可以来用执行策略,如&quot;不应调用邮件&quot;或&quot;系统只能用字符串 ls 调用&quot;,类似面向切面的编程</li>
<li>关于 简化 对 二进制大小 和 执行性能 影响的 实质分析. 结果标明,简化的二进制文件在性能上没有额外的开销,根据不同的应用程序可以显著减少二进制文件的大小</li>
<li>一种工具 透明地增强大型软件项目的比那一过程,如Php,SQLite,以生成LLVM为嘛和本机目标文件</li>
</ul>
</li>
</ul>
<h3 id="2-winnowing" tabindex="-1">2 winnowing</h3>
<p>本节介绍了我们的方法的一个实例<br>
2.1 描述筛选一个单独的编译片段,用LLVM调用模块<br>
2.2 描述多模块筛选,使之可在更大的库和动态加载中使用</p>
<h4 id="2.1-%E6%A8%A1%E5%9D%97%E5%86%85%E7%B2%BE%E7%AE%80" tabindex="-1">2.1 模块内精简</h4>
<p><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(10)_1.png" alt></p>
<ul>
<li>LLVM的基本编译单元是模块,对于简单的程序,通常包含在一个单独的模块中,此时可以用上图的方法进行简化程序
<ul>
<li>下面以简化C语言正则表达式库为例(仅使用C进行说明,所有的分析和转换都在LLVM位码上进行)</li>
</ul>
</li>
</ul>
<pre><code class="language-C">int regcomp ( regex_t ∗preg , const char ∗regex ,int cflags )
&#123; /∗ . . . regcomp code . . . ∗/ &#125;
void main ( int argc , char∗ argv[ ] ) &#123;
  regex_t re;
  regcomp (&amp;re,argv[1] , REG_EXTENDED|REG_ICASE ) ;
  . . .
&#125;
</code></pre>
<ul>
<li>
<p>算法过程如下</p>
</li>
<li>
<p><strong>0. 编译</strong>:将源码编译为LLVM位码. 第三部分将讨论我们的工具,他能自动化的构建LLVM位码,通过指导构建Unix系统的脚本,如GNU的自动化工具</p>
</li>
<li>
<p><strong>1. 部分估值</strong>:winnower的核心是部分估值器,由两个阶段组成,winnower交错并迭代执行这两个阶段</p>
<ul>
<li><strong>1.1 优化</strong>:
<ul>
<li>部分求值始于简化代码。其目标是暴露在编译时可确定的常量，消除死代码，并减少已知的控制流。将部分求值器应用于我们的代码片段将减少按位或运算，得到以下结果：<pre><code class="language-C">void main ( int argc , char∗ argv[ ] ) &#123;
  regex_t re;
  regcomp (&amp;re,argv[1] , REG_EXTENDED|REG_ICASE ) ;
  . . .
&#125;
</code></pre>
</li>
<li>正如 Fujita [2] 和 Smowton [12] 所指出的那样，LLVM 优化器的激进性使其成为一个合理的程序内部部分求值器。</li>
<li>我们使用LLVM的 -O3 优化配置文件,包含了一些列简化,如 局数值编号、启发式循环展开、稀疏条件常数传播、常数折叠以及已知函数简化（简化对 libc 函数的调用，如 strlen 和 memcpy）。此优化传递还对局部函数执行一些保守的程序间优化，例如内联小函数和消除未使用的参数。</li>
</ul>
</li>
<li><strong>1.2 特化</strong>
<ul>
<li>优化阶段后,使用启发式方法 更 激进地在跨函数边界进行特化,在这个过程中寻找编译时已知参数的函数调用. 例如,regcomp的最后一个参数指定选项,如不区分大小写或是否支持扩展正则表达式. 该选项在编译时已知,因此可以进行特化,用已知的常量进行替代,删除不需要的参数<pre><code class="language-C">int regcomp ( regex_t ∗preg , const char ∗regex  )
&#123; /∗ . . . regcomp with cflags=3 . . . ∗/ &#125;
</code></pre>
</li>
<li>再将优化运用到这个特化后的函数上,可以通过简化对cflags的分支语句来删除四代码,还有可能将常量推送到其它参数的位置上,进行更进一步地特化</li>
<li>如果原始地使用,这两个阶段的迭代可能会增加代码的大小,但可以通过各种启发式方法来控制这一点.
<ul>
<li>一种启发式方法是仅在未特化版本可以删除时特化函数,这个启发式方法完全对应减少功能的情况,是一种理想情况</li>
<li>实际上,我们发现 需要更激进地进行特化,以揭示有益的低级特化. 我们目前的启发式方法是贪婪的,只要看到一个支持的常量就进行特化,同时忽略可变参数函数.  除了整数之外，我们的专门化过程还支持浮点数、常量字符串、任何类型的空值以及全局变量和函数的地址。</li>
</ul>
</li>
<li><strong>递归</strong>:函数特化的主要困难是调用图中的循环,如果没有递归,我们可以限制特化的数量,因为我们指导LLVM优化器不会无限展开训话,然而,在有递归的情况下,我们必须检测特化何时会发散,考虑如下简单递归函数<pre><code class="language-C">int foo(int start,int end)&#123;
  if(start&gt;end)&#123;return start-end;&#125;
  return foo(start+1,end);
&#125;
int bar(ing x)&#123;
  return foo(1,x);
&#125;
//特化后
int foo_1(int end)&#123;
  if(1&gt;end)&#123;return 1-end;&#125;
  return foo_1(2,end);
&#125;
</code></pre>
<ul>
<li>此时foo_1(2,end)仍然可以特化,此时特化将无法停止,因为不知道end的值. 因此我们当前的实现选择不特化递归函数.</li>
<li>值得注意的是,部分评估器通过实践绑定分析[1,5]解决了这个问题,同时确实存在递归函数的部分评估技术[4]</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>2 消除</strong>:在部分评估稳定,或二进制文件变得过大而无法处理时,我们会删除不再需要的内部全局变量.</p>
<ul>
<li>在优化删除无法访问的代码时,全局变量可能变得没用.如果全局函数被特化,并且其所有被调用的位置都可以被特化的实例替代,则将删除这些全局函数.</li>
<li>我们使用LLVM的三个优化器实现了这个阶段: globaldce, globalopt, strip-dead-prototypes</li>
</ul>
</li>
<li>
<p><strong>3 链接</strong>:在迭代到固定点之后，我们使用 LLVM 工具将精简后的代码链接在一起构建二进制文件。这</p>
</li>
<li>
<p>模块内的简化算法构建了输入模块的语义等效版本，同时努力消除不必要的功能。</p>
</li>
<li>
<p>该算法可应用于任何单个编译单元，包括静态库和共享对象，因为它不通过删除导出的函数或更改其名称或类型来修改外部可见接口（在 LLVM 的抽象层面）。</p>
</li>
<li>
<p>然而，部分评估可能会极大地改变程序的内部结构，使得在代码中未表现的监控行为（如堆栈检查）失效。</p>
</li>
</ul>
<h4 id="2.2-%E6%A8%A1%E5%9D%97%E9%97%B4%E7%B2%BE%E7%AE%80" tabindex="-1">2.2 模块间精简</h4>
<ul>
<li>模块内精简效果好,因为大多数应用程序可以在精简之前通过静态链接库构建为单个模块。,但大型程序必须要与共享库进行交互,因此需要模块间精简</li>
<li>跨模块的精简的难点在于 代码的分离 和 维护兼容的二进制接口. 此外,我们希望特化是可重用的.
<ul>
<li>如,我们会构建标准库的自定义版本,该版本通过仅包含这些应用程序所需的功能来支持多个应用程序。</li>
<li>然后，我们希望能够自动重写客户端应用程序以重用相同的精简库</li>
</ul>
</li>
<li>原理上,我们将模块间精简分为三个任务
<ul>
<li>2.2.1 计算模块间依赖关系,使模块间的独立精简称为可能</li>
<li>2.2.2 对模块进行特化,</li>
<li>2.2.3 根据生成的规范进行重写</li>
<li>2.2.4 封存模块,隐藏其它模块未使用的符号,以便在链接时优化期间消除未使用的函数</li>
</ul>
</li>
<li>简化构成迭代 模块特化和封存 步骤,以产生完整的二进制文件</li>
<li>处于解释目的,我们考虑特化以下简单的代码片段，其中 bar 是在另一个模块中实现的。</li>
</ul>
<pre><code class="language-C">extern void bar(int,int);
int main(int argc, char* argv[])&#123;
  bar(argc,5);
  bar(2,argc);
  return 0;
&#125;
</code></pre>
<h5 id="2.2.1-%E4%BE%9D%E8%B5%96%E8%AE%A1%E7%AE%97" tabindex="-1">2.2.1 依赖计算</h5>
<ul>
<li>核心的组合机制是计算和使用模块的（函数和全局变量）依赖关系。
<ul>
<li>在但模块内 简化时,有bar的代码可以立即特化</li>
<li>此时bar在另一个模块中定义,我们只能将foo记录未客户端模块的依赖</li>
</ul>
</li>
<li>为了对函数进行有意义的特化,我们需要知道关于参数值的信息。我们使用单例类型系统来表达这些信息 [8,16]。
<ul>
<li>单例类型系统支持使用相等谓词对类型进行细化. 例如C 类型系统只能表达变量 x 是整数（int x）。使用单例类型，我们可以细化这个类型，不仅说明 x 是一个整数，而且其值为 5（int=5 x）。因此，我们简单程序的依赖关系如下：<pre><code class="language-C">bar(int=?, int=5)// 使用int=?表示未知的int值
bar(int=2, int=?)
</code></pre>
</li>
</ul>
</li>
<li>为了计算一个模块的依赖项,我们从模块的入口遍历调用图,并寻找外部符号引用.
<ul>
<li>直接引用和调用点很简单；我们确定目标函数并记录信息</li>
<li>间接函数调用和函数指针则更为复杂。我们依赖于 LLVM 工具计算调用图，这些工具采用标准的程序分析技术，如别名分析和控制流和数据流分析。这些分析提高了 OCCAM 解析间接函数调用的能力。
<ul>
<li>当我们无法静态确定调用的目标时，我们必须记录对每个可能的目标函数的最一般化（即未特化）调用。这是因为我们可能在不进行全局代码重写情况下,更改二进制接口。例如，如果代码将 bar 的地址存储在函数指针中，我们必须保守地记录最一般的依赖关系：</li>
</ul>
</li>
<li>在某些情况下，模块内部剔除期间进行的部分评估将简化这个结构，使我们能够静态解析函数。虽然这阻止了进一步的特化，但在一般情况下是不可避免的，例如，当被特化的程序在表中查找函数指针时。</li>
</ul>
</li>
<li>要计算整个应用程序的依赖项，我们从包含程序入口点的模块开始，并遍历代码链接的库，如下图所示。为了处理循环模块依赖的一般情况，我们迭代这个过程，直到后续的依赖计算不产生额外的依赖项<br>
<img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(10)_2.png" alt="image"></li>
</ul>
<h5 id="2.2.2-%E7%89%B9%E5%8C%96" tabindex="-1">2.2.2 特化</h5>
<p><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(10)_3.png" alt="image"></p>
<ul>
<li>特化,使用每个客户模块的依赖性来决定要特化的函数</li>
<li>如上图示,遍历依赖文件中的调用列表，确定是否以及如何特化每个函数。函数特化的工作方式与模块内情况相同</li>
<li>即，复制函数体，删除常量参数，并将它们替换为函数体中。</li>
<li>区别在,与模块内简化不同,我们无法访问函数调用点以重写它们来调用专门的函数. 因此,我们生成了一份重写规范,详细说明客户端如何修改以使用更具体地接口.</li>
<li>以之前bar的特化举例,生成以下重写,此时只需调用一个参数</li>
</ul>
<pre><code class="language-C">&quot;bar&quot;(int=?1, int=5) -&gt; &quot;bar_x_5&quot;(int=?1)
&quot;bar&quot;(int=2, int=?2) -&gt; &quot;bar_2_x&quot;(int=?2)
</code></pre>
<h5 id="2.2.3-%E9%87%8D%E5%86%99" tabindex="-1">2.2.3 重写</h5>
<ul>
<li>特化后,使用重写规范更新客户端模块. 我们遍历所有外部定义函数的调用点,并查找与调用点匹配的最精确的重写,更新调用点以使用新的函数名和参数</li>
<li>例如之前的例子变为</li>
</ul>
<pre><code class="language-C">int main(int argc, char* argv[])&#123;
  bar_x_5(argc);
  bar_2_x(argc);
  return 0;
&#125;
</code></pre>
<ul>
<li>特化步骤不会删除任何未特化的函数,因为不匹配任何规则的调用点将继续调用未专门化的函数</li>
<li>重写本质上与模块内特化修改调用者相同,但需要向模块内添加新的函数原型,并从重写规范中重新读取.</li>
<li>因为我们没有修改通用函数的数显,因此我们可以安全地忽略间接调用和将外部符号存储在变量中</li>
</ul>
<h5 id="2.2.4-%E5%B0%81%E5%AD%98" tabindex="-1">2.2.4 封存</h5>
<ul>
<li>
<p>重写完成后，模块内和跨模块的消除即可等效。在此步骤中，我们将对外部世界没有直接引用的符号变为内部，有效地覆盖了其他模块可以与我们的模块进行交互的漏洞。这允许模块内精简删除不可达代码并更激进地优化函数，因为它可以静态分析所有潜在的调用点。</p>
</li>
<li>
<p>使用我们的接口，封装模块非常简单，如下图所示。我们只需迭代所有外部符号，并将任何未在接口中引用的符号变为内部。值得注意的是，拥有准确的接口对于此步骤的正确性至关重要，因为如果我们尝试在另一个模块中引用内部符号，链接将失败。</p>
</li>
</ul>
<p><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(10)_4.png" alt="image"></p>
<h4 id="2.3-%E5%8A%A8%E6%80%81%E6%A3%80%E6%9F%A5" tabindex="-1">2.3 动态检查</h4>
<ul>
<li>当我们能够在组件中静态确定接口的时候，简化效率最高。</li>
<li>然而在某些情况下，比如通过函数指针进行调用时，确定函数如何调用将会变得困难。例如，在面向对象语言中进行动态分派或在动态语言的解释器中查找函数表时，以下说明一个实例</li>
</ul>
<pre><code class="language-C">extern int (*foo)(int);
extern int (*bar)(int);

void go(bool foobar) &#123;
    int (*f)(int) = foobar ? foo : bar;
    f(2); 
    f(3);
&#125;
</code></pre>
<ul>
<li>此代码中，我们只知道 foo 和 bar 会以参数2，3调用，但重写代码并不简单，因为我们在对f的调用中要实用不同的函数。 在这里，我们必须要构建一个包装函数来检查参数并根据需要调度到特化版本，或者在违反接口时发出错误信号，以保持相同的二进制级别的接口。</li>
<li>这里有两个潜在位置执行动态检查，在调用点或者函数定义处，各有不同的好处</li>
</ul>
<h5 id="2.3.1-%E9%87%8D%E5%86%99%E5%AE%A2%E6%88%B7%E7%AB%AF" tabindex="-1">2.3.1 重写客户端</h5>
<p>第一种选择是重写客户端，即在调用点执行检查。<br>
此时，库只导出特化函数（foo_2 和 foo_3 ），但客户端同时需要非特化的。为此，我们必须通过测试其参数并将其分配到合适的特化函数中来实现通用函数。如在客户端模块实现foo如下</p>
<pre><code class="language-C">extern int foo_2();
extern int foo_3();

inline int foo(int x) &#123;
    if (x == 2) return foo_2(); // foo(2)
    if (x == 3) return foo_3(); // foo(3)
    exit(1);
&#125;
</code></pre>
<ul>
<li>对客户端进行部分估值将导致该调用被内联，并且在x是静态已知的情况下删除条件。对于调用不符合接口的代码，将执行fall-through并发出错误信号</li>
</ul>
<h5 id="2.3.2-%E9%87%8D%E5%86%99%E5%BA%93" tabindex="-1">2.3.2 重写库</h5>
<ul>
<li>另一种选择是重写库中的目标函数，这对于强制执行，无法静态验证的 库的接口很有用<br>
。它还可以在单独模块中进行使用，以解决间接调用的困难那，为此，OCCAM复制了旧的foo实现并进行重写</li>
<li>我们将导出的函数foo替换为一个检查参数的函数（以强制执行foo只能用2，3调用），并相应的进行委托或终止客户端。 由于oldfoo在库中是内部的，有static修饰，模块内的简化将对其进行特化并最终从执行文件中删除通用版本</li>
</ul>
<pre><code class="language-C">int foo(int x) &#123;
    if (x == 2) return oldfoo(2);
    if (x == 3) return oldfoo(3);
    exit(1);
&#125;
static int oldfoo(int x) &#123; /* foo code */ &#125;
</code></pre>
<h3 id="3-%E5%AE%9E%E7%8E%B0" tabindex="-1">3 实现</h3>
<ul>
<li>
<p>我们实现了我们描述的所有技术，并应用于多个实例，以了解在实际应用中实用简化技术的实用性</p>
</li>
<li>
<p>我们的代码作为一组LLVM编译器传递实现的。我们通过一组Python包装器实用LLVM opt程序运行它。这意味着简化的每个简短都会产生一个新的程序文件（或接口文件）。虽然这种方法不如纯C但不实体化中间结果的效率高，但它能够灵活地尝试其它转化和特化的启发式方法，我们的代码发布提供了一个教程，演示了我们如何使用我们的工具对应用程序进行简化</p>
</li>
<li>
<p>为了创建程序的bit码，我们开发了一组脚本来包装现有的构建工具，这是因为大型应用程序的构建过程通常使用各种工具，如autoconf，libtool，cmake，make。 虽然这些工具支持各种平台和配置，但不支持将LLVM bit码作为目标架构</p>
</li>
<li>
<p>为了与检查依赖项的现有构建脚本集成，我们的工具将每个命令翻译成两个命令（如调用gcc或ld）。</p>
<ul>
<li>第一个编译产生一个修改的版本来获取LLVMbit码</li>
<li>第二个生成ELF标准版本，生成ELF对象确认构建成功，并确保所有的依赖选项都存在。</li>
</ul>
</li>
<li>
<p>虽然在构建速度方面不太理想，但我们的脚本相当健壮，能够编译大型程序和库，如PHP，SQLite，uClibc</p>
</li>
</ul>
<h3 id="4-%E4%BE%8B%E5%AD%90%E7%A0%94%E7%A9%B6" tabindex="-1">4 例子研究</h3>
<ul>
<li>
<p>首先回顾我们的目标</p>
</li>
<li>
<p>首先，我们希望减少代码的功能，但这不一定意味着代码的减少；相反，它可能意味着减少可能的执行次数，复制一个函数会增加代码大小，但不会增加复杂性。同样地。在一个参数上特化一个函数，可以通过限制传递的值来减少其可能的行为。为了衡量这一点，我们可以查看应用程序在简化前后的调用图。</p>
</li>
<li>
<p>次要目标是代码大小的减少和配置复杂性。</p>
<ul>
<li>大型库支持在粗粒度上启用功能，例如PHP中支持MySQL。</li>
<li>简化为库用户提供了一种自动化方式，来精确地选择它们想要地功能。为衡量这一点，我们可以将简化与现有技术进行比较，例如使用库地静态链接（仅使用存档中的必要对像）</li>
</ul>
</li>
<li>
<p>我们的例子研究包括两个web服务器，nweb[3],thttpd[9],及两个web应用程序使用的PHP解释器</p>
</li>
</ul>
<h4 id="nweb" tabindex="-1">nweb</h4>
<ul>
<li><strong>nweb</strong>是一个静态内容Web服务器，只有200多行C代码，它的大小和架构并不是简化的理想对象（小且配置少），但其可以展示简化的实际效果。 因为nweb仅依赖于libc，且非常简单，uClibc足以满足它的需求 （libc和uClibc都是C标准库，但uClibc是面向嵌入式系统的轻量级库）</li>
<li>由于nweb通过命令行进行配置，我们根据我们希望提供的参数对main函数进行特化。为此我们使用命令<code>nweb 8080 /root</code> 告诉nweb监听端口并从root提供文件<br>
<img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(10)_5.png" alt="image"></li>
<li>上图展示了简化对nweb调用图的影响，图中的粗灰色框表示特化的函数。 简化前有27个函数，简化后只有17个，其余10个被特化或内联到11个不同的函数中，每个特化都减少了至少一个参数。这些特化包括
<ul>
<li>
<ol>
<li>log函数被复制了三次，每次都因不同的状态可以打印日志。通用函数已被删除，特化实例的部分求值去除了怪异的控制流，变成straight-line code程序（只有顺序结构），使其可以直接调用sprint，open，write</li>
</ol>
</li>
<li>
<ol start="2">
<li>libc中设置socket的函数（bind，listen和socket）每个被特化为处理TCP请求。其中socket函数最有趣，被特化为 面向 Internet（AF_NET） 和 面向流的socket（SOCK_STREAM）</li>
</ol>
</li>
<li>
<ol start="3">
<li>libc中处理软件中断的函数（signal）被特化两次以处理SIGCHLD和SIGHUP，这些特化可以使得其他工具可以轻松地确认程序仅以有限的方式响应中断</li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="thttpd" tabindex="-1">thttpd</h4>
<ul>
<li><strong>thttpd</strong>是另一个考虑的Web服务器。其有许多功能，约8500行C代码，支持CGI，在启动时使用chroot，在内存中缓存，使用htpasswd身份验证。除了核心的libc功能外，thttpd还连接到libcrypt以保护其.htpasswd文件，httpd可以在运行时通过命令行参数配置，也可以在编译时使用一个头文件进行配置，该头文件同构一组49个宏控制代码生成。这些宏包括我们希望在简化中公开的，如.htpasswd的路径存储在AUTH_FIL宏中</li>
<li>对thttpd进行简化会产生125个特化函数，主要分为三类
<ul>
<li>定时器创建（tmr_create）的特化：所有这些调用都会被特化，包括在计时器到期时运行的函数指针。 这可以防止数据攻击。</li>
<li>缓冲区分配（httpd_realloc_str）:一个调用扩展了用于存储标头的缓冲区大小，该调用对前领个参数进行了特化，因为二者都是全局变量的地址 。<code>httpd_realloc_str(&amp;header, &amp;maxheader, sizeof(headerstr) + strlen(realm) + 3);</code></li>
<li>错误代码的特化。 因为我们的特化框架不支持可变参数函数，因此我们无法特化错误函数中对 snprintf的调用。 然而，常量的传播可以进行，因此，可以通过额外的特化来注入这些常量所需的特化</li>
</ul>
</li>
</ul>
<h4 id="php" tabindex="-1">PHP</h4>
<ul>
<li>PHP [14] 是一个用于网站的流行编程语言。它附带了一个庞大的标准库，涵盖了从简单的字符串和日期操作到像chroot这样的POSIX系统调用的各种功能。这种“一揽子式”方法对于快速启动新应用程序非常有用。同时，这也为攻击提供了广泛的攻击面，特别是对于使用eval的应用程序。为了解决这个问题，我们可以对托管应用程序不需要的 PHP 运行时功能进行剪裁。</li>
<li>为了演示这一点，我们构建了一个minblog[13]专用的PHP解释器，这是一个用PHP编写的小型博客框架。我们用我们的工具链自动地构建PHP解释器的LLVM二进制位码。在编译后，我们需要确定miniblog需要的接口，这里有两个复杂问题
<ul>
<li>
<ol>
<li>首先PHP以文本形式提供给PHP解释器，这意味着我们无法使用LLVM通道来确定运行应用程序所需要的接口。PHP的静态评估超出了本文的范围。因此我们使用正则表达式来捕捉与PHP函数调用语法相对应的文本模式。之后，我们人工地检查结果，这个过程可以由语义的静态分析和在程序运行时记录跟踪的工具来替代。即便使用这些工具，我们认为由手动审核此列表仍然是有用的，以查看底层系统所依赖的内容。</li>
</ol>
<ul>
<li>从静态分析我们可以确定miniblog依赖于PHP标准库中地52个函数，包括包括字符串和文件操作以及 MySQL 函数。为了比较，我们编译了可以使用 PHP 的编译选项配置的最小解释器（包括 PHP 标准库和 MySQL 扩展）的解释器。这包含 1029 个函数，包括可能危险的函数，如 system 和 mail。一些被消除的函数包含过去 PHP 版本中的漏洞（CVE-2011-1148 和 CVE-2010-2191）。这些漏洞在已经进行了精简的 PHP 部署中将不再存在。</li>
</ul>
</li>
<li>
<ol start="2">
<li>第二个问题是PHP解释器的架构。PHP解释器讲库函数实现存储在一个可以动态调度的表中。因此，通过此表中的函数进行的所有调用都太过保守，所有函数都有可能是目标。即使我们可以使用类似 Smowton [12] 开发的技术将 PHP 代码拉入部分评估期间，使用 LLVM 优化器很难实现解决通过此表调用所需的部分评估。取而代之的是，我们注意此表的结构并使用第 2.3 节中描述的技术修改函数。在标准的 PHP 解释器中，每个库例程 Xxx 都在函数 zif_Xxx 中实现。因此，我们可以轻松编写钩子，将未使用的函数重写为错误。</li>
</ol>
</li>
</ul>
</li>
<li>对简化miniblog，生成了997个形如<code>zif_system(?) =&gt; fail</code>的重写，处于审计和调试的目的，我们实现fail函数时记录了违规的函数调用</li>
</ul>
<h3 id="5-%E8%AF%84%E4%BC%B0" tabindex="-1">5 评估</h3>
<h4 id="%E6%80%A7%E8%83%BD" tabindex="-1">性能</h4>
<ul>
<li>
<p>我们比较了使用专门化和不使用专门化构建的每个服务器在请求率上的表现，以了解运行时的影响。</p>
</li>
<li>
<p>性能以每秒请求数来衡量，用于提供单个小型静态页面。</p>
</li>
<li>
<p>为了控制网络带宽，我们在 localhost:8080 上执行了测试。</p>
</li>
<li>
<p>我们使用 Apache 基准测试工具 ab 来生成请求。</p>
</li>
<li>
<p>我们运行了 40 次试验，每次对服务器进行 5000 次请求。</p>
</li>
<li>
<p>测试在一台轻度负载的 Intel Core 2 四核桌面上运行，时钟频率为 2.4 GHz，配备 4 GB 的 RAM 和 Linux 2.6.38，并使用 TuxOnIce 补丁集</p>
</li>
<li>
<p>为了进行公平比较，基线在链接之前使用LLVM-O3进行优化，两个版本都静态链接到uClibc-0.9.32，使用OCCAM构建并使用uClibc构建的标准配置选项进行优化（使用-O2）。</p>
</li>
<li>
<p>下图显示了nweb和thttpd的比较结果<br>
<img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(10)_6.png" alt="image"></p>
</li>
<li>
<p>nweb中差异在样本中变化较大，不具有统计意义</p>
</li>
<li>
<p>thttpd中，简化版本在95%的置信度上高于基线版本。这种性能改善可能有两个原因造成</p>
<ul>
<li>简化使用-O3作为其部分求值器，而标准配置使用-O2。这种差异可能会导致简化版本的代码更快。</li>
<li>函数的复制暴露了常量，创造了更多的编译时优化机会</li>
</ul>
</li>
</ul>
<h4 id="%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%B0%8F" tabindex="-1">代码大小</h4>
<ul>
<li>我们在简化中使用的激进特化策略导致httpd模块大小增加了45%，如下图示，这是部分评估技术已知的问题，其中大部分由于报错函数特化参数的复制引起的。这个问题可以使用更保守地启发式搜索解决，如果产生了显著的差异，其只会保留一个特化，</li>
</ul>
<p><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(10)_7.png" alt="image"></p>
<ul>
<li>libcrypt和libc模块的二进制大小在简化后几乎没有增加，这是因为大多数函数都是叶子例程（例如字符串操作）或它们立即调用操作系统。因此，在这些单独的模块中，很少有机会内联或特化函数。额外的大小是由于对库的特化调用减去了静态链接器引入，但thttpd模块未使用的额外函数和常量。在高度优化的低级别库中，这些都不是显著的，因为档案中的每个对象通常只定义了最小数量的函数。</li>
</ul>
<p><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(10)_8.png" alt="image"></p>
<ul>
<li>许多常见的库，如libc，通常被编译为共享对象（或系统等效物），而不是静态链接。正常的共享对象包含整个库，与这样的库动态链接的任何应用程序都会引入大量不相关的功能。通过在构建共享对象之前应用精简，我们可以大大减少这种情况。</li>
</ul>
<p><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(10)_9.png" alt="image"></p>
<ul>
<li>图9展示了应用第4节技术于PHP的结果。
<ul>
<li>min表示使用PHP编译配置选项可以构建的最小PHP模块。它的大小为5.5 MB，其中4.0 MB（用虚线标记）是解释器（没有导出的PHP函数）。剩下的1.5 MB是标准库。</li>
<li>+mysql表示添加了MySQL支持的二进制文件。它需要额外的4%存储（不包括MySQL库）。</li>
<li>+mysql-sys是添加了一个策略以阻止对11个危险的PHP函数的调用后的二进制文件。</li>
<li>miniblog表示在对miniblog的接口进行精简之后得到的解释器版本。在模块内精简之后，LLVM比特码的大小从5.8 MB缩小到4.2 MB，减少了27%；这只比核心解释器大5.5%。从精简中减小PHP解释器二进制大小的效果类似于我们在thttpd案例中看到的libc共享对象的最小化（如图8所示）。</li>
</ul>
</li>
</ul>
<h3 id="6-%E7%BB%93%E8%AE%BA" tabindex="-1">6 结论</h3>
<ul>
<li>我们开发了OCCAM工具,用于将应用程序特化到其部署环境</li>
<li>我们解释了为什么我们的工具可以精确地从应用程序中移除功能</li>
<li>我们还认为,少量的手动工作可以用于解决优于信息的不完整引起的困难(如,不知道解释器正在运行的程序或不精确的别名分析)</li>
</ul>
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><em></em><a class="button is-default" href="/2024/03/21/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/SoftwareDebloating/Software%20Debloating%20%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB(8)/" title="Software Debloating 论文阅读 (8)"><span class="has-text-weight-semibold">Next: Software Debloating 论文阅读 (8)</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="Haojen/Claudia-theme-blog" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/Mrcold2002"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Mr_cold 2024</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>
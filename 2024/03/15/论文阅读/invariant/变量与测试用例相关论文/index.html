<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>不变量与测试用例相关论文</title><meta name="description" content="菜"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="1 Counterexample-Guided Directed Fuzzing via Likely Invariant Inference

引用：Huang H, Zhou A, Payer M, et al. Everything is Good for Something: Counterexample-Guided Directed Fuzzing via Likely Invariant Inference[C], 2024 IEEE Symposium on Security and Privacy (SP). IEEE Computer Society, 2024: 142-142.
CCF A S&amp;amp;P , IEEE Symposium on Security and Privac.."><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Mr_cold's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">不变量与测试用例相关论文</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-counterexample-guided-directed-fuzzing-via-likely-invariant-inference"><span class="toc-text">1 Counterexample-Guided Directed Fuzzing via Likely Invariant Inference</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1.0-%E6%91%98%E8%A6%81"><span class="toc-text">1.0 摘要</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1.1-%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.1 实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1.2-%E7%9B%B8%E5%85%B3%E5%B7%A5%E4%BD%9C%EF%BC%9A%E4%B8%8D%E5%8F%98%E9%87%8F%E6%8E%A8%E6%96%AD"><span class="toc-text">1.2 相关工作：不变量推断</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-the-oracle-problem-in-software-testing:-a-survey"><span class="toc-text">2 The Oracle Problem in Software Testing: A Survey</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2.0-%E6%91%98%E8%A6%81"><span class="toc-text">2.0 摘要</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2.1-%E9%87%8D%E8%A6%81%E5%86%85%E5%AE%B9"><span class="toc-text">2.1 重要内容</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#derived-test-oracles-%E6%B4%BE%E7%94%9F%E6%B5%8B%E8%AF%95oracle"><span class="toc-text">DERIVED TEST ORACLES 派生测试Oracle</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#system-executions-%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C-&-invariant-detection"><span class="toc-text">System Executions 系统运行 &amp; Invariant Detection</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-the-use-of-likely-invariants-as-feedback-for-fuzzers"><span class="toc-text">3 The use of likely invariants as feedback for fuzzers</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3.0-%E6%91%98%E8%A6%81&%E4%BB%8B%E7%BB%8D"><span class="toc-text">3.0 摘要&amp;介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3.1-%E4%B8%BB%E8%A6%81%E5%86%85%E5%AE%B9"><span class="toc-text">3.1 主要内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3.2-%E5%AE%9E%E7%8E%B0"><span class="toc-text">3.2 实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-automated-patch-correctness-assessment:-how-far-are-we"><span class="toc-text">4 Automated patch correctness assessment: How far are we</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text"></span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-1"><span class="toc-text"></span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-2"><span class="toc-text"></span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-3"><span class="toc-text"></span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-4"><span class="toc-text"></span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-5"><span class="toc-text"></span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-6"><span class="toc-text"></span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#combined-static-and-dynamic-automated-test-generation"><span class="toc-text">Combined static and dynamic automated test generation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-7"><span class="toc-text"></span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-8"><span class="toc-text"></span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-9"><span class="toc-text"></span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#from-daikon"><span class="toc-text">From Daikon</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#a-survey-on-automatic-test-data-generation-1999-8%E9%A1%B5"><span class="toc-text">A Survey on Automatic Test Data Generation 1999 8页</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/InVariant"><i class="tag post-item-tag">InVariant</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">不变量与测试用例相关论文</h1><time class="has-text-grey" datetime="2024-03-14T16:40:54.798Z">2024-03-15</time><article class="mt-2 post-content"><h2 id="1-counterexample-guided-directed-fuzzing-via-likely-invariant-inference" tabindex="-1">1 Counterexample-Guided Directed Fuzzing via Likely Invariant Inference</h2>
<ul>
<li>引用：Huang H, Zhou A, Payer M, et al. Everything is Good for Something: Counterexample-Guided Directed Fuzzing via Likely Invariant Inference[C], 2024 IEEE Symposium on Security and Privacy (SP). IEEE Computer Society, 2024: 142-142.</li>
<li>CCF A S&amp;P , IEEE Symposium on Security and Privacy</li>
<li><a target="_blank" rel="noopener" href="https://www.researchgate.net/profile/Heqing-Huang-14/publication/377767294_Everything_is_Good_for_Something_Counterexample-Guided_Directed_Fuzzing_via_Likely_Invariant_Inference/links/65b786ab1bed776ae3138790/Everything-is-Good-for-Something-Counterexample-Guided-Directed-Fuzzing-via-Likely-Invariant-Inference.pdf">链接</a></li>
</ul>
<h3 id="1.0-%E6%91%98%E8%A6%81" tabindex="-1">1.0 摘要</h3>
<ul>
<li>定向模糊测试输入许多都无关。本文提出通过限制输入来增加达到目标位置的输入产量，关键见解是通从可达和不可达的执行输入中推断出可能的不变量，以限制后续输入生成的搜索空间并产生更多可达的输入。此外，提出两种策略，最小化不必要的输入比例名进行高效的不变量推理</li>
<li>本文贡献总结
<ul>
<li>
<ol>
<li>提出利用已执行的输入动态推断可能的不变量，以限制后续输入生成的搜索空间，从而加速定向模糊测试中的漏洞重现过程</li>
</ol>
</li>
<li>
<ol start="2">
<li>设计了两种新颖的选择策略，以提高输入生成的效率，有效地减少了生成的不相关输入的比例</li>
</ol>
</li>
<li>
<ol start="3">
<li>我们提供了实证证据证明我们的方法比SOTA定向模糊器更高效，有效</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="1.1-%E5%AE%9E%E7%8E%B0" tabindex="-1">1.1 实现</h3>
<ul>
<li>使用Dig: A dynamic invariant generator for polynomial and array invariants不变量推断引擎，采用的模板不变式包括常数检查、涉及单个变量的下界检查以及多个变量之间的线性不等式依赖关系（这是现在动态不变量推断技术常用模板）</li>
</ul>
<pre><code class="language-Java">Algorithm 1 Counterexample-guided Directed Fuzzing
Require: Seeds S, Target t
1: repeat
2:      s, I_use ← ChooseNext(S) //I_use为使用的不变量
3:      if I_use = ∅ or I_use is not effective then
4:          Sreach, Sunreach ← InputSelect(s, t) (§3.2)
5:          Ireach ← InvInfer(Sreach)
6:          Iunreach ← InvInfer(Sunreach)
7:          I_use ← InvSelect(Ireach, ¬Iunreach) (§3.3)
8:      end if
9:      Inputnew ← Sample(I_use)
10:     Tracing(Inputnew)
11:     Havoc&amp;Splice(s)
12: until Timeout is reached
</code></pre>
<h3 id="1.2-%E7%9B%B8%E5%85%B3%E5%B7%A5%E4%BD%9C%EF%BC%9A%E4%B8%8D%E5%8F%98%E9%87%8F%E6%8E%A8%E6%96%AD" tabindex="-1">1.2 相关工作：不变量推断</h3>
<ul>
<li>DySy [37] 利用符号执行和模糊测试来推断可能的模板不变量。</li>
<li>iDiscovery [28] 利用中间的符号状态进行增量不变量推断以提高不变量的准确性</li>
<li>MRI [38] 将推理过程建模为搜索问题，并使用挖掘方法来获得精确的不变量。</li>
<li>Dig [26] 依赖于来自反例的执行反馈来剪除不变量的不可行性范围，并逐渐提高精度。</li>
<li>在Halo中使用的不变量推断引擎利用了上述技术的见解来实现更高的效率。到目前为止，还没有现有工作关注优化给定输入的质量[28]，这是影响不变量推断效果的关键因素之一。相反，Halo利用模糊器作为输入生成器来提高不变量的精度，并最终增强用于模糊测试的输入生成。</li>
</ul>
<h2 id="2-the-oracle-problem-in-software-testing%3A-a-survey" tabindex="-1">2 The Oracle Problem in Software Testing: A Survey</h2>
<ul>
<li>引用：Barr E T, Harman M, McMinn P, et al. The oracle problem in software testing: A survey[J]. IEEE transactions on software engineering, 2014, 41(5): 507-525.</li>
<li>CCF A TSE</li>
<li><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=6963470">链接</a></li>
</ul>
<h3 id="2.0-%E6%91%98%E8%A6%81" tabindex="-1">2.0 摘要</h3>
<ul>
<li>
<p>本文提供了对测试预言问题的当前方法的全面调查，以及在这一重要的软件测试研究和实践领域的分析趋势。</p>
</li>
<li>
<p>在软件测试的许多工作中，我们试图将测试过程尽可能地自动化，以使测试更快、更便宜和更可靠。为此，我们需要一个测试预言，这是一种能够区分被测系统（System under Testing SUT）的正确行为和错误行为的. 然而，目前程序自动化测试预言的问题关注的少</p>
</li>
<li>
<p>如何利用测试预言（test oracle）来自动化地验证被测系统（SUT）的行为是否符合预期，有以下两种情况</p>
<ul>
<li>如果SUT的开发遵循了良好的测试设计原则，并且有详细正式的规范描述了预期行为，那么测试预言的成本问题可以通过自动化的测试语言解决，无需人工干预</li>
<li>如果SUT没有完整的规范，但存在部分规范，可以构建一个部分测试预言来回答某些输入的问题。这种部分测试预言可以使用形态测试（metamorphic testing）来构建（基于已知的期望行为之间的关系），或者从执行或文档中推导出神谕信息。</li>
</ul>
</li>
<li>
<p>在工业界，普遍没有完整的规范，因此测试人员需要为所有测试用例手动检查系统行为，此时，自动化测试方法必须人工解决oracle成本问题。本文旨在通过提供对测试预言问题的现有文献的全面回顾和分析，帮助应对这一挑战。</p>
</li>
<li>
<p>我们为解决测试预言问题的四个广泛类别的解决方案绘制了增长趋势，我们在第4、5、6和7节中对这些进行了调查。这四个类别包括：</p>
<ul>
<li>可以指定测试预言的方法（第4节）；</li>
<li>可以派生测试预言的方法（第5节）；</li>
<li>可以从隐性信息构建测试预言的方法（第6节）；以及</li>
<li>没有可用的自动化预言，但仍然可以减少人类努力的情况（第7节）。</li>
<li>最后，第8节以结束语作为结论。</li>
</ul>
</li>
</ul>
<h3 id="2.1-%E9%87%8D%E8%A6%81%E5%86%85%E5%AE%B9" tabindex="-1">2.1 重要内容</h3>
<h4 id="derived-test-oracles-%E6%B4%BE%E7%94%9F%E6%B5%8B%E8%AF%95oracle" tabindex="-1">DERIVED TEST ORACLES 派生测试Oracle</h4>
<ul>
<li>指通过各种工件（如，文档，系统运行）或 北侧系统的属性或其它版本的信息中区分系统的正确与错误行为。</li>
</ul>
<h4 id="system-executions-%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C-%26-invariant-detection" tabindex="-1">System Executions 系统运行 &amp; Invariant Detection</h4>
<ul>
<li>系统执行跟踪可以用来派生测试oracle,或者通过将不正确的执行与预期执行对齐降低人工测试成本</li>
<li>接下来讨论从系统运行跟踪中的两种技术： 不变量检测和规范挖掘</li>
<li>不变量检测在计算上可能是昂贵的，因此采用了增量[22]、[171]和轻量级静态分析[39]、[63]。一份技术报告总结了各种动态分析技术[157]。模型推断[90]、[187]也可以被视为一种不变量生成的形式，其中不变量被表达为一个模型（通常是一个FSM）。Ratcliff等人使用基于搜索的软件工程(SBSE) [84]来寻找不变量，[153]由突变测试指导。</li>
</ul>
<h2 id="3-the-use-of-likely-invariants-as-feedback-for-fuzzers" tabindex="-1">3 The use of likely invariants as feedback for fuzzers</h2>
<ul>
<li>引用：Fioraldi A, D’Elia D C, Balzarotti D. The use of likely invariants as feedback for fuzzers[C], 30th USENIX Security Symposium (USENIX Security 21). 2021: 2829-2846.</li>
<li>CCF A USENIX Security</li>
<li><a target="_blank" rel="noopener" href="https://www.usenix.org/system/files/sec21-fioraldi.pdf">链接</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/eurecom-s3/invscov">代码</a></li>
</ul>
<h3 id="3.0-%E6%91%98%E8%A6%81%26%E4%BB%8B%E7%BB%8D" tabindex="-1">3.0 摘要&amp;介绍</h3>
<ul>
<li>模糊测试是发现软件错误的很有效的方法，一个主要限制是目前流行的基于覆盖率引导的模糊测试优化了对程序不同部分的访问，担当仅凭可达性不可以触发漏洞时，就会遇到困难。</li>
<li>本文提出一种反馈机制，通过考虑程序变量之间的通常值和关系来增强代码覆盖。谓词，我们在基本块级别学习可能的不变量，并划分程序状态空间。我们的反馈机制可以区分输入何时违反了一个或多个不变量并对其进行建立，从而改进代码覆盖通常提供的程序状态相似。</li>
<li>我们在一个名为INVSCOV的原型上使用了我们的技术，该原型基于LLVM和AFL++基础上进行开发。</li>
<li>我们的实验表明，与使用纯代码覆盖反馈的模糊器相比，我们的方法可以发现更多且不同类型的错误。</li>
<li>本文贡献：
<ul>
<li>一种新的反馈机制，结合了控制流和从挖掘的不变量中抽象出的程序状态；</li>
<li>基于LLVM和AFL++的我们方法的一个原型实现，名为INVSCOV；</li>
<li>针对经典和上下文敏感的边覆盖率，对我们方法的有效性进行了评估。</li>
</ul>
</li>
</ul>
<h3 id="3.1-%E4%B8%BB%E8%A6%81%E5%86%85%E5%AE%B9" tabindex="-1">3.1 主要内容</h3>
<ul>
<li>
<p>我们从一组测试用例语料库开始，就像在实际情况下的真实应用程序一样，这些测试用例不能代表所有的应用状态，然后我们修改fuzzer使其对偏离初始语料库的不变量的行为更加敏感。</p>
</li>
<li>
<p>我们这么做的直觉是：此时，不变量代表的是执行的属性，而不是程序本身的属性。</p>
</li>
<li>
<p>设计三类不变量剪枝原则</p>
<ul>
<li>
<ol>
<li>舍弃不可能违反的不变量</li>
</ol>
</li>
<li>
<ol start="2">
<li>舍弃结合了不相关变量的不变量</li>
</ol>
</li>
<li>
<ol start="3">
<li>当不变量重叠时，舍弃更弱的不变量</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="3.2-%E5%AE%9E%E7%8E%B0" tabindex="-1">3.2 实现</h3>
<ul>
<li>
<p>使用LLVM [43]和DAIKON [25]可能不变式系统进行基于不变式的模糊测试。</p>
</li>
<li>
<p>分为两个阶段</p>
<ul>
<li><strong>学习阶段</strong>：记录进行不变量挖掘所需要的有关程序状态的信息，通过在增强的程序上运行输入来实现。输入可从集中方式获得（我们的实验中从24小时覆盖率引导的模糊测试会话生成的种子）。不变量挖掘使用Daikon，由于我们的技术应用于基本块级别，故不变量计算成本线性依赖于基本块的数量</li>
<li><strong>插桩阶段</strong>：随后将可能的不变式信息编码到程序函数中，以将它们暴露给覆盖率引导的模糊器。我们转换后的程序可以在任何基于AFL的模糊器上开箱即用。</li>
</ul>
</li>
<li>
<p>状态不变量学习：修改Daikon使用适配LLVM IR（有点工作）</p>
</li>
</ul>
<h2 id="4-automated-patch-correctness-assessment%3A-how-far-are-we" tabindex="-1">4 Automated patch correctness assessment: How far are we</h2>
<ul>
<li>引用：Wang S, Wen M, Lin B, et al. Automated patch correctness assessment: How far are we?[C]//Proceedings of the 35th IEEE/ACM International Conference on Automated Software Engineering. 2020: 968-980.</li>
<li>CCF A ASE</li>
<li><a target="_blank" rel="noopener" href="https://dl.acm.org/doi/abs/10.1145/3324884.3416590">链接</a></li>
</ul>
<h2 id tabindex="-1"></h2>
<p>P. Sagdeo, N. Ewalt, D. Pal, and S. Vasudevan, “Using automatically<br>
generated invariants for regression testing and bug localization,” in Proc.<br>
IEEE/ACM 28th Int. Conf. Automated Softw. Eng., 2013, pp. 634–639.</p>
<h2 id="-1" tabindex="-1"></h2>
<p>H. Ye, M. Martinez, T. Durieux, and M. Monperrus, “A comprehensive<br>
study of automatic program repair on the quixbugs benchmark,” in Proc.<br>
IEEE 1st Int. Workshop Intell. Bug Fixing, 2019, pp. 1–10</p>
<h2 id="-2" tabindex="-1"></h2>
<p>J. Yang, A. Zhikhartsev, Y. Liu, and L. Tan, “Better test cases for better<br>
automated program repair,” inProc. 11th Joint Meeting Found. Softw. Eng.,<br>
2017, pp. 831–841.</p>
<h2 id="-3" tabindex="-1"></h2>
<p>Gordon Fraser and Andrea Arcuri. 2011. Evosuite: automatic test suite generationfor object-oriented software. InESEC/FSE. 416–419.</p>
<h2 id="-4" tabindex="-1"></h2>
<p>Z. Y. Ding, Y. Lyu, C. Timperley, and C. L. Goues, “Leveraging program<br>
invariants to promote population diversity in search-based automatic program repair</p>
<h2 id="-5" tabindex="-1"></h2>
<p>G. Yang, C. S. Pas˘ areanu, and S. Khurshid, “Memoized symbolic ˘<br>
execution,” in Proceedings of the 2012 International Symposium on<br>
Software Testing and Analysis, 2012, pp. 144–154.</p>
<h2 id="-6" tabindex="-1"></h2>
<p>D. Schuler, V. Dallmeier, and A. Zeller. EfficientMutation Testing by Checking Invariant Violations. InISSTA ’09, pages 69–80. ACM, 2009</p>
<h2 id="combined-static-and-dynamic-automated-test-generation" tabindex="-1">Combined static and dynamic automated test generation</h2>
<ul>
<li>引用：Zhang S, Saff D, Bu Y, et al. Combined static and dynamic automated test generation[C]//Proceedings of the 2011 international symposium on software testing and analysis. 2011: 353-363.</li>
<li>CCF A ISSTA</li>
<li><a target="_blank" rel="noopener" href="https://dl.acm.org/doi/epdf/10.1145/2001420.2001463">链接</a></li>
</ul>
<h2 id="-7" tabindex="-1"></h2>
<p>J. Zhang, J. Chen, D. Hao, Y. Xiong, B. Xie, L. Zhang, and H. Mei,<br>
“Search-based inference of polynomial metamorphic relations,” in<br>
Proceedings of the 29th ACM/IEEE International Conference on<br>
Automated Software Engineering, ser. ASE ’14. New York, NY,<br>
USA: Association for Computing Machinery, 2014, p. 701–712.<br>
[Online]. Available: <a target="_blank" rel="noopener" href="https://doi.org/10.1145/2642937.2642994">https://doi.org/10.1145/2642937.2642994</a></p>
<h2 id="-8" tabindex="-1"></h2>
<p>动态检测到的不变量还可以帮助删除无意义的测试（违反前提条件）并推断何时失败（违反后置条件）[23]<br>
C. Pacheco, M.D. Ernst, Eclat: Automatic generation and classification of test inputs, ECOOP (2005) 504–527</p>
<h2 id="-9" tabindex="-1"></h2>
<p>S. Artzi, M. D. Ernst, A. Kiezun, C. Pacheco, and J. H. Perkins, _<br>
“Finding the needles in the haystack: Generating legal test inputs<br>
for object-oriented programs,” in Proc. 1st Workshop Model-Based<br>
Testing Object-Oriented Syst., Oct. 23, 2006.</p>
<h2 id="from-daikon" tabindex="-1">From Daikon</h2>
<p>例如用于测试选择和优先级排序；更多的覆盖度量指标会产生更好的测试套件[21,22]</p>
<p>M. Harder, J. Mellen, M.D. Ernst, Improving test suites via operational abstraction, ICSE (2003) 60–71.<br>
T. Xie, D. Notkin, Tool-assisted unit test selection based on operational violations, ASE (2003) 40–48.</p>
<h2 id="a-survey-on-automatic-test-data-generation-1999-8%E9%A1%B5" tabindex="-1">A Survey on Automatic Test Data Generation 1999 8页</h2>
<p><a target="_blank" rel="noopener" href="https://faculty.cc.gatech.edu/~harrold/6340/cs6340_fall2009/Readings/test.data.genration.survey.pdf">https://faculty.cc.gatech.edu/~harrold/6340/cs6340_fall2009/Readings/test.data.genration.survey.pdf</a></p>
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2024/03/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/invariant/%E4%B8%8D%E5%8F%98%E9%87%8F%E4%BB%A3%E8%A1%A8%E5%8A%9F%E8%83%BD%E8%83%BD%E5%8A%9B%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" title="不变量代表功能能力相关论文阅读"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: 不变量代表功能能力相关论文阅读</span></a><a class="button is-default" href="/2024/03/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/invariant/daikon%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/" title="daikon使用"><span class="has-text-weight-semibold">Next: daikon使用</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="Haojen/Claudia-theme-blog" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/Mrcold2002"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Mr_cold 2024</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>
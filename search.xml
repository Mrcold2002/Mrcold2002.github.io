<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>编译原理（未完）</title>
      <link href="/2023/03/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
      <url>/2023/03/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/meitu/3.jpg"></p><p>[toc]</p><p>主要参考<a href="https://www.bilibili.com/video/BV1cE411f78c/?spm_id_from=333.999.0.0&amp;vd_source=240b8edf72530a8ec2d9f48cc6514072">视频</a></p><h2 id="01-编译器与解释器简介"><a href="#01-编译器与解释器简介" class="headerlink" title="01 编译器与解释器简介"></a>01 编译器与解释器简介</h2><p>编译器：编译器编译源代码生成可执行代码<br>解释器：解释器通过源代码和数据直接生成输出<br>最早的解释器： 1953年John Backus的“Speedcodeing”<br>和大多数解释器一样，其优点是编程难度下降，但运行速度慢10-20倍<br>但John Backus在“Speedcoding”中获得了灵感，在之后的1954-1957年开发出FORTRAN，这是第一个高级语言及编译器。之后在1958年有一半的程序都用该语言来实现。<br>直到今日现代编译器依旧保留了FORTRAN的框架</p><ol><li>Lexical Analysis 词法分析</li><li>Parsing 句法分析</li><li>Semantic Analysis 语义分析</li><li>Optimization</li><li>Code Generation</li></ol><p>1和2主要是Syntactic语法方面，<br>3更关心语义方面，如Types类型和scope作用域规则<br>4优化，让程序运行更快或使用更少的内存<br>5将程序转换为其它语言</p><h2 id="02-编译器结构"><a href="#02-编译器结构" class="headerlink" title="02 编译器结构"></a>02 编译器结构</h2><ol><li>Lexical Analysis 词法分析<br>词法分析的目标是将程序代码文本按照它的方式进行分词，即编译器对词的区分</li><li>Parsing 句法分析：图解句子结构<br>确认每个单词在这个句子中担任的角色，然后再进行语法分析</li><li>Semantic Analysis 语义分析<br>编译器所能做的语义分析十分有限，因为人类尚且不知为何能理解句子；<br>通常对于编辑器，他只能试图找出那些矛盾的地方，并报告这些错误，但不知道程序想要做什么</li><li>Optimization 优化<br>优化是希望代码使用更少得资源（时间，空间，耗电量，网络信息传递次数，数据库访问次数）</li><li>Code Generation 代码生成<br>从高级语言转化为汇编语言</li></ol><p>以前的编译器：<br>复杂的L，P，占比小的S，较复杂的O，CG<br>现在的编译器：<br>占比小的L，P，复杂的S，非常复杂的O，占比小的CG</p><h2 id="03-编程语言的性价比-The-Economy-of-PL"><a href="#03-编程语言的性价比-The-Economy-of-PL" class="headerlink" title="03 编程语言的性价比(The Economy of PL)"></a>03 编程语言的性价比(The Economy of PL)</h2><ul><li><p>为什么有这么多的编程语言(Why are there so many programming languages?)<br>众口难调，不同的编程语言实现不同的需求。例：</p><ul><li>科学计算领域：需要很好的浮点数运算能力，好的数组结构能力，一定的并行化能力。FORTRAN语言</li><li>商业应用领域：需要好的可持续能力，报告生成能力，数据分析能力。SQL语言</li><li>系统编程领域：需要好的资源控制能力，时间控制能力。C/C++.</li></ul></li></ul><p>很难在一种编程语言中达到全部的需求，更很难达到最佳。</p><ul><li><p>为什么有新的编程语言(Why are there new programming languages?)<br>新的编程语言的出现与培训成本(在一个新的语言的流行花费中占主要部分)应该是成反比的？<br>猜想：</p><ul><li>使用广泛的编程语言很难去做出改变</li><li>而一门新的编程语言可以更轻易地去做出改变</li><li>因此随着技术地进步，一定会有新的编程语言的出现去填补空缺</li><li>同时，一般新的编程语言都比较像老的编程语言：一是创新点很难想出，二是为了降低培训成本，如JAVA的一些语法很像C++</li></ul></li><li><p>什么是一个好的编程语言(What os a good programming languages?)</p></li></ul><p>在语言通用性上没有一个能达到很好的语言</p><ul><li>总结<ul><li>很难设计一个系统包含所有功能</li><li>一个编程语言的发展过程中，培养该语言的程序员占了主要成本</li></ul></li></ul><h2 id="04"><a href="#04" class="headerlink" title="04"></a>04</h2>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件分析（未完）</title>
      <link href="/2023/03/07/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"/>
      <url>/2023/03/07/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/meitu/6.jpg"></p><p>本笔记参考<a href="https://www.bilibili.com/video/BV1b7411K7P4/?spm_id_from=333.337.search-card.all.click&amp;vd_source=240b8edf72530a8ec2d9f48cc6514072">视频</a></p><h2 id="01介绍"><a href="#01介绍" class="headerlink" title="01介绍"></a>01介绍</h2><ol><li>PL and Static Analysis</li><li>Why We Learn Static Analysis?</li><li>What is Static Analysis?</li><li>Static Analysis Features and Examples</li><li>Teaching Plan</li><li>Evaluation Criteria</li></ol><h3 id="1-PL-and-Static-Analysis"><a href="#1-PL-and-Static-Analysis" class="headerlink" title="1 PL and Static Analysis"></a>1 PL and Static Analysis</h3><p>PL：Programming Languages程序语言</p><h3 id="2-Why-We-Learn-Static-Analysis"><a href="#2-Why-We-Learn-Static-Analysis" class="headerlink" title="2 Why We Learn Static Analysis?"></a>2 Why We Learn Static Analysis?</h3><h3 id="3-What-is-Static-Analysis"><a href="#3-What-is-Static-Analysis" class="headerlink" title="3 What is Static Analysis?"></a>3 What is Static Analysis?</h3><h3 id="4-Static-Analysis-Features-and-Examples"><a href="#4-Static-Analysis-Features-and-Examples" class="headerlink" title="4 Static Analysis Features and Examples"></a>4 Static Analysis Features and Examples</h3><h3 id="5-Teaching-Plan"><a href="#5-Teaching-Plan" class="headerlink" title="5 Teaching Plan"></a>5 Teaching Plan</h3><h3 id="6-Evaluation-Criteria"><a href="#6-Evaluation-Criteria" class="headerlink" title="6 Evaluation Criteria"></a>6 Evaluation Criteria</h3><h2 id="02"><a href="#02" class="headerlink" title="02"></a>02</h2>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库试验--PostgreSQL源码分析--遗传算法的使用</title>
      <link href="/2023/03/06/%E6%95%B0%E6%8D%AE%E5%BA%93PostgreSQL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2023/03/06/%E6%95%B0%E6%8D%AE%E5%BA%93PostgreSQL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><p><img src="/images/meitu/5.jpg"></p><p><a href="https://github.com/postgres/postgres.git">源码地址</a></p><h2 id="1-PostgreSQL的体系结构"><a href="#1-PostgreSQL的体系结构" class="headerlink" title="1 PostgreSQL的体系结构"></a>1 PostgreSQL的体系结构</h2><p>PostgreSQL数据库由连接管理系统(系统控制器)、编译执行系统、存储管理系统、事务系统、系统表五大部分组成</p><ul><li>连接管理系统接受外部操作对系统的请求，对操作请求进行预处理和分发，起系统逻辑控制作用</li><li>编译执行系统由查询编译器、查询执行器组成，完成操作请求在数据库中的分析处理和转化工作，最终实现物理存储介质中数据的操作</li><li>存储管理系统由索引管理器、内存管理器、外存管理器组成，负责存储和管理物理数据，提供对编译查询系统的支持;</li><li>事务系统囱事务管理器、日志管理器、并发控制、锁管理器组成，日志管理器和事务管理器完成对操作请求处理的事务一致性支持，锁管理器和并发控制提供对并发访问数据的一致性支持</li><li>系统表是 PostgreSQL 数据库的元信息管理中心，包括数据库对象信息和数据库管理控制信息,系统表管理元数据信息，将 PostgreSQL 数据库的各个模块有机地连接在一起，形成个高效的数据管理系统。</li></ul><h2 id="2-PostgreSQL的查询编译阶段中的遗传算法"><a href="#2-PostgreSQL的查询编译阶段中的遗传算法" class="headerlink" title="2 PostgreSQL的查询编译阶段中的遗传算法"></a>2 PostgreSQL的查询编译阶段中的遗传算法</h2><p>查询处理器是数据库管理系统中的一个部件集合，它允许用户使用 SQL 语言在较高层次上表达查询，其主要职责是将用户的各种命令转化成数据库上的操作序列并执行。查询处理分查询编译和查询执行两个阶段。</p><p>当PostgreSQL 的后台服务进程接收到查询语句后，首先将其传递到查询分析模块，进行词法、语法和语义分析 若是简单的命令(例如建表、创建用户、备份等)则将其分配到功能性命令处理模块;</p><p>对于复杂的命令( SELECT/INSERT/DELETEl UPDA四)则要为其构建查询树( Query 结构体) .然后交给查询重写模块。查询重写模块接收到查询树后，按照该查询所涉及的规则和视图对查询树进行重写，生成新的查询树。</p><p>生成路径模块依据重写过的查询树，考虑关系的访问方式、连接方式和连接顺序等问题，采用动态规划算法或遗传算法，生成最优的表连接路径 最后，由最优路径生成可执行的计划，并将其传递到查询执行模块执行。</p><p>因此PG中的遗传算法的使用主要在生成最优的表链接路径上</p><h2 id="3-查询规划的总体流程"><a href="#3-查询规划的总体流程" class="headerlink" title="3 查询规划的总体流程"></a>3 查询规划的总体流程</h2><p>查询规划的最终目的是得到可被执行器执行的最优计划，整个过程可分为预处理、生成路径和生成计划三个阶段。</p><ul><li>预处理实际上是对查询树( Query 结构体)的进一步改造，这种改造可通过 SQL语句体现。在此过程中，最重要的是提升子链接和提升子查询。</li><li>在生成路径阶段，接收到改造后的查询树后，采用动态规划算法或遗传算法，生成最优连接路径和候选的路径链表。</li><li>在生成计划阶段，用得到的最优路径 首先生成基本计划树，然后添加 GROUPBY HAVING ORDER BY 子句所对应的计划节点形成 整计划树</li></ul><h2 id="4-路径生成算法"><a href="#4-路径生成算法" class="headerlink" title="4 路径生成算法"></a>4 路径生成算法</h2><p>路径代表了对一个表或者多个表中数据的访问方式。</p><p>由于单个表的访问方式(顺序访问、索引访问)、两个表间的连接方式(嵌套循环连接、归并连接、 Hash 连接)以及多个表间的连接顺序(左连接、右连接和布希连接)都有多种，因此访问 表或多个袤的路径也会有多种，</p><p>每个路径都可能是上述访问方式、连接方式和连接顺序的一种组合。查询执行模块只需要执行效率最高的路径。因此在准备计划时，查询规划器需要考虑所有的路径，并从中挑选出最优的路径来生成执行计划，这个生成并挑选最优路径的工作由路径生成算法完成</p><p>PostgreSQL 中有两种路径生成算法:动态规划算法和遗传算法。</p><p>动态规划算法是生成路径的默认算法，但在某些情况下，检查一个查询所有可能的路径会花去很多的时间和内存空间，特别是所要执行的查询涉及大量的关系的时候。在这种情况下，为了在合理的时间里判断一个合理的执行计划， PostgreSQ 将使用遗传算法生成路径。</p><p>是否启用遗传算法由两个因素决定:</p><ul><li>在系统配置中是否允许使用遗传算法：由全局变量enable_geqo控制，其值来自于配置文件中的 geqo 配置项，默认情况下是允许。</li><li>需要连接的基本关系是否超过使用遗传算法的阈值：由全局变量geqo_threshold 控制，其值来自于配置文件中的geqo_threshold配置选项，<br>默认值是 12 ，即参加连续的基本关系数大于或等于 12 时就会采用遗传算法来生成路径</li></ul><h2 id="5-遗传算法概述"><a href="#5-遗传算法概述" class="headerlink" title="5 遗传算法概述"></a>5 遗传算法概述</h2><p>遗传算法 (GA) 是一种种启发式的优化方法 (heuristic optimization method) ，它通过既定的随机搜索进行操作。</p><p>优化问题的可能解的集合被认为是个体(individuals)组成的种群(population).一个个体对它的环境的适应程度由它的适应值(fitness) 。一个个体在搜索空间里的参照物是用染色体(chromosomes)表示的,实际上这是一套字符串。一个基因(gene)是染色体的一个片段，基因是被优化的单个参数的编码。对一个基因的典型的编码 以是二进制 (binary)或整数(integer)。通过仿真进化过程的重组(recombination)、变异(mutation) 和选择(selection )找到新一代的搜索点，它们的平均适应值要比它们的祖先好。</p><p>在PostgreSQL中，遗传算法将路径作为个体，将个体以某种方式编码(个体体现了连接顺序),然后通过重组得到后代，考虑连接代价来计算后代的适应值，再选择合适的后代进行下一次迭代。当到达一定的迭代次数之后，遗传算法终止。选择遗传算法可以减少生成路径的时间，但是遗传算法并不一定能找到”最好”的规划，它只能找到相对较优的路径。</p><h2 id="6-PostgreSQL中的遗传算法"><a href="#6-PostgreSQL中的遗传算法" class="headerlink" title="6 PostgreSQL中的遗传算法"></a>6 PostgreSQL中的遗传算法</h2><p>PostgreSQ 中，遗传算法主要用在连接路径的生成操作中，其流程如下：</p><p><img src="/images/PostgreSQL/GA_process.jpg" alt="GA_process"></p><h3 id="（1）个体编码方式及种群初始化"><a href="#（1）个体编码方式及种群初始化" class="headerlink" title="（1）个体编码方式及种群初始化"></a>（1）个体编码方式及种群初始化</h3><p>PG中用遗传算法解决表连接的问题的方式类似于TSP问题。可能的连接路径被当作整数串进行编码。v每个穿代表查询中的一种可能的连接顺序。</p><p>如下图的查询书可以用整数串<code>&quot;4132&quot;</code>编码,即首先连接表”4”和”1” 得到的结果表再和表 “3” 连接，最后再和”2” 连接。</p><p><img src="/images/PostgreSQL/查询树1.jpg" alt="查询树"></p><p>遗传算法执行第一步为随机初始化种群。假设种群大小为n，首先随机初始化n个排列树，每一个排列数即是一个个体。然后基于n各排列数生成的基本表的连接路径，在此过程中进行代价评估，将最后的代价作为适应值衡量该个体的优劣。</p><p>每一个个体都用Chromosome结构表示，记录了个体的排列和代价</p><pre><code class="lang-c">typedef int Gene;typedef struct Chromosome&#123;    Gene *string;//染色体的数据值    Cost worth;//对染色体的代价评估&#125;//Chromosome</code></pre><h3 id="（2）适应值"><a href="#（2）适应值" class="headerlink" title="（2）适应值"></a>（2）适应值</h3><p>个体的适应值等于该个体中N个表的连接代价。适应值计算由geqo_eval实现，包括以下步骤：</p><ol><li>检查个体的有效性</li><li>确定个体的连接次序以及连接方式</li><li>计算个体的适应值</li></ol><p>计算个体的适应值时.首先要检查个体是否有效。也就是说，对一个给定的个体，能不能把这个个体中的表按照某种次序连接起来，因为有些表之间是不能连接的。如果一个个体按任何次序都不能连接，那么这么个体是无效的。对于有效的个体，还要确定连续次序和连接方式。在连接次序和连接方式确定之后才能计算个体的</p><h3 id="（3）父体选择策略"><a href="#（3）父体选择策略" class="headerlink" title="（3）父体选择策略"></a>（3）父体选择策略</h3><p>附体选择策略是基于排名的选择策略，选择概率函数如下公式。<br>其中max是个体总数，bias默认值是2.0，geo_rand是0.0~1.0之间的随机数，f(geo_rand)表示当前个体在种群中的编号（该编号是根据当前个体的适应值在种群中的排名来确定）。<br>该函数表明，排名越前的个体被选择的概率越大。</p><script type="math/tex; mode=display">f(geo\_rand)=\left\{\begin{array}{rcl}max*\frac{bias-A}{2*bias-1}&& {A<0}\\max*\frac{bias-\sqrt{A}}{2*bias-1}&& {A\geq 0}\\其中,A=bias*bias-4*(bias-1)*geo\_rand\end{array} \right.</script><h3 id="（4）杂交算子"><a href="#（4）杂交算子" class="headerlink" title="（4）杂交算子"></a>（4）杂交算子</h3><p>PostgreSQL 中的遗传算法提供 边重组杂交、部分匹配杂交、循环杂交、基于位置的杂交和顺序杂交等多种杂交算子，用于从父辈种群中产生新的后代个体，默认使用的是边重组杂交算法</p><h4 id="a-边重组杂交"><a href="#a-边重组杂交" class="headerlink" title="a 边重组杂交"></a>a 边重组杂交</h4><p>边重组杂交算子自函数gimme_edge_table和gimme_tour实现。函数 gimme_edge_table 用来计算边关系;函数 gimme_tour由边关系得到后代。<br>边重组杂交过程如下：</p><ol><li>两个父体中的基因构成循环队列<br><img src="/images/PostgreSQL/GA_ERX.jpg" alt="查询树"></li><li>确定父体间的边关系<br>在步骤1中的循环队列中，任意一个基因和相邻的基因构成“边关系”。如果某“边关系”同时在父体1和父体2中出现，则称为“共享边”。</li><li>由边关系得到后代<br>边重组杂交的基本思想是:随机地选择一个基因作为起始点，顺着它的边关系找到下一<br>个基因(优先考虑共享边) ，再顺着找到的基因的边关系找到第三个基因，直到找到的基因能够构成一个个体为止，最后将找到的基因按找到的顺序组成一个个体即可。</li></ol><h4 id="b-部分匹配杂交"><a href="#b-部分匹配杂交" class="headerlink" title="b 部分匹配杂交"></a>b 部分匹配杂交</h4><p>由函数pmx实现，该函数流程如下：</p><ol><li>在字串上均匀随机地选择两点，由这两点确定的子串称为映射段，定义两个整型变量left和right(left&lt; right) 表示选取的映射段的起始边界。</li><li>用父体2的映射段替换父体1的映射段产生原始后代。</li><li>确定两映射段之间的映射关系</li><li>根据映射关系将后代合法化</li></ol><h4 id="c-循环杂交"><a href="#c-循环杂交" class="headerlink" title="c 循环杂交"></a>c 循环杂交</h4><p>循环杂交算子由函数 cx 实现，该方法从一个双亲中取一些基因，而其他的基因则取自另外一个双亲。</p><p>该方法首先随机确定一个初始位置，作为当前位置，把父体1当前位置下的基因(即编<br>号)赋值给当前位置下的子代，并标记此基因已被使用 然后推进当前位置到父体2当前位置(未修改前的位置)下的基因在父体1中的位置，同样把父体1当前位置下的基因赋值给当前位置下的子代。<br>同理推进当前位置，生成子代的基因片段，直到循环到初始位置下父体1的基因与父体2中的当前位置下的基因一样时循环结束。如果循环结束后仍有部分基因没有被使用，则将父体2中的这些基因按在父体2中存在的位置赋值到子代中同样位置。</p><h4 id="d-基于位置的杂交"><a href="#d-基于位置的杂交" class="headerlink" title="d 基于位置的杂交"></a>d 基于位置的杂交</h4><p>基于位置的杂交算子由函数 px 实现，该函数的处理流程如下:</p><ol><li>根据基因数目 gene ，首先随机选择一个区间[gene/3 , 2/3 * gene ]中的整数p,从父体1中随机选择p个基因，设为集合A</li><li>对于在A中的基因，从父体1拷贝到后代中对应的位置上。</li><li>不在A中的基因，按它们在父体2中的顺序拷贝到后代剩余的位置上。</li></ol><h4 id="e-顺序杂交ox1"><a href="#e-顺序杂交ox1" class="headerlink" title="e 顺序杂交ox1"></a>e 顺序杂交ox1</h4><p>顺序杂交算子有两种：OX1和OX1。OX1算子由函数 ox1 实现，函数 oxl 的处理流程如下:</p><ol><li>从第一个父体中随机选择一个子串。</li><li>将子串复制到一个空串的相应位置，产生一个原始后代。</li><li>删去第二个父体中子串已有的基因，得到原始后代需要的其他基因的顺序。</li><li>按照这个基因顺序，从左到右将这些基因复制到后代的空缺位置上。</li></ol><h4 id="f-顺序杂交ox2"><a href="#f-顺序杂交ox2" class="headerlink" title="f 顺序杂交ox2"></a>f 顺序杂交ox2</h4><p>OX2 算子由函数ox2实现，其处理流程如下:</p><ol><li>根据基因的数目 gene ，随机选择一个 [gene/3 , 2/3 * gene] 之间的整数 ，从父体1中随机选择p个基因，设为集合A</li><li>对于父体2中不在A中基因，拷贝到后代对应的位置中。</li><li>对在A中的基因，按它们在父体 中的顺序依次拷贝到后代剩余的位中。</li></ol><h3 id="（5）变异算子"><a href="#（5）变异算子" class="headerlink" title="（5）变异算子"></a>（5）变异算子</h3><p>变异算子由函数geqo_mutation实现，该函数随机地从父体中产生两个变异位，交换这两个变异位的数值，执行num_gene(基因数目)次这样的操作。</p><h3 id="（6）终止条件"><a href="#（6）终止条件" class="headerlink" title="（6）终止条件"></a>（6）终止条件</h3><p>遗传算法采用设定演化代数的方法，但演化到一定数量的代数时，就停止演化。默认的演化代数是种群的大小(pool_size ，缓冲池的大小)。演化代数的计算涉及下面两个参数:</p><ol><li>geqo_effort :整型变量，是用于限制种群大小的影响因子。取值范围是 [1 10 ]，默认值为5</li><li>geqo_pool_size :整型变量 ，表示缓冲池(用于存储种群中的个体)大小.缓冲池的大小和种群大小相同， 其值至少为2</li></ol><p>种群大小(缓冲池的大小) pool_size 由函数伊gimme_pool_size 确定，其参数 nr_rel 为查询中表的数量。计算方法如下:</p><ol><li>计算上限值 maxsize和下限值minsize<script type="math/tex; mode=display">maxsize=50*geqo_effort\\minsize=10*geqo_effort</script></li><li>计算基准大小$size=pow(2.0,nr_rel+1.0)$</li><li>如果基准大小位于上限值和下限值之间，则取基准大小作为种群大小;如果低于下限值，则取下限值;如果高于上限值，则取上限值</li></ol><h3 id="（7）基于排列生成路径"><a href="#（7）基于排列生成路径" class="headerlink" title="（7）基于排列生成路径"></a>（7）基于排列生成路径</h3><p>在遗传算法中由排列生成连接路径由以下算法实现</p><p><img src="/images/PostgreSQL/GA_creat_path.jpg" alt="GA_creat_path"></p><p>其中变量rels中保存了按照排列数所对应的各个基本关系（即基本表）。<br>变量rels_temp用来保存当前不可连接的关系。（不可连接指只能用笛卡尔积进行连接）</p><p>该算法的处理过程：</p><p>依次取rels中的所有基本表，在rels_temp中依次寻找可以与其连接的表，如果存在可连接的表，则把这两个表进行连接生成新的表，并从头开始继续在rels_temp中寻找可连接的表，并将其与新生成的表连接，一直到找不到可连接的表位置，最后将最终生成的新表插入rels_temp结尾；继续在rels中取下一个表，重复上述过程。</p><h2 id="7-源码分析"><a href="#7-源码分析" class="headerlink" title="7 源码分析"></a>7 源码分析</h2><h3 id="源码目录分析"><a href="#源码目录分析" class="headerlink" title="源码目录分析"></a>源码目录分析</h3><p>access文件夹包含各种存储访问方法、索引的实现。(重要)<br>bootstrap文件夹为数据库初始化时调用方法。<br>catalog文件夹为系统目录。<br>commands文件夹为SQL命令。(重要)<br>executor文件夹为执行器相关代码。(重要)<br>foreign文件夹为FDW相关代码，使得用户可以通过SQL访问没有存储在数据库中的数据。(扩展)<br>jit文件夹为Just-In-Time Compilation，为即时编译的相关代码，用于提高查询语句性能。（扩展）<br>lib文件夹为通用函数。<br>libpq文件夹为c/cpp的库函数，处理与客户端的通信。<br>main文件夹为主程序。<br>nodes文件夹为链表、节点等数据结构，以及相关的方法。(重要)<br>optimizer文件夹为优化器相关代码。(重要)<br>parser文件夹为编译器相关代码。(重要)<br>partitioning文件夹为分片相关代码。(重要)<br>po文件夹为语言文件配置。<br>port文件夹为平台兼容性处理相关代码。<br>postmaster文件夹为postmaster进程，以及相关辅助进程的代码。<br>regex文件夹为正则处理相关代码。(重要)<br>replication文件夹为有关流复制的相关代码。(重要)<br>rewrite文件夹为规则与视图相关的重写处理。<br>snowball文件夹为全文检索相关（语干处理）代码。<br>statisics文件夹为收集统计信息相关代码，与估算相关。<br>storage文件夹为管理各种类型存储系统相关代码。(重要)<br>tcop文件夹为postgres服务进程的主要处理部分，即查询流程调用的相关代码。(重要)<br>tsearch文件夹为全文检索。(扩展)<br>utils文件夹为各种支持函数，如错误报告、各种初始化操作、内存管理等。</p><p>我的分析任务：PG中遗传算法的使用分析</p><p>在文件src/backend/optimizer/geqo中为<code>遗传优化计划器</code></p><h3 id="src-backend-optimizer目录分析"><a href="#src-backend-optimizer目录分析" class="headerlink" title="src/backend/optimizer目录分析"></a>src/backend/optimizer目录分析</h3><p>该目录下的文件使用解析器返回的查询结构，生成执行器使用的计划。</p><p>/plan目录生成实际的输出计划<br>/path目录生成所有可能的连接表的方法<br>/geqo目录下位单独的“遗传优化”计划器<br>/prep目录处理特殊情况下的预处理步骤<br>/util目录下为公用的模块</p><h3 id="geqo下的代码具体分析"><a href="#geqo下的代码具体分析" class="headerlink" title="geqo下的代码具体分析"></a>geqo下的代码具体分析</h3><h4 id="1-geqo-main-c"><a href="#1-geqo-main-c" class="headerlink" title="(1) geqo_main.c"></a>(1) geqo_main.c</h4><p>其中共有三个函数</p><ul><li><p><code>RelOptInfo * geqo(PlannerInfo *root, int number_of_rels, List *initial_rels)</code><br>  该函数为遗传算法优化的主函数，通过调用该函数来用遗传算法生成查询计划。<br>  该函数有三个参数</p><ul><li><code>root</code>：PlannerInfo 结构体包含有关正在优化的查询的各种信息，包括涉及的表、连接条件以及可能相关的任何约束或索引。遗传算法使用此信息生成潜在查询计划并评估其适合度。</li><li><code>number_of_rels</code>：这个整数表示正在优化的关系数，即查询中涉及的表数。</li><li><code>initial_rels</code>：这是一个 RelOptInfos 的 List，表示正在优化的初始关系。</li></ul></li></ul><p>函数返回一个指向 RelOptInfo 结构体的指针，该结构体表示遗传算法找到的最佳查询计划。</p><p>随后该函数依次完成：</p><p>初始化数据；获得随机数种子；设置GA相关参数；为缓冲池分配空间；随机初始化缓冲池；并按适应值对缓冲池中的个体进行排序；为重组杂交进行空间分配；进行遗传算的迭代，依次进行选择重组变异；选择最优个体；释放空间；返回最优个体。</p><p>该函数为遗传算法的主要部分，main函数。</p><ul><li><code>static int gimme_pool_size(int nr_rel)</code><br>该函数用于确定缓冲池大小（种群大小）</li><li><code>static int gimme_number_generations(int pool_size)</code><br>从该函数得到迭代次数</li></ul><h4 id="2-geqo-misc-c"><a href="#2-geqo-misc-c" class="headerlink" title="(2) geqo_misc.c"></a>(2) geqo_misc.c</h4><p>该文件下函数主要进行调试使用，对算法中间的结果进行输出</p><ol><li><code>static double avg_pool(Pool *pool)</code><br>返回平均代价值</li><li><code>void print_pool(FILE *fp, Pool *pool, int start, int stop)</code><br>输出当前种群中所有个体的染色体和代价</li><li><code>void print_gen(FILE *fp, Pool *pool, int generation)</code><br>输出某一代基因的最好，最坏，中位数和平均代价值</li><li><code>void print_edge_table(FILE *fp, Edge *edge_table, int num_gene)</code><br>输出边重组杂交的边表</li></ol><h4 id="3-geqo-mutation-c"><a href="#3-geqo-mutation-c" class="headerlink" title="(3) geqo_mutation.c"></a>(3) geqo_mutation.c</h4><p>只有一个函数，对种群中的个体实施变异操作<br><code>void geqo_mutation(PlannerInfo *root, Gene *tour, int num_gene)</code></p><h4 id="4-geqo-pool-c"><a href="#4-geqo-pool-c" class="headerlink" title="(4) geqo_pool.c"></a>(4) geqo_pool.c</h4><p>该文件中包含与缓冲区的相关函数</p><ol><li><code>Pool * alloc_pool(PlannerInfo *root, int pool_size, int string_length)</code><br>为遗传算法缓冲器分配空间</li><li><code>void free_pool(PlannerInfo *root, Pool *pool)</code><br>释放1函数中分配的空间</li><li><code>voidrandom_init_pool(PlannerInfo *root, Pool *pool)</code><br>随机初始化缓冲池</li><li><code>void sort_pool(PlannerInfo *root, Pool *pool)</code><br>从小到大按适应度排序缓冲池中的个体</li><li><code>static int compare(const void *arg1, const void *arg2)</code><br>排序的方法，源码中使用快速排序算法</li><li><code>Chromosome * alloc_chromo(PlannerInfo *root, int string_length)</code><br>为个体分配空间</li><li><code>void free_chromo(PlannerInfo *root, Chromosome *chromo)</code><br>释放为个体分配的空间</li><li><code>void spread_chromo(PlannerInfo *root, Chromosome *chromo, Pool *pool)</code><br>插入一个新的个体到缓冲池中，代替缓冲池中的最差的个体</li></ol><h4 id="5-geqo-random-c"><a href="#5-geqo-random-c" class="headerlink" title="(5) geqo_random.c"></a>(5) geqo_random.c</h4><p>该文件用来产生随机数，含有三个函数</p><ol><li><code>void geqo_set_seed(PlannerInfo *root, double seed)</code><br>设置GEQO随机数生成器的种子，以确保每次运行GEQO时使用相同的随机数序列</li><li><code>double geqo_rand(PlannerInfo *root)</code><br>函数使用了简单的线性同余算法来生成伪随机数。该函数返回一个范围在 0 到 1 之间的双精度浮点数</li><li><code>int geqo_randint(PlannerInfo *root, int upper, int lower)</code><br>函数的作用是生成一个介于 upper 和 lower 之间的随机整数。</li></ol><h4 id="6-geqo-selection-c"><a href="#6-geqo-selection-c" class="headerlink" title="(6) geqo_selection.c"></a>(6) geqo_selection.c</h4><p>该文件内进行父体选择</p><ol><li><code>static int linear_rand(PlannerInfo *root, int pool_size, double bias)</code><br>该函数实现线性随机选择算法,使用了类似于概率密度函数的方法，其中偏差参数用于增加某些候选项被选择的概率,用于选择父代来产生后代。</li><li><code>void geqo_selection(PlannerInfo *root, Chromosome *momma, Chromosome *daddy,Pool *pool, double bias)</code><br> 该函数使用随机选择过程来选择两个父染色体进行交叉。</li></ol><h4 id="7-geqo-copy-c"><a href="#7-geqo-copy-c" class="headerlink" title="(7) geqo_copy.c"></a>(7) geqo_copy.c</h4><p>该文件内只有一个函数<code>void geqo_copy(PlannerInfo *root, Chromosome *chromo1, Chromosome *chromo2,int string_length)</code>,用来复制个体</p><h4 id="8-几个杂交算子文件"><a href="#8-几个杂交算子文件" class="headerlink" title="(8) 几个杂交算子文件"></a>(8) 几个杂交算子文件</h4><ul><li>geqo_cx.c 循环杂交<br>包含函数<code>int cx(PlannerInfo *root, Gene *tour1, Gene *tour2, Gene *offspring,int num_gene, City * city_table)</code></li><li>geqo_erx.c 边重组杂交,包含以下函数<ul><li><code>Edge * alloc_edge_table(PlannerInfo *root, int num_gene)</code>为边表分配空间</li><li><code>void free_edge_table(PlannerInfo *root, Edge *edge_table)</code>释放边表空间</li><li><code>float gimme_edge_table(PlannerInfo *root, Gene *tour1, Gene *tour2, int num_gene, Edge *edge_table)</code>填充记录两个个体间的边的数据结构</li><li><code>static int gimme_edge(PlannerInfo *root, Gene gene1, Gene gene2, Edge *edge_table)</code>从给定基因中构建一条边并将其加入边表</li><li><code>int gimme_tour(PlannerInfo *root, Edge *edge_table, Gene *new_gene, int num_gene)</code>通过边表和基因返回一条可行的路径长度</li><li><code>static void remove_gene(PlannerInfo *root, Gene gene, Edge edge, Edge *edge_table)</code>从边表中移除该基因</li><li><code>static Gene gimme_gene(PlannerInfo *root, Edge edge, Edge *edge_table)</code>从给定的边表中返回一个基因</li><li><code>static Gene edge_failure(PlannerInfo *root, Gene *gene, int index, Edge *edge_table, int num_gene)</code>当遇到失败的边缘时，对基因进行修复</li></ul></li><li>geqo_pmx.c 部分匹配杂交<br>包含函数<code>void pmx(PlannerInfo *root, Gene *tour1, Gene *tour2, Gene *offspring, int num_gene)</code></li><li>geqo_ox1.c 顺序杂交1<br><code>void ox1(PlannerInfo *root, Gene *tour1, Gene *tour2, Gene *offspring, int num_gene,City * city_table)</code></li><li>geqo_ox1.c 顺序杂交2<br><code>voidox2(PlannerInfo *root, Gene *tour1, Gene *tour2, Gene *offspring, int num_gene, City * city_table)</code></li><li>geqo_px.c 基于位置的杂交<br><code>void px(PlannerInfo *root, Gene *tour1, Gene *tour2, Gene *offspring, int num_gene,City * city_table)</code></li></ul><h4 id="9-geqo-eval-c"><a href="#9-geqo-eval-c" class="headerlink" title="(9) geqo_eval.c"></a>(9) geqo_eval.c</h4><p>该文件对查询树进行估价</p><ul><li><code>Cost geqo_eval(PlannerInfo *root, Gene *tour, int num_gene)</code><br>返回一个个体的查询树的代价</li><li><code>RelOptInfo * gimme_tree(PlannerInfo *root, Gene *tour, int num_gene)</code>接收一个查询优化器（PlannerInfo）的指针和一组遗传算法的基因（Gene），然后返回一个查询优化树（RelOptInfo）。</li><li><code>static List * merge_clump(PlannerInfo *root, List *clumps, Clump *new_clump, int num_gene,bool force)</code>作用是合并一个新的数据块（new_clump）到一个包含多个数据块的列表中（clumps），并返回合并后的列表。参数 num_gene 表示数据块中基因的数量，而参数 force 用于控制是否强制进行合并。</li><li><code>static bool desirable_join(PlannerInfo *root,RelOptInfo *outer_rel, RelOptInfo *inner_rel)</code>用于确定是否应该对两个关系进行连接，这两个关系分别由 outer_rel 和 inner_rel 表示，其确定连接是否可行是基于多个因素，如连接的预估成本和选择性等</li></ul><h4 id="10-geqo-recombination-c"><a href="#10-geqo-recombination-c" class="headerlink" title="(10) geqo_recombination.c"></a>(10) geqo_recombination.c</h4><p>该文件为杂交重组程序，包含以下函数</p><ul><li><code>void init_tour(PlannerInfo *root, Gene *tour, int num_gene)</code>随机生成一条合法的“旅行推销员”路径（即每个点仅访问一次）</li><li><code>City * alloc_city_table(PlannerInfo *root, int num_gene)</code>为城市表分配内存</li><li><code>void free_city_table(PlannerInfo *root, City * city_table)</code>为城市表回收内存</li></ul><h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8 总结"></a>8 总结</h2><p>本次数据库实验我主要对PostgreSQL源码中的遗传算法部分进行了分析，分析了源码中该部分的具体函数，并了解了遗传算法在PG中的工作流程，如果之后有空，希望能研习全部的PG源码。</p><p>源码中遗传算法用于寻找最优的生成路径，这一点与TSP问题相似。</p><p>当点数过多时，使用动态规划难以求出最优解，这时就可以使用遗传算法较快地求出较优解来生成路径，提升了查询编译地速度。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统试验--在linux环境下复现操作系统（未完）</title>
      <link href="/2023/03/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%95%E9%AA%8C/"/>
      <url>/2023/03/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%95%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/meitu/4.jpg"><br>本次操作系统实验根据<code>Orange&#39;s 一个操作系统的实现</code>一书进行操作。在此记录试验的过程及心得</p><h2 id="第一章-amp-第二章-Hello，OS-world"><a href="#第一章-amp-第二章-Hello，OS-world" class="headerlink" title="第一章&amp;第二章 Hello，OS world"></a>第一章&amp;第二章 Hello，OS world</h2><p>这两章通过在windows使用虚拟机运行Ubuntu操作系统，在Ubuntu上使用bochs虚拟机来完成操作系统。</p><h3 id="1-使用vm运行Ubuntu"><a href="#1-使用vm运行Ubuntu" class="headerlink" title="1 使用vm运行Ubuntu"></a>1 使用vm运行Ubuntu</h3><p>我这里虚拟机运行的是Ubuntu20.04，安装虚拟机时主要遇到的问题有：</p><ol><li>虚拟机连不上网，但在瞎搞之后能连上了，选择的时NAT连接</li><li>VM Tools 自动安装不上，会报错。VMtools可以实现Windows环境和Linux环境直接的文件交换，还是有必要安装的。解决方法是手动下载VM Tools，尽管之后还会报错，但已经能实现文件互通。</li></ol><h3 id="2-在Ubuntu中使用bochs"><a href="#2-在Ubuntu中使用bochs" class="headerlink" title="2 在Ubuntu中使用bochs"></a>2 在Ubuntu中使用bochs</h3><p>我这里是在<a href="https://bochs.sourceforge.io/">官网</a>下载的安装包，版本是<a href="https://sourceforge.net/projects/bochs/files/bochs/2.7/bochs-2.7.tar.gz/download">2.7</a><br>之后参考书上和网上的一些博客进行安装，主要参考<a href="https://blog.csdn.net/weixin_49635198/article/details/126831887">博客</a><br>这里建议新建一个文件夹解压压缩包<br>使用命令<code>tar vxzf bochs-2.7.tar.gz</code>解压<br>之后使用命令<code>cd bochs-2.7</code>进入该文件夹<br>之后进行配置<br>输入命令<code>./configure --prefix=$home/你解压的地址 --enable-debugger --enable-disasm --enable-iodebug --enable-x86-debugger --with-x --with-x11</code><br>配置时可能遇到问题</p><ol><li>fatal error: X11/Xlib.h: No such file or directory<br>这里表示x11没有安装完整，输入：<code>sudo apt-get install libghc-x11-dev</code>即可</li><li>Ubuntu 编译提示 configure: error: no acceptable C compiler found in $PATH<br>这是没有安装 C 编译器,通过命令<code>sudo apt-get install -y build-essential</code>下载一些必要环境即可</li></ol><p>随后依次使用命令<code>make</code>和<code>sudo make install</code></p><p>这两个命令执行过程中我没有遇到什么问题，如果有遇到的话还请自己搜搜。</p><p>之后返回上一级目录，可以发现多了两个文件bin和share文件夹。</p><p>之后进入bin文件夹里面可以看到bximage和bochs两个文件，前者用来创建虚拟磁盘，或者用来配置虚拟机。</p><p>接下来让我们配置bochs文件，进入bin文件，输入命令<code>sudo gedit bochsrc</code>创建bochsrc配置文件，向该文件中输入以下代码进行虚拟机配置（直接复制粘贴即可）</p><pre><code class="lang-cmd">################################################################ Configuration file for Bochs################################################################ how much memory the emulated machine will havemegs: 32# filename of ROM imagesromimage: file=/home/mr-cold/boch/share/bochs/BIOS-bochs-latestvgaromimage: file=/home/mr-cold/boch/share/bochs/VGABIOS-lgpl-latest# what disk images will be used floppya: 1_44=a.img, status=inserted# choose the boot disk.boot: floppy# where do we send log messages?log: bochsout.txt# disable the mousemouse: enabled=0# enable key mapping, using US layout as default.#keyboard_mapping: enabled=1, map=/home/mr-cold/boch/share/bochs/keymaps/x11-pc-us.map</code></pre><p>之后在bin文件夹下输入<code>bochs -f bochsrc</code>即可运行虚拟机，选择6开始模拟，之后输入c即可显示交互命令行界面<br><img src="/images/OS实验/bochs_1.jpg"><br><img src="/images/OS实验/bochs_2.jpg"><br><img src="/images/OS实验/bochs_3.jpg"><br>在上图中，报错是因为我们还没有驱动磁盘，在bochsrc的配置代码中我们可以看到该虚拟机配备软盘floppy为a.img，那么接下来我们就要创建一个软盘去实现一个最小的操作系统</p><h3 id="3-最简单的操作系统"><a href="#3-最简单的操作系统" class="headerlink" title="3 最简单的操作系统"></a>3 最简单的操作系统</h3><p>我们首先创建一个虚拟软盘(硬盘应该也可以，书中为软盘，毕竟是09年老书)。命令<code>bximage</code><br>随后依据提示创建一个1.44MB的软盘，同时将bochsrc中<code>floppya: 1_44=a.img, status=inserted</code>中的软盘改为你创建磁盘的名字，这将是虚拟机的磁盘。</p><p>随后实现书中的boot.asm(可以直接从书附带磁盘复制出来，磁盘从学校云图书馆即可下载)：通过<code>basm boot.asm -o boot.bin</code>将asm文件转为bin文件(asm文件即汇编文件，bin文件即二进制文件)</p><pre><code class="lang-asm"> org 07c00h   ; 告诉编译器程序加载到7c00处 mov ax, cs mov ds, ax mov es, ax call DispStr   ; 调用显示字符串例程 jmp $   ; 无限循环DispStr: mov ax, BootMessage mov bp, ax   ; ES:BP = 串地址 mov cx, 16   ; CX = 串长度 mov ax, 01301h  ; AH = 13,  AL = 01h mov bx, 000ch  ; 页号为0(BH = 0) 黑底红字(BL = 0Ch,高亮) mov dl, 0 int 10h   ; 10h 号中断 retBootMessage:  db &quot;Hello, OS world!&quot;times  510-($-$$) db 0 ; 填充剩下的空间，使生成的二进制代码恰好为512字节dw  0xaa55    ; 结束标志</code></pre><p>这里的boot文件即是引导扇区，其作用是将loader模块调入内存，且大小固定为512B，默认在磁盘的第一个扇区。</p><p>将生成的bin文件放入bochs虚拟机的文件夹。使用命令<code>dd if=boot.bin of=a.img bs=512 count=1 conv=notrunc</code>将bin文件写入软盘的第一个扇区，这里<code>conv=notrunc</code>不能删去，否则软盘会被截断(变为bin文件的大小)</p><ul><li><code>dd if=boot.bin of=a.img bs=512 count=1 conv=notrunc</code>这句话是一个命令行指令，作用是将文件boot.bin复制到a.img中的第一个扇区（512字节），覆盖原有内容而不追加。其中：<ul><li>dd：一个Linux/Unix系统下的复制工具。</li><li>if：输入文件的路径。</li><li>of：输出文件的路径。</li><li>bs：每次复制的块大小，这里是512字节。</li><li>count：复制的块数，这里是1个块（即512字节）。<br>-conv：转换选项，这里是不做任何转换（notrunc）。</li></ul></li></ul><p>随后即可运行bochs虚拟机，使用指令<code>bochs -f bochsrc</code>。</p><p>结果：视窗第一行显示<code>Hello, OS world!</code><br><img src="/images/OS实验/bochs_4.jpg"></p><h2 id="第三章-保护模式"><a href="#第三章-保护模式" class="headerlink" title="第三章 保护模式"></a>第三章 保护模式</h2><p>纯纯的概念，先小跳一下</p><h2 id="第四章-让操作系统进入保护模式"><a href="#第四章-让操作系统进入保护模式" class="headerlink" title="第四章 让操作系统进入保护模式"></a>第四章 让操作系统进入保护模式</h2><p>概念：FAT12，一种文件系统，详见书</p><h3 id="loader模块"><a href="#loader模块" class="headerlink" title="loader模块"></a>loader模块</h3><p>一个操作系统从开机到运行，大致经历</p><pre><code class="lang-mermaid">graph LRA[引导]--&gt;B[加载内核到内存];B--&gt;C[跳入保护模式];C--&gt;D[开始执行内核]</code></pre><p>因此在执行内核前，还需要几步，仅靠一个512B的引导扇区是无法加载内核到内存的，因此我们将这一步工作交给一个称为Loader的模块去实现，该模块没有内存限制。</p><p>一个简单的loader模块为</p><pre><code class="lang-asm">org 0100h mov ax, 0B800h mov gs, ax mov ah, 0Fh    ; 0000: 黑底    1111: 白字 mov al, &#39;L&#39; mov [gs:((80 * 0 + 39) * 2)], ax ; 屏幕第 0 行, 第 39 列。 jmp $    ; 到此停住</code></pre><p>随后通过<code>nasm loader.asm -o loader.bin</code>转为二进制文件，准备放入磁盘。</p><h3 id="加载Loader入内存"><a href="#加载Loader入内存" class="headerlink" title="加载Loader入内存"></a>加载Loader入内存</h3><p>这里boot首先要做出改变，首先引导扇区需要BPB头信息才能被识别，其次我们要在boot的代码里实现寻找loader模块，这里代码见书附磁盘。</p><p>随后我们就要将loader模块放入磁盘，让boot程序找到它并执行。</p><p>这里书上给出命令集合为</p><pre><code class="lang-asm">nasm boot.asm -o boot.binnasm loader.asm -o loader.bindd if=boot.bin of=a.img bs=512 count=1 conv=notruncsudo mount -o loop a.img /mnt/floppy/sudo cp loader.bin /mnt/floppy/ -vsudo umount /mnt/floppy/</code></pre><p>该指令将软盘挂载到/mnt/floppy下，在将loader程序复制进去，以达到将loader放入软盘的目的，但是我的<code>mnt</code>目录下没有floppy文件夹，因此首先用指令<code>mkdir /mnt/floppy/</code>创建一个挂载软盘的区域</p><p>查询chatgpt后也有以下方法：</p><ul><li>可以使用dd命令将bin文件写入img文件的指定扇区。具体命令如下：<code>dd if=boot.bin of=a.img bs=512 count=1 seek=1 conv=notrunc</code><br>其中，boot.bin为输入的bin文件，a.img为输出的img文件；bs=512表示每个块的大小为512字节；count=1表示只写入一个块；seek=1表示从a.img的第二个扇区开始写入，因为第一个扇区通常是引导扇区，需要保留；conv=notrunc表示不截断输出文件。</li></ul><h2 id="第五章-内核雏形"><a href="#第五章-内核雏形" class="headerlink" title="第五章 内核雏形"></a>第五章 内核雏形</h2><h3 id="1-linux下asm文件的运行"><a href="#1-linux下asm文件的运行" class="headerlink" title="1 linux下asm文件的运行"></a>1 linux下asm文件的运行</h3><p>运行hello.asm文件</p><pre><code class="lang-asm">; 编译链接方法; (ld 的‘-s’选项意为“strip all”);; $ nasm -f elf hello.asm -o hello.o; $ ld -s hello.o -o hello; $ ./hello; Hello, world!; $[section .data] ; 数据在此strHello db &quot;Hello, world!&quot;, 0AhSTRLEN  equ $ - strHello[section .text] ; 代码在此global _start ; 我们必须导出 _start 这个入口，以便让链接器识别_start: mov edx, STRLEN mov ecx, strHello mov ebx, 1 mov eax, 4  ; sys_write int 0x80  ; 系统调用 mov ebx, 0 mov eax, 1  ; sys_exit int 0x80  ; 系统调用</code></pre><p>之后首先转换为.o二进制文件<br><code>nasm -f elf hello.asm -o hello.o</code><br>再进行链接得到可执行文件<br><code>ld -s hello.o -o hello</code>，然而这句话会报错，因为书中系统为32位，而目前（2023）年基本为64位机，所以我们应用指令<code>ld -m elf_i386 -s hello.o -o hello</code>生成可执行文件<br>再运行<code>./hello</code>可看到输出Hello，World!</p><h3 id="2-linux下汇编和C同步使用"><a href="#2-linux下汇编和C同步使用" class="headerlink" title="2 linux下汇编和C同步使用"></a>2 linux下汇编和C同步使用</h3><p>书中例子</p><pre><code class="lang-asm">; 编译链接方法; (ld 的‘-s’选项意为“strip all”);; $ nasm -f elf foo.asm -o foo.o; $ gcc -c bar.c -o bar.o; $ ld -s hello.o bar.o -o foobar; $ ./foobar; the 2nd one; $extern choose ; int choose(int a, int b);[section .data] ; 数据在此num1st  dd 3num2nd  dd 4[section .text] ; 代码在此global _start ; 我们必须导出 _start 这个入口，以便让链接器识别。global myprint ; 导出这个函数为了让 bar.c 使用_start: push dword [num2nd] ; `. push dword [num1st] ;  | call choose  ;  | choose(num1st, num2nd); add esp, 8  ; / mov ebx, 0 mov eax, 1  ; sys_exit int 0x80  ; 系统调用; void myprint(char* msg, int len)myprint: mov edx, [esp + 8] ; len mov ecx, [esp + 4] ; msg mov ebx, 1 mov eax, 4  ; sys_write int 0x80  ; 系统调用 ret</code></pre><pre><code class="lang-C">void myprint(char* msg, int len);int choose(int a, int b)&#123; if(a &gt;= b)&#123;  myprint(&quot;the 1st one\n&quot;, 13); &#125; else&#123;  myprint(&quot;the 2nd one\n&quot;, 13); &#125; return 0;&#125;</code></pre><p>使用指令来运行代码<br><code>nasm -f elf -o foo.o foo.asm</code><br><code>gcc - m32 -c -o bar.o bar.c</code>(这里和书上的不一样，这里生成32位可执行文件)<br><code>ld -m -elf_i386 -s -o foobar foo.o bar.o</code>32位链接<br><code>./foobar</code></p><p>运行结果可以根据代码得出</p><h3 id="3-ELF-Executable-and-Linkable-Format"><a href="#3-ELF-Executable-and-Linkable-Format" class="headerlink" title="3 ELF(Executable and  Linkable Format)"></a>3 ELF(Executable and  Linkable Format)</h3><p>操作系统内核位ELF文件格式,该文件格式由四部分组成（ELF头，程序头表，节，节头表），只有ELF头位置固定，其余部分由ELF头位置决定</p><h3 id="4-从Loader到内核"><a href="#4-从Loader到内核" class="headerlink" title="4 从Loader到内核"></a>4 从Loader到内核</h3><p>loader要做的两项工作：</p><ol><li>加载内核到内存</li><li>跳入保护模式</li></ol>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统复习</title>
      <link href="/2023/02/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0/"/>
      <url>/2023/02/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/meitu/2.jpg"></p><p>主要观看 <a href="https://www.bilibili.com/video/BV1VE411h7hq?p=176&amp;vd_source=240b8edf72530a8ec2d9f48cc6514072">数据库系统实现网课</a>1700后的内容所成笔记。</p><p>与 数据库系统实现（机械工业出版社）所讲内容基本吻合，但在具体部分所讲的顺序有略有不同，但考虑到啃书（尤其是机翻工业出版社的书）有些困难，所以先过一边网课再啃书。<br>网课中得顺序有些与书中不同，这里需要注意。<br>[toc]</p><h2 id="第二章-辅助存储管理"><a href="#第二章-辅助存储管理" class="headerlink" title="第二章 辅助存储管理"></a>第二章 辅助存储管理</h2><h3 id="01-存储体系回顾"><a href="#01-存储体系回顾" class="headerlink" title="01 存储体系回顾"></a>01 存储体系回顾</h3><h4 id="（1）数据组织的基础—存储体系"><a href="#（1）数据组织的基础—存储体系" class="headerlink" title="（1）数据组织的基础—存储体系"></a>（1）数据组织的基础—存储体系</h4><li>将不同性价比的存储器组织在一起，满足高速度，大容量，低价格需求</li><li>CPU与内存直接交换信息，按存储单元（字）进行访问</li><li>外存按存储块进行访问，其信息先装入内存，才能被CPU处理。#### （2）操作系统对数据的组织FAT-目录-磁盘块/簇FAT（文件分配表 File Allocation Table）#### （3）内存管理</li><li>一条记录的地址=存储单元的地址=内存地址=页面：页面偏移量</li><li>页面 = 块</li><li>内存页面的分配</li><li>内存页面的置换### 02 磁盘的结构与特性#### （1）磁盘及磁盘容量此处应为磁盘结构图磁盘位置表述：盘面：磁道：扇区磁盘读写单位：扇区(sector)->簇cluster/块(block)#### （2）磁盘的访问寻道时间(1-20ms)旋转时间(0-10ms)传输时间(每4KB页<1ms) 三个时间的和称为延迟 物理存取算法考虑的关键：降低i o次数 降低排队等候时间<="=">降低寻道/旋转延迟时间<li>同一磁道连续存储</li><li>同一柱面不同磁道并行块存储</li><li>多个磁盘并行块存储#### （3）提高磁盘数据读写时间与存储可靠性的方法RAID技术：Redundant Array of Independent Disk(独立磁盘冗余磁盘阵列)主要思想：</li><li>并行处理：并行读取多个磁盘<ul><li>    比特级拆分：一个字节被拆分成八个比特位，不同比特位存储于不同磁盘</li><li>    块级拆分：一个文件由多个块组成，不同块存储于不同磁盘</li></ul></li><li>可靠性<ul><li>    扇区/块读写校验：对一个扇区/块读写做校验</li><li>    多个磁盘间共同构成的信息读写做校验。</li></ul></li><p>实现结果：</p><ol><li>RAID0 块级拆分但无冗余</li><li>RAID2 镜像处理：每个磁盘有个一镜像磁盘</li><li>RAID3 位交叉纠错处理：4个磁盘存储4位+3个校验盘P存储3校验位</li><li>RAID4 位交叉检验：4个磁盘存储4位+1个校验盘存储1校验位，位拆分存储(借助于扇区读写校验判断出出错磁盘再根据校验盘进行纠错)</li><li>RAID5 块交叉检验：块拆分存储，其它同上</li><li>RAID6 快交叉分布式校验：块拆分存储，互为校验盘</li><li>更多复杂冗余</li></ol><h3 id="03-查询实现的基本思想"><a href="#03-查询实现的基本思想" class="headerlink" title="03 查询实现的基本思想"></a>03 查询实现的基本思想</h3><h4 id="（1）数据存储的映射关系示意"><a href="#（1）数据存储的映射关系示意" class="headerlink" title="（1）数据存储的映射关系示意"></a>（1）数据存储的映射关系示意</h4><p>查询操作算法  —&gt;<br>文件管理/索引管理：数据逻辑结构 —&gt;<br>内存-缓冲区管理 —&gt;<br>磁盘-磁盘管理：读/写 块 —&gt;</p><h4 id="（2）数据存储与查询实现的基本框架示意"><a href="#（2）数据存储与查询实现的基本框架示意" class="headerlink" title="（2）数据存储与查询实现的基本框架示意"></a>（2）数据存储与查询实现的基本框架示意</h4><p><img src="/images/数据存储与查询实现的基本框架示意.jpg"></p><h3 id="04-记录与表在磁盘上的存储"><a href="#04-记录与表在磁盘上的存储" class="headerlink" title="04 记录与表在磁盘上的存储"></a>04 记录与表在磁盘上的存储</h3><h4 id="（1）数据库概念与磁盘相关概念的映射示意"><a href="#（1）数据库概念与磁盘相关概念的映射示意" class="headerlink" title="（1）数据库概念与磁盘相关概念的映射示意"></a>（1）数据库概念与磁盘相关概念的映射示意</h4><p><img src="/images/数据库概念与磁盘相关概念的映射示意.jpg"></p><h4 id="（2）数据库中记录的区分及记录属性值的区分"><a href="#（2）数据库中记录的区分及记录属性值的区分" class="headerlink" title="（2）数据库中记录的区分及记录属性值的区分"></a>（2）数据库中记录的区分及记录属性值的区分</h4><p>定长记录：按长度分记录<br>边长记录：按指针或标志区分记录</p><p>块头如何设计？</p><h4 id="（3）-数据库中的记录-vs-磁盘块"><a href="#（3）-数据库中的记录-vs-磁盘块" class="headerlink" title="（3） 数据库中的记录 vs.磁盘块"></a>（3） 数据库中的记录 vs.磁盘块</h4><p>记录在磁盘中的存储：</p><p>非跨块存储：</p><li>浪费一些存储空间</li><li>磁盘块之间无关联可并行跨块存储：靠指针连接</li><li>节省一些存储空间</li><li>磁盘间有关联需要串行#### （4）数据库中的表 vs.磁盘块表所占磁盘块的分配方法：</li><li>连续分配：数据块被分配到连续的数据块上(会存在扩展困难问题)</li><li>链接分配：数据块中包含指向下一数据块的指针(访问速度问题)</li><li>按簇分配：簇是若干连续的磁盘块，簇之间靠指针链接</li><li>索引分配：索引块中存放指向实际数据块的指针### 05 四种文件组织方法1. 无序文件组织2. 有序文件组织3. 散列文件组织4. 聚簇文件组织#### （1）数据组织与存取方法</li><li>数据组织要考虑更新(增删改)和检索需求1. 更新将涉及数据存储空间的扩展和回收问题2. 检索将涉及扫描整个数据库的问题，大批量处理数据问题3. 不同的需求要求不同的数据组织方法和存取方法</li><li> 文件组织：指的是数据组织成记录，块和访问结构的方式，包括把记录和块存储在磁盘上的方式，以及记录块之间相互联系的方法。(可以理解为是一种数据结构)</li><li>存取方法：指的是对文件所采取的存取操作方法。（可以理解为在数据结构上使用的算法）</li><li>一种文件组织可以采用多种存取方法进行访问#### （2）无序文件组织</li><li>特点：记录可存储于任意空间的位置，磁盘上存储的记录是无序的。更新效率高，但检索效率可能 低。</li><li>如何建立？方法1：新记录插入到文件尾部；删除记录时，可以直接删除该记录所在位置的内容，也可以在该记录前标记“删除标记”方法2：在前者基础上，新增记录可以利用那些标记为“删除标记”的记录空间</li><li>频繁删增记录时会造成空间浪费，所以需要周期性重新组织数据库。数据库重组 是通过移走被删除的记录使有效记录连续存放，从而回收那些由删除记录而产生的未利用空间。#### （3）有序文件组织</li><li>特点：记录按某属性或属性组值得顺序插入，磁盘上存储的记录是有序的。检索效率较高。</li><li>用户存储排序的属性通常称为 排序字段 ，通常，排序字段使用关系中的主码，所以又称排序码</li><li>当按排序字段进行检索时，速度得到很大提升</li><p>问题：</p><li>有序记录文件的更新效率可能很低</li><li>因为：在更新时要移动其它记录，为插入记录流出空间改进：</li><li>改进措施是为将来可能插入的元组预留空间，或者再使用一个临时的无序文件（被称为溢出文件）保留新增的记录。</li><li>当采取溢出文件措施时，检索操作既要操作主文件，也要操作溢出文件</li><li>因此需要周期性地重组数据库</li><li>数据库重组是将溢出文件合并到主文件中，并恢复主文件中的记录顺序。#### （4）散列文件组织</li><li>特点：可以把记录按照某属性或属性组地值，依据一个散列函数来计算其应放位置：桶号（Bucket，块号或簇号等）。检索效率和更新效率都有一定程度的提升。</li><li>用于进行散列函数计算的属性通常称为散列字段，散列字段通常也采用关系中的主码，所以又称散列码。</li><li>不同记录可能被hash成同一桶号，此时需在顺序检索出某一记录。优化：</li><li>链接法处理溢出</li><li>动态散列技术等#### （5）聚簇文件组织</li><li>聚簇：将具有相同或相似属性值的记录存放在连续的磁盘簇块中</li><li>多表聚簇：将若干个相互关联的Table存储于一个文件中---这可以提高多表情况下的查询速度。### 06 Oracle数据库物理存储简介这个书上好像没有，先跳了### 07 第二章总结<img src="/images/数据库物理存储.jpg">## 第三章 索引结构### 01 索引的概念和作用#### （1）索引的概念`索引`是定义在存储表基础上，有助于无需检查所有记录而快速定位所需记录的一种`辅助存储结构`，由一系列存储在磁盘上的`索引项`组成，每一项索引由两部分组成：1. 索引字段，由Table中某些列中的值串接而成。索引中通常存储了索引字段的每一个值，索引字段类似于词典中的词条。2. 行指针：指向Table中包含索引字段值的记录 在磁盘上的存储位置，行指针类似于词条在数据，词典中出现的页码</li><li>存储索引项的文件为索引文件，相对应，存储表又称主文件</li><h4 id="（2）索引的一般性特点"><a href="#（2）索引的一般性特点" class="headerlink" title="（2）索引的一般性特点"></a>（2）索引的一般性特点</h4><p><li>索引文件是一种辅助存储结构，其存在不改变存储表的物理存储结构，但可以明显提高存储表的访问速度</li></p><p><li>索引文件组织方式有两种：</li></p><ol><li>排序索引文件：按索引字段值的某一种顺序组织存储</li><li>散列索引文件：依据索引字段值使用散列函数分配散列桶的方式存储</li></ol><p><li>主文件组织有 堆文件，排序文件，散列文件，聚簇文件等多种方式</li></p><p><li>在一个表上可以针对不同的属性值或属性组和建立不同的索引文件，可建立多个索引文件。索引字段的值可以是table中的任何一个属性的值或任何多个属性值的组合值</li></p><p><li>索引文件比主文件小很多，通过检索一个小的索引文件（可以全部装载进内存），快速定位后，再有针对性的读取非常大的主文件中的有关记录</li></p><p><li>有索引时，更新操作必须同步更新索引文件和主文件</li></p><h4 id="（3）关于索引应用的评价问题"><a href="#（3）关于索引应用的评价问题" class="headerlink" title="（3）关于索引应用的评价问题"></a>（3）关于索引应用的评价问题</h4><p><li>索引技术应用是检索效率大幅度提高，但同时也增加了存储空间，使维护负担加重</li></p><p><li>衡量索引性能好坏： 1 访问时间 2 插入时间 3 删除时间 4 空间负载 5 支持存取的有效比</li></p><h4 id="（4）索引相关概念的区分"><a href="#（4）索引相关概念的区分" class="headerlink" title="（4）索引相关概念的区分"></a>（4）索引相关概念的区分</h4><p><li>字段，排序字段，索引字段</li></p><p><li>码（Key），主码，又称表键—-具有唯一性</li></p><p><li>排序码：对主文件进行排序存储的那些属性或属性组</li></p><p><li>索引码：即索引字段，不一定具有唯一性</li></p><p><li>搜索码：在主文件中查找记录的属性或属性集</li></p><h3 id="02-SQL语言中的索引创建与维护"><a href="#02-SQL语言中的索引创建与维护" class="headerlink" title="02 SQL语言中的索引创建与维护"></a>02 SQL语言中的索引创建与维护</h3><p>书上没有，先跳了</p><h3 id="03-稠密索引和稀疏索引"><a href="#03-稠密索引和稀疏索引" class="headerlink" title="03 稠密索引和稀疏索引"></a>03 稠密索引和稀疏索引</h3><h4 id="（1）稠密索引和稀疏索引概念"><a href="#（1）稠密索引和稀疏索引概念" class="headerlink" title="（1）稠密索引和稀疏索引概念"></a>（1）稠密索引和稀疏索引概念</h4><p><li>对于一个主文件中的每一个记录（形成的每一个索引字段值），都有一个索引项和它对应，指明该记录所在位置。这样的索引称为稠密索引</li></p><p><li>对于主文件中的部分记录(形成的索引字段值)，有索引项和它对应，这样的索引称为 非稠密索引或稀疏索引</li></p><h4 id="（2）稀疏索引如何定位记录"><a href="#（2）稀疏索引如何定位记录" class="headerlink" title="（2）稀疏索引如何定位记录"></a>（2）稀疏索引如何定位记录</h4><p><li>索引文件中不存在搜索码的值，不代表主文件没有对应搜索码的记录</li></p><p><li>定位索引字段值为K的记录，需要</li></p><ol><li>首先找相邻的小于K的最大索引字段值对应的索引项</li><li>从该索引项对应的记录考试顺序进行table的检索</li></ol><p><li>稀疏索引的使用要求—主文件必须是按对应检索字段属性排序存储</li></p><p><li>相比稠密搜索：空间占用更少，维护任务更轻，但速度较慢</li></p><p><li>平衡：索引项不指向记录指针，而是指向记录所在存储块的指针，即每一个存储块有一个索引项，而不是每条记录有一个索引项</li></p><h4 id="（3）-稠密索引如何定位记录"><a href="#（3）-稠密索引如何定位记录" class="headerlink" title="（3） 稠密索引如何定位记录"></a>（3） 稠密索引如何定位记录</h4><p>候选键属性的稠密索引：先查索引，然后再根据索引读主文件。</p><p>非候选键属性的稠密索引：</p><p>第一种情况：索引文件中索引字段值是不重复的；主文件按检索字段排序且索引字段不是候选键。</p><p>第二种情况：索引文件中索引字段值有重复；主文件 未按索引字段排序且索引字段不是候选键。</p><p>第三种情况：引入指针桶处理非候选键索引的多记录情况；主文件未按检索字段排序且检索字段不是候选键。</p><h3 id="04-主索引与辅助索引"><a href="#04-主索引与辅助索引" class="headerlink" title="04 主索引与辅助索引"></a>04 主索引与辅助索引</h3><h4 id="（1）主索引"><a href="#（1）主索引" class="headerlink" title="（1）主索引"></a>（1）主索引</h4><p>主索引通常是每一存储块有一个索引项，索引项的总数和存储表所占的存储块数目相同，存储表的每一存储块的第一条记录，又称为锚记录，或者称为块锚。</p><p><li>主索引的索引字段值为块锚的索引字段值，而指针指向其所在的存储块</li></p><p><li>主索引是是按索引字段值进行排序的一个有序文件，通常建立在有序主文件的基于主码的排序字段上，即主索引的索引字段与主文件的主码有对应关系</li></p><p><li>主索引是稀疏索引</li></p><h4 id="（2）-辅助索引"><a href="#（2）-辅助索引" class="headerlink" title="（2） 辅助索引"></a>（2） 辅助索引</h4><p>辅助索引是定义在主文件的任意或者多个非排序字段上的辅助存储结构。</p><p><li>辅助索引通常是对某一非排序字段上的每一个不同值有一个索引项；索引字段既是该字段的不同值，而指针则指向包含该纪录的块或该记录本身</li></p><p><li>当非排序字段为索引字段时，如果该字段值不唯一，则要采用一个类似链表的结构来保存包含该字段值的所有记录的位置</li></p><p><li>辅助索引是稠密索引，检索效率有时相当高</li></p><h4 id="（3）差别"><a href="#（3）差别" class="headerlink" title="（3）差别"></a>（3）差别</h4><p><li>一个主文件只有一个主索引，但可以有多个辅助索引</li></p><p><li>主索引通常建立在主码/排序码上；辅助索引建立在其他属性上</li></p><p><li>可以利用主索引重新组织主文件数据，但辅助索引不能改变主文件数据</li></p><p><li>主索引是稀疏索引，辅助索引是稠密索引</li></p><h3 id="05-其他索引"><a href="#05-其他索引" class="headerlink" title="05 其他索引"></a>05 其他索引</h3><h4 id="（1）聚簇索引与非聚簇索引"><a href="#（1）聚簇索引与非聚簇索引" class="headerlink" title="（1）聚簇索引与非聚簇索引"></a>（1）聚簇索引与非聚簇索引</h4><p>聚簇索引：是指索引中邻近的记录在著文件中也是临近存储的<br>非聚簇索引：是指索引中邻近的记录在主文件中不一定是临近存储的</p><h4 id="（2）倒排索引"><a href="#（2）倒排索引" class="headerlink" title="（2）倒排索引"></a>（2）倒排索引</h4><p>正排：一个文档包含了哪些词汇<br>倒排：一个词汇包含在哪些文档中</p><h4 id="（3）其它索引"><a href="#（3）其它索引" class="headerlink" title="（3）其它索引"></a>（3）其它索引</h4><p><li>多级索引：当索引想比较多时，可以对索引再建立索引，形成多级索引。 常见多级索引有B树/B+树，以树形数据结构来组织索引项。</li></p><p><li>多属性索引：索引字段由table的多个属性值组合在一起形成的索引</li></p><p><li>散列索引：使用散列技术组织的索引</li></p><p><li>网格索引：使用多索引字段进行交叉联合定位与检索</li></p><h3 id="06-B-树索引（书上是B树）"><a href="#06-B-树索引（书上是B树）" class="headerlink" title="06 B+树索引（书上是B树）"></a>06 B+树索引（书上是B树）</h3><h4 id="（1）多级索引"><a href="#（1）多级索引" class="headerlink" title="（1）多级索引"></a>（1）多级索引</h4><p>当索引较多时，可以对索引再建立索引</p><h4 id="（2）B-树的基本概念"><a href="#（2）B-树的基本概念" class="headerlink" title="（2）B+树的基本概念"></a>（2）B+树的基本概念</h4><p>B+树索引：一种以树形数据结构来组织索引项的多级索引</p><p>一块中索引项的组织：<br>Ki:索引字段值<br>Pj：指针，只想索引块或数据块或数据块中记录的指针</p><p>索引文件的叶子节点的指针指向主文件的数据块</p><p>B+树能自动保持与主文件大小相适应的树的层次，每个索引块指针的利用率都大于50%</p><h4 id="（3）B-树的存储约定"><a href="#（3）B-树的存储约定" class="headerlink" title="（3）B+树的存储约定"></a>（3）B+树的存储约定</h4><p>B+树有一个参数n，决定了树的所有存储块的状态</p><p><li>一块中有 n-1 个索引项（&lt;索引字段值Ki，指针Pi&gt;） + 1个指针（Pn）</li></p><p>示例： 存储块=4096B，整数型索引字段值=4B，指针=8B<br>则n应该满足 4（n-1) + 8n &lt; 4096,n取341为最大值</p><p>指针情况：</p><ul><li>索引字段值x在$k_{i-1}&lt;x&lt;k_i$的由$p_i$指向；而$k_i&lt;x&lt;k_{i+1}$的由$P_{i+1}$指向 非叶节点指针指向索引块，叶子节点指向主文件的数据块或数据记录</li><li>叶子节点的最后一个指针始终指向其下一个数据块</li><li>一个索引块实际使用的索引指针个数d满足(n/2&lt;d&lt;n)</li><li>根节点至少两个指针被使用</li><li>索引字段值重复出现于叶节点和非叶子节点</li><li>指向主文件的指针仅出现在叶子节点</li><li>所有叶子节点即可覆盖所有键值的索引</li><li>索引字段值在叶子节点中是按顺序排列的</li></ul><p>B+树级数相同—平衡，如何保证？</p><ul><li>插入删除记录时，伴随着节点的分裂和合并</li><li>分裂和合并将调整部分节点块中的索引项，需要算法支持</li></ul><h4 id="4-利用B-树建立不同的索引"><a href="#4-利用B-树建立不同的索引" class="headerlink" title="(4) 利用B+树建立不同的索引"></a>(4) 利用B+树建立不同的索引</h4><p>1： 利用B+树建立键属性稠密索引<br>索引字段是主文件的主键，索引是稠密的。主文件可以按逐渐排序，也可以不按逐渐排序。指针指向的是记录<br>2： 利用B+树建立键属性稀疏索引<br>索引字段是主文件的逐渐，索引是稀疏的。主文件必须按逐渐排序。指针指向的是数据块。</p><h4 id="（5）-B树"><a href="#（5）-B树" class="headerlink" title="（5） B树"></a>（5） B树</h4><p>不同：</p><ul><li>索引字段值仅出现一次</li><li>主文件的指针也可出现在非叶子节点</li><li>所有节点才能覆盖所有的键值索引</li><li>分裂新增节点原理相似，细节不一样</li></ul><h4 id="（6）-B-树相关算法"><a href="#（6）-B-树相关算法" class="headerlink" title="（6） B+树相关算法"></a>（6） B+树相关算法</h4><p>检索算法，增加记录的算法，删除记录的算法</p><h3 id="07-B-树之键值插入与节点分裂示意"><a href="#07-B-树之键值插入与节点分裂示意" class="headerlink" title="07 B+树之键值插入与节点分裂示意"></a>07 B+树之键值插入与节点分裂示意</h3><h4 id="（1）-插入"><a href="#（1）-插入" class="headerlink" title="（1） 插入"></a>（1） 插入</h4><p>关键：</p><ol><li>分裂（当插入节点全满时）</li><li>由叶子节点向根节点逐层处理<br>能够自动保持与主文件大小相适应的书的层次<br>每个索引块的指针利用率可以在50%以上</li><li>指针调整</li></ol><h4 id="（2）-删除"><a href="#（2）-删除" class="headerlink" title="（2） 删除"></a>（2） 删除</h4><ol><li>先定位待删除键值的叶子节点，从根节点向下</li><li>删除键值及其主文件记录</li><li>如指针数目不小于规定数目，则可以结束；否则，需要合并。<ol><li>从相邻节点能否转移一些键值到该节点，如果可以，则转移，并更新父节点的相应键值</li><li>否则考虑节点合并，合并后调整父节点的键值及次序，调整叶子节点的指针链接</li><li>如果父节点在删除索引项及指针后，指针数目小于规定，则继续步骤2，直至根节点；如果不小于规定则结束</li></ol></li><li>如果删除位置是第一个，还需更新父节点键值</li></ol><h3 id="08-散列索引"><a href="#08-散列索引" class="headerlink" title="08 散列索引"></a>08 散列索引</h3><h4 id="（1）-散列的基本概念"><a href="#（1）-散列的基本概念" class="headerlink" title="（1） 散列的基本概念"></a>（1） 散列的基本概念</h4><p>由m个桶，每个桶是具有相同容量的存储地，称为主桶，溢出后可设置溢出桶<br>散列函数h（k），可以将键值k映射到{0,1,…m-1}中的某一个值<br>将具有键值k的记录Record（k）存储到对应的h（k）编号的桶中（此处映射应尽可能均匀）</p><h4 id="（2）散列索引"><a href="#（2）散列索引" class="headerlink" title="（2）散列索引"></a>（2）散列索引</h4><ul><li>内存数据可采用散列确定存储页，主文件可采用散列确定存储块，索引亦可用散列确定散列项的存储块</li><li>m个桶，一个桶可以是一个存储块，也可以是连续存储块</li></ul><h4 id="（3）-散列索引的插入和删除"><a href="#（3）-散列索引的插入和删除" class="headerlink" title="（3） 散列索引的插入和删除"></a>（3） 散列索引的插入和删除</h4><p>插入键值d的索引项：</p><ol><li>计算h（d）=2</li><li>如2号桶有空间，则将索引项d插入2号桶</li><li>如没空间，则申请一溢出桶，插入d</li></ol><p>删除键值f的索引项：</p><ol><li>计算h（f）=2</li><li>删除2号桶中的键值f</li><li>将溢出桶中的值放入主桶，删除溢出桶</li></ol><h4 id="（4）散列的问题"><a href="#（4）散列的问题" class="headerlink" title="（4）散列的问题"></a>（4）散列的问题</h4><p>散列索引的目标：最好是没有溢出桶，每一个散列值仅有一个桶。读写每一个键值都只写一个存储块。</p><ul><li>均匀分布如何做到？</li><li>桶的数目m如何确定？</li></ul><p>如果桶数m固定——静态散列索引<br>&nbsp;&nbsp;&nbsp;如果m过大，则浪费，过小则产生更多溢出桶，增加索引检索时间<br>桶的数目随键值增多动态增加—-动态散列索引<br>&nbsp;&nbsp;&nbsp;</p><h3 id="09-可扩展散列索引与线性散列索引"><a href="#09-可扩展散列索引与线性散列索引" class="headerlink" title="09 可扩展散列索引与线性散列索引"></a>09 可扩展散列索引与线性散列索引</h3><p>先略过，书上有，开卷考现场学来得及</p><p>以下第三章书上有，视频里没有</p><h3 id="10-多维索引（3-4）"><a href="#10-多维索引（3-4）" class="headerlink" title="10 多维索引（3.4）"></a>10 多维索引（3.4）</h3><p>多维索引的应用：对地理数据的处理。</p><p>利用传统索引执行范围查询，效果甚微，如果数据小点还可以。</p><p>大多数支持多维数据查询的数据结构归于以下两类</p><ol><li>类散列表方式</li><li>类树方式</li></ol><h3 id="11-多维数据的散列结构"><a href="#11-多维数据的散列结构" class="headerlink" title="11 多维数据的散列结构"></a>11 多维数据的散列结构</h3><h4 id="（1）网格文件"><a href="#（1）网格文件" class="headerlink" title="（1）网格文件"></a>（1）网格文件</h4><p>一种比单维索引性能好的最简单的数据结构。在每一维上用网格线将空间分成条状，被分成的每个区域可以看成是散列表的一个桶，以此来进行插入和删除.</p><h4 id="（2）分段散列函数"><a href="#（2）分段散列函数" class="headerlink" title="（2）分段散列函数"></a>（2）分段散列函数</h4><p>散列函数可以接受属性值的一个列表作为参数，以此可以将高维转换到一维。</p><p>这种方法其实在最近邻查询和范围查询中没什么用，点之间的物理距离没有通过桶号反应，否则就是网格文件了。</p><h3 id="12-多维数据的树结构"><a href="#12-多维数据的树结构" class="headerlink" title="12 多维数据的树结构"></a>12 多维数据的树结构</h3><h4 id="（1）多键索引"><a href="#（1）多键索引" class="headerlink" title="（1）多键索引"></a>（1）多键索引</h4><p>一种简单的树模式，它的每一层的节点是一个属性的索引。</p><p>性能：<br>部分匹配查询：如果属性可以按树的从浅到深的属性索引给出，效率很高，否则很低。<br>范围查询：单个索引在他们本身支持范围查询，效果很好<br>最近邻查询：即为若干个范围查询</p><h4 id="（2）kd-树"><a href="#（2）kd-树" class="headerlink" title="（2）kd-树"></a>（2）kd-树</h4><h5 id="kd树概念"><a href="#kd树概念" class="headerlink" title="kd树概念"></a>kd树概念</h5><p>kd树（k维搜索树）是把二叉搜索树推广到多维数据的一种主存数据结构。</p><p>kd树是一个二叉树，它的内部节点有一个相关联的属性a和一个值V，它将数据点集分为两个部分：左子树是a值小于V的部分，右子树是a值大于等于V的部分。<br>并增加以下定义：</p><ol><li>内部节点只有一个属性，该属性具有一个划分值和指向左右子树的指针</li><li>叶子节点是块，快空间存放着尽可能多的记录</li></ol><h5 id="kd树操作"><a href="#kd树操作" class="headerlink" title="kd树操作"></a>kd树操作</h5><p>查找：同二叉树</p><p>插入：先做一个查找，找到对应的叶子节点，如果叶子节点中的块还有空间，就将新的数据放在那里；否则将块分裂成两个，并根据所在层属性再次划分。最后，我们创建了一个新的内部节点：它的子节点分别为我们分裂得到的两个新块，并且给该内部节点一个相应的划分值。</p><h5 id="kd树优化"><a href="#kd树优化" class="headerlink" title="kd树优化"></a>kd树优化</h5><ol><li>内部节点多分支。kd树内部节点可以有多个键-指针对，让其更像B树节点。</li><li>聚集内部节点到块。可以把多个内部节点压缩到一个块中，减少遍历路径访问的块的数量。</li></ol><h4 id="（3）四叉树"><a href="#（3）四叉树" class="headerlink" title="（3）四叉树"></a>（3）四叉树</h4><p>在四叉树中，每个内部节点对应于二维空间中的一个正方形区域，或是k维空间的k维立方体。在二维的情况，一个节点的子节点即为它二维平面的四个象限。</p><h4 id="（4）R-树"><a href="#（4）R-树" class="headerlink" title="（4）R-树"></a>（4）R-树</h4><p>R树是一种利用B-树的某些本质特征来处理多维数据的数据结构。</p><p>R树表示由二维或更高维区域组成的数据，我们把它称为数据区，R树的一个内部节点对应于某个内部区域，运行子区域有重叠，但应尽量小。</p><h3 id="13-位图索引"><a href="#13-位图索引" class="headerlink" title="13 位图索引"></a>13 位图索引</h3><p>略，看书，考场现编</p><h2 id="第四章-查询执行"><a href="#第四章-查询执行" class="headerlink" title="第四章 查询执行"></a>第四章 查询执行</h2><h3 id="1901-查询实现算法概述"><a href="#1901-查询实现算法概述" class="headerlink" title="1901 查询实现算法概述"></a>1901 查询实现算法概述</h3><h4 id="（1）数据库查询的基本思想"><a href="#（1）数据库查询的基本思想" class="headerlink" title="（1）数据库查询的基本思想"></a>（1）数据库查询的基本思想</h4><p>基本动作：</p><ul><li>关系模型的基本运算<ul><li>并，差，积，选择，投影</li></ul></li></ul><p>用户语言实现关系模型基本元素的基本组合，随后数据库管理系统（程序执行机构）解释这种组合，并按次序调用基本动作予以执行</p><h4 id="（2）查询实现-vs-查询优化"><a href="#（2）查询实现-vs-查询优化" class="headerlink" title="（2）查询实现 vs. 查询优化"></a>（2）查询实现 vs. 查询优化</h4><p>SQL语句 经过编译 得到关系代式；<br>关系代式先经过逻辑优化；<br>在经过物理优化（为每一个关系代数才做选择优化的执行例行程序，形成物理查询计划）；<br>最后经过执行引擎运行（依物理查询计划调用的例行程序进行处理，并返回结果）</p><h4 id="（3）-查询算法总览"><a href="#（3）-查询算法总览" class="headerlink" title="（3） 查询算法总览"></a>（3） 查询算法总览</h4><ul><li>数据库的三大类操作<ul><li>以此单一元组的一元操作<ul><li>选择，投影</li></ul></li><li>整个关系的一元操作<ul><li>去重，group by，排序</li></ul></li><li>整个关系的二元操作<ul><li>集合的并交差</li><li>包的并交差</li><li>积，连接</li></ul></li></ul></li></ul><h3 id="1902-连接操作的实现算法"><a href="#1902-连接操作的实现算法" class="headerlink" title="1902 连接操作的实现算法"></a>1902 连接操作的实现算法</h3><h4 id="（1）连接操作的逻辑实现算法"><a href="#（1）连接操作的逻辑实现算法" class="headerlink" title="（1）连接操作的逻辑实现算法"></a>（1）连接操作的逻辑实现算法</h4><p>两个for循环即可</p><h4 id="（2）连接操作的物理实现算法"><a href="#（2）连接操作的物理实现算法" class="headerlink" title="（2）连接操作的物理实现算法"></a>（2）连接操作的物理实现算法</h4><p>关系是存储在磁盘上的，磁盘是以磁盘块为操作单位的，首先要装载进内存(I/O操作)，然后在进行元组的处理</p><ul><li>一些参数<ul><li>$T_R$：关系R的元组数目</li><li>$B_R$：关系R的磁盘数目</li><li>$M$：主存缓冲区的页数（主存每页容量等于一个磁盘的容量）</li><li>$I_R$：关系R的每个元组的字节数</li><li>$b$：每个磁盘的字节数</li></ul></li></ul><p>需要错做的Byte数$B_{R\times S}=T_RT_S(I_R+I_S)/b$</p><h4 id="（3）连接操作的基本实现算法"><a href="#（3）连接操作的基本实现算法" class="headerlink" title="（3）连接操作的基本实现算法"></a>（3）连接操作的基本实现算法</h4><p>对于关系R，S的连接，一次分别将R和S的一个块从磁盘中移到内存中进行连接<br>复杂度 $B_R+B_R*B_S$,但只需要内存三个块</p><h4 id="（4）连接操作的全主存实现算法"><a href="#（4）连接操作的全主存实现算法" class="headerlink" title="（4）连接操作的全主存实现算法"></a>（4）连接操作的全主存实现算法</h4><p>将两个关系都撞入内存中进行连接，此时内存页数需要大于两个关系的内存块数。<br>复杂度$B_R+B_S$</p><h4 id="（5）连接操作的半主存实现算法"><a href="#（5）连接操作的半主存实现算法" class="headerlink" title="（5）连接操作的半主存实现算法"></a>（5）连接操作的半主存实现算法</h4><p>内存只能装入一个关系的所有块的条件下</p><p>先将一个装入内存，再将另一个关系的所有快一个个的放入内存进行连接</p><h4 id="（6）连接操作的大关系实现算法"><a href="#（6）连接操作的大关系实现算法" class="headerlink" title="（6）连接操作的大关系实现算法"></a>（6）连接操作的大关系实现算法</h4><p>此时内存不能装入任一关系的所有快。</p><p>此时先将内存装一个关系得所有快，每次装得只剩两个块得位置，装入多次，剩下两个一个用作输出，一个依次输入另一个关系得所有快，依次来进行连接操作</p><h4 id="（7）连接操作的其他方法"><a href="#（7）连接操作的其他方法" class="headerlink" title="（7）连接操作的其他方法"></a>（7）连接操作的其他方法</h4><ul><li>归并排序</li><li>散列排序</li><li>索引连接算法</li></ul><h3 id="1903-利用迭代器构造查询实现算法"><a href="#1903-利用迭代器构造查询实现算法" class="headerlink" title="1903 利用迭代器构造查询实现算法"></a>1903 利用迭代器构造查询实现算法</h3><h4 id="（1）迭代器算法的提出"><a href="#（1）迭代器算法的提出" class="headerlink" title="（1）迭代器算法的提出"></a>（1）迭代器算法的提出</h4><ul><li>查询实现的两种策略<ul><li>物化计算策略：每一步将所有中间值得出再进行下一步</li><li>流水线计算策略，每得到的元组依次经过查询条件得到结果</li></ul></li><li>区别<ul><li>是一个关系操作还是一组关系操作</li><li>中间的结果是否完整的存储</li></ul></li></ul><p>迭代器算法在流水线计算策略中实现</p><h4 id="（2）迭代器算法基础"><a href="#（2）迭代器算法基础" class="headerlink" title="（2）迭代器算法基础"></a>（2）迭代器算法基础</h4><p>迭代器：迭代的读取一个集合中的每一个元素，而封装其读取细节</p><p>有一个抽象类：</p><pre><code class="lang-C++">class iterator&#123;  void Open();  tuple GetNext();  void Close();  iterator &amp;inputs[];&#125;</code></pre><p>所有的关系操作可继承此迭代器进行构造。<br>不同操作，可以构造不同的Open(),GetNext(),Close()函数</p><h4 id="（3）迭代器的构造"><a href="#（3）迭代器的构造" class="headerlink" title="（3）迭代器的构造"></a>（3）迭代器的构造</h4><p>迭代器示例：表空间扫描发—读取关系</p><pre><code class="lang-C++">Open()&#123;  b:=R的第一块  t:=b的第一个元组&#125;GetNext()&#123;  IF(t已经超过块b的最后一个元组)&#123;    将b前进到下一块    IF(没有下一块)      return NotFound;    ELSE/*b是一个新块*/      t:=b的第一个元组  &#125;  oldt:=t  将t前进到b的下一元组  RETURN oldt;&#125;Close()&#123;&#125;</code></pre><p>迭代器示例：R并S算法</p><pre><code class="lang-C++">Open()&#123;  R.Open();  CurRel:=R;&#125;GetNext()&#123;  IF(CurRel==R)&#123;    t:=R.GetNext();    IF(t&lt;&gt;NotFound)      RETURN t;    ELSE&#123;      s.Open();      curRel:=S;    &#125;  &#125;  RETURN S.GetNext();&#125;Close()&#123;R.close();S.close();&#125;</code></pre><h3 id="1904-数据库查询的一趟扫描算法"><a href="#1904-数据库查询的一趟扫描算法" class="headerlink" title="1904 数据库查询的一趟扫描算法"></a>1904 数据库查询的一趟扫描算法</h3><h4 id="（1）什么是一趟算法"><a href="#（1）什么是一趟算法" class="headerlink" title="（1）什么是一趟算法"></a>（1）什么是一趟算法</h4><p>内存能放下关系的所有块，即只需要调用一次数据库的算法。</p><h4 id="（2）关系-表数据的读取"><a href="#（2）关系-表数据的读取" class="headerlink" title="（2）关系/表数据的读取"></a>（2）关系/表数据的读取</h4><h5 id="聚簇关系"><a href="#聚簇关系" class="headerlink" title="聚簇关系"></a>聚簇关系</h5><p>下文中B（R）是R的存储块的数目，T（R）是R的元组数目，M是内存能放下的块的数目</p><ul><li>关系的元组集中存放（一个块中仅是一个关系的元组）<ul><li>TableScan(R) 表空间扫描算法<br>扫描结构未排序：B（R）</li><li>SortTableScan(R)<br>扫描结构排序：3B（R）</li><li>IndexScan(R) 索引扫描算法<br>扫描结果未排序：B（R）</li><li>SortIndexScan(R)<br>扫描结果排序 B(R) or 3 B(R)</li></ul></li></ul><h5 id="非聚簇关系"><a href="#非聚簇关系" class="headerlink" title="非聚簇关系"></a>非聚簇关系</h5><ul><li><p>关系的元组不一定集中存放</p></li><li><p>扫描结果未排序：T(R)</p></li><li>扫描结果排序：T(R)+2B(R)</li></ul><h4 id="（3）整个关系的一元操作算法"><a href="#（3）整个关系的一元操作算法" class="headerlink" title="（3）整个关系的一元操作算法"></a>（3）整个关系的一元操作算法</h4><ul><li>需要在内存中保存已经处理过的元组</li><li>当新元组到达时，需要和之前处理过的元组进行比较</li><li>建立不同的内存数据结构，来保存之前处理过的数据，以便快速处理整个关系上的操作</li><li>算法复杂性：B（R）</li><li><p>应用条件：B(&amp;R)&lt;=M</p></li><li><p>去重复 &amp;(R)，分组聚集<br>可以在内存中采取散列的数据结构，达到快速插入，快速定位的效果</p></li></ul><h4 id="（4）整个关系的二元操作实现算法"><a href="#（4）整个关系的二元操作实现算法" class="headerlink" title="（4）整个关系的二元操作实现算法"></a>（4）整个关系的二元操作实现算法</h4><ul><li>扫描一个关系，再扫描另一个关系</li><li>集合的操作需要去重；包的操作需要做计数</li><li>算法复杂度：B(R)+B(S)</li><li>应用条件:min(B(R),B(S))&lt;=M</li></ul><h3 id="1905-基于索引的算法"><a href="#1905-基于索引的算法" class="headerlink" title="1905 基于索引的算法"></a>1905 基于索引的算法</h3><h4 id="（1）基于索引的选择算法"><a href="#（1）基于索引的选择算法" class="headerlink" title="（1）基于索引的选择算法"></a>（1）基于索引的选择算法</h4><ul><li>选择条件中有涉及到索引属性时，可以使用索引，辅助快速索引</li><li>聚簇和非聚簇索引，使用时效率不一样</li><li>可能在多个属性上都存在索引</li></ul><p>索引应用分析示例：<br>假设B(R)=1000，T(R)=20000，即有20 000 个元组放到1000个块中。a是R的一个属性，在a上有一个索引，考虑 $\sigma_{a=0}(R)$操作</p><ul><li>如果R是聚簇的，且不使用索引，查询代价1000I/O</li><li>如果R不是聚簇的，且不使用索引，查询代价20000</li><li>如果V(R,a)=100（表示a只有100个不同的大小）,且索引是聚簇的，查询代价 即a=0d的元组所在的总共的块数，平均1000/100=10。</li><li>如果V(R,a)=100且索引是非聚簇的，查询代价平均20000/100=200</li><li>如果V(R,a)=20000，即a是关键字，查询代价为1</li></ul><h4 id="（2）基于有序索引的连接算法（Zig-Zag连接算法）"><a href="#（2）基于有序索引的连接算法（Zig-Zag连接算法）" class="headerlink" title="（2）基于有序索引的连接算法（Zig-Zag连接算法）"></a>（2）基于有序索引的连接算法（Zig-Zag连接算法）</h4><p>略难，跳，对应书P122</p><h3 id="1906-回顾"><a href="#1906-回顾" class="headerlink" title="1906 回顾"></a>1906 回顾</h3><ul><li>查询实现算法的基本思维</li><li>连接的逻辑实现算法</li><li><p>连接的物理实现算法</p><ul><li>如何降低磁盘I/O</li><li>充分利用内存，减少循环量</li><li>如何降低内存的查找量</li><li>建立合适的数据结构</li></ul></li><li><p>一趟算法：只要有一个关系能够全部装入内存即可实施<br>需要用一些算法</p><ul><li>迭代器算法</li><li>基于散列的算法</li><li>基于排序的算法</li><li>基于索引的算法</li></ul></li></ul><h3 id="2001-两趟扫描算法的基本思想"><a href="#2001-两趟扫描算法的基本思想" class="headerlink" title="2001 两趟扫描算法的基本思想"></a>2001 两趟扫描算法的基本思想</h3><h4 id="（1）整个关系操作存在的问题"><a href="#（1）整个关系操作存在的问题" class="headerlink" title="（1）整个关系操作存在的问题"></a>（1）整个关系操作存在的问题</h4><ul><li>对于一个关系，可能不能将整个关系都放入内存中，一趟算法已经不能实施</li></ul><h4 id="（2）两趟算法的基本思路"><a href="#（2）两趟算法的基本思路" class="headerlink" title="（2）两趟算法的基本思路"></a>（2）两趟算法的基本思路</h4><ul><li>第一趟：划分子集，使得子集具有某种特性，如有序或相同散列值</li><li>第二趟：处理全局性内容的操作，形成结果关系。如多子集间的归并排序，相同的散列值子集的操作等</li></ul><p>可实现原因：大数据集上的操作可以等价于子集上操作的并集</p><h3 id="2002-两阶段多路归并排序"><a href="#2002-两阶段多路归并排序" class="headerlink" title="2002 两阶段多路归并排序"></a>2002 两阶段多路归并排序</h3><h4 id="（1）-内排序和外排序"><a href="#（1）-内排序和外排序" class="headerlink" title="（1） 内排序和外排序"></a>（1） 内排序和外排序</h4><ul><li>内排序问题：待排序的数据可以一次性地装入内存中，即排序者可以完整地看到和操纵所有数据。内存中的排序算法：插入排序，冒牌排序</li><li>外排序问题：待排序的数据不能一次性地装入内存，即排序者不能一次完整地看到和操纵所有地数据，需要将数据分批次装入内存分批处理地排序问题。</li></ul><h4 id="（2）两阶段多路归并排序"><a href="#（2）两阶段多路归并排序" class="headerlink" title="（2）两阶段多路归并排序"></a>（2）两阶段多路归并排序</h4><p>全称TPMMS， Two-Phase Multi-way Merge Sort based join<br>两阶段多路归并排序是一种外排序。<br>现在假设内存大小x块，待排序数据要y块，y&gt;x。</p><ol><li>首先将要排序的数据划分为n份，x*n&gt;y</li><li>依次将分好的子集放入内存中进行内排序</li><li>随后将排序好的子集，对于所有的子集每次取一块放入内存中，将最小值或最大值取出后放入内存，原来的数据删除</li><li>内存中存在个子集中最小的元素，此时进行内排序，排序后的结果输入到新的外部存储中</li><li>重复4，5直至数据全部排序完</li></ol><p>算法效率：</p><ul><li>子集和排序阶段读一遍写一遍</li><li>归并阶段读一遍写一遍</li><li><p>总I/O次数4B(R)</p></li><li><p>算法应用条件：</p><ul><li>子集合数&lt;$B_{mermory}$</li><li>子集和块数&lt;$B_{mermory}$</li><li>大数据集块数&lt;$B_{mermory}^2$</li></ul></li></ul><h4 id="（3）更大规模的多阶段归并算法"><a href="#（3）更大规模的多阶段归并算法" class="headerlink" title="（3）更大规模的多阶段归并算法"></a>（3）更大规模的多阶段归并算法</h4><ul><li>设内存大小 $B_{mermory}=3$</li><li>待排序数据 $B_{problem}$=30$</li></ul><p>基本策略</p><ul><li>30块数据集-&gt;10个子集和，每个子集合3块，排序并存储</li><li>10个已经排序的子集合再分为5组进行二路归并排序，得到5个排序好的子集合</li><li>5个集合再分为3组，进行归并排序；最后得到3个排好序的子集和</li><li>再归并即可得到最终的排序</li></ul><h3 id="2003-基于排序的两趟扫描算法"><a href="#2003-基于排序的两趟扫描算法" class="headerlink" title="2003 基于排序的两趟扫描算法"></a>2003 基于排序的两趟扫描算法</h3><h4 id="（1）操作"><a href="#（1）操作" class="headerlink" title="（1）操作"></a>（1）操作</h4><p>去重复，聚集 复杂度等同TPMMS</p><ul><li>并<ul><li>包上直接合并即可，无需两趟</li><li>集合上需要两趟，需要去重<ul><li>效果同TPMMS</li></ul></li></ul></li><li>交，差<ul><li>包上和集合上都要两趟，需要处理出现次数或者去重复，效果同TPMMS</li></ul></li><li>连接运算$R\Join_{R.Y=S.Y} S$<ul><li>第一趟：划分R和S的子表并进行子表排序，排序均基于Y属性排序</li><li>第二趟，归并时注意是R的输入还是S的输入。R和S的两路输入之间进行连接检查后连接后输出</li><li>又称“排序-连接”算法</li></ul></li></ul><h3 id="2004-基于散列的两趟扫描算法"><a href="#2004-基于散列的两趟扫描算法" class="headerlink" title="2004 基于散列的两趟扫描算法"></a>2004 基于散列的两趟扫描算法</h3><h4 id="（1）基本思想"><a href="#（1）基本思想" class="headerlink" title="（1）基本思想"></a>（1）基本思想</h4><ul><li>第一趟：散列子表，用散列函数$h_p$将原始关系划分为$M-1$个子表并存储（剩一个用来输出）</li><li>第二趟：处理每个子表，用另一散列函数$h_r$将子表读入内存并建立内存结构，进行不同操作的处理</li></ul><h4 id="（2）实例"><a href="#（2）实例" class="headerlink" title="（2）实例"></a>（2）实例</h4><ul><li>去重复操作<ul><li>$H_p$计算元组部分属性的值$modM$,将可能重复的元组散列到同一子表中</li><li>$H_r$计算整个元组的值$modM$，将可能重复的元组散列到同一内存中</li><li>元组在子表上不重复，则在大关系中不重复</li><li>算法复杂度：4B(R)</li></ul></li><li>分组操作<ul><li>第一趟：将原始关系通过$h_p$散列成m-1个子表，并进行存储</li><li>第二趟：处理每个子表。将每个子表读入内存，并用另一函数$h_r$形成散列数据结构，进行分组聚集操作。</li><li>应选择不同的$h_p,h_r$</li></ul></li><li>并操作<ul><li>包的并无需两次，直接合并即可</li><li>集合的并需要两趟，需要去重复。</li><li>第一趟：以相同的散列函数将R和S形成M-2个子表$R_i,S_i$</li><li>第二趟：将$S_i$再整体散列读入内存中，再依次处理$R_i$的每一块，如判断$R_i,S_i$都出现元组t，则仅输出t的一个副本，否则输出$S_i,Ri$</li></ul></li><li>交叉操作类似并操作</li><li>连接操作<ul><li>$R\Join_{R.y=S.y} S$</li><li>以连接属性Y作为散列关键字，设计散列函数</li><li>第一趟：使用相同的散列函数散列两个操作对象R和S，形成R1…Rm,S1…Sm</li><li>第二趟：将Si再整体散列读入到内存中，再依次处理Ri的每一块，进行连接</li></ul></li></ul><h2 id="第五章-查询编译器"><a href="#第五章-查询编译器" class="headerlink" title="第五章 查询编译器"></a>第五章 查询编译器</h2><h3 id="2101-什么是查询优化"><a href="#2101-什么是查询优化" class="headerlink" title="2101 什么是查询优化"></a>2101 什么是查询优化</h3><h4 id="（1）为什么需要查询优化"><a href="#（1）为什么需要查询优化" class="headerlink" title="（1）为什么需要查询优化"></a>（1）为什么需要查询优化</h4><ul><li>关系数据库的执行效率问题</li><li>关系代数操作执行次序对效率的影响</li></ul><h4 id="（2）什么是查询优化"><a href="#（2）什么是查询优化" class="headerlink" title="（2）什么是查询优化"></a>（2）什么是查询优化</h4><ul><li>如何使数据库查询时间最短</li><li>三个层面进行优化<ul><li>语义优化：利用模型的语义及完整性规则，优化查询</li><li>语法优化—-逻辑层优化：利用语法结构，优化操作执行顺序</li><li>执行优化—-物理层优化：存取路径和执行算法的选择与执行次序优化</li></ul></li></ul><h3 id="2102-查询优化的总体思路"><a href="#2102-查询优化的总体思路" class="headerlink" title="2102 查询优化的总体思路"></a>2102 查询优化的总体思路</h3><h4 id="（1）语义优化—内容等价性"><a href="#（1）语义优化—内容等价性" class="headerlink" title="（1）语义优化—内容等价性"></a>（1）语义优化—内容等价性</h4><p>sql层优化，不在这里进行讨论，此处需要用户取想办法，相关研究再进行了</p><h4 id="（2）语法优化（逻辑层优化）—内容等价性"><a href="#（2）语法优化（逻辑层优化）—内容等价性" class="headerlink" title="（2）语法优化（逻辑层优化）—内容等价性"></a>（2）语法优化（逻辑层优化）—内容等价性</h4><ul><li>基本思想：改变关系代数的操作次序：尽可能地早做选择和投影运算</li><li>关系代数地五种基本操作中哪些能够交换次序</li><li>次序变化前后两个表达式地等价性问题</li><li>关系代数表达式的等价变换定理及证明（略）</li><li>关系代数表达式的优化算法？逻辑查询计划形成</li></ul><h4 id="（3）执行优化（物理层优化）"><a href="#（3）执行优化（物理层优化）" class="headerlink" title="（3）执行优化（物理层优化）"></a>（3）执行优化（物理层优化）</h4><ul><li>获取数据库的相关信息（定期统计）</li><li>实现同一关系操作的不同例行程序</li><li>选择相应的例行程序</li><li>依据相关信息进行代价估算，选择代价最少的例行程序及确定相应的参数</li><li>形成查询计划：以基本的例行程序为基本，确定这些例行程序的执行顺序</li></ul><h4 id="（4）查询优化的总过程"><a href="#（4）查询优化的总过程" class="headerlink" title="（4）查询优化的总过程"></a>（4）查询优化的总过程</h4><ul><li>用户书写sql语言</li><li>转化为关系代数</li><li>逻辑查询计划—逻辑层优化<ul><li>关系代数操作顺序的优化</li></ul></li><li>物理查询计划—物理层优化<ul><li>代价估算</li><li>算法选择与装配次序</li></ul></li><li>由执行引擎解释并调用算法（程序）予以执行</li></ul><h3 id="2103-逻辑层优化策略"><a href="#2103-逻辑层优化策略" class="headerlink" title="2103 逻辑层优化策略"></a>2103 逻辑层优化策略</h3><h4 id="（1）一个待优化的实例背景"><a href="#（1）一个待优化的实例背景" class="headerlink" title="（1）一个待优化的实例背景"></a>（1）一个待优化的实例背景</h4><p>考虑一个图书馆的关系数据库<br>$BOOKS(TUTLE,AUTHOR,PNAME,LC_NO)$<br>$PNAME$为出版社名，$LC_NO$为图书馆图书编号<br>$PUBLISHERS(PNAME,PADDR,PCITY)$<br>出版社名字，出版社地址，出版社城市<br>$BORROWERS(NAME,ADDR,CITY,CARD_NO)$<br>$CARD_NO$为图书证号<br>$LOADS(CARD_NO,LC_NO,DATE)$</p><h4 id="（2）用语法树表达关系代数表达式"><a href="#（2）用语法树表达关系代数表达式" class="headerlink" title="（2）用语法树表达关系代数表达式"></a>（2）用语法树表达关系代数表达式</h4><ul><li>由树叶向树根反映了操作的先后次序</li></ul><h4 id="（3）逻辑优化的策略"><a href="#（3）逻辑优化的策略" class="headerlink" title="（3）逻辑优化的策略"></a>（3）逻辑优化的策略</h4><ul><li>尽可能地早做选择和投影<ul><li>可以使得中间结果变小，减小几个数量级的执行时间</li></ul></li><li>把选择和投影串接起来：<ul><li>一元运算序列可以一起执行，只需对整个关系扫描一遍</li></ul></li><li>把投影与其前后的二元运算结合起来<ul><li>在第一次用关系时去掉一些无关属性，可以避免多次扫描整个关系</li></ul></li><li>把某些选择与其前的笛卡尔积合并成一个连接<ul><li>当$R\times S$前有选择运算且期中有条件是R，S属性间的比较运算时，可将其转化为连接运算可节省时间</li></ul></li><li>执行连接运算前对关系适当预处理<ul><li>文件排序，建立临时索引等，可以使得俩关系公共值高效连接</li></ul></li><li>找出表达式里的公共子表达式<ul><li>若公共子表达式结果不大，可以预先计算，以后可读入此结果，节省时间较多，在试图情况下尤其有用</li></ul></li></ul><h3 id="2104-关系代数操作次序交换的等价性"><a href="#2104-关系代数操作次序交换的等价性" class="headerlink" title="2104 关系代数操作次序交换的等价性"></a>2104 关系代数操作次序交换的等价性</h3><h4 id="（1）等价性"><a href="#（1）等价性" class="headerlink" title="（1）等价性"></a>（1）等价性</h4><p>定义：</p><ul><li>设$E_1,E_2$是两个关系操作表达式，若$E_1,E_2$表示相同的映射，记当$E_1,E_2$的同名变量带入相同的关系后产生相同的结果(影响几何)，则说$E_1,E_2$是等价的，记为$E_1\equiv E_2$</li></ul><h4 id="（2）哪些关系操作次序可以交换"><a href="#（2）哪些关系操作次序可以交换" class="headerlink" title="（2）哪些关系操作次序可以交换"></a>（2）哪些关系操作次序可以交换</h4><h5 id="定理L1：连接与连接，积与积的交换律"><a href="#定理L1：连接与连接，积与积的交换律" class="headerlink" title="定理L1：连接与连接，积与积的交换律"></a>定理L1：连接与连接，积与积的交换律</h5><ul><li>$E_1 \Join_F E_2\equiv E_2 \Join_F E_1$</li><li>$E_1 \Join E_2\equiv E_2 \Join E_1$</li><li>$E_1 \times E_2\equiv E_2\times E_1$</li></ul><p>并，交运算也有交换律</p><h5 id="定理L2：定理L1：连接与连接，积与积的结合律"><a href="#定理L2：定理L1：连接与连接，积与积的结合律" class="headerlink" title="定理L2：定理L1：连接与连接，积与积的结合律"></a>定理L2：定理L1：连接与连接，积与积的结合律</h5><ul><li>$(E_1\Join_{F1}E_2)\Join_{F_2}E_3\equiv E_1\Join_{F1}(E_2\Join_{F_2}E_3)$</li><li>$(E_1\Join E_2)\Join E_3\equiv E_1\Join (E_2\Join E_3)$</li><li>$(E_1\times E_2)\times E_3\equiv E_1\times (E_2\times E_3)$</li></ul><p>并，交运算也有结合律</p><h5 id="定理L3：投影串接率"><a href="#定理L3：投影串接率" class="headerlink" title="定理L3：投影串接率"></a>定理L3：投影串接率</h5><p>设属性集合${A_1,..A_n}\subseteq {B_1..B_m}$,$E$是表达式，则有：</p><script type="math/tex; mode=display">\pi_{A_1,..A_n}(\pi_{B_1,..B_m}(E))\equiv \pi_{A_1,..A_n}</script><ul><li>此定理可以双向使用<ul><li>正向可以将两遍扫描变为一边扫描</li><li>逆向可以将属性扩展便于投影操作的移动</li></ul></li></ul><h5 id="定理L4：选择的串接率"><a href="#定理L4：选择的串接率" class="headerlink" title="定理L4：选择的串接率"></a>定理L4：选择的串接率</h5><p>若$E$是关系代数表达式，$F_1,F_2$是条件，则有<script type="math/tex">\sigma_{F1}(\sigma_{F2}(E))\equiv \sigma_{F_1\wedge F_2}(E)</script></p><ul><li>此定理可以双向使用<ul><li>正向可以将两遍扫描变为一边扫描</li><li>逆向可以将属性扩展便于选择操作的移动</li></ul></li></ul><h5 id="定理L5：选择和投影的交换律"><a href="#定理L5：选择和投影的交换律" class="headerlink" title="定理L5：选择和投影的交换律"></a>定理L5：选择和投影的交换律</h5><p>设条件F只涉及属性${A_1…A_n}$,$E$是关系表达式，则有<script type="math/tex">\pi_{A_1..A_n}(\sigma_{F}(E))\equiv\sigma_F(\pi_{A_1..A_n}(E))</script><br>更一般地，若$F$还涉及不属于${A1,..A_n}$的属性${B_1,..B_m}$,则<script type="math/tex">\pi_{A_1,...A_n}(\sigma_F(E))\equiv\pi_{A_1,..A_n}(\sigma_F(\pi_{A_1,..A_n,B_1,..B_m}(E)))</script></p><p>尽可能地早做选择</p><h5 id="定理L6：选择合积的交换律"><a href="#定理L6：选择合积的交换律" class="headerlink" title="定理L6：选择合积的交换律"></a>定理L6：选择合积的交换律</h5><p>设$E_1,E_2$是关系代数表达式</p><ul><li>(1):若条件F只涉及$E_1$中的属性：则有<script type="math/tex">\sigma_F(E_1\times E_2)\equiv \sigma_{F}(E_1)\times(E_2)</script></li><li>(2):若$F=F_1\wedge F_2$,$F_1$,$F_2$,分别只涉及$E_1,E_2$中属性，则有：<script type="math/tex">\sigma_F(E_1\times E_2)\equiv \sigma_{F_1}(E_1)\times \sigma_{F_2}(E_2)</script></li><li>(3):若$F=F_1\wedge F_2$,$F_1$只涉及$E_1$中属性，而$F_2$涉及$E_1,E_2$中属性，则有<script type="math/tex">\sigma_F(E1\times E2)\equiv \sigma_{F_2}(\sigma_{F_1}(E_1)\times E_2)</script></li></ul><h5 id="定理L7-投影和积的交换律"><a href="#定理L7-投影和积的交换律" class="headerlink" title="定理L7:投影和积的交换律"></a>定理L7:投影和积的交换律</h5><p>设$E_1,E_2$为俩关系的代数表达式，$A_1,…A_n$是出现在$E_1$或$E_2$中的一些属性，其中$B_1,..B_m$出现在中$E_1$，剩余的属性$C_1,..C_k$出现在$E_2$中，则有<script type="math/tex">\pi_{A_1..A_n}(E_1\times E_2)\equiv \pi_{B_1,..B_m}(E_1)\times \pi_{C_1,..c_k}(E_2))</script></p><h5 id="定理L8-选择和并的交换律"><a href="#定理L8-选择和并的交换律" class="headerlink" title="定理L8:选择和并的交换律"></a>定理L8:选择和并的交换律</h5><p>设关系代数表达式$E=E_1\cup E_2$，$F$是条件，则有：<script type="math/tex">\sigma_{F}(E_1\cup E_2)\equiv \sigma_F(E_1) \cup \sigma_F(E_2)</script></p><h5 id="定理L9-选择和差的交换律"><a href="#定理L9-选择和差的交换律" class="headerlink" title="定理L9:选择和差的交换律"></a>定理L9:选择和差的交换律</h5><p>设关系代数表达式$E=E_1-E_2$，$F$是条件，则有：<script type="math/tex">\sigma_{F}(E_1 - E_2)\equiv \sigma_F(E_1) - \sigma_F(E_2)</script></p><h5 id="定理L10-投影和并的交换律"><a href="#定理L10-投影和并的交换律" class="headerlink" title="定理L10:投影和并的交换律"></a>定理L10:投影和并的交换律</h5><p>设关系代数表达式$E=E_1\cup E_2,A_1…A_n$是$E$中的一些属性，则有<script type="math/tex">\pi_{A_1..A_n}(E_1\cup E_2)\equiv \pi_{A_1..A_n}\cup \pi_{A_1..A_n}(E_2)</script></p><h3 id="2105-基于关系代数的查询优化算法及示例"><a href="#2105-基于关系代数的查询优化算法及示例" class="headerlink" title="2105 基于关系代数的查询优化算法及示例"></a>2105 基于关系代数的查询优化算法及示例</h3><ul><li>算法：关系代数表达式的优化算法</li><li>input：一个关系代数表达式的语法树</li><li>output：计算该表达式的程序</li><li>method：<ul><li>依据定理L4,把形如$\sigma_{F_1\wedge F_2\wedge …\wedge F_n}$的选择表达式变成串接形式$\sigma_{F1}(\sigma_{F2}(…(\sigma_{Fn}(E))))$</li><li>对每个选择，依据定理L4-L9，尽可能把它移动到树的底部</li><li>对每个投影，依据定理L3,7,10,5,尽可能的移到书的底部。如果一个投影是对表达式的所有属性进行的，则可以删去</li><li>依据定理L4，5把串接的选择和投影组合为单个选择，单个投影，或者一个选择后跟一个投影</li><li>对修改后的语法树，将其内节点按以下方式分组：<ul><li>每个二元运算节点和其所有的一元运算的直接祖先放在一组；对于所有的后代节点，若后代节点是一串一元运算且树叶为终点，则将这些一元运算节点放在改组中；如该二元运算节点是笛卡尔积，则其后代节点不能和它组合成连接，则不能将后代节点归入改组</li></ul></li><li>产生一个程序：它以每组节点为一步，但后代组先执行</li></ul></li></ul><h3 id="2106-物理层查询优化"><a href="#2106-物理层查询优化" class="headerlink" title="2106 物理层查询优化"></a>2106 物理层查询优化</h3><h4 id="（1）物理查询优化—总体思路"><a href="#（1）物理查询优化—总体思路" class="headerlink" title="（1）物理查询优化—总体思路"></a>（1）物理查询优化—总体思路</h4><ul><li>获取数据库的相关信息（定期统计）</li><li>实现同一关系操作的不同例行程序</li><li>选择相应的例行程序</li><li>依据相关信息进行代价估算，选择代价最少的例行程序及确定相应的参数</li><li><p>形成查询计划：以基本的例行程序为基本，确定这些例行程序的执行顺序</p></li><li><p>物理查询运算符</p><ul><li>获取关系元组的操作<ul><li>表空间扫描法</li><li>表空间扫描排序法</li><li>索引扫描法</li><li>索引扫描排序法</li></ul></li><li>关系操作的各种实现算法<ul><li>一趟算法，两趟算法</li><li>基于索引算法，基于散列算法，基于排序算法</li></ul></li><li>迭代器构造—流水化，物化</li></ul></li></ul><p>物理查询运算符通常是关系代数操作符的一个特定实现</p><h4 id="（2）衡量一个物理查询计划"><a href="#（2）衡量一个物理查询计划" class="headerlink" title="（2）衡量一个物理查询计划"></a>（2）衡量一个物理查询计划</h4><p>依据数据库中的一些统计信息—存放在数据字典或系统目录中的</p><ul><li>$T_R$或$T(R):$关系R的元组数目</li><li>$B_R$或$B(R):$关系R的磁盘块数目</li><li>$I_R$或$I(R):$关系R的每个元组的字节数</li><li>$f_R$或$f(R):$R的块因子，即一个块中能够储存的R的元组数目</li><li>$V(A,R):$R中属性A出现不同值的数目</li><li>$SC(A,R):$R中属性A的选择基数，满足A上等值条件的平均记录数</li><li>$b:$每个磁盘块的字节数</li><li>…</li></ul><p>DBMS依据上述统计信息对DB操作的各种物理查询计划进行评估，以确定最优的计划予以执行。</p><h4 id="（3）如何收集这些信息"><a href="#（3）如何收集这些信息" class="headerlink" title="（3）如何收集这些信息"></a>（3）如何收集这些信息</h4><ul><li>当一个表装入内存和创建索引的时候，统计信息不是被自动收集的，必须有DBA使用特定的命令来完成信息统计，这些命令就是收集统计信息并把其存入系统目录中的实用程序</li><li>随着表的更新操作。统计信息可能会过时，过时的统计信息会使DBMS确定方案时决策错误，因此要求DBA定期的对有频繁更新操作的Table进行统计</li><li>DBA要熟悉统计信息收集命令的使用，并定期执行</li></ul><h3 id="2107-代价估算"><a href="#2107-代价估算" class="headerlink" title="2107 代价估算"></a>2107 代价估算</h3><h4 id="（1）投影运算的代价估算"><a href="#（1）投影运算的代价估算" class="headerlink" title="（1）投影运算的代价估算"></a>（1）投影运算的代价估算</h4><ul><li>投影运算并未减少行数，但可能有效地减少了存储结果关系地块数</li></ul><h4 id="（2）选择运算地代价估算"><a href="#（2）选择运算地代价估算" class="headerlink" title="（2）选择运算地代价估算"></a>（2）选择运算地代价估算</h4><p>估算选择运算$S=\sigma_{A=c}(R)$的大小</p><ul><li>$T(S)$介于0 到$T(R)-V(R,A)+1$之间<ul><li>最多：A属性不同值的元组都只存在一个，剩余的都是$A=c$的分组</li></ul></li><li>估计：$T(S)=T(R)/V(R,A)$<ul><li>A属性的不同值的元组假设是平均分布的</li></ul></li><li>当不知道$V(R,A)$时，估计：$T(S)=T(R)/10$</li></ul><p>估算选择运算$S=\sigma_{A&lt;c}(R)$的大小</p><ul><li>一般取$T(S)=T(R)/3$</li></ul><p>估算选择运算$S=\sigma_{C1 or C2}(R)$</p><ul><li>$T(S)=n(1 - (1-\frac{m1}{n})(1-\frac{m2}{n}))$,m1为满足$C1$的个数，m2为满足$C2$的个数，R有n个元组</li></ul><h4 id="（3）连接运算的代价估算"><a href="#（3）连接运算的代价估算" class="headerlink" title="（3）连接运算的代价估算"></a>（3）连接运算的代价估算</h4><p>估计连接运算$S=R(X,Y) Natural Join S(Y,Z)$的大小</p><ul><li>$T(S)=\frac{T(R)T(S)}{max(V(R,Y),V(S,Y))}$</li></ul><h3 id="2108-回顾"><a href="#2108-回顾" class="headerlink" title="2108 回顾"></a>2108 回顾</h3><p>以往关系型数据库被认为是不可能的，因为连接会产生巨大的中间数据，但在查询优化后，中间数据变得可以接受，使得关系型数据库成为了现实。</p><ul><li>查询优化<ul><li>逻辑层优化<ul><li>关系代数操作次序优化</li></ul></li><li>物理层优化<ul><li>代价估算</li><li>算法选择和装配次序</li></ul></li></ul></li></ul><h2 id="第七章-并发控制-及-第八章-再论事务管理"><a href="#第七章-并发控制-及-第八章-再论事务管理" class="headerlink" title="第七章 并发控制 及 第八章 再论事务管理"></a>第七章 并发控制 及 第八章 再论事务管理</h2><h3 id="2201-为什么要进行并发控制"><a href="#2201-为什么要进行并发控制" class="headerlink" title="2201 为什么要进行并发控制"></a>2201 为什么要进行并发控制</h3><h4 id="（1）数据库可能存在不一致"><a href="#（1）数据库可能存在不一致" class="headerlink" title="（1）数据库可能存在不一致"></a>（1）数据库可能存在不一致</h4><ul><li>三种典型不一致<ul><li>丢失修改</li><li>不能重复读</li><li>脏读</li></ul></li></ul><h4 id="（2）并发控制的缘由"><a href="#（2）并发控制的缘由" class="headerlink" title="（2）并发控制的缘由"></a>（2）并发控制的缘由</h4><pre><code class="lang-mermaid">graph LRA(DB共享)--&gt;B(多应用程序使用);B--&gt;C(可能同时使用);C--&gt;D(数据的不一致性);D--&gt;E(不一致性的类型);E--&gt;F(并发控制);F--&gt;G(并发控制方法);</code></pre><h4 id="（3）并发控制及相应的事务处理技术是DBMS的核心技术"><a href="#（3）并发控制及相应的事务处理技术是DBMS的核心技术" class="headerlink" title="（3）并发控制及相应的事务处理技术是DBMS的核心技术"></a>（3）并发控制及相应的事务处理技术是DBMS的核心技术</h4><p>核心概念：事务，并发控制，封锁</p><h3 id="2202-深入认识事务"><a href="#2202-深入认识事务" class="headerlink" title="2202 深入认识事务"></a>2202 深入认识事务</h3><h4 id="（1）事务的概念"><a href="#（1）事务的概念" class="headerlink" title="（1）事务的概念"></a>（1）事务的概念</h4><ul><li>事务（Transaction）<br>事务是数据库管理系统提供的控制数据操作的一种手段，通过这一手段，应用程序员将一系列的数据库操作组合在一起作为一个整体进行操作和控制，以便数据库管理系统能够提供一致性状态转换的保证。</li></ul><h4 id="（2）事务的宏观性和微观性"><a href="#（2）事务的宏观性和微观性" class="headerlink" title="（2）事务的宏观性和微观性"></a>（2）事务的宏观性和微观性</h4><h5 id="事务的宏观性（应用程序员看到的事务）"><a href="#事务的宏观性（应用程序员看到的事务）" class="headerlink" title="事务的宏观性（应用程序员看到的事务）"></a>事务的宏观性（应用程序员看到的事务）</h5><ul><li>一个存取或改变数据库内容的一次执行，或者说一条或多条SQL语句的一次执行被看作一个事务</li><li>事务一般是由应用程序员提出，因此有开始和结束，结束前需要提交或撤销</li><li>一个事务可以处理一个数据或一条记录</li><li>复杂的事务可以处理一批数据或一批记录</li><li>一段程序语言，可能会循环执行，执行中，由SQL语句引出事务，直到事务结束，每次循环都将产生一个事务</li></ul><h5 id="事务的微观性（DBMS看到的事务）"><a href="#事务的微观性（DBMS看到的事务）" class="headerlink" title="事务的微观性（DBMS看到的事务）"></a>事务的微观性（DBMS看到的事务）</h5><ul><li>对数据库的一系列基本操作（读，写）的一个整体性执行</li><li>事物的并发执行：多个事务在宏观上看是并发执行，但其在微观上的基本操作则可以是交叉执行的</li></ul><h4 id="（3）事务的特性"><a href="#（3）事务的特性" class="headerlink" title="（3）事务的特性"></a>（3）事务的特性</h4><ul><li>宏观独立性</li><li>微观交错执行</li><li><p>并发控制就是通过事务微观交错执行次序的正确安排，保证事务宏观的独立性，完整性和正确性</p></li><li><p>事务的特性 ACID</p><ul><li>原子性（Atomicity）:DBMS能够保证事务的一组更新操作是原子不可分的，即对DB而言，要么全做，要么不做</li><li>一致性（Consistency）:DBMS保证事务的操作状态是正确的，符合一致性的操作规则，不能出现三种典型的不一致性。它是进一步由隔离性来保证的。</li><li>隔离性（Isolation）:DBMS保证并发执行的多个事务之间互相不受影响。例如两个事务T1，T2，既是并发执行，也相当于依次执行</li><li>持久性（Durablity）:DBMS保证已提交的事务影响是持久的，被撤销事务的影响是可以恢复的</li></ul></li><li>具有ACID特性的若干数据库基本操作的组合体称为事务</li></ul><h4 id="（4）DBMS对事务的控制"><a href="#（4）DBMS对事务的控制" class="headerlink" title="（4）DBMS对事务的控制"></a>（4）DBMS对事务的控制</h4><p><img src="/images/DBMS对事务的控制.jpg"></p><h3 id="2203-事务调度的可串行性"><a href="#2203-事务调度的可串行性" class="headerlink" title="2203 事务调度的可串行性"></a>2203 事务调度的可串行性</h3><h4 id="（1）基本概念"><a href="#（1）基本概念" class="headerlink" title="（1）基本概念"></a>（1）基本概念</h4><ul><li>事务调度：一组事务的基本步（读，写，其它控制操作比如加锁，解锁等）的一种执行顺序称为对这组事务的一个调度。<br>并发调度：多个事务从宏观上看是并发执行的，但是其微观上的基本操作(读写)则是交叉执行的。</li><li>并发调度的正确性：当且仅当在这个并发调度下所得到的新数据库结果与分别串行地运行这些事务所得到地新数据库完全一直，则说调度是正确的。</li><li>可串行性：如果不管数据库初始状态如何，一个调度对数据库状态的影响都和某个串行调度相同，则我们说这个调度是可串行化的或者说可序列化的。</li><li>可串行化调度一定是正确地并行调度，但正确的并行调度，却未必第一事故可串行化的调度</li><li>并行调度的正确性是指内容上的结果正确性，而可串行性是指形式上结果正确性</li><li>可串行化的等效串行序列不一定唯一</li></ul><h4 id="（2）一种简单的事务调度的标记模型"><a href="#（2）一种简单的事务调度的标记模型" class="headerlink" title="（2）一种简单的事务调度的标记模型"></a>（2）一种简单的事务调度的标记模型</h4><p>$r_T(A):$事务T读A. $w_T(A):$事务T写A</p><h4 id="（3）冲突的串行性"><a href="#（3）冲突的串行性" class="headerlink" title="（3）冲突的串行性"></a>（3）冲突的串行性</h4><ul><li>冲突：调度中的一对连续的动作，他们满足：如果它们的顺序交换，那么涉及的事务中至少有一个事务的行为会改变</li><li>有冲突的两个操作是不能交换次序的，没有冲突的两个事务是可交换的</li><li>几种冲突情况<ul><li>同一事务的任何两个操作都是冲突的</li><li>不同事务对同一元素的两个写操作是冲突的</li><li>不同事务对同意元素的一读一写操作是冲突的</li></ul></li><li>冲突可串行性：一个调度，如果通过交换两个相邻的无冲突的操作能够转换到某一个串行的调度，则称此调度为冲突可串行化的调度。</li><li>冲突可串行化是比 可串行化更严格的概念</li><li>满足冲突可串行化，一定满足可串行性</li></ul><h4 id="（4）冲突可串行性判别算法"><a href="#（4）冲突可串行性判别算法" class="headerlink" title="（4）冲突可串行性判别算法"></a>（4）冲突可串行性判别算法</h4><h5 id="（1）问题"><a href="#（1）问题" class="headerlink" title="（1）问题"></a>（1）问题</h5><ul><li><p>并发调度的正确性：当且仅当在这个并发调度下所得到的新数据库结果与分别串行地运行这些事务所得到的新数据库完全一致，则说调度是正确的</p></li><li><p>问题1：怎样判断一个并发调度是正确的</p><ul><li>解决：通过判断是否为冲突可串行性</li></ul></li><li>问题2：怎样产生一个正确的并发调度</li></ul><h5 id="（2）算法表达"><a href="#（2）算法表达" class="headerlink" title="（2）算法表达"></a>（2）算法表达</h5><ul><li>构造一个前驱图（有向图）</li><li>节点是每一个事务$T_i$，如果$T_i$的一个操作与$T_j$的一个操作发生冲突，且$T_i$在$T_j$前执行，则绘制一条边，由$T_i$指向$T_j$，表示$T_i$要在前$T_j$执行</li><li>测试检查：如果该有向图没有环，则是冲突可串行化的</li></ul><h3 id="2204-基于封锁的并发控制方法"><a href="#2204-基于封锁的并发控制方法" class="headerlink" title="2204 基于封锁的并发控制方法"></a>2204 基于封锁的并发控制方法</h3><h4 id="（1）-问题"><a href="#（1）-问题" class="headerlink" title="（1） 问题"></a>（1） 问题</h4><ul><li>怎样产生一个冲突可串行化的调度<ul><li>基于封锁的并发控制</li><li>基于时间戳的并发控制</li><li>基于有效性确认的并发控制</li></ul></li></ul><h4 id="（2）什么是“锁”"><a href="#（2）什么是“锁”" class="headerlink" title="（2）什么是“锁”"></a>（2）什么是“锁”</h4><ul><li>“锁”是控制并发的一种手段<ul><li>每一数据元素都有一个唯一的锁</li><li>每一事务读写数据元素前，要获取锁</li><li>如果被其他食物持有该元素的锁，则要等待</li><li>事务处理完成后要释放锁</li></ul></li></ul><p>$L_i(A):$事务$T_i$对数据元素$A$加锁<br>$U_i(A):$事务$T_i$对数据元素$A$解锁</p><ul><li>事务调度器   拥有锁表，来管理锁<ul><li>利用锁来保证冲突的可串行性</li><li>对所有事务的操作产生一个读写操作序列</li><li>保证事务的一致性</li></ul></li><li>锁本身并不能保证冲突可串行性</li><li>锁为调度提供了控制的手段，但如何用锁，仍需说明，并采用不同的协议</li></ul><h4 id="（3）封锁协议需要考虑什么"><a href="#（3）封锁协议需要考虑什么" class="headerlink" title="（3）封锁协议需要考虑什么"></a>（3）封锁协议需要考虑什么</h4><ul><li>封锁协议之锁的类型<ul><li>排他锁（又称X锁）<ul><li>只有一个事务能读，写，其它任何事物不能读写</li></ul></li><li>贡献锁<ul><li>所有事务都可以读，但任何事务都不能写</li></ul></li><li>更新锁<ul><li>初始读，以后可升级为写</li></ul></li><li>增量锁<ul><li>增量更新</li><li>区分增量更新和其他类型的更新</li></ul></li></ul></li><li>封锁协议之相容性矩阵<ul><li>当某事务对一数据对象持有一种锁时，另一事务再申请对该对象加某一类型锁时，时允许还是不允许</li></ul></li><li>封锁协议之解锁和加锁的时机<ul><li>SQL之隔离性级别</li><li>读未提交</li><li>读已提交</li><li>可重复读</li><li>可串行化</li></ul></li><li>封锁协议之封锁力度<ul><li>封锁力度指封锁数据对象的大小</li><li>粒度单位：属性值-元组-元组集合-整个关系-整个DB某索引项-某个索引</li><li>从前往后：并发度变小，封锁开销小，从后往前相反</li></ul></li></ul><h4 id="（4）两端封锁协议"><a href="#（4）两端封锁协议" class="headerlink" title="（4）两端封锁协议"></a>（4）两端封锁协议</h4><h5 id="什么是两段封锁协议"><a href="#什么是两段封锁协议" class="headerlink" title="什么是两段封锁协议"></a>什么是两段封锁协议</h5><ul><li>读写数据之前要获得锁。每个事务中所有封锁请求先于任何一个解锁请求</li><li><p>两阶段：加锁段，解锁段。加锁段中不能有解锁操作，解锁段中不能有加锁操作。</p></li><li><p>两段封锁协议可以保证冲突可串行化<br>归纳法证明P215</p></li><li>两端封锁协议可能产生死锁</li></ul><h3 id="2205-基于时间戳的并发控制"><a href="#2205-基于时间戳的并发控制" class="headerlink" title="2205 基于时间戳的并发控制"></a>2205 基于时间戳的并发控制</h3><h4 id="（1）什么是时间戳"><a href="#（1）什么是时间戳" class="headerlink" title="（1）什么是时间戳"></a>（1）什么是时间戳</h4><ul><li>一种基于时间的标志</li><li><p>时间戳具有唯一性和递增性</p></li><li><p>事务T启动时，系统将该时刻赋予T，为T的时间戳</p></li><li>时间戳可以表征一系列事务执行的先后顺序：时间戳小的事务先执行，大的后执行</li><li>利用时间戳，可以不用锁来进行并发控制</li></ul><h4 id="（2）基于时间戳并发控制的基本思路"><a href="#（2）基于时间戳并发控制的基本思路" class="headerlink" title="（2）基于时间戳并发控制的基本思路"></a>（2）基于时间戳并发控制的基本思路</h4><ul><li>借助时间戳，强制使一组并发事务的交叉执行，等价于一个特定顺序（时间戳从小到大）的串行执行</li><li>如何强制：执行判断冲突<ul><li>如无冲突，予以执行</li><li>如有冲突，则撤销事务，并重启该事务<br>此时该事务获得了一个更大的时间戳，表明是后执行的事务</li></ul></li><li>有哪些冲突<ul><li>读读无冲突</li><li>读写或写读冲突</li><li>写写冲突</li></ul></li></ul><h4 id="（3）基于时间戳的简单调度"><a href="#（3）基于时间戳的简单调度" class="headerlink" title="（3）基于时间戳的简单调度"></a>（3）基于时间戳的简单调度</h4><p>对DB中的每个元素x，系统保留其上最大的时间戳</p><ul><li>RT（X）即R-timestamp（x）<ul><li>读过该数据事务中最大的时间戳，即最后读x的事务的时间戳</li></ul></li><li>WT（X）即W-timestamp（x）<ul><li>写过该数据事务中最大的时间戳，即最后写x的事务的时间戳</li></ul></li><li><p>事务的时间戳</p><ul><li>TS（T）：即TimeStamp</li></ul></li><li><p>读写并发：</p><ul><li>若T事务读x，则将T的时间戳TS与WT（x）比较：<ul><li>若TS大（T 后进行），则允许T操作，并且更改RT（x）为max(RT(x),TS)</li><li>否则，有冲突，撤回T，重启T</li></ul></li><li>若T事务写x，则将T的时间戳TS与RT（x）比较<ul><li>若TS大（T后进行），则允许T操作，并且更改WT（x）为max(WT(x),TS)</li></ul></li></ul></li><li>写写并发<ul><li>若T事务写x，则将T的时间戳TS与WT（x）比较<ul><li>若TS大，则允许T写，并且更改WT（x）为T的时间戳</li><li>否则有冲突，T撤回重做</li></ul></li></ul></li></ul><h4 id="（4）（3）的改进"><a href="#（4）（3）的改进" class="headerlink" title="（4）（3）的改进"></a>（4）（3）的改进</h4><p>新增标志：</p><ul><li>C（x）：x的提交位<ul><li>该位为真，当且仅当最近写x的事务已经提交</li><li>C（x）的目的是避免出现事务读另一事务U所写数据然后U还未写完终止这样的情况</li></ul></li><li>对来自事务T的读写请求，调度器可以<ul><li>同意请求</li><li>撤销或终止T，并重启具有新时间戳的T(终止+重启，称为回滚)</li><li>推迟T，并在以后决定是终止T还是同意请求(如果请求是读，且此读可能是脏的)</li></ul></li></ul><h5 id="调度规则"><a href="#调度规则" class="headerlink" title="调度规则"></a>调度规则</h5><ul><li>假设调度器收到请求$r_T(x)$<ul><li>(1)如果TS(T)&gt;=WT(x)，此读是事实上可实现的<ul><li>如果C(x)为真，同意请求。如果TS(T)&gt;RT(x),置RT(x):=TS(T);否则不改变RT(x)</li><li>如果C(x)为假，推迟T直到C(x)为真或写x的事务终止</li></ul></li><li>(2)如果TS(T)&lt;=WT(x),此读是事实上不可实现的<ul><li>回滚T（过晚的读）</li></ul></li></ul></li><li>假设调度器收到请求$w_T(x)$<ul><li>(1)如果$TS(T)&gt;=RT(x)$，且$TS(T)&gt;=WT(x)$，此写是事实上可实现的<ul><li>为x写入新值，置$WT(x):=TS(T),C(x)=false$</li></ul></li><li>(2)如果$TS(T)&gt;=RT(x)$，但是$TS(T)&lt;WT(x)$，此写是事实上可实现的，但x已经有一个更晚的值<ul><li>如果$C(x)$为真，那么前一个x的写已提交，则忽略T的写</li><li>如果$C(x)$为假，则我们推迟T，直到$C(x)$为真或x的事务终止</li></ul></li><li>(3)如果$TS(T)&lt;RT(x)$，此写事实上是不可实现的<ul><li>T必须回滚</li></ul></li></ul></li><li>假设调度器收到提交T的请求<ul><li>它必须找到T所写的所有数据库元素x，并置$C(x):=true$</li><li>如果有任何等待x被提交的事务，这些事务就被允许继续进行</li></ul></li><li>假设调度器收到终止T的请求<ul><li>向前面步骤一样回滚T。</li><li>那么任何等待T所写元素x的事务必须重新读或写，看这一动作现在的T的写被终止后是否合法</li></ul></li></ul><h3 id="2206-基于有效性确认的并发控制方法"><a href="#2206-基于有效性确认的并发控制方法" class="headerlink" title="2206 基于有效性确认的并发控制方法"></a>2206 基于有效性确认的并发控制方法</h3><h4 id="（1）思想"><a href="#（1）思想" class="headerlink" title="（1）思想"></a>（1）思想</h4><ul><li>事务在启动时刻被赋予唯一的时间戳，以示其启动顺序</li><li>为每一个活跃的事务保存其读写数据集合，RS(T):事务T读数据的集合，WS(T):事务T写数据的集合</li><li>通过对多个事务的读写集合，判断是否有冲突，即有效性确认，来完成事务的提交与回滚，强制事务以可串行化的方式执行</li></ul><h4 id="（2）调度器的运行"><a href="#（2）调度器的运行" class="headerlink" title="（2）调度器的运行"></a>（2）调度器的运行</h4><p>事务分三个阶段进行</p><ul><li>读阶段：事务从数据库中读取读集合中的所有元素，事务还在其局部地址空间计算它将要写的值</li><li>有效性确认阶段：调度器通过比较该事务与其它事务的读写集合来确认该事务的有效性</li><li>写阶段：事务往数据库中写入其写集合元素中的值</li><li>每个成功确认的事务是在其有效性确认的瞬间执行的</li><li>并发事务串行的顺序即事务有效性确认的顺序</li></ul><p>调度器维护三个集合：</p><ul><li>start集合：已经开始但尚未完成有效性确认的事务集合，对此集合中的事务，调度器维护start(T)，即事务T开始的时间</li><li>val集合，已经确认有效性但尚未完成第三阶段写的事务，对此集合中的事务，调度器维护start(T),val(T)，即T确认的时间</li><li>FIN集合，已经完成三阶段的事务，对于这样的事务T，调度器记录start(T),val(T),fin(T),即T的完成时间</li></ul><h4 id="（3）有效性确认的规则"><a href="#（3）有效性确认的规则" class="headerlink" title="（3）有效性确认的规则"></a>（3）有效性确认的规则</h4><ul><li>（1）对于所有已经经过有效性确认，且在T开始前没有完成的U，即对于满足$FIN(U)&gt;START(T)$的U，检测<ul><li>$RS(T)\cap WS(U)$是否为空</li><li>若为空，则确认，否则不予确认</li></ul></li><li>（2）对于所有已经经过有效性确认，且在T有效性确认前没有完成的U，即对于满足$FIN(U)&gt;VAL(T)$的U，检测<ul><li>$WS(T)\cap WS(U)$是否为空</li><li>若为空，则确认，否则不予确认</li></ul></li></ul><h2 id="第六章-系统故障对策"><a href="#第六章-系统故障对策" class="headerlink" title="第六章 系统故障对策"></a>第六章 系统故障对策</h2><h3 id="2301-数据库的故障及其影响"><a href="#2301-数据库的故障及其影响" class="headerlink" title="2301 数据库的故障及其影响"></a>2301 数据库的故障及其影响</h3><h4 id="（1）基础需要需要知道的"><a href="#（1）基础需要需要知道的" class="headerlink" title="（1）基础需要需要知道的"></a>（1）基础需要需要知道的</h4><ul><li>DBMS运行方式<ul><li>DBMS利用内存和外存这样的存储体系来进行数据库管理</li><li>在内存中，又分为程序数据和系统数据</li></ul></li><li>事务<ul><li>上一章已经提及</li></ul></li></ul><h4 id="（2）数据库的故障类型"><a href="#（2）数据库的故障类型" class="headerlink" title="（2）数据库的故障类型"></a>（2）数据库的故障类型</h4><ul><li>事务故障<ul><li>某一个程序自身运行错误所引起的故障</li><li>影响该程序本身</li></ul></li><li>系统故障<ul><li>由于掉电，非正常关机等所引起的故障</li><li>影响正在运行的事务以及数据库缓冲区，数据库缓冲区将涉及正在运行和已经运行的事务</li></ul></li><li>介质故障<ul><li>由于介质损坏等引起的故障</li><li>影响是全面的，既影响内存中的数据，也影响介质中的数据</li></ul></li></ul><h3 id="2302-数据库回复的宏观思路"><a href="#2302-数据库回复的宏观思路" class="headerlink" title="2302 数据库回复的宏观思路"></a>2302 数据库回复的宏观思路</h3><ul><li>数据库故障回复</li><li>把DB由当前不正确状态恢复到已知为正确的某一状态</li><li>需要保证事务的<ul><li>原子性：事务的所有操作，要么全部执行，要不全都不执行</li><li>持久性：已经提交的事务对数据库产生的影响是持久的，未提交的事务对数据库不应该有影响</li></ul></li></ul><h4 id="（1）事务故障的回复"><a href="#（1）事务故障的回复" class="headerlink" title="（1）事务故障的回复"></a>（1）事务故障的回复</h4><ul><li>事务故障可以通过重做事务(Redo)和撤销事务(Undo)来恢复。重做事务可保证已经提交事务的持久性，而撤销事务则消除未提交事务的影响。</li></ul><h4 id="（2）系统故障恢复"><a href="#（2）系统故障恢复" class="headerlink" title="（2）系统故障恢复"></a>（2）系统故障恢复</h4><p>运行日志：</p><ul><li>运行日志是DBMS维护的一个文件，该文件以流水的形式记录乐每一个事务对数据库的每一次操作及操作顺序</li><li>运行日志直接写入介质存储上，会保持正确性</li><li><p>当事务对数据库进行操作时：先写运行日志，写成功后，再与数据库缓冲区进行信息交换</p></li><li><p>系统故障可以通过运行日志来恢复</p><ul><li>按照运行日志记录的事务操作来重做事务（当事务在发生故障时已经正确结束）或撤销事务（当事务在故障发生时未结束）</li></ul></li><li><p>但故障恢复是需要时间的</p><ul><li>运行日志保留了若干天的记录，故障发生时应从哪个点开始恢复呢？</li></ul></li><li><p>DBMS在运行日志中定期的设置和更新检查点</p><ul><li>检查点是这样的时刻：在该时刻，DBMS强制使内存DB Buffer中的内容和介质DB中的保持一致，即将DB Buffer更新的所有内容写回DB</li><li>检查点表征了，在检查点之前内存中数据和介质中数据是保持一致的</li></ul></li><li>系统故障的恢复<ul><li>检查点之间结束的书屋不需要恢复(已经写回DB)</li><li>检查点之后结束或发生的事务需要依据运行日志进行恢复(不能确定是否写回DB)：故障点前结束的重做，故障点时刻未结束的撤销</li></ul></li></ul><h4 id="（3）介质故障恢复"><a href="#（3）介质故障恢复" class="headerlink" title="（3）介质故障恢复"></a>（3）介质故障恢复</h4><ul><li><p>副本</p><ul><li>在某一时刻，对数据库在其他介质存储上产生的令一份等同记录</li><li>用副本替代被损坏的数据库</li></ul></li><li><p>介质故障的恢复</p><ul><li>用副本替换被破环的数据库</li><li>由于介质故障影响全面，用副本恢复后还需要根据运行日志进行恢复</li></ul></li><li>如何确定备份的时刻：转储点<ul><li>过频，影响系统工作效率；过疏，会造成运行日志过大，也影响系统性能</li><li>备份转储周期与运行日志的大小密切相关，应注意防止衔接不畅而引起的漏洞</li></ul></li></ul><h4 id="（4）小结"><a href="#（4）小结" class="headerlink" title="（4）小结"></a>（4）小结</h4><ul><li>三种类型故障：事务故障，系统故障，介质故障</li><li>三种恢复手段：事务的撤销和重做，运行日志，备份</li><li>两个重要时刻：检查点和转储点</li></ul><h3 id="2303-运行日志的概念"><a href="#2303-运行日志的概念" class="headerlink" title="2303 运行日志的概念"></a>2303 运行日志的概念</h3><h4 id="（1）日志所记录的"><a href="#（1）日志所记录的" class="headerlink" title="（1）日志所记录的"></a>（1）日志所记录的</h4><ul><li>每个事务都会读/写某些元素<ul><li>READ(X,t):将元素X读到事务的局部变量t中</li><li>WRITE(X,t):将事务局部变量t写回元素X中</li><li>INPUT(X):将元素X从磁盘读入到内存缓冲区中</li><li>OUTPUT(X):将元素X写回到磁盘中</li></ul></li><li><p>每个事务都以提交或者撤销结束</p><ul><li>COMMIT：事务提交</li><li>ABORT：事务撤销</li></ul></li><li><p>DBMS保证事务的：</p><ul><li>持久性：已提交的事务对数据库产生的影响是持久的，未提交的事务对数据库不应用影响<ul><li>已提交的事务—-缓冲区内容保证写回磁盘</li><li>未提交的事务—-缓冲区的内容不能影响磁盘</li></ul></li><li>原子性：事务的所有操作，要么全都执行，要么全不执行</li></ul></li></ul><h4 id="（2）不同的缓冲区策略影响事务的持久性"><a href="#（2）不同的缓冲区策略影响事务的持久性" class="headerlink" title="（2）不同的缓冲区策略影响事务的持久性"></a>（2）不同的缓冲区策略影响事务的持久性</h4><p>缓冲区处理策略</p><ul><li>Force：内存中的数据最晚在commit的时候写入磁盘</li><li>No Steal：不允许事务commit之前把内存中的数据写入磁盘</li><li>No force：内存中的数据可以一直保留，在commit之后过一段时间在写入磁盘(此时在系统崩溃的时候可能还没写入到磁盘，需要redo)—-灵活</li><li>Steal：允许事务commit之前把内存中的数据写入磁盘（此时若系统commit之前崩溃时），已经有数据写入到磁盘时，要恢复到崩溃前的状态，需要Undo）—-灵活</li></ul><h4 id="（3）事务故障影响事务的原子性"><a href="#（3）事务故障影响事务的原子性" class="headerlink" title="（3）事务故障影响事务的原子性"></a>（3）事务故障影响事务的原子性</h4><p>在事务运行时故障，事务会中断，影响原子性</p><h4 id="（4）怎样记录日志"><a href="#（4）怎样记录日志" class="headerlink" title="（4）怎样记录日志"></a>（4）怎样记录日志</h4><p>日志</p><ul><li>一个包含日志记录的只能追加的顺序文件，不同事务的日志交错存储，按事件发生顺序存储</li><li>发生系统故障时，使用日志进行恢复<ul><li>故障时已提交的事务，重做（Redo）</li><li>故障时未提交的事务，撤销（Undo）</li></ul></li><li>日志记录的信息<ul><li>&lt; Start T  &gt;表明事务T已经开始</li><li>&lt; Commut T &gt;表示事务T已经完成</li><li>&lt; Abort T &gt;事务T未成功，被终止</li><li>&lt; T,x,v1 &gt;或&lt; T,x,v2 &gt;，&lt; T,x,v1,v2 &gt;事务T改变了数据库元素X，X原来的值为v1，新值为v2</li></ul></li><li>三种日志：Undo型日志，Redo型日志，Undo/Redo型日志</li></ul><h4 id="（5）缓冲区处理策略和日志恢复策略的关系"><a href="#（5）缓冲区处理策略和日志恢复策略的关系" class="headerlink" title="（5）缓冲区处理策略和日志恢复策略的关系"></a>（5）缓冲区处理策略和日志恢复策略的关系</h4><div class="table-container"><table><thead><tr><th></th><th>No Steal</th><th>Steal</th></tr></thead><tbody><tr><td>No Force</td><td></td><td>最快</td></tr><tr><td>Force</td><td>最慢</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th></th><th>No Steal</th><th>Steal</th></tr></thead><tbody><tr><td>No Force</td><td>只需Redo<br>无需Undo</td><td>需要Redo<br>需要Undo</td></tr><tr><td>Force</td><td>无需Redo<br>无需Undo</td><td>无需Redo<br>只需Undo</td></tr></tbody></table></div><h3 id="2304-Undo型日志及其故障恢复"><a href="#2304-Undo型日志及其故障恢复" class="headerlink" title="2304 Undo型日志及其故障恢复"></a>2304 Undo型日志及其故障恢复</h3><h4 id="（1）Undo型日志的记录规则"><a href="#（1）Undo型日志的记录规则" class="headerlink" title="（1）Undo型日志的记录规则"></a>（1）Undo型日志的记录规则</h4><ul><li>对于任一事务T，按下列顺序像磁盘输出T的日志信息<ul><li>首先&lt;T,x,v&gt;被写入日志中</li><li>其次，OUTPUT(x)</li><li>最后,&lt;COMMIT T&gt; 或&lt;ABORT T&gt;被写入到日志中</li></ul></li><li>注意：undo型日志仅保留旧值。&lt;T,x,v&gt;，v为X原来的值</li><li>Undo型日志：“将事务改变的所有数据写到磁盘前不能提交该事务”</li></ul><h4 id="（2）利用Undo型日志进行恢复"><a href="#（2）利用Undo型日志进行恢复" class="headerlink" title="（2）利用Undo型日志进行恢复"></a>（2）利用Undo型日志进行恢复</h4><ul><li>首先，确定每一个事务是否已经完成<ul><li>start T,commit T = yes</li><li>start T,abort T = no（已结束，但未完成）</li><li>start T.. = no</li></ul></li><li>然后，从日志的尾部开始按日志记录的反序，处理每一日志记录，撤销未完成事务的所有修改<ul><li>commit T:标记T已完成</li><li>abort T:标记T已经结束但未完成</li><li>T,x,v:如果T未完成，则将X=v写回磁盘，否则跳过</li><li>Start T:跳过</li></ul></li></ul><h4 id="（3）检查点及其使用"><a href="#（3）检查点及其使用" class="headerlink" title="（3）检查点及其使用"></a>（3）检查点及其使用</h4><p>检查点</p><ul><li>静止检查点：周期性地对日志设置检查点<ul><li>停止接受新的事务，等到所有当前活跃事务提交或终止，并在日志中写入COMMIT或ABORT记录后</li><li>将日志刷新到磁盘，写入日志记录&lt;CKPT&gt;,并再次刷新日志</li></ul></li><li>非静止检查点<ul><li>在设置检查点时不必关闭系统，允许新事务进入</li><li>在写入一条&lt;CKPT(T1,..Tk)&gt;（其中T1，..Tk）是所有活跃的未结束的事务</li><li>继续正常的操作，直到T1..T_k完成时，写入&lt;END CKPT&gt;</li></ul></li></ul><p>恢复时恢复到第一个检查点的位置，即恢复到第一个&lt;END CKPT&gt;或&lt;CKPT&gt;的位置</p><h3 id="2305-Redo型日志及其故障恢复"><a href="#2305-Redo型日志及其故障恢复" class="headerlink" title="2305 Redo型日志及其故障恢复"></a>2305 Redo型日志及其故障恢复</h3><h4 id="（1）Redo型日志的日志记录规则"><a href="#（1）Redo型日志的日志记录规则" class="headerlink" title="（1）Redo型日志的日志记录规则"></a>（1）Redo型日志的日志记录规则</h4><ul><li><p>Undo型日志的问题“将事务改变的所有数据写入磁盘前不能提交该事务”<br>Redo型日志记录信息：</p></li><li><p>对于任一事务T，按下列顺序向磁盘输出T的日志信息</p><ul><li>首先 T,x,v被写入到日志中</li><li>其次，COMMIT T被写到日志中</li><li>最后，OUTPUT(X)</li></ul></li><li>注意：redo型日志保留新值，T,x,v，v为更新后的值</li><li>与undo型的差别，往后两步，先写提交记录输出，还是先输出再写提交记录</li></ul><h4 id="（2）利用redo日志进行恢复"><a href="#（2）利用redo日志进行恢复" class="headerlink" title="（2）利用redo日志进行恢复"></a>（2）利用redo日志进行恢复</h4><ul><li>首先，确定每一个事务是否已经完成<ul><li>start T,commit T = yes</li><li>start T,abort T = no（已结束，但未完成）</li><li>start T.. = no</li></ul></li><li>从日志的起始位置开始按日志记录的正序处理每一日志记录，重做已经提交事务的所有修改<ul><li>commit t：标记t已经完成</li><li>abort t：标记t已结束但未完成</li><li>t，x，v：如果t已经完成，则将x=v写回磁盘，否则跳过</li><li>start t：跳过</li></ul></li></ul><h4 id="（3）检查点及其应用"><a href="#（3）检查点及其应用" class="headerlink" title="（3）检查点及其应用"></a>（3）检查点及其应用</h4><ul><li>静态检查点（同Undo）</li><li><p>非静态检查点</p><ul><li>再进行检查点设置时不必关闭系统，允许新事务进入</li><li>写入一条 start ckpt(t1,..tk)，其中t1,..tk是所有活跃的未结束的事务</li><li>将所有已提交的事务写回磁盘</li><li>继续正常的操作，直到t1,..tk都完成时，写入end ckpt</li></ul></li><li><p>step1：寻找到最后的end ckpt</p></li><li>step2：从start ckpt里的事务的最早开始处开始恢复，忽略更早的提交事务</li></ul><h3 id="2306-Undo-Redo结合型日志及其故障恢复"><a href="#2306-Undo-Redo结合型日志及其故障恢复" class="headerlink" title="2306 Undo/Redo结合型日志及其故障恢复"></a>2306 Undo/Redo结合型日志及其故障恢复</h3><h4 id="（1）单种日志的问题"><a href="#（1）单种日志的问题" class="headerlink" title="（1）单种日志的问题"></a>（1）单种日志的问题</h4><ul><li>Undo型日志<ul><li>OUTPUT必须先做</li><li>如果 COMMIT T 可见，T确定地已经将所有其数据写回磁盘，因此不必重做</li><li>但可能引起性能下降（因为频繁的写磁盘）</li></ul></li><li>Redo型日志<ul><li>OUTPUT必须后做</li><li>如果 COMMIT T不可见，T确定地没有将任何数据写回到磁盘，因此无需撤销</li><li>但灵活性差，数据必须在COMMIT后才可见</li></ul></li><li>更好地—-Undo/Redo 型日志</li></ul><h4 id="（2）Undo-Redo结合型日志记录规则"><a href="#（2）Undo-Redo结合型日志记录规则" class="headerlink" title="（2）Undo/Redo结合型日志记录规则"></a>（2）Undo/Redo结合型日志记录规则</h4><ul><li>对于任一事务T，按下列顺序向磁盘输出T的日志信息<ul><li>第一步，&lt;T,X,u,v&gt;被写到磁盘中</li><li>第二步，COMMIT T 或 OUTPUT T 都可以</li></ul></li><li>Undo/Redo结合型日志既保留新值v，也有旧值u。</li></ul><h4 id="（3）Undo-Redo结合型日志进行恢复"><a href="#（3）Undo-Redo结合型日志进行恢复" class="headerlink" title="（3）Undo/Redo结合型日志进行恢复"></a>（3）Undo/Redo结合型日志进行恢复</h4><ul><li>自前向后地，按日志记录的正序，重做所有已经提交的事务；</li><li>自后向前地，按日志记录地反序，撤销所有未完成事务地修改</li></ul></1ms)></li>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello Hexo World</title>
      <link href="/2023/02/27/hello-world/"/>
      <url>/2023/02/27/hello-world/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/meitu/1.jpg"></p><p>该博客就此投入使用，用以记录一些笔记及学习。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

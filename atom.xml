<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-06-30T12:12:28.198Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Software Debloating 论文阅读 （16）- 安卓简化调研</title>
    <link href="http://example.com/2024/06/30/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/SoftwareDebloating/Software%20Debloating%20%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB(16)/"/>
    <id>http://example.com/2024/06/30/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/SoftwareDebloating/Software%20Debloating%20%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB(16)/</id>
    <published>2024-06-30T12:10:11.002Z</published>
    <updated>2024-06-30T12:12:28.198Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(16)_x.png" alt></p><h2 id="reddroid%3A-android-application-redundancy-customization-based-on-static-analysis" tabindex="-1">REDDROID: Android Application Redundancy Customization Based on Static Analysis</h2><pre><code class="language-bibtex">@inproceedings&#123;jiang2018reddroid,  title=&#123;RedDroid: Android application redundancy customization based on static analysis&#125;,  author=&#123;Jiang, Yufei and Bao, Qinkun and Wang, Shuai and Liu, Xiao and Wu, Dinghao&#125;,  booktitle=&#123;2018 IEEE 29th international symposium on software reliability engineering (ISSRE)&#125;,  pages=&#123;189--199&#125;,  year=&#123;2018&#125;,  organization=&#123;IEEE&#125;&#125;</code></pre><h3 id="1-introduction" tabindex="-1">1 INTRODUCTION</h3><ul><li>将安卓应用的软件膨胀分为两类：编译时-多余和加载时-多余</li><li>同时我们提出了一个自动化方法删除这两种软件膨胀，我们的方法主要基于静态分析和程序转化</li><li>对于 compile-time redundancy<ul><li>为安卓应用构造一个近似的函数调用图，我们可以移除图中未使用过的函数和类</li><li>我们克服了在安卓应用中静态分析的多个挑战，包括 安卓应用的多入口，回调的大量运用，安卓组件的生命周期</li><li>我们方法使用静态字符串权值分析处理反射，这只是用了应用的代码而没有其它信息。</li></ul></li><li>对于 instll-time redundancy：我们讨论了两个普遍存在的冗余来源的存在和解决方案，即多个软件开发包（SDKs）和嵌入式应用程序二进制接口（ABIs）。</li><li>我们实现了方法原型REDDROID，在超过500个安卓应用进行了评估<ul><li>我们里算了 代码大小，代码复杂度，反射调用点，冗余SDK大小，冗 嵌入ABIs大小</li><li>我们的结果显示<ul><li><strong>代码大小</strong><ul><li>在移除 compile-time redundancy时平均15%的应用代码被移除</li><li>在移除 install-time redundancy时<ul><li>如果因冗余SDKs引起，平均20%的应用代码被移除</li><li>如果因冗余嵌入ABIs引起，平均7%的应用代码被移除</li></ul></li><li>如果两种冗余能够与都有，可以移除平均42%的代码</li></ul></li><li><strong>代码复杂度</strong>：显著减小</li></ul></li></ul></li><li>总结，我们作了以下贡献</li></ul><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(16)_x.png&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;reddroid%3A-android-applicat</summary>
      
    
    
    
    <category term="论文" scheme="http://example.com/categories/%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="SoftwareEngineering" scheme="http://example.com/tags/SoftwareEngineering/"/>
    
    <category term="SoftwareDebloating" scheme="http://example.com/tags/SoftwareDebloating/"/>
    
  </entry>
  
  <entry>
    <title>Software Debloating 论文阅读 （15）- 安卓简化调研</title>
    <link href="http://example.com/2024/06/18/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/SoftwareDebloating/Software%20Debloating%20%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB(15)/"/>
    <id>http://example.com/2024/06/18/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/SoftwareDebloating/Software%20Debloating%20%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB(15)/</id>
    <published>2024-06-17T16:45:46.704Z</published>
    <updated>2024-06-30T12:11:57.295Z</updated>
    
    <content type="html"><![CDATA[<h2 id="autodebloater%3A-automated-android-app-debloating" tabindex="-1">AutoDebloater: Automated Android App Debloating</h2><pre><code class="language-bibtex">@inproceedings&#123;liu2023autodebloater,  title=&#123;AutoDebloater: Automated Android App Debloating&#125;,  author=&#123;Liu, Jiakun and Hu, Xing and Thung, Ferdian and Maoz, Shahar and Toch, Eran and Gao, Debin and Lo, David&#125;,  booktitle=&#123;2023 38th IEEE/ACM International Conference on Automated Software Engineering (ASE)&#125;,  pages=&#123;2090--2093&#125;,  year=&#123;2023&#125;,  organization=&#123;IEEE&#125;&#125;</code></pre><ul><li><a href="http://autodebloater.club">工具使用地址</a></li><li><a href="https://github.com/jiakun-liu/autodebloater/">工具源代码</a></li><li><a href="https://youtu.be/Gmz0-p2n9D4">使用视频</a></li></ul><h3 id="1-%E4%BB%8B%E7%BB%8D" tabindex="-1">1 介绍</h3><ul><li>例子：Wikipedia应用，用户可以读文章，找寻信息，编辑文章，阅读被保存的文章，包括创建账号，登入，登出，充值密码。然而，用户不需要所有的功能，比如如果一个用户只想看文章，他就不需要登入，重置密码和编辑文章</li><li>先前研究：<ul><li>[5]静态分析安卓应用中的死代码进行清楚</li><li>[6]将不会被运行的代码认定为膨胀代码；这些代码通过自动化程序探索找到（如 fuzzer）；随后移除这些代码并冲洗编译应用</li><li>[7]从不同角度静态识别功能（如 permission,activity,modularity），要求开发者选择他们想要保留的功能</li></ul></li><li>然而，这些研究不能辨认用户不想要的功能。对于用户，简化呈现了以下几个问题：<ul><li><ol><li>完全探索一个应用，并且辨认不需要的功能会很困难。用户意识不到一些他们不需要功能的存在。如，他们意识不到应用简化掉的功能，而这些功能或特性对于他们的特定需求来说是不必要的，也就是说，他们没有意识到应用程序中的多余功能。</li></ol><ul><li>让用户充分探索应用是困难的[8]</li></ul></li><li><ol start="2"><li>现有方法需要完整的安卓软件开发环境[7]，需要面向终端用户简化程序</li></ol></li></ul></li><li>为此，我们提出AutoDebloater，自动化简化安卓应用。<ul><li>其为网络应用，终端用户可以通过浏览器方便获取</li><li>其可以自动化探索程序，使用StoryDistiller[8,9]（是自动化探索安卓应用并生成ATG的SOTA）识别activities之间的转化；随后用户在ATG中选择需要保留的活动；最后ATG移除用户不需要的活动</li></ul></li><li>为了评估性能，<ul><li>我们从Google Play和F-Droid中获得5个安卓应用，包括3类（经济，工具，导航）。</li><li>我们要求7个用户使用AutoDebloater简化应用。</li><li>结果显示，用户队简化后程序的可靠性很满意，同时给也肯定了AutoDebloater帮助他们识别activities的能力。</li><li>平均每个简化过程平均20s</li></ul></li></ul><h3 id="2-autodebloater" tabindex="-1">2 AUTODEBLOATER</h3><h4 id="a-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF" tabindex="-1">A 使用场景</h4><ul><li>考虑Alice只想使用维基百科看文章，她想移除编辑文章的功能<ul><li><ol><li>Alice上传维基百科APK到我们的服务器</li></ol></li><li><ol start="2"><li>我们的服务器使用StoryDistiller在APK上，（1）识别app的所有activities（2）对每个活动进行截屏（3）生成ATG。 最后我们的服务器返回ATG给ALice（如果APK之前就有，会直接返回ATG）</li></ol></li><li><ol start="3"><li>Alice选择需要保留的活动，服务器移除Alice不想要的activities，随后重编译APK，发送简化后的程序给Alice</li></ol></li></ul></li></ul><h4 id="b-%E4%BD%BF%E7%94%A8storydistiller%E6%8F%90%E5%8F%96atg" tabindex="-1">B 使用StoryDistiller提取ATG</h4><ul><li>StoryDistiller的细节可以在[8,9]中找到</li><li>为了探索活动间的转移，StoryDistiller需要外部的挂起应用activity（如使用命令行）<ul><li>一个应用是否能被外部挂起，被 <em>AndroidManifest.xml</em> 中 <em>android:exported</em>决定，其默认不可被外部挂起</li><li>为此，StoryDistiller插桩应用，修改<em>AndroidManifest.xml</em>中的值</li></ul></li><li>随后，StoryDistiller使用静态分析得到静态ATG。具体地<ul><li><ol><li>生成应用调用图CG</li></ol></li><li><ol start="2"><li>遍历每个类的每个方法，得到活动间的转移</li></ol></li></ul></li><li>在静态提取过程中，StoryDistiller同时提取Inter-Component Communication（ICC）数据来收集信息（如 初始属性和额外参数）来外部挂起活动。更具体地<ul><li><ol><li>StoryDistiller解析manifest文件或Javadiamagnetic来提取初始属性如 action 和category</li></ol></li><li><ol start="2"><li>为了提取额外参数，StoryDistiller 可以识别与活动生命周期相关的方法，并根据这些方法中的附加参数与活动渲染之间的关系对这些方法进行连续分析。</li></ol></li></ul></li><li>最后，StoryDistiller动态使用提取的ICC数据和Android Debug Bridge（ADB）来挂起活动。<ul><li>然后，StoryDistiller探索每个活动的所有交互组件来识别动态活动间的跳转</li><li>动态活动跳转和静态活动跳转结合得到最终ATG，此时StoryDistiller也获得了每个活动的截图</li></ul></li><li>StoryDistiller运行很耗时，所以对于所有分析过的APK，我们将对其结果进行记忆化</li></ul><h4 id="c-%E7%AE%80%E5%8C%96%E5%AE%89%E5%8D%93%E5%BA%94%E7%94%A8" tabindex="-1">C 简化安卓应用</h4><ul><li>我们需要移除用户不需要的活动<ul><li><ol><li>识别用户想要移除的活动的类的方法</li></ol></li><li><ol start="2"><li>识别这些方法的相关方法，使用前向切片。更具体的</li></ol><ul><li>我们标识需要删除的类的方法为初始的待删除方法集合</li><li>对每个方法，识别在CG中该方法的连续方法，如果该方法只被需要被删除的方法调用，那么可以将该方法的后者加入待删除方法集合</li><li>删除直到集合为空</li></ul></li></ul></li><li>我们使用 Soot 框架[10]从安卓应用中删除方法。</li><li>我们开发了Java库集成了方法移除模块：<ul><li>输入：初始应用，调用图，移除的活动</li><li>输出：简化后应用</li></ul></li></ul><h3 id="3-%E8%AF%84%E4%BC%B0" tabindex="-1">3 评估</h3><ul><li>选择5个应用 Bitcoin Wallet, Amaze File Manager, Gas Prices, Vespucci8, A2DP Volume</li><li>选择7个参与者，他们有使用安卓的经验，但不是开发者或研究员</li><li>我们首先解释简化的原理；然后要求他们探索选择应用的功能，使用我们的服务获得相应的ATG；如果他们发现有活动他们永远不会使用，我们要求他们使用AutoDebloator移除这些活动；最后我们要求他们对简化后程序stability（简化后程序运行不会崩溃）和overall satisfaction（AutoDebloater帮助他们识别和移除活动的能力）打分</li><li>结果<ul><li>stability： 平均 4.8</li><li>overall satisfaction : 平均3.97</li><li>一些用户抱怨：活动不能充分的展示在ATG上，在chen[9]的工作中已经提及。</li></ul></li></ul><h3 id="4-%E7%9B%B8%E5%85%B3%E5%B7%A5%E4%BD%9C" tabindex="-1">4 相关工作</h3><ul><li>Google提供了一些简化工具，目的是减小安卓应用大小，而不是移除活动。<ul><li>如 R8 静态检测并移除死代码，应用中不使用的资源</li></ul></li><li>[13]简化安卓应用以最小化移动设备网络带宽使用</li><li>[7]的工作与我们最相似，然而没开源。同时，我们以服务的形式提供我们的工作。</li></ul><h3 id="5-%E7%BB%93%E8%AE%BA" tabindex="-1">5 结论</h3><ul><li>本文中，我们提供了一个网站，AutoDebloater，用户可以使用它简化安卓应用。</li><li>我们的工具使用StoryDistiller提取ATG，用户可以在ATG中选择需要保留的活动，随后我们移除用户不需要的活动。</li><li>我们的评估显示，用户对简化后程序的稳定性和AutoDebloater帮助他们识别和移除活动的能力很满意。</li><li>今后，我们计划允许用户以更细的粒度（如按钮或文本字段的粒度）标注他们不想要的功能。</li></ul><h2 id="xdebloat%3A-towards-automated-feature-oriented-app-debloating" tabindex="-1">XDebloat: Towards Automated Feature-Oriented App Debloating</h2><pre><code class="language-bibtex">@article&#123;tang2021xdebloat,  title=&#123;Xdebloat: Towards automated feature-oriented app debloating&#125;,  author=&#123;Tang, Yutian and Zhou, Hao and Luo, Xiapu and Chen, Ting and Wang, Haoyu and Xu, Zhou and Cai, Yan&#125;,  journal=&#123;IEEE Transactions on Software Engineering&#125;,  volume=&#123;48&#125;,  number=&#123;11&#125;,  pages=&#123;4501--4520&#125;,  year=&#123;2021&#125;,  publisher=&#123;IEEE&#125;&#125;</code></pre><h3 id="1-introduction" tabindex="-1">1 INTRODUCTION</h3><ul><li>开发者趋向构建复杂和庞大的单个程序，以：包含所有的功能 ，支持各个版本的库，以及<strong>多样的为不同平台准备的应用二进制接口（ABIs）</strong>[1]。<ul><li>这种“one-size-fits-all”策略会导致代码膨胀[3,4],导致很多问题如低传输率，低下载率，大攻击面，低攻击率[4]</li></ul></li><li><strong>feature定义</strong>：应用中满足特定需求的功能。如，社交应用中，“chat with friends”考虑为一个功能</li><li>简化措施分两类<ul><li><strong>pruning-based debloating</strong>：移除程序中不需要的功能[5,6,7,9,9,10]，如在软件演化中，一些功能过时或不在维护，开发者想要移除。<ul><li>目前只有RedDroid[6]在安卓应用上采用了这种策略，其在编译阶段移除死代码，减少多余的ABIS，包括多个SDKs和在下载过程中嵌入的ABIS</li><li>我们与[6]不同在两个方面<ul><li>（1）臃肿代码：RedDroid只考虑死代码为臃肿；XDebloat在应用中使用三种特征定位定位特征，运行开发者定义移除什么</li><li>（2）臃肿ABIs：除了移除特定于操作系统的ABIs外，Xdebloat还会移除应用中臃肿的资源</li></ul></li></ul></li><li><strong>module-based debloating</strong>：将程序分为若干模块，使得用户可以根据需要下载。<ul><li>Google的两个框架 App Bundles 和 instant-enable app bundle 遵循了这一想法。</li><li>然而，目前没有自动化工具可以将应用转为 app bundle。开发者必须重新开发应用</li></ul></li></ul></li><li><strong>我们提出了</strong><em>第一个</em>面向特征的应用简化框架，并实现了原型XDebloat自动化这一过程。<ul><li>我们专注于安卓应用因为其占据80%市场份额[13]</li><li>对于给定的二进制格式的安卓应用（如APK），XDebloat支持pruning-based和module-based debloating</li></ul></li><li><strong>挑战</strong>：<ul><li>C1：type erors：错误移除类型时，其使用会出错</li><li>C2：modelling unique dependencies in Andorid：与桌面应用不同，安卓应用会有被系统委托的间接调用。例如，Android 中的 Intents 可用于实现组件（如活动）之间的通信。</li><li>现有简化技术[5,6,8,14] 不能解决这些挑战，因[5,8,14]面向C应用，RedDroid[6]面向安卓应用但是其不能构建完整的程序调用图来进行简化。如，其不能解决组件间交流问题[15]，一些方法被认为是死代码而错误地被删除</li></ul></li><li><strong>措施</strong><ul><li>解决C1，我们使用静态分析，分析安卓的特殊机制（如是不明确 Intent 和调用引发的数据/控制 流）。我们提出一个类型系统来避免在简化时引入类型错误</li><li>解决C2，我们探索了应用中安卓特定的依赖在3.2中</li></ul></li><li><strong>贡献</strong><ul><li><ol><li>第一个对面向功能的应用简化进行了系统调研</li></ol></li><li><ol start="2"><li>为应用简化开发了XDebloat原型，支持移除不想要的功能，同时支持将程序自动化地转化为instant app或 app bundle</li></ol></li><li><ol start="3"><li>在200个开源，1000个商用应用上评估。结果现实其可以正确地简化程序，生成正确的 instant app或app bundles，并保持较低的性能消耗。其减少代码率平均为34.33%（Activity-based），29.31%(permission-based),32.74(modularity-based).相关工作在[16]</li></ol></li></ul></li></ul><h3 id="2-background-and-motivating-example" tabindex="-1">2 BACKGROUND AND MOTIVATING EXAMPLE</h3><ul><li>在module-based debloating 我们使用了两种框架：instant app和 app bundle</li></ul><h4 id="2.1-instant-app" tabindex="-1">2.1 Instant App</h4><ul><li>instant app：用户可以在不安装应用的情况下直接使用[12].</li><li>包括 base module 和 大于等于零的 feature modules<ul><li>feature modules：使用定义在base module中的代码，资源和库；包含至少一个activity，为该module的入口，以url的形式访问</li><li>用户访问feature module时，一个包含该module 和 base module的apk会被下载，否则只下载base module[12,17]</li></ul></li><li>如图一示<img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(15)_1.png" alt></li></ul><h4 id="2.2-app-bundle" tabindex="-1">2.2 App Bundle</h4><ul><li>app bundle：app模块化打包，用户只下载需要的模块</li><li>一个应用必须包含一个 base module，其他dynamic feature modules是可选的</li><li>如图2示<ul><li>base 和 dynamic feature modules 打包到一个 .aab 文件中,上传到google play发布，google play会根据用户设备下载对应的模块，可以运行时再下载</li><li>对开发者，不需要构建过多apk；对用户，只下载需要的模块</li><li>图中例子，当dynamic feature module B被调用时，才会被下载<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(15)_2.png" alt></li></ul></li></ul><h4 id="2.3-motivating-example" tabindex="-1">2.3 Motivating Example</h4><ul><li>使用 arxiv 应用（com.commonsware.android.arXiv）作例子展示我们的Xdebloat，其所有activity如图3示<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(15)_3.png" alt></li><li>登录app后，用户可以看到种子列表(RSSListWindow)，历史记录(HistoryWindow)，同时设置app偏好(EditPreference)，查询文章(SearchWindow)，查询结果展示在SearchListWindow 。 如果一个元素被选中，该元素的细节被展示在 SingleItemWindow。app还允许用户打印文章(PrintDialogActivity)</li><li>XDebloat进行了以下操作</li><li><ol><li>Feature Location：</li></ol><ul><li>定位功能，并为下一个步骤生成相应配置文件</li><li>XDebloat支持多维度功能定位，包括 类，方法，语句，可以手动功能定位；自动化功能定位维度包括 Activity-based, Permission-based, Modularity-based<ul><li>Activity-based：活动以及附属于该活动的所有用户界面回调作为一种功能。如图3分为8个功能</li><li>Permission-based：检测应用中的权限，以此分类功能。如Arxiv需要NETWORK权限，所有需要网络的功能都被归为一类</li><li>Modularity-based：使用 Louvain算法将应用分为模块，以此分类功能。如图8分为10个功能</li></ul></li></ul></li><li><ol start="2"><li>Specification Construction and Checking</li></ol><ul><li>生成可阅读的配置文件，开发者方便修改</li><li>配置文件记录&lt;fId,config&gt;，表示功能Id到config的映射。config为0表示移除，1保留。该配置只用在 pruning-based debloating。例子如图四示。</li><li><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(15)_4.png" alt></li><li>仅有config不够，简化要具体到程序元素。因此对每一个config需要具体的 Specification，其表示了每个 程序元素的决定，本文中有3种决定，为 remove，preserve，unknown</li></ul></li><li><ol start="3"><li>Debloating</li></ol><ul><li>给定specification，XDebloat进行 pruning-based debloating或者module-based debloating</li><li>前者移除不需要的功能，后者将应用转化为instant app或app bundle</li></ul></li></ul><h3 id="3-xdebloat" tabindex="-1">3 XDEBLOAT</h3><h4 id="3.1-overview" tabindex="-1">3.1 Overview</h4><ul><li>如图五示，XDebloat对给定的应用4步操作<ul><li>功能识别 3.3</li><li>specification 构造和检查 3.4</li><li>简化 3.5，3.6</li><li>错误报告系统 3.7</li></ul></li><li>输入文件形式是apk，支持pruning-based debloating和module-based debloating<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(15)_5.png" alt></li></ul><h4 id="3.2-static-analysis" tabindex="-1">3.2 Static Analysis</h4><ul><li><p><strong>Overview</strong>:使用静态分析收集信息：</p><ul><li>AndroidManifest.xml中的Activities</li><li>需要的权限</li><li>所有布局文件</li><li>程序依赖图 program dependency graph (PDG) [18]. PDG包含了所有的控制和数据依赖关系</li></ul></li><li><p>安卓<strong>应用入口</strong>两个来源[19]</p><ul><li>(1)安卓组件的生成周期方法 （如activity）：组件的标准入口，从AndroidManifest.xml中提取</li><li>(2)UI回调：<ul><li>开发者使用callback方法捕捉UI事件（如button click）</li><li>callback方法与register方法绑定[20,21],被应用定义为与安卓框架交互的方法[21]. 也称为registration-callback pairs [20].</li><li>使用EdgeMiner[20]探索安卓框架中的registration-callback pairs。使用原因<ul><li><ol><li>SOTA 找UI callbacks</li></ol></li><li><ol start="2"><li>广泛使用在从应用中探索UI callbacks[22,23,24]</li></ol></li><li><ol start="3"><li>结果精确，被DroidBench证明[18,20]</li></ol></li></ul></li></ul></li></ul></li><li><p><strong>Inter-Component Communication (ICC)</strong></p><ul><li>Intents：安卓中组件间通信的标准方式，其会导致额外的控制和数据流</li><li>使用IC3[25]推断Intent的目的地，其将ICC问题转化为Multi-Valued Composite (MVC) constant propagation problem 。</li></ul></li><li><p><strong>Reflections</strong></p><ul><li>移植DroidRA[26]至我们的分析模块，其是SOTA分析反射的工具</li><li>DroidRA将反射调用转化为composite constant propagation problem。</li><li>他们使用COALsolver[15]推断被调用者</li></ul></li><li><p><strong>Asynchronous Task Dependencies</strong></p><ul><li>异步任务（即 android.os.AsyncTask）是指在后台线程上运行的计算，其结果在用户界面线程上发布[21]。</li><li>要实现异步任务，开发人员可以实现 AsyncTask 的子类，并实现一些方法</li></ul></li><li><p><strong>Implementation</strong></p><ul><li>在FlowDroid[18]上构建，其提供了dunmmyMain方法，可以通过其遍历调用图</li><li>使用IC3检测ICC</li></ul></li></ul><h4 id="3.3-%E5%8A%9F%E8%83%BD%E5%AE%9A%E4%BD%8D" tabindex="-1">3.3 功能定位</h4><ul><li>[28,29,30,31]不同软件需要不同的功能定位方法</li><li>Activity-based：以活动及其相关的UI回调作为一个功能<ul><li>方法：分析layout文件获得UI元素及回调</li></ul></li><li>permission-based：以需要同一权限的方法为同一功能<ul><li>也与安卓硬件设备相关</li><li>方法：使用PScout[33]探索权限使用。<ul><li>1.在赵安卓API和权限需要的对应中SOTA</li><li><ol start="2"><li>其在相关研究中广泛使用[34,35,36,37]</li></ol></li></ul></li></ul></li><li>modularity-based<ul><li>motivated：面向对象编程思想，一个程序的每个模块应该高内聚[38].收到[2,29,39,40]的影响，程序中的一个模块可以看作用户的一个功能</li><li>方法：社区检测方法[41]。在函数调用图CG上使用Louvain社区检测算法[42]</li></ul></li></ul><h4 id="3.4-%E8%A7%84%E5%88%99%E6%9E%84%E9%80%A0" tabindex="-1">3.4 规则构造</h4><ul><li>因为简化可能破坏原有类型关系，因此我们需要构造类型系统。首先要<strong>建模语言</strong>，随后形成<strong>类型系统</strong>，随后根据类型系统，<strong>找到需要去除的类型的相关代码元素</strong>；最后对每个代码元素<strong>构建规范</strong></li></ul><h4 id="3.5-%E7%AE%80%E5%8C%96%EF%BC%88%E5%9F%BA%E4%BA%8E%E4%BF%AE%E5%BB%BA%E7%9A%84%EF%BC%89" tabindex="-1">3.5 简化（基于修建的）</h4><ul><li>步骤<ul><li><ol><li>功能定位</li></ol></li><li><ol start="2"><li>配置：选择哪些功能移除</li></ol></li><li><ol start="3"><li>规范：具体到哪些代码元素是否被移除</li></ol></li><li><ol start="4"><li>简化</li></ol></li></ul></li><li>解决Native Code</li><li>解决死代码</li><li>移除ABIs和DPIs</li></ul><h4 id="3.6-%E5%9F%BA%E4%BA%8E%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%AE%80%E5%8C%96" tabindex="-1">3.6 基于模型的简化</h4><ul><li>Instant App：<ul><li>因为每个模型至少含有一个Activity，因此选择基于Activity的功能定位</li><li>需要满足Google的要求[12]</li></ul></li><li>App Bundle<ul><li>需要满足Google的要求</li></ul></li></ul><h4 id="3.7-%E9%94%99%E8%AF%AF%E6%8A%A5%E5%91%8A%E7%B3%BB%E7%BB%9F" tabindex="-1">3.7 错误报告系统</h4><ul><li>两种可能的措施<ul><li><ol><li>通过应用性能管理工具插桩[47,48]</li></ol></li><li><ol start="2"><li>为整个应用设置crash handle</li></ol></li></ul></li><li>bug来源<ul><li><ol><li>原来程序</li></ol></li><li><ol start="2"><li>简化引起的bug</li></ol></li></ul></li><li>通过错误报告，我们可以指导bug来源，同时帮助我们解决</li></ul><h3 id="4-%E8%AF%84%E4%BC%B0" tabindex="-1">4 评估</h3><h4 id="4.1-%E5%AE%9E%E9%AA%8C%E8%AE%BE%E7%BD%AE" tabindex="-1">4.1 实验设置</h4><ul><li>依据已有的相关工作[5,6,7,9,10]设置了5个RQ<ul><li>RQ1:简化后程序是否可以成功运行？</li><li>RQ2：XDebloat是否可以成功将app转化为instant app或app bundle？</li><li>RQ3：XDebloat可以移除多少代码？</li><li>RQ4：XDebloat可以对运行时资源减少作贡献吗（如data，battery）？</li><li>RQ5：Xdebloat运行时间如何？</li></ul></li><li>我们使用F-Droid的200个应用[49]和1000个商用应用[50]进行评估</li><li>与SOTA方法比较。只有[1,6]但都没开源<ul><li>在功能上比较<ul><li>[6]提供了简化ABIs集合，去除死代码。这些XDebloat都有，并且提供了更多</li><li>[1]专注简化UI组件及相关代码。然而，我们不考虑UI组件为功能。</li></ul></li></ul></li></ul><h4 id="4.2-rq1%EF%BC%9A%E7%AE%80%E5%8C%96%E5%90%8E%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%EF%BC%9F" tabindex="-1">4.2 RQ1：简化后程序是否可以成功运行？</h4><ul><li>配置：随机产生配置进行简化（随机配置原因阐释）</li><li>程序使用：使用开源应用进行评估（及其原因）</li><li>方法：使用Sapienz[50]对简化后程序进行评估</li><li>评估步骤：<ul><li><ol><li>使用EMMA对简化后程序进行插桩，使用Sapienz运行2个小时</li></ol></li><li><ol start="2"><li>fuzzer在简化程序中引发崩溃时进行记录以重现崩溃，以区分崩溃来源于源程序还是简化</li></ol></li></ul></li><li>评估结果<ul><li>Activity: 100%通过</li><li>Permission:25/1415失败<ul><li>失败原因：缺少动态字符串分析；应用的开发框架</li></ul></li><li>Modularity: 1972/2023 成功</li></ul></li><li>人工评估</li></ul><h4 id="4.3-rq2%EF%BC%9Axdebloat%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E6%88%90%E5%8A%9F%E5%B0%86app%E8%BD%AC%E5%8C%96%E4%B8%BAinstant-app%E6%88%96app-bundle%EF%BC%9F" tabindex="-1">4.3 RQ2：XDebloat是否可以成功将app转化为instant app或app bundle？</h4><ul><li>方法：使用Google提供的app bundle验证工具</li><li>instant app结果：<ul><li>都可以转化为instant app</li><li>164个可以直接上传Google Play，36个需要修改（26个包含不支持的权限，10个因为不支持的或弃用的API）</li></ul></li><li>app bundles 结果<ul><li>190/200 个应用成功转化为 bundles；剩下10个使用了弃用的API</li></ul></li></ul><h4 id="4.4-rq3%3A-xdebloat%E5%8F%AF%E4%BB%A5%E7%A7%BB%E9%99%A4%E5%A4%9A%E5%B0%91%E4%BB%A3%E7%A0%81%EF%BC%9F" tabindex="-1">4.4 RQ3: XDebloat可以移除多少代码？</h4><ul><li>两种策略：<ul><li><ol><li>禁用识别出的所有功能，在100个商用应用和200个开源应用上进行评估</li></ol></li><li><ol start="2"><li>只保留应用的主要功能，在200个开源应用上进行评估</li></ol></li></ul></li><li>方法：使用代码简化率进行评估</li><li>策略1结果<ul><li>Activity: 34.33%</li><li>Permission: 29.31%</li><li>Modularity: 32.74%</li><li>结果分析：简化率十分接近，这是因为 库，图，其它资源占多数。开发者可以选择性的去移除</li></ul></li><li>策略2结果<ul><li>Activity: 19.12%</li><li>Permission: 15.38%</li><li>Modularity: 23.4%</li></ul></li></ul><h4 id="4.5-rq4%3A-xdebloat%E5%8F%AF%E4%BB%A5%E5%AF%B9%E8%BF%90%E8%A1%8C%E6%97%B6%E8%B5%84%E6%BA%90%E5%87%8F%E5%B0%91%E4%BD%9C%E8%B4%A1%E7%8C%AE%E5%90%97%EF%BC%88%E5%A6%82data%EF%BC%8Cbattery%EF%BC%89%EF%BC%9F" tabindex="-1">4.5 RQ4: XDebloat可以对运行时资源减少作贡献吗（如data，battery）？</h4><ul><li>方法：随机选择10个应用，人工比较和评估简化在 内存使用，电源使用，CPU时间上带来的影响。</li><li>策略1结果：</li></ul><table><thead><tr><th>减少率</th><th>内存使用</th><th>电源使用</th><th>CPU时间</th></tr></thead><tbody><tr><td>Activity</td><td>32.1%</td><td>27.2%</td><td>40.7%</td></tr><tr><td>Permission</td><td>16.5%</td><td>21.0%</td><td>38.4%</td></tr><tr><td>Modularity</td><td>46.8%</td><td>42.7%</td><td>42.7%</td></tr></tbody></table><ul><li>策略2结果</li></ul><table><thead><tr><th>减少率</th><th>内存使用</th><th>电源使用</th><th>CPU时间</th></tr></thead><tbody><tr><td>Activity</td><td>10.8%</td><td>12.2%</td><td>19.1%</td></tr><tr><td>Permission</td><td>9.1%</td><td>10.9%</td><td>14.3%</td></tr><tr><td>Modularity</td><td>14.3%</td><td>19.5%</td><td>25.8%</td></tr></tbody></table><h4 id="4.6-rq5%3A-xdebloat%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%E5%A6%82%E4%BD%95%EF%BC%9F" tabindex="-1">4.6 RQ5: Xdebloat运行时间如何？</h4><ul><li>结论<ul><li><ol><li>功能定位方法影响运行性能</li></ol></li><li><ol start="2"><li>Activity，Permission的方法收到程序属性影响，modularity的方法受到程序结构的影响</li></ol></li><li><ol start="3"><li>XDebloat在构建app bundles时需要更多时间</li></ol></li></ul></li></ul><h3 id="5-%E4%BE%8B%E5%AD%90%E7%A0%94%E7%A9%B6" tabindex="-1">5 例子研究</h3><ul><li>移除应用中 不受欢迎/不需要的 组件</li><li>移除应用中 与硬件相关的功能</li></ul><h3 id="6-%E8%AE%A8%E8%AE%BA" tabindex="-1">6 讨论</h3><h4 id="6.1-%E5%8A%9F%E8%83%BD%E5%AE%9A%E4%BD%8D%E6%96%B9%E6%B3%95" tabindex="-1">6.1 功能定位方法</h4><ul><li>应该由开发者决定[29]</li><li>本文提出 Activity-based, Permission-based, Modularity-based</li><li>也可以是 class， method ，statement，field</li></ul><h4 id="6.2-%E9%9D%A2%E5%90%91%E5%8A%9F%E8%83%BD%E7%9A%84%E7%AE%80%E5%8C%96%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF" tabindex="-1">6.2 面向功能的简化使用场景</h4><ul><li>生成合法应用的轻量级版本</li><li>生成合法应用的 Instant App 或 App Bundle</li><li>移除应用中脆弱的部分</li></ul><h4 id="6.3-%E9%99%90%E5%88%B6" tabindex="-1">6.3 限制</h4><ul><li><ol><li>作为静态分析工具，XDebloat有着静态分析的固有问题，其不能解决运行时产生的值。未来工作我们将扩充XDebloat动态分析的能力</li></ol></li><li><ol start="2"><li>在本地库上我们采取了保守的策略，我们计划支持XDebloat简化本地代码</li></ol></li><li><ol start="3"><li>XDebloat不支持混淆的应用，这将导致功能不好定位</li></ol></li></ul><h4 id="6.4-%E6%9C%89%E6%95%88%E6%80%A7%E5%A8%81%E8%83%81" tabindex="-1">6.4 有效性威胁</h4><ul><li>评估应用不够多，实验结果可能不够准确</li></ul><h3 id="7-%E7%9B%B8%E5%85%B3%E5%B7%A5%E4%BD%9C" tabindex="-1">7 相关工作</h3><ul><li><strong>程序简化</strong><ul><li>Chisel[8] 在C程序上使用强化学习进行简化</li><li>[14] 在编译和加载阶段使用 piece-wise简化方法去除不用的C函数</li><li>CIMPLIFIER运行简化应用容器，如Docker</li><li>[5]TRIMMER使用用户提供的配置数据修建C应用</li><li>JRed[7] 使用静态方法移除应用和运行时JRE中冗余的比特码</li><li>RedDroid[6]使用静态分析移除安卓应用中死代码</li><li>我们的方法不仅可以去除无用的函数，同时也可以将应用转化为instant app和app bundles</li></ul></li><li><strong>软件膨胀检测</strong><ul><li>[4]提出一个检测Java应用中代码膨胀来源的方法</li><li>[3]和[55]讨论了代码膨胀的影响</li><li>[56,57]检测了运行时膨胀</li><li>这超出了我们的研究范围</li></ul></li><li><strong>程序简化和定制化</strong><ul><li>[9]PERSE提出了 语法制导的C语言简化方法</li><li>[10]C-Reduce从Clang中获得的语义使用一系列启发式方法进行简化</li><li>我们的方法使用功能来对程序进行定制化</li></ul></li><li><strong>程序切片 Program sicing</strong><ul><li>一个切片是原始程序的一部分，表示了一些有趣的值</li><li>与切边工作不同[58,59,60],我们的工作基于用户定义的配置而不是特定的有趣的值</li></ul></li></ul><h3 id="8-%E7%BB%93%E8%AE%BA" tabindex="-1">8 结论</h3><ul><li>我们提出了一个面向功能的简化方法，实现了原型XDebloat来自动化这一工程</li><li>XDebloat的功能定位支持不同粒度，并且可以进行 pruning-based和module-based的简化。除了移除不需要的功能，其可以将简化后应用转化为instant app和app bundle</li><li>我们在1200个真实应用上评估了XDebloat，结果显示XDebloat在很短时间内可以成功简化并将他们转化为instant app和app bundles。</li></ul><h2 id="towards-speedy-permission-based-debloating-for-android-apps" tabindex="-1">Towards Speedy Permission-Based Debloating for Android Apps</h2><pre><code class="language-bibtex">@inproceedings&#123;thung2024towards,  title=&#123;Towards Speedy Permission-Based Debloating for Android Apps&#125;,  author=&#123;Thung, Ferdian and Liu, Jiakun and Rattanukul, Pattarakrit and Maoz, Shahar and Toch, Eran and Gao, Debin and Lo, David&#125;,  booktitle=&#123;Proceedings of the IEEE/ACM 11th International Conference on Mobile Software Engineering and Systems&#125;,  pages=&#123;84--87&#125;,  year=&#123;2024&#125;&#125;</code></pre><h3 id="1-introduction-1" tabindex="-1">1 INTRODUCTION</h3><ul><li>现代安卓应用通常包含大量功能以满足不同的目标用户，这包括但不限于 不同的使用场景，不同的库，为不同设备架构准备的多样的应用二进制接口[7]</li><li>用户不需要的功能是与他们所不允许的权限相关的，我们可以安全地移除这些功能</li><li>最近的安卓简化工作[7,8,14],只有[14]专注于 基于权限的简化。<ul><li>他们主要基于 FlowDroid来构建调用图并进行静态分析[1], 然而FlowDroid在现代软件运行时间需要几个小时[3,15]</li><li>这对用户不太友好，因此需要加速简化时间</li></ul></li><li>本文提出MINIAPPPERM加速基于权限的简化，通过构建函数调用子图而不是全图<ul><li>基于权限的简化首先要移除与权限相关的方法，随后移除可能会被这些方法移除的其它方法。</li><li>因此，我们不需要整个调用图，我们只需要探索 权限相关方法 的可达方法</li><li>构建可达方法的子图，我们可以加速简化时间</li></ul></li><li>为了评估MINIAPPPERM，我们收集了现代安卓应用数据集<ul><li>我们首先在这些APP上使用FlowDroid收集函数调用图构建时间</li><li>我们的试验表明，我们最多可以减少85.3%的函数调用图构建时间</li><li>我们也人工检查了简化后应用可以正确运行</li></ul></li></ul><h3 id="2-miniappperm" tabindex="-1">2 MINIAPPPERM</h3><p><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(15)_6.png" alt></p><ul><li>MINIAPPPERM总括如上图示：输入为应用和禁止的权限，输出为简化后的应用</li><li>包括4个部分<ul><li><ol><li><strong>权限识别器</strong>：读取权限表，识别应用中权限相关的方法</li></ol><ul><li>使用PScount[2]将权限映射到方法</li></ul></li><li><ol start="2"><li><strong>调用图构建器</strong>：构建只包含权限相关方法的可达方法的部分调用图</li></ol><ul><li>在BackDroid上构建[15]</li><li>BackDroid执行有针对性的跨程序分析，可以跳过无法到达的代码，只跟踪那些通向安全敏感汇点API的路径（可将权限相关方法视为汇点API）</li></ul></li><li><ol start="3"><li><strong>调用图切片器</strong>：遍历部分调用图，移除可以图中可以移除的可达方法</li></ol><ul><li>前向切片：移除只被权限相关方法调用的方法</li><li>后向切片：移除只调用权限相关方法的方法</li></ul></li><li><ol start="4"><li><strong>简化器</strong>：移除不需要的方法，返回重新打包的APK</li></ol></li></ul></li></ul><h3 id="3-preliminary-experiment" tabindex="-1">3 PRELIMINARY EXPERIMENT</h3><ul><li>数据集：取样10个应用</li><li>实验设置：<ul><li>不同版本FlowDroid在函数调用图构造时间上差别很大</li><li>与XDebloat不比较，其没开源，且时间差不多；与其它基于权限的方法也不比较，我们的方法是补充</li></ul></li><li>结果：<ul><li>函数调用图构建时间占主体，这里应该加速</li><li>调用图构造时间不取决于权限的适量，却决于权限相关方法的广度</li></ul></li></ul><h3 id="4-relatedwork" tabindex="-1">4 RELATEDWORK</h3><ul><li>许多工作面向程序简化<ul><li>Chisel[6]</li><li>Piece-wise[11] 分段编译和加载，可以系统地检测和移除内存中的不用代码</li><li>Cimplifier[12] 基于用户定义的限制简化Docker容器</li><li>TRIMMER[13]通过在部署环境中特化程序简化C程序中不需要的功能</li><li>JRed[9]通过静态分析移除Java应用和JRE中的不用代码</li><li>RedDroid[8]移除编译时和加载时冗余来简化安卓应用</li><li>XDebloat[14]面向功能的安卓简化</li><li>我们的工作是对以上工作的补充，加速了函数调用图的构建</li></ul></li><li>一些工作致力于检测和分析软件膨胀<ul><li>[4]提出了通过关注信息检测Java应用中运行膨胀的方法</li><li>[17]分析如何找到，移除，阻止软件膨胀带来的问题</li><li>[5]强调了 bloat-aware design在大数据应用中的重要性</li><li>[10]分析了软件膨胀在数据敏感系统中的影响</li><li>[16]引入了一种称为复制图的抽象概念，可以用来揭示Java中常见的膨胀模式。</li><li>上述研究为去膨胀方法的工作提供了基础。在移除膨胀之前，应先检测到膨胀。对软件膨胀的更好理解也有助于未来去膨胀方法的开发。</li></ul></li></ul><h3 id="5-conclusion-and-futurework" tabindex="-1">5 CONCLUSION AND FUTUREWORK</h3><ul><li>我们提出MINIAPPPERM加速 安卓应用中基于权限的简化</li><li>其通过构建函数调用子图而不是全图来加速简化，最快可以加速85.3%</li><li>未来：<ul><li>在更多应用上更广泛地验证MiniAppPerm的有效性。</li><li>计划通过优化部分调用图构建来提高MiniAppPerm的速度<ul><li>例如引入并行化。另一种可能性是在不完全构建调用图的情况下进行即时切片。</li><li>还有一个方向是使用神经符号程序分析来构建部分调用图，例如使用深度学习技术预测部分调用图的边。</li></ul></li></ul></li></ul><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;autodebloater%3A-automated-android-app-debloating&quot; tabindex=&quot;-1&quot;&gt;AutoDebloater: Automated Android App Debloating&lt;/h2&gt;
&lt;pre&gt;&lt;code cla</summary>
      
    
    
    
    <category term="论文" scheme="http://example.com/categories/%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="SoftwareEngineering" scheme="http://example.com/tags/SoftwareEngineering/"/>
    
    <category term="SoftwareDebloating" scheme="http://example.com/tags/SoftwareDebloating/"/>
    
  </entry>
  
  <entry>
    <title>Software Debloating 论文阅读 （14）</title>
    <link href="http://example.com/2024/06/04/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/SoftwareDebloating/Software%20Debloating%20%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB(14)/"/>
    <id>http://example.com/2024/06/04/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/SoftwareDebloating/Software%20Debloating%20%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB(14)/</id>
    <published>2024-06-04T15:46:09.348Z</published>
    <updated>2024-06-30T12:12:10.023Z</updated>
    
    <content type="html"><![CDATA[<h1 id="minimon" tabindex="-1">MiniMon</h1><h2 id="0-abstract" tabindex="-1">0 ABSTRACT</h2><ul><li>为了满足多样的用户需求，安卓应用的大小正变得越来越大。然而，并不是所有应用的功能是被特定用户所期望的。不必要的或不期望的功能增多了攻击面，消耗系统资源如存储和内存。为了解决这一问题，我们提出了一种框架 <strong>MiniMon</strong> 基于特定用户与APP的交互的日志来从安卓应用中去除不必要功能。</li><li>然而，很少使用的功能在数据收集中可能不被记录，并且用户的偏好可能随时间变化。为此，我们内嵌了几种措施在我们的框架中，可以通过学习和泛化用户与应用交互的日志揭示用户期望的功能。<ul><li><ol><li>MiniMon首先收集应用的方法，他们在用户交互时被调用。</li></ol></li><li><ol start="2"><li>随后给定收集的运行方法及应用的调用图，MiniMon使用10种技术来泛化这些日志，辨别出与日志记录方法相似的额外的方法</li></ol><ul><li>3种基于程序分析的技术</li><li>2种图聚类的技术</li><li>5种图内嵌技术</li></ul></li><li><ol start="3"><li>最后，MiniMon通过移除与运行方法不相似的方法后，生成一个简化后的程序。</li></ol></li></ul></li><li>为了评估MiniMon使用不同泛化技术后不同的变现，我们为受控实验<strong>创建了一个基准</strong>。<ul><li>结果显示，基于图内嵌的泛化技术最为全面地考虑了调用图中的所有结点，并且可以正确地揭示75.5%未被观测到但期望的行为，同时简化了APP超过一半。</li></ul></li><li>我们还进行了一项用户研究，发现使用 MiniMon 的智能（泛化）方法可将用户总体满意度提高 37.6%。</li></ul><h2 id="1-introduction" tabindex="-1">1 INTRODUCTION</h2><ul><li>安卓在移动操作系统具有统治地位，占据71.95%的市场[4]。</li><li>随着CPU性能和移动设备存储的提升，安卓应用由于开发者为了满足各式的用户而普遍提供很多功能（a feature is -functionality that satisfies a certain requirement [59]），这导致了应用变得庞大。<ul><li>如，Twitter的大小为108MB。用户可以使用 Twitter 发布推文、转发推文、回复、分享、探索热门话题，甚至进行有声交流 [6,13] 。</li></ul></li><li>然而，并非应用所有的功能被用户所需要，这将导致应用的膨胀。旋前研究展示了软件产品中平均80%的功能很少或从未使用[15]。这些不使用的功能提升了攻击面并且消耗了额外的资源，如内存和存储[22]。更具体的，确定的功能对一些用户很必要，但对另一些用户可能不重要。如图1示，“书签”功能是否需要每个用户各异，每个用户都有自己的偏好。<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(14)_1.png" alt></li><li>为了解决用户的期望与使用更多功能吸引用户之间的矛盾，先前的研究已经提出了很多措施来简化安卓应用，如通过移除特定功能（如按照活动，权限，模块的粒度），或通过静态[44]或动态[51]移除死代码。<ul><li>[43]提出一种基于UI的方法移除用户选定的不需要的UI组件及相关的后端代码。他们需要用户手动地标记不想要的组件。然而，从所有组件种标识不需要的组件时困难的，因为 （1）组件会动态地创建[14],（2）很难获得应用的所有组件。</li><li>现有最优秀的方法在活动层面都没有较高的覆盖度68%[47]，更不用说组件级别。因此，这里存在用户从未探索到的不需要的组件。用户不会意识到这些功能的存在，只会把这些功能认为是不需要的功能。</li><li>因此，这驱动我们需要积极地询问用户需要的功能而不是标记不需要的功能。同时[43]需要开发者手动地获得具体UI组件的id来对应到后端代码。这降低了自动化等级，这驱使我们自动化地讲UI元素对应到后端代码。</li></ul></li><li>为了弥补这一差距，我们提出了MinMon，其可以保留用户需要的功能同时移除终端用户不使用的。</li><li>MiniMon首先静态地对应用进行插桩。<ul><li>当用户探索插桩应用时，应用运行的方法记录在日志中。这样我们可以收集 （1）收集用户期望的功能（2）及交互种用户期望功能相应的后端方法。</li><li>然而，一些用户的行为在监视中可能没被记录（如与仅使用功能相关的），同时用户偏好可能轻微改变[66]。如图1示，用户可能在监视中不使用 “书签”功能，但在未来可能使用。这驱动我们生成的简化后程序需要包括可见及不可见的用户需要的功能，</li></ul></li><li>为了确定未见的用户行为代表的用户需要的功能，MiniMon生成应用的调用图（call graph，CG）。之后，一种方法是采用半监督学习，利用图节点分类方法预测哪些方法与用户所需的特征相关[39,45,46,50,56,60,67,70].然而，我们无法应用这些解决方案，因为在半监督图节点分类任务中，标注数据中存在不止一个标签，即存在负样本。不幸的是，在我们的任务中，我们只有在用户探索应用时执行的方法，而没有永远不会执行的方法。因此，在给定监控过程中记录的 CG 和特征方法的情况下，MiniMon 需要使用无监督技术识别出所需特征的其他方法。之后，MiniMon可以删除与所需功能的执行无关的方法，并生成一个去浮应用程序。</li><li>我们将MiniMon中辨识期望功能的方法的组件称为 <strong>MethodGeneralizer</strong>.我们需要数据来构建 MethodGeneralizer 模型。然而，目前还没有这样一个数据集，可以记录与一系列类似用户行为相对应的已执行方法。为了解决这个问题，我们在 SARA [40] 的帮助下创建了一个基准，记录了 45 个 Android 应用中 214 种类似用户行为的交互以及相应的执行方法。</li><li>基于在监控 45 个应用程序期间记录的执行方法及其相应的 CG，我们探讨了三个研究问题：</li><li><strong>RQ1：MethodGeneralizer 的不同变体在识别具有所需特征的方法方面效果如何？</strong><ul><li>我们在 MethodGeneralizer 组件中应用了三种基于程序分析的技术、两种基于图聚类的技术和五种基于图嵌入的技术。我们在基准上对每种方法泛化技术进行了实验评估，评估指标包括回调率（发现具有所需特征的方法的能力）和简化率（被删除方法的比例），以及回调率和简化率的加权调和平均值（即 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝐹</mi><mrow><mi>𝑑</mi><mi>𝑒</mi><mi>𝑏</mi><mi>𝑙</mi><mi>𝑜</mi><mi>𝑎</mi><mi>𝑡</mi></mrow></msub></mrow><annotation encoding="application/x-tex">𝐹_{𝑑𝑒𝑏𝑙𝑜𝑎𝑡}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> ）。</li><li>评估结果表明，四种基于图嵌入的技术（Node2Vec 和反文档频率技术，LSTM 除外）在所有指标上都优于基于程序分析的技术和基于图聚类的技术。MiniMon 能将应用程序平均简化 58%，并能使用表现最佳的 MethodGeneralizer 技术挖掘出 76% 的所需特征方法。</li></ul></li><li><strong>RQ2: MiniMon可以高效率地简化应用吗</strong><ul><li>我们在由表现最好的方法泛化器生成地简化后应用复现基准中的交互。</li><li>我们对8个应用进行了用户调研，收集了8位用户的使用情况。我们发现88.8%的测试用例复现成功。用户研究结果表明使用MiniMon的智能（泛化）方法使总体用户满意度提高了37.6%。</li><li>我们还通过消融研究讨论了表现最佳的方法泛化器技术（基于图嵌入的技术）的最重要组成部分。我们发现，考虑调用图中的所有节点是基于图嵌入的技术中最重要的组成部分。</li></ul></li><li>总之，<strong>本文的贡献</strong>包括：<ul><li><ol><li>我们创建了一个基准，包括45个安卓应用的214个用户的行为及相关的运行方法</li></ol></li><li><ol start="2"><li>我们实现了一个基于监督的简化框架MiniMon，尽可能地简化一个程序使其包含用户所需要的功能</li></ol></li><li><ol start="3"><li>我们提出MethodGeneralizer组件，对于给定监视中的调用图和记录的运行的方法，这是MiniMon辨识期望功能相关的未运行方法的组件。我们使用了10种技术在该组件中并在实验中评估他们的表现。结果显示基于图内嵌的技术可以有效地考虑调用图的全局信息，很好的辨识出期望功能的相关方法。</li></ol></li></ul></li><li>余下部分结构如下：<ul><li>Section2描述基于监督的简化框架MiniMon及其使用场景。</li><li>Section3构建MethodGeneralizer，辨识用户期望功能的在使用中未出现的相关方法。</li><li>Section4描述我们构建基准的过程</li><li>Section5描述评估设置</li><li>Section6描述评估结果</li><li>Section7讨论 MethodGeneralizer中最重要的部分以及对有效性的威胁</li><li>Section8相关工作</li><li>Section9总结</li></ul></li></ul><h2 id="2-minimon%3A-monitoring-based-debloating-framework" tabindex="-1">2 MINIMON: MONITORING-BASED DEBLOATING FRAMEWORK</h2><ul><li>图2展示MiniMon的概要<ul><li>1.1 插桩（instruments，insert code）安卓应用程序监视运行，用户探索插桩程序（section 2.1）</li><li>1.2 MiniMon使用静态分析得到应用调用图（section 2.2）</li><li>2 基于调用图和记录的运行方法，MethodGeneralizer组件辨识出用户期望功能的额外方法（section 3）</li><li>3 最后MiniMon修建对于期望功能不需要的代码指令(section 2.3)<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(14)_2.png" alt></li></ul></li></ul><h3 id="2.1-instrumenting-android-applications" tabindex="-1">2.1 Instrumenting Android Applications</h3><ul><li>（<strong>函数或方法级别简化原因</strong>）我们关注监视过程中运行的方法。这是因为：<ul><li>如果我们只关注类的层面，就无法对应用程序进行细粒度拆解：许多函数可能只与单个方法相关。</li><li>如果我们关注指令级别，我们需要记录太多信息，需要大量存储。</li><li>因此，我们详细函数粒度是一个合适的选择</li></ul></li><li>因此需要静态插桩安卓应用程序.<ul><li>不能使用现实中基于源码的监视用户的插桩工具(如Amplitude[18],Dynatrace [1]),因为我们没有app源码</li><li>不能使用动态插桩,太费工作.如(1)root权限安卓设备(2)运行应用时链接电脑[6].</li></ul></li><li>因此,我们使用Soot中BodyTransformer类静态地插桩程序,通过插入(1)方法签名(2)时间戳(3)应用名再每个方法的第一个指令前[7].一旦方法运行,插入的代码会被运行,方法签名,时间戳和应用名将会被记录</li><li>在我们的实验中,我们使用Logcat从安卓模拟器中收集数据.实际上,我们要求用户从GooglePlay下载Logcat记录工具. 与其它现实用户常用的监视工具类似,日志将会在安卓设备的RAM中缓存,并被成块的写入磁盘以最小化影响应用的性能.</li></ul><h3 id="2.2-generating-call-graph" tabindex="-1">2.2 Generating Call Graph</h3><ul><li>我们使用 FlowDroid 进行静态分析来生成CG.CG中的节点代表方法,边代表方法间的关系(如调用者和被调用者)</li><li>跟随之前的研究,我们使用(1)安卓组件中(如活动)的生命周期方法(如onCreate(),onStop())(2)回调(如位置更新或UI交互),作为应用的入口[19,59].<ul><li>在安卓中,生命周期方法是组件的标准入口.安卓中回调函数的运行(更新位置或点击按钮)回触发应用代码的运行.之后,我们可以将具体的方法调用构建在调用图中CG[54].</li></ul></li><li>然而,安卓应用也支持模糊方法调用.<ul><li>如反射,为了识别反射的目标,我们识别了所有传播的字符串常量[19].</li><li>对于组件间通信（即 ICC），我们使用 ICCBot 来检测应用程序中的 ICC [68].与传统的 ICC 解析工具（如 Epicc [49] 和 IC3 [48]）相比，ICCBot 是一种片段感知且对上下文敏感的 ICC 解析工具。</li><li>对于异步任务，我们沿用 Tang 等人[59]的方法，在 CG 中添加以下边：AsyncTask.execute() → onPreExecute，以及 onPreExecute→doInBackground 等。</li></ul></li></ul><h3 id="2.3-debloating-android-application" tabindex="-1">2.3 Debloating Android Application</h3><ul><li>在识别出需要保留和删除的方法后(在Section 3),我们使用Soot从安卓应用中移除需要移除的方法.</li><li>依据之前的简化Java程序的研究[27],对于每个需要移除的方法,我们提供两个选择(1) 情况函数体并改变返回值为null或0.(2) 替换函数体为标识功能已被移除的代码<ul><li>基于之前的研究[27],我们默认为第一个选择,我们在Section 6中展示地也是这个选择.</li></ul></li><li>我们没有改变应用的UI元素,所有用户可以看到之前的特征.</li><li>注意到基于图内嵌的方法(在Section 3) 计算了所有应用方法与监视地运行方法间地相似度.我们设置了一个相似阈值,对于每个阈值,我们识别出了相似方法集合.这表明了我们由多个方法的集合,每个集合关联一个阈值.因此,对于图内嵌方法,我们会有多个不同阈值的简化版本的安卓应用.</li></ul><h3 id="2.4-usage-scenario" tabindex="-1">2.4 Usage Scenario</h3><ul><li>图3展示了与样例应用的可能交互(Amaze File Manager).</li><li>考虑用户Bob,他想要浏览在Amaze File Manage的本地应用.使用我们工具,Bob下载完整的 AFM APK.用户不想要的功能,如链接FTP,会加载进内存.这些额外的功能会消耗Bob手机额外的电源和存储.如果Bob使用我们的工具,Bob可以简化APK,使其只包含Bob想要的功能.</li><li>更具体的,Bob需要首先下载插桩APK的应用,随后日常使用.随后,Bob放松日志到我们的服务,我们的服务会发送使用不同相似度阈值的简化后的AFM APL给Bob. Bob会基于他的风险偏好和试错意愿选择下载的APK.<ul><li>如果关注大小和安全更多,选择简化程度最高的.同时如果简化过于苛刻,也可以选择其它程度的简化.</li><li>如果Bob不想试错,就选择APK相对简化的,这样就可以执行与功能稍有关联的行为。</li></ul></li></ul><p><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(14)_3.png" alt></p><h2 id="3-methodgeneralizer%3A-generalizing-desired-methods" tabindex="-1">3 METHODGENERALIZER: GENERALIZING DESIRED METHODS</h2><h3 id="3.1-our-task" tabindex="-1">3.1 Our Task</h3><ul><li>对于给定的方法集合 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span></eq> ,其包含了应用中所有方法. 集合 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span></eq> 为记录到的用户使用应用时运行的方法.我们的目的是找到集合 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>M</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">M&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></eq> ,包含用户所有想要的功能(而并不是单纯地从方法记录标记功能[17,20,37,65]).</li><li>通过这样我们可以找到很少使用,但用户期望的,收集的方法中没有的功能.更具体地 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>⊆</mo><msup><mi>M</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>⊆</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">m\subseteq M&#x27; \subseteq M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8879em;vertical-align:-0.136em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span></eq></li></ul><h3 id="3.2-our-techniques-for-methodgeneralizer" tabindex="-1">3.2 Our Techniques for MethodGeneralizer</h3><ul><li>先前关于程序理解研究表明[16,23,41,55,58,61],使用方法-调用关系来推断特征相关性是有效地.例如，Biggerstaff 等人[23] 和 Alanazi 等人[16] 使用方法调用关系来识别源代码和特征之间的映射关系。</li><li>受这些研究的启发，我们使用方法调用关系来推断特征相关性。我们考虑了三种基于程序分析的技术（即forward-slicing, backward-slicing, and forwardbackward-slicing）[62]，两种基于图聚类的技术（Louvain community detection [25], and Label propagation algorithm[71]），以及五种基于图嵌入的技术（node2vec[39], LSTM [42], OneHot Encoding, IDF-Encoding, and IDF-POSencoding）作为 MethodGeneralizer 的候选技术。</li></ul><h4 id="3.2.1-program-analysis-based-techniques" tabindex="-1">3.2.1 Program analysis-based techniques</h4><ul><li><strong>Forward slicing:</strong> (简称 FORWAER)<ul><li>直觉地,如果方法m正在运行,被方法m调用的方法未来也会被执行.</li><li>例如,如果两个方法被同一个方法集合调用(如,被同一个入口点调用),他们应该是相似的(如,在Amaze file manager中打开不同类型的文件)</li><li>更具体地,我们直接将 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span></eq> 调用的方法加入到 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>M</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">M&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></eq></li></ul></li><li><strong>Backward slicing:</strong>(简称 BACKWARD)<ul><li>直觉地,如果方法 m 正在运行,调用m的函数在未来可能被执行(多入口点)</li><li>类似的,如果两个方法钓友同一个方法集合,这两个方法是相似的(如,在FTP活动中使用FTP功能与FTP按钮)</li><li>更具体地,我们将直接或简介调用 m 的方法加入到 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>M</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">M&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></eq></li></ul></li><li><strong>Forward and backward slicing:</strong>(简称 BIDIRECTION))<ul><li>以上2者的结合</li></ul></li></ul><h4 id="3.2.2-graph-clustering-based-techniques" tabindex="-1">3.2.2 Graph clustering-based techniques</h4><ul><li><strong>Louvain community detection algorithm</strong>(简称 LCD)<ul><li>根据面向对象编程的原则，具有高内聚性和低耦合性（即高模块性）的方法可被视为一个模块。</li><li>我们将程序中的模块视为用户的一项功能，并采用 LCD 算法来识别模块。</li><li>LCD 算法首先将每个节点分配到其社区中。然后，该算法会反复判断将节点移至其相邻社区是否能获得更好的模块化效果。如果是，该节点就会被移到它的邻近社区。</li></ul></li><li><strong>Label propagation algorithm:</strong>(简称 LPA)<ul><li>直觉是方法的执行过程与标签传播类似。即如果其邻居被执行，那么该方法就有可能被执行。因此,接可以使用LPA识别类似的方法</li><li>更具体地,LPA为每个节点初始化唯一的标签,然后重复设置节点的标签,使其称为邻居中出现频率最高的标签.</li><li>我们沿用Tang等人的工作,设置边权0.5或1. 前者表示单向调用(如 n调用m或m调用n),后者表示双向调用(n调用m且m调用n).</li><li>我们使用LCD和LPA在CG上,其它参数设置默认如[9,10]. 如果由LCD或LPA生成的运行的方法,我们加入到 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>M</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">M&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></eq></li></ul></li></ul><h4 id="3.2.3-graph-embedding-based-techniques" tabindex="-1">3.2.3 Graph embedding-based techniques</h4><ul><li><p>这里我们(1)生成CG中每个方法的嵌入的东西然后(2)这用这些嵌入的东西来识别用户期望的但未收集到的可能的方法.</p></li><li><p>直觉上,如果我们可以将CG中多维度的信息(如结构信息,调用关系)到低维度的向量空间,我们可以使用这些信息更好地识别出期望的方法.</p></li><li><p>如图4示,我们是要首先探究如何通过将CG转换为序列来生成方法嵌入.</p><ul><li>具体地,为了生成CG中每个方法的嵌入,我们(1)首先将图结构转换为序列(2)使用4种技术(LSTM,One-hot,IDF,IDF-POS) 来为每个序列的每个方法生成嵌入.然后(3)统计每个方法在序列种的所有嵌入得到每个方法的最终嵌入.</li></ul></li><li><p>我们同时也使用一个属性的图嵌入技术Node2Vec[39],来直接地生成CG种方法的嵌入,我们使用cosine similarity来识别用户期望功能的额外方法.<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(14)_4.png" alt></p></li><li><p><strong>生成静态运行路径</strong></p><ul><li>Static Execution Path 是方法序列,被CG中的边链接.</li><li>静态运行路劲的第一个方法是应用的入口点(入口点入度为0).随后使用DFS在CG上获得静态运行路径.为了解决递归,每条边只遍历一次.</li><li>图4展示了样例CG和静态运行路径,这样我们可以将图结构转化为序列结构,同时保持图的拓扑序.例如,CG中度数高的节点会分布在很多静态路径中,静态路径记录了所有可能的路径</li></ul></li><li><p><strong>生成在静态运行路径中每个方法的嵌入</strong></p><ul><li><strong>运行路径</strong>:因为静态运行路径代表了CG的信息,我们希望利用静态执行路径的嵌入来获得 CG 中方法的嵌入。具体来说，我们探索了以下技术：</li></ul></li><li><p><strong>1 LSTM</strong></p><ul><li>是一种递归神经网络,可以学习序列中的长期依赖关系[42].</li><li>我们将静态执行路径视为一个序列,并使用LSTM模型来学习执行路径中方法之间的长期依赖关系。我们使用 LSTM 模型的最后一个隐藏状态作为执行路径的嵌入。</li><li>具体来说，对于静态执行路径中的每个方法，我们将其分为两部分，即直接调用该方法的路径（即调用者路径）和被该方法直接调用的路径（即被调用者路径）。</li><li>然后，我们使用 LSTM 模型分别生成调用者路径和被调用者路径的嵌入。最后，我们将这些嵌入连接起来，作为该路径中方法的嵌入。</li></ul></li><li><p><strong>2 One-hot</strong></p><ul><li>将路径中所有节点考虑编码.对于路径中的每个方法,其嵌入与上下文一起考虑: <section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>E</mi><mi>m</mi><mi>b</mi><mi>e</mi><mi>d</mi><mi>d</mi><mi>i</mi><mi>n</mi><mi>g</mi><mo stretchy="false">(</mo><mi>𝑚</mi><mi>𝑖</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">(</mo><msub><mi>𝑚</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">(</mo><msub><mi>𝑚</mi><mrow><mi>𝑖</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">(</mo><msub><mi>𝑚</mi><mrow><mi>𝑖</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">(</mo><msub><mi>𝑚</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">Embedding(𝑚𝑖 ) = [1(𝑚_{1}), . . . , 1(𝑚_{𝑖−1}), 0, 1(𝑚_{𝑖+1}), . . . , 1(𝑚_n)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal">mb</span><span class="mord mathnormal">e</span><span class="mord mathnormal">dd</span><span class="mord mathnormal">in</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">mi</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)]</span></span></span></span></span></eqn></section> <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo stretchy="false">(</mo><msub><mi>𝑚</mi><mi>𝑗</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">1(𝑚_𝑗)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord">1</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq> 是方法 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝑚</mi><mi>𝑗</mi></msub></mrow><annotation encoding="application/x-tex">𝑚_𝑗</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></eq> 的指示函数。如果方法 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝑚</mi><mi>𝑗</mi></msub></mrow><annotation encoding="application/x-tex">𝑚_𝑗</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></eq> 是在 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝑚</mi><mi>𝑖</mi></msub></mrow><annotation encoding="application/x-tex">𝑚_𝑖</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 的语境中，则 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo stretchy="false">(</mo><msub><mi>𝑚</mi><mi>𝑗</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1(𝑚_𝑗) = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord">1</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></eq>；否则，<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo stretchy="false">(</mo><msub><mi>𝑚</mi><mi>𝑗</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">1(𝑚_𝑗) = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord">1</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></eq>。</li></ul></li><li><p><strong>3 IDF</strong></p><ul><li>如果一个方法在静态运行路径中普遍被执行,那么其应该在嵌入中权值较低.<ul><li>例如,一个工具方法,如 amaze file应用中重写 ImmutableEntry class,在静态执行路径中被普遍执行.ImmutableEntry class在Map class运行时会频繁地被运行.当 ImmutableEntry class 在一个具体的功能中被运行时,这并不意味着用户会使用其它功能.</li><li>相反,⟨𝑐𝑜𝑚.𝑎𝑚𝑎𝑧𝑒.𝑓𝑖𝑙𝑒𝑚𝑎𝑛𝑎𝑔𝑒𝑟 .𝑎𝑠𝑦𝑛𝑐ℎ𝑟𝑜𝑛𝑜𝑢𝑠.𝑠𝑒𝑟𝑣𝑖𝑐𝑒𝑠.𝑓 𝑡𝑝.𝐹𝑡 -𝑝𝑆𝑒𝑟𝑣𝑖𝑐𝑒 : 𝑣𝑜𝑖𝑑𝑟𝑢𝑛()⟩ 方法在静态路径中很少被执行(52/12363 静态运行轨迹). 该方法的运行表示用户使用了FTP链接功能.这驱使着我们将方法频率纳入生成方法嵌入的考量中.</li></ul></li><li>受信息检索中 IDF（inverse document frequency）的启发，我们将一种方法的反向文档频率（IDF）定义为 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>D</mi><mi>F</mi><mo stretchy="false">(</mo><mi>𝑚</mi><mo stretchy="false">)</mo><mo>=</mo><mi>l</mi><mi>o</mi><mi>g</mi><mfrac><mi>𝑁</mi><msub><mi>𝑛</mi><mi>𝑚</mi></msub></mfrac></mrow><annotation encoding="application/x-tex">IDF(𝑚) = log \frac{𝑁}{𝑛_𝑚}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3174em;vertical-align:-0.4451em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4451em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></eq> 。包含方法的静态执行路径越多，方法的 IDF（即重要性）就越小。方法的嵌入为 <section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>E</mi><mi>m</mi><mi>b</mi><mi>e</mi><mi>d</mi><mi>d</mi><mi>i</mi><mi>n</mi><mi>g</mi><mo stretchy="false">(</mo><msub><mi>𝑚</mi><mi>𝑖</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">(</mo><msub><mi>𝑚</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>×</mo><mi>I</mi><mi>D</mi><mi>F</mi><mo stretchy="false">(</mo><msub><mi>𝑚</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">(</mo><msub><mi>𝑚</mi><mrow><mi>𝑖</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>×</mo><mi>I</mi><mi>D</mi><mi>F</mi><mo stretchy="false">(</mo><msub><mi>𝑚</mi><mrow><mi>𝑖</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">(</mo><msub><mi>𝑚</mi><mrow><mi>𝑖</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>×</mo><mi>I</mi><mi>D</mi><mi>F</mi><mo stretchy="false">(</mo><msub><mi>𝑚</mi><mrow><mi>𝑖</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">(</mo><msub><mi>𝑚</mi><mi>𝑛</mi></msub><mo stretchy="false">)</mo><mo>×</mo><mi>I</mi><mi>D</mi><mi>F</mi><mo stretchy="false">(</mo><msub><mi>𝑚</mi><mi>𝑛</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">Embedding(𝑚_𝑖) = [1(𝑚_1 ) × IDF(𝑚_1 ), · · · , 1(𝑚_{𝑖−1})×IDF(𝑚_{𝑖−1} ), 0, 1(𝑚_{𝑖+1} ) × IDF(𝑚_{𝑖+1} ), · · · , 1(𝑚_𝑛 ) × IDF(𝑚_𝑛 ) ]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal">mb</span><span class="mord mathnormal">e</span><span class="mord mathnormal">dd</span><span class="mord mathnormal">in</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,⋅⋅⋅,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,⋅⋅⋅,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)]</span></span></span></span></span></eqn></section></li></ul></li><li><p><strong>4 IDF-POS</strong></p><ul><li>考虑的是相对于到嵌入节点的位置信息。如果一个方法被执行，那么离嵌入方法较近的方法比离嵌入方法较远的方法更有可能被执行。</li><li>我们定义方法 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>m</mi><mi>q</mi></msub></mrow><annotation encoding="application/x-tex">m_q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></eq> 在方法 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>m</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">m_p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></eq> 的嵌入贡献为 $ Weight \frac{m_q}{m_p} = \frac{q}{p} if(q&lt;p) or \frac{(n-q+1)}{(n-p+1)} (if q&gt;p)$</li><li>因此我们有 <section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>E</mi><mi>m</mi><mi>b</mi><mi>e</mi><mi>d</mi><mi>d</mi><mi>i</mi><mi>n</mi><mi>g</mi><mo stretchy="false">(</mo><msub><mi>𝑚</mi><mi>𝑖</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">(</mo><msub><mi>𝑚</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>×</mo><mi>I</mi><mi>D</mi><mi>F</mi><mo stretchy="false">(</mo><msub><mi>𝑚</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>×</mo><mi>W</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><msubsup><mi>t</mi><msub><mi>𝑚</mi><mi>𝑖</mi></msub><mn>1</mn></msubsup><mo separator="true">,</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">(</mo><msub><mi>𝑚</mi><mrow><mi>𝑖</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>×</mo><mi>I</mi><mi>D</mi><mi>F</mi><mo stretchy="false">(</mo><msub><mi>𝑚</mi><mrow><mi>𝑖</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>×</mo><mi>W</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><msubsup><mi>t</mi><msub><mi>𝑚</mi><mi>𝑖</mi></msub><mrow><mi>𝑖</mi><mo>−</mo><mn>1</mn></mrow></msubsup><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">(</mo><msub><mi>𝑚</mi><mrow><mi>𝑖</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>×</mo><mi>I</mi><mi>D</mi><mi>F</mi><mo stretchy="false">(</mo><msub><mi>𝑚</mi><mrow><mi>𝑖</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>×</mo><mi>W</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><msubsup><mi>t</mi><msub><mi>𝑚</mi><mi>𝑖</mi></msub><mrow><mi>𝑖</mi><mo>+</mo><mn>1</mn></mrow></msubsup><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">(</mo><msub><mi>𝑚</mi><mi>𝑛</mi></msub><mo stretchy="false">)</mo><mo>×</mo><mi>I</mi><mi>D</mi><mi>F</mi><mo stretchy="false">(</mo><msub><mi>𝑚</mi><mi>𝑛</mi></msub><mo stretchy="false">)</mo><mo>×</mo><mi>W</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><msubsup><mi>t</mi><msub><mi>𝑚</mi><mi>𝑖</mi></msub><mi>𝑛</mi></msubsup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex"> Embedding(𝑚_𝑖) = [1(𝑚_1)×IDF(𝑚_1)× Weight^1_{𝑚_𝑖} , · · · ,1(𝑚_{𝑖−1}) × IDF(𝑚_{𝑖−1} ) × Weight^{𝑖−1}_{𝑚_𝑖} , 0, 1(𝑚_{𝑖+1} ) × IDF(𝑚_{𝑖+1} )× Weight^{𝑖+1}_{𝑚_𝑖} , 1(𝑚_𝑛 ) × IDF(𝑚_𝑛 ) × Weight^𝑛_{𝑚_𝑖}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal">mb</span><span class="mord mathnormal">e</span><span class="mord mathnormal">dd</span><span class="mord mathnormal">in</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2112em;vertical-align:-0.3471em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3471em;"><span></span></span></span></span></span></span><span class="mpunct">,⋅⋅⋅,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2218em;vertical-align:-0.3471em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8747em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3471em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2218em;vertical-align:-0.3471em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8747em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3471em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0971em;vertical-align:-0.3471em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3471em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></span></eqn></section></li><li><em>Aggregating Embedding From Each Path</em><ul><li>图四展示了一个方法可以在不同的静态执行路径中.这可能导致每个方法在每个静态路径上的嵌入不同.因此,我们将不同静态执行路径的嵌入聚合在一起，以获得特定方法的嵌入</li><li>为此,我们取每个方法在每个静态执行路径上的最大嵌入值为确定方法的嵌入值(如最大池).通过这种方法的嵌入是静态执行路径中方法上下文中最重要的方法。</li></ul></li></ul></li><li><p><strong>5 Node2Vec</strong> (简称N2V)</p><ul><li>直接将图中点映射到低维向量空间(没有用图4描述的过程)</li><li>不同于之前提到的技术使用DFS生成序列,N2V基于随机游走将图转换为序列.然后使用神经网络.<ul><li>如 Word2Vec 为了基于序列生成嵌入,从而从附近 k 个窗口的标记中捕捉图的属性。当 Node2Vec 的参数设置足够大时，它将生成从入口点到终点的序列（与我们的方法相同），并且可以从整个图的信息中获得一种方法的嵌入（与我们的方法相同，但嵌入技术不同）： Node2Vec 采用的是 Word2Vec，而我们使用的是 IDF 信息）。我们使用 Node2Vec 的默认设置，输入为 CG [31]。</li></ul></li><li><em>Finding Similar Methods:</em><ul><li>在获得方法的嵌入后,给定运行的方法集合 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span></eq> ,我们需要找到用户期望的功能的所有方法集合 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>M</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">M&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></eq> . 如果我们训练了一个预测模型使用 (半)监督方法,在训练数据集中,在 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span></eq> 中的方法标记为1,没有数据标记为0(即这里没有方法不会被用户运行). 所以这驱动我们使用无监督方法来通过 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span></eq> 找到 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>M</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">M&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></eq></li><li>此外,不同用户对简化有不同看法.<ul><li>例如,一些用户可能会使用不同的功能实现同一个目标(如 用户可以使用FTP功能,通过不同的入口,如FTP活动,FTP链接按钮,FTP 片段);或应用同一行动包含不同功能(如amazi file manager中不同的文件类型). 这指示我们这些用户对某个功能有多种行为,所有我们需要给他们更大的 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>M</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">M&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></eq>.</li><li>另一些用户可能更喜欢使用与我们收集数据时相同的功能。这表明这类用户对该功能的使用行为较少，我们需要为他们提供较小的 𝑀′。</li></ul></li><li>在我们的工作中,我们使用<strong>Cosine similarity</strong>计算 所有方法与运行方法嵌入的相似度.<ul><li>Cosine similarity设置不同的阈值,可以获得不同大小的M’,用户可以选择.</li></ul></li></ul></li></ul></li></ul><h2 id="4-benchmark-creation" tabindex="-1">4 BENCHMARK CREATION</h2><ul><li><strong>基准构造原理:</strong> 一个用户可能只运行了期望功能的子集,MiniMon需要泛化这个子集找到期望功能的所有行为.为了测试MiniMon的泛化能力在大量应用和功能中的情况,我们构建了一个基准.<ul><li>基准中,对于每个应用,我们定义了一组功能.对于每个功能,我们识别相对应的用户行为.<ul><li>例如 “Open File” 是图3中左部分代表的功能.其可能包括的行为有 “open a PDF file”, “open a text file”, “open a PPT file”.</li></ul></li><li>对于给定的功能 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span></eq> , 及其相关的用户行为 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">LF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span></eq>,我们获得了 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">LF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span></eq> 的子集 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><msup><mi>F</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo><mi>L</mi><msup><mi>F</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>⊆</mo><mi>L</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">LF&#x27;,LF&#x27;\subseteq LF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">L</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">L</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span></eq>,并将其给到MiniMon. 随后我们观察MiniMon揭示的在 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>F</mi><mo>−</mo><mi>L</mi><msup><mi>F</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">LF - LF&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord mathnormal">L</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></eq> 中出现的方法.这些方法与目标所需功能所需的方法相对应，但在用户与应用程序之前的交互过程中并未观察到。</li></ul></li><li><strong>程序来源:</strong> 我们从Google Play中收集了45个应用程序.<ul><li>这些应用在<a href="https://www.androidrank.org/">AndroidRank</a>排前40.</li><li>这些应用程序的平均反编译代码行数为 15,318 行，最多可达 67,312 行.这一平均行数大于先前简化研究的基准应用程序的平均代码行数[27,53]</li><li>如果用户只使用某些功能，应用程序就可以被视为臃肿；未使用的功能不会给用户带来任何好处，而且出于安全[24,38,52,57]和其他原因，这些功能可以被省略。</li></ul></li><li><strong>基准具体构造:</strong> 对于每个应用程序，我们希望收集一组类似的用户行为。根据 Material Design 指南[11]、同一活动中的小部件更有可能相互关联[69].因此，我们将同一活动中的小部件视为一组相似的用户行为。<ul><li>在上述启发式方法的基础上,我们创建了测试用例,以捕捉应用程序功能相关的用户行为.我们使用SARA[40]记录测试用例.<ul><li>SARA是一种记录和重放工具.可以(1) 根据屏幕坐标记录运动事件，(2) 根据屏幕坐标和部件重放记录的事件。</li></ul></li><li>我们第一第二作者记录了程序的启动,确保了简化后程序的正确运行.然后,作者启动一个活动,并且与其中一个小部件进行交互.如果小部件触发了对话框,那么作者会选择一个选项或直接关闭对话框并存储测试用例.这些都是随机完成,如果选项启动了一个新的活动或没有任何其他弹出窗口，我们将直接停止</li><li>请注意，每次开始生成新的测试用例时，我们都会重新安装应用程序，以避免不同的初始条件影响已记录的测试用例。因此，对于每个功能，我们都会根据目标活动中部件的数量生成 4 到 6 个测试用例（共 214 个）。</li><li>对于每个应用程序，探索、生成和记录测试用例通常需要 30 分钟。最后，我们使用 SARA 来重放插桩应用程序的用户行为，并收集运行过程中执行的方法,</li></ul></li></ul><h2 id="5-evaluation-setup" tabindex="-1">5 EVALUATION SETUP</h2><ul><li>这里介绍实验设置和评估指标</li></ul><h3 id="5.1-%E8%AF%95%E9%AA%8C%E8%AE%BE%E7%BD%AE" tabindex="-1">5.1 试验设置</h3><ul><li>MethodGeneralizer将监视中记录的方法作为输入(即集合 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span></eq> ), 来辨识期望功能的其它方法 (即集合 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>M</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">M&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></eq> ).</li><li>为了评估 MethodGeneralizer 的性能，我们随机选取一个用户行为（启动应用除外）中的方法作为未见用户行为（ <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝑚</mi><mrow><mi>𝑡</mi><mi>𝑒</mi><mi>𝑠</mi><mi>𝑡</mi></mrow></msub></mrow><annotation encoding="application/x-tex">𝑚_{𝑡𝑒𝑠𝑡}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">es</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>，即测试集）中的方法。然后，我们将其他用户行为中的方法作为监测过程中记录的执行方法（<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑚</mi></mrow><annotation encoding="application/x-tex">𝑚</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span></eq>，即输入）。我们为每个应用反复选择测试集和执行方法𝑚，直到测试集中有额外的方法为止（即 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑡</mi><mi>𝑒</mi><mi>𝑠</mi><mi>𝑡</mi><mtext>⊄</mtext><mi>𝑚</mi></mrow><annotation encoding="application/x-tex">𝑡𝑒𝑠𝑡 ⊄ 𝑚</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">es</span><span class="mord mathnormal">t</span><span class="mord">⊄</span><span class="mord mathnormal">m</span></span></span></span></eq>  ）。</li></ul><h3 id="5.2-%E8%AF%84%E4%BC%B0%E6%8C%87%E6%A0%87" tabindex="-1">5.2 评估指标</h3><ul><li>使用 recall召回率,简化率,二者的加权平均 作为评估MethodGeneralizer识别期望功能的指标</li><li><strong>recall</strong><ul><li>当用户运行未见过行为时(运行 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>m</mi><mrow><mi>t</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">m_{test}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">es</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>),我们需要评估 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>M</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">M&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></eq> 中的方法是否满足用户的需求,如(<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>m</mi><mrow><mi>t</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow></msub><mo>⊆</mo><msup><mi>M</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">m_{test} \subseteq M&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.786em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">es</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></eq>). 这驱动我们使用racall召回率作为评估指标.</li><li>一个方法的recall的定义是指认 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>M</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">M&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></eq> 中正确方法的能力: <section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>r</mi><mi>e</mi><mi>c</mi><mi>a</mi><mi>l</mi><mi>l</mi><mo>=</mo><mfrac><mrow><mi mathvariant="normal">∣</mi><msub><mi>m</mi><mrow><mi>t</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow></msub><mo>∩</mo><msup><mi>M</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mi mathvariant="normal">∣</mi></mrow><mrow><mi mathvariant="normal">∣</mi><msub><mi>m</mi><mrow><mi>t</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow></msub><mi mathvariant="normal">∣</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">recall = \frac{|m_{test} \cap M&#x27;|}{|m_{test}|}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">rec</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">ll</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.3649em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4289em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">es</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">es</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></eqn></section>我们需要最大化recall的值,包含尽可能多的未见过行为</li></ul></li><li><strong>debloating rate</strong><ul><li |m|>debloating rate为方法移除 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span></eq> 中方法的能力: <section><eqn><span class="katex-error" title="ParseError: KaTeX parse error: Unexpected end of input in a macro argument, expected &#x27;}&#x27; at end of input: …\frac{|M|-|M&#x27;|}" style="color:#cc0000">debloating \; rate = \frac{|M|-|M&#x27;|}</span></eqn></section></li><li>我们需要最大化简化率.我们并不考虑准确值,因为我们不知道与用户特征无关的方法.因此,我们无法计算准确度,只能用简化率代替准确度.</li></ul></li><li><strong>trade-off</strong><ul><li>保留更多的方法导致较校的简化率.我们想要平衡二者,二者中,recall比简化率更重要,因为我们想要用户在使用应用时至少不会崩溃.</li><li>基于标准的 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mi>β</mi></msub></mrow><annotation encoding="application/x-tex">F_{\beta}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05278em;">β</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></eq> 分数,如 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mi>β</mi></msub><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><msup><mi>β</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mo>×</mo><mfrac><mrow><mi>p</mi><mi>r</mi><mi>e</mi><mi>c</mi><mi>i</mi><mi>s</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo>×</mo><mi>r</mi><mi>e</mi><mi>c</mi><mi>a</mi><mi>l</mi><mi>l</mi></mrow><mrow><msup><mi>β</mi><mn>2</mn></msup><mo>×</mo><mi>p</mi><mi>r</mi><mi>e</mi><mi>c</mi><mi>i</mi><mi>s</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo>+</mo><mi>r</mi><mi>e</mi><mi>c</mi><mi>a</mi><mi>l</mi><mi>l</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">f_{\beta} = (1+\beta^2) \times \frac{precision \times recall}{\beta^2 \times precision + recall}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05278em;">β</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.4133em;vertical-align:-0.4811em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mbin mtight">×</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">rec</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight">rec</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">ll</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">rec</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">n</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight">rec</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">ll</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4811em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></eq>,我们定义 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mrow><mi>d</mi><mi>e</mi><mi>b</mi><mi>l</mi><mi>o</mi><mi>a</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">F_{debloat}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 分数为recall和debloating rate的加权平均.我们设置 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mo>=</mo><mn>1</mn><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">\beta = 1/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1/2</span></span></span></span></eq> 给recall更高权重. <section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>F</mi><mrow><mi>d</mi><mi>e</mi><mi>b</mi><mi>l</mi><mi>o</mi><mi>a</mi><mi>t</mi></mrow></msub><mo>=</mo><mfrac><mrow><mn>5</mn><mo>×</mo><mi>r</mi><mi>e</mi><mi>c</mi><mi>a</mi><mi>l</mi><mi>l</mi><mo>×</mo><mi>d</mi><mi>e</mi><mi>b</mi><mi>l</mi><mi>o</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>n</mi><mi>g</mi><mtext>  </mtext><mi>r</mi><mi>a</mi><mi>t</mi><mi>e</mi></mrow><mrow><mn>4</mn><mo>×</mo><mi>r</mi><mi>e</mi><mi>c</mi><mi>a</mi><mi>l</mi><mi>l</mi><mo>+</mo><mi>d</mi><mi>e</mi><mi>b</mi><mi>l</mi><mi>o</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>n</mi><mi>g</mi><mtext>  </mtext><mi>r</mi><mi>a</mi><mi>t</mi><mi>e</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">F_{debloat} = \frac{5 \times recall \times debloating\;rate}{4\times recall + debloating\;rate}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.2519em;vertical-align:-0.8804em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">rec</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">ll</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">in</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">rec</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">ll</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">in</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></eqn></section> 高 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mrow><mi>d</mi><mi>e</mi><mi>b</mi><mi>l</mi><mi>o</mi><mi>a</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">F_{debloat}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 值意味着可以同时实现高简化率和高recall,同时我们对recall权重较高.</li></ul></li></ul><h2 id="6-evaluation-result" tabindex="-1">6 EVALUATION RESULT</h2><h3 id="6.1-methodgeneralizer-%E7%9A%84%E4%B8%8D%E5%90%8C%E5%8F%98%E4%BD%93%E5%9C%A8%E8%AF%86%E5%88%AB%E5%85%B7%E6%9C%89%E6%89%80%E9%9C%80%E7%89%B9%E5%BE%81%E7%9A%84%E6%96%B9%E6%B3%95%E6%96%B9%E9%9D%A2%E6%95%88%E6%9E%9C%E5%A6%82%E4%BD%95" tabindex="-1">6.1 MethodGeneralizer 的不同变体在识别具有所需特征的方法方面效果如何</h3><h4 id="%E8%AE%BE%E8%AE%A1" tabindex="-1">设计</h4><ul><li>不同变体间比较,同时与不使用泛化的基线比较(移除未运行的方法)</li><li>注意到使用图内嵌技术时,MethodGeneralizer 会生成不同的 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>M</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">M&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></eq> 集合,每个关联不同的阈值.我们选择 <eq><span class="katex-error" title="ParseError: KaTeX parse error: Can&#x27;t use function &#x27;$1#x27; in math mode at position 13: F_{debloat} $̲ 最高的 $M&#x27;" style="color:#cc0000">F_{debloat} $ 最高的 $M&#x27;</span></eq> 集合作为应用的最终结果.</li></ul><h4 id="%E7%BB%93%E6%9E%9C" tabindex="-1">结果</h4><ul><li>图5展示了三种指标的结果,“.” 表示平均值<ul><li>图内嵌技术(除LSTM)比其它技术在所有指标上都表现好</li><li>且差异在统计学上有很大意义（P 值小于 0.05 且效应大小很大）。</li><li>我们使用 Wilcoxon 符号秩检验来比较 MiniMon 变体的性能，并使用 Bonferroni 校正来调整 p 值 [33, 63]。我们计算 Cliff’s delta 来衡量效应大小[30]。<ul><li>Bonferroni 校正用于抵消多重比较的问题。</li><li>Cliff’s delta 是一种非参数效应大小测量方法，用于评估两组之间的差异量。Romano 等人将小于 0.147、介于 0.147 和 0.33 之间、介于 0.33 和 0.474 之间以及大于 0.474 的绝对 delta 分别定义为 “可忽略”、“小”、&quot;中 &quot;和 &quot;大 &quot;效应大小[30]。</li></ul></li></ul></li><li>基于图嵌入的技术（LSTM 除外）之间没有明显差异。<ul><li>N2V、Onehot、IDF 和 IDF-POS 的平均 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝐹</mi><mi>𝑑</mi></msub><mi>𝑒</mi><mi>𝑏</mi><mi>𝑙</mi><mi>𝑜</mi><mi>𝑎</mi><mi>𝑡</mi></mrow><annotation encoding="application/x-tex">𝐹_𝑑𝑒𝑏𝑙𝑜𝑎𝑡</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">e</span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span></span></span></span></eq> 分别为 62.82%、64.44%、64.77% 和 64.95%。</li><li>这表明这些特征对这项任务的影响不大。不过，考虑到平均 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝐹</mi><mi>𝑑</mi></msub><mi>𝑒</mi><mi>𝑏</mi><mi>𝑙</mi><mi>𝑜</mi><mi>𝑎</mi><mi>𝑡</mi></mrow><annotation encoding="application/x-tex">𝐹_𝑑𝑒𝑏𝑙𝑜𝑎𝑡</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">e</span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span></span></span></span></eq> 的改进，我们将 IDF-POS 作为最佳方法泛化技术。</li><li>IDF-POS最坏情况,相似阈值为0.1,也比不基于图嵌入的技术表现好。</li><li><strong>结论：</strong> 图嵌入技术在本任务中展示出了很大的优势，不论节点如何嵌入（不论idf信息或使用word2vec）。未来研究应继续在该方向，在CG的方法上生成更好的基于图嵌入的表示</li></ul></li><li>除图嵌入技术外，BIDIRECTION在 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝐹</mi><mi>𝑑</mi></msub><mi>𝑒</mi><mi>𝑏</mi><mi>𝑙</mi><mi>𝑜</mi><mi>𝑎</mi><mi>𝑡</mi></mrow><annotation encoding="application/x-tex">𝐹_𝑑𝑒𝑏𝑙𝑜𝑎𝑡</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">e</span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span></span></span></span></eq> 平均上表现最好。<ul><li>这意味着简单的将CG所有可达方法纳入考虑是一个直觉地且有效地方法。然而其在简化率上表现较差，因为引入了过多用户不期望功能地方法。</li><li>相反，FORWARD表现最差</li><li><strong>结论：</strong> 当决定两个方法是否相似时，调用这两个方法地调用者与被这两个方法调用的被调用者更重要。</li></ul></li><li>除图嵌入技术外，LCD是在 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝐹</mi><mi>𝑑</mi></msub><mi>𝑒</mi><mi>𝑏</mi><mi>𝑙</mi><mi>𝑜</mi><mi>𝑎</mi><mi>𝑡</mi></mrow><annotation encoding="application/x-tex">𝐹_𝑑𝑒𝑏𝑙𝑜𝑎𝑡</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">e</span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span></span></span></span></eq> 平均上表现第二好的。<ul><li>其回调率高，简化率较低。</li><li>这告诉我们 应用的模块可以高效地辨认出用户功能相关的方法。然而，LCD辨识的模块太粗粒度，导致简化率较低</li><li>LPA表现比LCD差，因为LPA只考虑了本地邻居，并没有反映正确的运行顺序</li></ul></li><li>LSTM表现最差之一。<ul><li>这是因为LSTM目的是抓取方法在静态运行路径中出现的样式，而不是每个方法在静态执行路径中的权重。导致其简化率很低。</li><li>**结论：**在静态路径中方法出现的样式对辨识相似路径贡献有限。<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(14)_5.png" alt></li></ul></li></ul><h3 id="6.2-minimon%E5%8F%AF%E4%BB%A5%E9%AB%98%E6%95%88%E7%8E%87%E5%9C%B0%E7%AE%80%E5%8C%96%E5%BA%94%E7%94%A8%E5%90%97" tabindex="-1">6.2 MiniMon可以高效率地简化应用吗</h3><ul><li><p>报告反编译后移除的代码的百分比。</p></li><li><p>同时评估简化后程序是否能正常使用，使用SARA回放Section 4中的操作，将简化后程序与原始程序进行比较。</p></li><li><p>我们同时进行了一个用户调研，探究我们方法的有效性。</p><ul><li>在我们的机构以多种方法向人们进行调研。如线上聊天频道。这个过程类似于 prior study[35]。</li><li>当有人对此产生兴趣时，我们选出8个应用，让用户选择一个他熟悉的使用。</li><li>8个毕业生参与其中。他们安卓使用经验丰富，对所有软件熟悉。</li><li>我们的用户调研的规模喝参与者与之前研究类似[21,28,29,34-36]</li><li>过程：<ul><li><ol><li>我们首先解释简化的理念</li></ol></li><li><ol start="2"><li>随后选择8个程序，随后插桩程序</li></ol></li><li><ol start="3"><li>最后我们得到8*8 = 64个数据点，来自真实用户，比之前研究[43,51]用的数据点大。</li></ol></li><li>我们提供指导来帮助用户收集日志，并要求每个用户在3天内使用每个应用5min。（5min长于应用的平均使用时间71.56s[26]，与之前研究设置时间相同[21,29]）</li></ul></li><li>具体过程<ul><li>第一天，他们被要求自由探索插桩后应用，理解软件功能</li><li>第二天和第三天，他们被要求使用插桩应用使用它们想要的功能。我们用这两天的收集的日志进行简化，使用每种技术中最好的方法（LCD，BIDIRECTION，IDF_POS）。</li><li>我们要求用户使用每个简化后程序5min，它们不知道每个简化程序对应的技术。</li><li>最后我们要求用户对每个简化后应用进行打分1-5（very unsatisifed - very satisified） 。包括<ul><li>（1）可用性：简化后程序保留期望功能到什么程度</li><li>（2）泛化性：简化后程序保留了他们想要的功能但之前未运行的到什么程度</li><li>（3）大小：它们对简化后程序的大小变化惊喜到什么程度</li><li>（4）整体满意度：</li></ul></li></ul></li></ul></li><li><p><strong>结果</strong></p><ul><li>简化后程序比原始程序反编译后代码平均减少38.8%。</li><li>214个测试用例中，88.8%的测试用例可以在表现最好的MethodGeneralizer简化后程序复现<ul><li>如 IDF-POS在10个应用中24个测试用例失败。我们深入探究了原因，发现 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span></eq> 中的静态路径和 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>m</mi><mrow><mi>t</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">m_{test}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">es</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 中的没有交集，方法相似度为0。</li><li>一个可能的原因是，用户在使用应用程序时可能会出现松动现象，有些方法不小心没有触发，因此无法记录（例如，关闭 Wi-Fi功能在Wi-Fi已经关的状态就不会被触发）</li></ul></li><li>表1展示了用户给的平均分。<ul><li>用户对IDF—POS产生的简化后程序有很高满意度，除过大小上。</li><li>智能（泛化）方法提升了37.6%的总体用户满意度</li></ul></li></ul></li></ul><p><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(14)_6.png" alt></p><h2 id="7-discussion" tabindex="-1">7 DISCUSSION</h2><h3 id="7.1-%E6%9C%80%E5%A5%BDmethodgeneralizer%E5%88%86%E6%9E%90" tabindex="-1">7.1 最好MethodGeneralizer分析</h3><ul><li>调查IDF-POS，N2V。其它图嵌入技术是IDF-POS变体，N2V是最受欢迎的一种</li><li>第3.2.3节表明，基于图嵌入的技术首先（1）使用CG中的所有节点生成方法的嵌入。然后它（2）直接将相似度分数高于特定阈值的两个方法视为相似。然而，我们不知道哪个组件是最重要的。因此，我们调查了每个组件在MiniMon中的效果。</li><li>我们将每个MethodGeneralizer与其两个变体进行比较：（这种比较可以让我们理解MethodGeneralizer组件的表现）<ul><li>MethodGeneralizer-PART使用每个静态执行路径中邻居的三分之一（而不是全部）节点来生成方法的嵌入。</li><li>MethodGeneralizer-CLU使用层次聚类来识别相似方法（而不是直接添加相似度分数高于阈值的最近邻居）。每个层次都有一个特定的相似度级别（按照第3节的设置，相似度级别从0到1，步长为0.1），其中包含一组集群。对于每个层次，如果集群中有执行的方法，我们将把集群中的所有方法添加到𝑀′中。</li></ul></li><li>表2为我们的比较结果。我们可以看到IDF-POS和N2V比他们的所有变体表现优秀<ul><li>**结论：**这表明图的全局信息（如考虑图中所有的点）是识别与用户所需功能相关方法的最重要组件。<ul><li>考虑两个不同UI组件的onclick方法，它们调用了不同的方法，但在CG的长链后，都调用了FTP相关的方法，如果仅考虑局部信息，这两个方法并不相似，因为其调用方法并不相似。但在考虑所有信息后，这两个方法是相似的</li><li>当我们在每个静态执行路径中仅考虑邻居的三分之一节点时，性能显著下降，特别是在N2V中。这表明，当Node2Vec中的窗口大小无法覆盖整个图时，N2V的性能会显著下降。未来的研究人员应考虑CG中的所有节点（具有足够大的窗口大小）来生成方法的嵌入。</li><li>此外，聚类方法不如简单地将最近邻居添加到𝑀′中有效。一个可能的原因是，聚类方法将集群中的所有方法都识别为相似的方法，这可能引入更多的噪音。</li></ul></li></ul></li></ul><p><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(14)_7.png" alt></p><h3 id="7.2-%E9%99%90%E5%88%B6%E5%92%8C%E6%9C%89%E6%95%88%E6%80%A7%E5%A8%81%E8%83%81" tabindex="-1">7.2 限制和有效性威胁</h3><ul><li><strong>本文的发现可能并不适用于所有应用程序</strong>。例如，与之前的研究类似[43,59]，我们没有考虑带有篡改检测机制和使用本地代码实现的功能的应用程序。<ul><li>我们无法修改带有篡改检测机制的应用程序，因为这些应用程序会检测到修改并停止工作[5]。</li><li>此外，本论文主要关注dex文件。本地代码实现的功能在dex文件中不可用，需要额外的努力进行分析和修改。我们相信，一旦获得这些应用程序的CG（调用图），我们的MethodGeneralizer组件也可以推广到这些应用程序上。</li><li>未来，我们计划在更多的应用程序上评估我们的工作，并研究如何简化带有篡改检测机制和使用本地代码实现功能的应用程序。</li></ul></li><li>在<strong>构建基准</strong>时，我们使用了一些启发式方法。例如，我们的基准是由作者根据假设创建的，即同一活动中的小部件可能与同一功能相关（基于指南[11,69]），而不是由实际用户创建的。然而，可能存在一些应用程序并不遵循这些指南。我们承认，基准创建过程并不完美，但目前没有其他替代基准。即使是我们创建的当前基准，也需要大量的手工工作。为了减轻不完美基准带来的威胁，我们通过用户研究评估了我们提出的方法，收集了真实用户与应用程序的交互数据。</li><li>**评估指标：**我们使用简化率、召回率和𝐹𝑑𝑒𝑏𝑙𝑜𝑎𝑡来评估我们的方法。我们没有报告实际的应用程序大小减少情况，因为每个应用程序中的资源占用了大量空间，而本文主要关注的是移除代码（即方法）。我们在真实设备上通过人类进行的真实世界应用程序实验。</li><li><strong>用户研究的局限性</strong>：我们的用户研究只有8名参与者。然而，这一研究规模在之前的研究中也被采用[21,28,29,34,35,36]。</li></ul><h2 id="8-%E7%9B%B8%E5%85%B3%E5%B7%A5%E4%BD%9C" tabindex="-1">8 相关工作</h2><ul><li><strong>安卓应用的简化</strong></li><li>Google提出了一些减少安卓应用程序大小的方法。例如<ul><li>（1）使用R8静态检测并移除无效代码及其库依赖</li><li>（2）移除未使用的资源</li><li>（3）缩短类和成员的名称以减少DEX文件大小[12]</li><li>开发者还可以配置App Bundle或使用按需交付，以便只下载特定设备或功能所需的代码和资源[2,8]。</li><li>这些方法已成为Android应用程序开发的默认设置，并且可以与MiniMon互补。MiniMon可以在R8之前或之后运行。</li></ul></li><li>我们利用Bruce等人的工作设置，检查我们的实验应用程序是否可以通过这些方法进一步简化。Bruce[27]等人将他们的方法（即JShrink）与ProGuard（使用与R8相同的设置）和其他基于静态分析的方法进行了比较。我们发现没有方法可以被移除。这意味着开发者已经在构建阶段使用了像R8这样的静态工具来简化Android应用程序。尽管如此，我们的研究表明，在这些应用程序中，仍然有大量特定用户不需要的方法，我们的工作对于更好的用户特定应用程序简化是必要的。</li><li>Xie等人通过简化应用程序来最小化移动网络的带宽消耗。[64]</li><li>Jiang等人基于静态分析移除无效代码。[44]</li><li>Tang等人在Activity、权限和模块化级别上对应用程序进行了简化。[59]<ul><li>为了在模块化级别上进行简化，他们将每个模块视为一个功能，并使用Louvain社区检测来识别CG（调用图）中的模块。</li><li>继他们的工作之后，我们也使用了LCD作为我们的一种技术。我们的结果显示，LCD在识别与用户所需功能相关的方法方面不如其他基于图嵌入的技术。</li></ul></li><li>Pilgun等人在测试过程中移除了未执行的指令。[51]<ul><li>我们尝试将MiniMon与Pilgun的工作在指令级别进行比较，但遇到了困难（我们只能在两个示例应用程序上复制他们的结果）。尽管与作者联系，我们仍未能解决问题。Pilgun承诺在更多应用程序上运行他们的工具，但在我们提交论文时尚未兑现。因此，我们实现了一个基线方法，即移除未执行的方法（即EXECUTED）。我们的结果显示，在𝐹𝑑𝑒𝑏𝑙𝑜𝑎𝑡和召回率方面，MiniMon优于EXECUTED。</li></ul></li><li>Huang等人提出了一种移除未使用的UI组件的方法。[43]<ul><li>他们要求用户指定要移除的组件，并使用前向/后向切片技术来识别与UI组件相关的指令，从而消除仅与这些组件相关的指令。然而，我们的工作旨在保留所有已执行的方法，并将其推广到未来的用户行为。与Huang等人不同，我们并不知道哪些UI组件是不必要的。因此，我们的方法与Huang等人的方法有不同的目标，无法直接进行比较。</li><li>尽管如此，我们相信EXECUTED基线方法在一定程度上体现了Huang等人的方法，通过记录经过仪器化的应用程序的日志信息来识别与UI组件相关的方法。此外，我们的程序分析技术在前向切片和后向切片方面也部分借鉴了Huang等人的方法。我们有信心已经进行了与Huang等人方法最相关的比较。</li></ul></li><li>Qian等人[53]和Xin等人[66]提出了基于单个用户使用情况简化C/C++程序（例如UNIX工具）的方法。<ul><li>他们首先收集C/C++程序使用时执行的语句日志，然后采用一些扩充技术来识别与已执行语句相关的程序元素。已执行和相关的程序语句被保留，而其余部分被删除。虽然我们的工作动机与这两项研究相似，但存在一些使这些工作互为补充的差异。</li><li>首先，Qian等人和Xin等人使用的扩充技术需要在语句级别进行插桩，而我们提出的方法（MiniMon）只需要在方法级别进行插桩，这更轻量，并且带来的性能开销对Android手机用户来说是可以接受的。<ul><li>此外，由于考虑的插桩级别不同，这两篇论文中扩充技术使用的启发式方法不能轻易应用于MiniMon。<ul><li>例如，Qian等人的扩充技术包括4种策略：添加额外的分支、可达指令、同一二进制文件内的可达函数或已执行的外部函数，以及具有相同功能的可达库函数。目前尚不清楚这些启发式方法如何应用于MiniMon以识别相关方法。我们认为，考虑所有调用方法作为用户所需功能方法的FORWARD技术在某种程度上体现了Qian等人的方法。</li><li>此外，Xin等人扩充技术（CovA）中灵活性的计算需要计算C/C++函数中已执行语句的唯一集合数量。</li></ul></li></ul></li></ul></li><li>我们的工作还与特征定位相关。现有的工作主要集中在促进程序理解。在我们的工作中，我们使用监控期间收集的特征来找到与所有用户所需功能对应的方法。我们相信，许多特征定位工作可以适应我们的任务。我们已经将我们的方法与我们领域中使用的一些特征定位方法进行了比较。未来，我们计划探索其他特征定位工作（如果基于无监督学习）以进一步提高性能。</li></ul><h2 id="9-%E7%BB%93%E8%AE%BA%E4%B8%8E%E6%9C%AA%E6%9D%A5%E5%B7%A5%E4%BD%9C" tabindex="-1">9 结论与未来工作</h2><ul><li>在本文中，我们旨在根据用户的使用方式简化Android应用程序。为了解决这个任务，我们实现了一个基于监控的简化框架MiniMon，该框架可以在监控时（1）收集执行的方法。然后，结合应用程序调用图，MiniMon中的MethodGeneralizer组件（2）采用三种基于程序分析的技术、两种基于图聚类的技术和五种基于图嵌入的技术来识别所需特征的其他方法。最后，MiniMon（3）通过删除剩余的方法生成简化的应用程序。</li><li>为了评估，我们手动创建了一个基准，该基准收集了每个特征执行的方法。使用此基准进行的受控实验突显了考虑调用图中所有节点信息的嵌入式泛化技术是最佳的，可以正确地发现75.5%的所需特征的其他方法，并简化超过一半的应用程序。</li><li>我们的用户研究表明，使用MiniMon的智能（泛化）方法将整体用户满意度提高了37.6%。</li><li>在未来，我们计划利用其他Android特性来识别与用户所需特征相关的方法。我们还计划使用更多的应用程序和测试用例扩大基准。·</li></ul><h2 id="10-%E5%BC%80%E6%BA%90%E5%9C%B0%E5%9D%80" tabindex="-1">10 开源地址</h2><p><a href="https://zenodo.org/records/10149997">开源地址</a></p><h2 id="%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93" tabindex="-1">个人总结</h2><ul><li>在安卓应用中，从函数粒度出发，记录用户期望的功能对应的函数（到这里相当于Cov），随后对这些方法进行泛化（相当于找到功能相关的函数），最后再加上这些泛化后的函数组成简化后程序</li><li>本文主要创新点：<ul><li><ol><li>在函数调用图上，使用3种泛化方法，包含10种具体技术，其中基于图嵌入的技术表现最好，达到了最好的简化平衡</li></ol></li><li><ol start="2"><li>构建了一个安卓简化基准</li></ol></li><li><ol start="3"><li>用户实际使用来验证结果</li></ol></li></ul></li><li>可能问题<ul><li><ol><li>基于APK文件的简化，看不到源码，简化的可审计性缺失，工业界是不敢用的</li></ol></li><li><ol start="2"><li>由于是在apk文件上基于函数级别，所以函数内部还有再进一步简化的可能</li></ol></li><li><ol start="3"><li>实际没有和其它方法对比，不知道是没有其它方法吗</li></ol></li></ul></li></ul><h2 id="%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8" tabindex="-1">工具使用</h2><ul><li><font face="微软雅黑" color="#FF0000">new:没文档，真不好搞，感觉不如重新写</font></li><li><font face="微软雅黑" color="#FF0000">自己重新拉依托还是比吃依托好受些</font></li><li>有以下几个文件夹<ul><li>/lib：依赖库</li><li>/SATA：我们的数据集合<ul><li>包括APK文件 /apks</li><li>记录的交互及复现的脚本/trace</li><li>记录的log文件/logcat_repeat</li></ul></li><li>/src：源代码位置<ul><li><strong>首先配置config.java</strong></li><li>随后跑/task里的代码</li></ul></li><li>/UserStudy 用户调研相关</li></ul></li></ul><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;minimon&quot; tabindex=&quot;-1&quot;&gt;MiniMon&lt;/h1&gt;
&lt;h2 id=&quot;0-abstract&quot; tabindex=&quot;-1&quot;&gt;0 ABSTRACT&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;为了满足多样的用户需求，安卓应用的大小正变得越来越大。然而，并不是所有应用</summary>
      
    
    
    
    <category term="论文" scheme="http://example.com/categories/%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="SoftwareEngineering" scheme="http://example.com/tags/SoftwareEngineering/"/>
    
    <category term="SoftwareDebloating" scheme="http://example.com/tags/SoftwareDebloating/"/>
    
  </entry>
  
  <entry>
    <title>Software Debloating 论文阅读 （13）</title>
    <link href="http://example.com/2024/05/28/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/SoftwareDebloating/Software%20Debloating%20%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB(13)/"/>
    <id>http://example.com/2024/05/28/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/SoftwareDebloating/Software%20Debloating%20%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB(13)/</id>
    <published>2024-05-28T13:37:33.005Z</published>
    <updated>2024-06-06T15:11:17.988Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ui-driven-andorid-application-reduction" tabindex="-1">UI Driven Andorid Application Reduction</h1><pre><code class="language-bibtex">@inproceedings&#123;huang2017ui,  title=&#123;UI driven Android application reduction&#125;,  author=&#123;Huang, Jianjun and Aafer, Yousra and Perry, David and Zhang, Xiangyu and Tian, Chen&#125;,  booktitle=&#123;2017 32nd IEEE/ACM International Conference on Automated Software Engineering (ASE)&#125;,  pages=&#123;286--296&#125;,  year=&#123;2017&#125;,  organization=&#123;IEEE&#125;&#125;</code></pre><h2 id="0-abstract" tabindex="-1">0 Abstract</h2><ul><li>现代移动应用APP包含许多很少使用的功能。如应用包含广告或包含其它功能（如天气APP上讲故事的功能）。这些功能对APP不必要，但会消耗电量，CPU周期和带宽。</li><li>本文设计了一种UI驱动的，通过删除不需要功能定制化Andorid APP的方法。<ul><li>具体的，我们的技术展示了UI，并且允许用户选择想要移除的表达了功能的元素。</li><li>使用这些信息，我们的技术自动的移除所有与所选功能关联的代码元素，包括相关的背景任务</li></ul></li><li>内在的分析是一种标记系统，每个代码元素被标记是否可以被移除。通过UI建议，我们的技术推断所有代码元素的标记，并根据此进行简化。</li><li>我们实现了方法原型，并在10个真实的现实世界的安卓APP上进行了评估。结果现实，我们的方法可以准确的发现可以移除的代码元素，在简化程序中节省了大量的资源</li></ul><h2 id="1-introduction" tabindex="-1">1 Introduction</h2><h3 id="1.1-%E8%83%8C%E6%99%AF" tabindex="-1">1.1 背景</h3><ul><li><p>APP包括很多很少使用的功能：</p><ul><li><ol><li>广告出现在超过50%的应用上[2],其引入的第三方库增加隐私和安全风险[3]。先前研究已经证实敏感信息会暴露在广告网络上[4,5],广告很容易引起传播攻击[6]。</li></ol></li><li><ol start="2"><li>用户不期望的应用的其它功能。如天气APP提供的新闻功能（见 Section IV-B2）</li></ol><ul><li>除过不相关的功能，也有与应用目的相关但复杂的功能，这被用户认为是多余的或分散注意力的。如购物APP根据购物历史和浏览记录的推荐功能，一些用户可能希望关掉</li></ul></li></ul></li><li><p>这些功能除了视觉上的影响，还会导致电池，CPU周期，带宽等的额外消耗。先前的研究已经正式使用广告的APP显著消耗更多网络数据和能源消耗[7]。</p></li><li><p>因此，现在急需一种自动化定制移动APP来满足不同用户人群的不同需求。</p><ul><li>企业和政府机构需要不包含第三方库的APP</li><li>常使用或户外使用的用户希望减少电池消耗。</li><li>甚至普通用户也希望定制应用。如家长希望屏蔽对孩子的不合适的内容。</li></ul></li><li><p>然而，如果没有可用的自动化工具，app定制化和私人化对于人类的开发者团队很昂贵</p></li></ul><h3 id="1.2-%E8%A7%A3%E5%86%B3" tabindex="-1">1.2 解决</h3><ul><li>本文，我们提出了一种UI驱动的APP定制技术，可以移除安卓APP中与给定UI元素相关的不需要的功能。具体的<ul><li><ol><li>我们技术需要用户首先明确想要移除的表达功能的UI元素</li></ol></li><li><ol start="2"><li>然后我们的技术自动化辨别指定元素对应的代码和变量的位置</li></ol></li><li><ol start="3"><li>随后我们的技术监视UI元素相关的使用，及相关的后端任务代码，如从远程服务器获取的数据</li></ol><ul><li>尽管UI相关的代码元素可以直接移除，与后端任务相关的代码需要更多的分析判断是否可以移除。</li><li>我们的技术检查后端任务察省的数据是否仅仅只流向指定的用户界面，如果是的那么这个后端任务被认为是可移除的。否则（即产生的数据传输到了其它组件）不可删除。</li></ul></li><li>深层的分析是一个标记系统，每个代码元素被标记是否可以被删除。推断系统推断所有与UI提示相关的代码元素。最后，我们的技术依据推断的类型简化APP.</li></ul></li><li>我们的技术可以使用在APP开发的最后一个阶段，产生大量的定制化版本来应对不同的需求。此外，我们的技术不需要源代码。</li><li>我们在10个常用安卓应用上评估了我们的原型，我们的结果展示了在各种资源上可观的简化。<ul><li>平均移除不需要功能的UI组件可以节省 28.1%数据使用,34.1%CPU时间,26.2%Wi-Fi运行时间,37.6% 计算电力使用。</li><li>我们实现的结果证明了我们UI驱动的应用简化的优点</li></ul></li></ul><h3 id="1.3-%E8%B4%A1%E7%8C%AE" tabindex="-1">1.3 贡献</h3><ul><li>我们的工作作出了以下贡献：<ul><li><ol><li>我们提出了一个UI驱动的方法，来移除安卓应用中用户指定的UI组件相关的不想要的功能。我们的技术以一个标记系统为特点，标记了相关的代码元素指示它们是否可以删除。</li></ol></li><li><ol start="2"><li>我们实现了一个原型，并在一组真实世界的安卓应用上进行评估。结果显示我们的方法准确的发现了可以移除的代码元素，并且简化引起了客观的资源节省。</li></ol></li></ul></li></ul><h2 id="2-motivation" tabindex="-1">2 Motivation</h2><ul><li><p>我们使用 WeatherBug[8]，真实的安卓应用来激励我们的技术。</p><ul><li>直觉上，当APP挂起，用户期望得到即时的天气情况，然而，主页通常提供一些额外的信息，如图1示，APP主页包括即时天气情况，天气新闻和横幅广告。如果我们继续向下滚动，该页包括了更多不相关的信息如其他用户的图片，the closest spark strike 等<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(13)_1.png" alt></li></ul></li><li><p>除了不相关的信息淹没了用户外，这些组件爷消耗了额外的能源和网络数据。因此，这里需要定制化或重构应用来移除一些对客户端不必要的功能。</p><ul><li>例如，为了阻止视觉干扰，减少潜在的隐私缺失和恶毒行为（在企业环境中）[9,3,6]，同时为了减少能量和网络数据消耗（在复杂环境如户外）。</li></ul></li><li><p><strong>我们工作的首要想法是通过辨别UI上不需要的特征来定制APP来满足不同用户的需求</strong></p></li><li><p>假设现在用户想要移除WeatherBug上不需要的UI组件和其相关功能。具体地，用户先要移除Weather News组件，图1中高亮部分。</p><ul><li>图2展示了工作流简化表示后的代码片段，分为n个顺序运行部分，当组件被加载时，安卓操作系统调用<ul><li>（1）onCreateView 方法，充入第4行的静态布局文件，以保存组件的内容。同时，一个StoriesAdapter被创建并加入组件。着提供了从具体组件数据到展示界面的绑定，如所有内在组件的图片和标题。随后安卓OS调用</li><li>（2）onActivityCreated方法，其最终会挂起一个后端功能来从远程服务器获取数据。当数据加载完成后，后端任务调用其回调函数</li><li>（3）onRequestCompleted。在后调方法中，数据被传输到一个线程，线程在运行队列中排队。随后安卓OS</li><li>（4）运行这个线程。在运行过程中，在第30行数据被取回并保存在共享数据集中。接下来，在31行线程告知StoriesAdapter关于数据集的变化。最终，数据集的变化通知引发了</li><li>（5）onCreateViewHolder 和 （6）onBindViewHolder的运行。前者方法创建了带有充气视图的视图支架，后者方法再45行从共享数据集中获取数据展示在膨胀视图上。<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(13)_2.png" alt></li></ul></li></ul></li><li><p>在我们的驱动例子中，4，37，43行与不想要的UI组件相关。我们的技术可前瞻性地追踪相关变量地使用，如图2中展示的，我们识别出了 行7，45是将数据推送到具体地组件上的。</p><ul><li>第7行绑定StoriesAdapter到UI组件上，以响应数据变化并显示内容。内容，其作用类似于动作处理程序。</li><li>第45行展示了给定的数据中图1中展示的相关图片的简短描述。从第45行开始，我们沿着onRequestCompleted向后收集数据，然后在后台功能（代码中省略）中跟踪数据生成点。我们在更远的地方发现了调用后端功能的位置在第12行。接下来，我们检查生成的数据是否仅用于具体的UI组件，通过向后地追踪数据使用。<ul><li>如图二示，在这个例子中，我们发现没有其它组件使用这些数据，因此这些数据是这个UI组件特定的数据。然而，我们发现这个后端功能是一个公共组件会被其它功能使用，包括这个数据生成点。最终，我们的技术移除了其他未在后端功能中出现的代码，并且迭代地移除了合适的方法和类。</li></ul></li></ul></li><li><p>为了展示代码简化的效果，我们的技术在onCreateViem中用一个代替视图替换了原来的视图并删除了可移除的代码啊组件。更改后的代码片段及运行时截屏如图3展示。代替视图如高亮部分描述。<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(13)_3.png" alt></p></li><li><p>在Section IV中，移除Weather News组件减少了9%的数据使用和20%的电量消耗。</p></li></ul><h2 id="3-design" tabindex="-1">3 Design</h2><ul><li><p>本节讨论我们UI驱动的方法来发现安卓APP中可以删除的代码元素。</p></li><li><p>图4展示了我们方法的工作流，正如Section 2中讨论的：在收到用户确定的UI元素并找到程序中与他们相关的具体部位后（Step0），我们的方式进行4步来检测潜在可移除代码元素</p><ul><li><ol><li>前瞻地发现确定的UI组件使用地部分</li></ol></li><li><ol start="2"><li>向后追踪UI组件使用的数据</li></ol></li><li><ol start="3"><li>从数据产生点开始，找到所有数据的使用地方</li></ol></li><li><ol start="4"><li>基于数据追踪结果，迭代地移除代码元素</li></ol></li></ul></li><li><p>0，1步在Section Ⅲ-C中讨论，Section Ⅲ-D讨论2，3步，Section Ⅲ-E讨论4步<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(13)_4.png" alt></p></li><li><p>我们在整个章节使用图5中的代码片段来说明方法的细节。假设id0，id1指代不需要的UI元素，但id2不是。BgTask表示一种后台功能，它从远程服务器获取输入数据并将结果存储到data中。第13行通过getInputData函数抽象了获取输入数据的操作。一个具体的例子是HttpClient.execute(),它通常在安卓应用中用于从Web服务器获取远程数据。数据获取任务在两个位置启动：第3，7行。数据在第5，9，11行显示在UI元素上。<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(13)_5.png" alt></p></li></ul><h2 id="4-evaluation" tabindex="-1">4 EVALUATION</h2><h2 id="5-related-work" tabindex="-1">5 RELATED WORK</h2><ul><li>目前有许多计数检测第三方库，包括安卓中的广告库。<ul><li>基于简单技术如：流行广告库的白名单命名空间[15,16]</li><li>[17]使用hierarchical clustering 区分应用的主要和非主要功能</li><li>[18]基于代码特征和包依赖关系为广告检测开发了分类器</li><li>[19]基于API频率</li><li>[20]提出了一种抗混淆的广告检测技术，通过提取对常见混淆技术具有弹性的配置文件，并依赖于类层次结构而不是代码</li><li>相比之下，我们的技术更通用，其专注于移除用户在UI上选择的特征而不仅是广告。且不依赖于特定的代码样式</li></ul></li><li>检测应用中冗余的技术。[21,22,23,24]。它们的目的是使软件系统更能抵抗故障，并利用重复的代码作为测试预言。它们与我们的技术支持互补，因为可以移除/替换冗余代码以提高质量。它们从程序中的错误组件开始发现冗余代码，而我们的方法从用户指定的UI信息开始。</li><li>此外，许多研究工作旨在提高能源效率<ul><li>[25,26]Gottschalk等人通过识别能源效率低下的模式，检测并移除了Android应用程序中的能源浪费代码</li><li>[27]Sahin等人研究了移动应用程序中代码混淆引起的能源消耗</li><li>[28]Gui等人测量了移动广告的能源消耗</li><li>[29]Banerjee等人提出了一种重构Android应用程序的技术，以遵循一系列指导方针来增强能源效率</li><li>[30]Wu等人使用预定义的能耗模式静态检测应用程序UI中的能源缺陷</li><li>作者提出的方法不依赖于代码模式，也不需要领域知识就可以正常工作。由于移除了选定的不需要的功能，因此节省了能源。</li></ul></li><li>使用UI信息进行安全性保护<ul><li>AsDroid [34]使用UI信息来确认程序行为是否为应用程序用户所预期</li><li>SUPOR [35]，UIPicker [36]和BidText [37]利用UI信息检查在UI上显示或输入的数据敏感性</li><li>特别是，BidText [37]通过将文本信息识别为类型并沿数据流执行类型传播，实现了信息泄露检测的类型系统。</li><li>Ernst等人开发的基于类型的污点分析系统预定义了一些安全类型，并检查到达程序点的类型是否兼容[38]。</li></ul></li></ul><h2 id="6-conclusion" tabindex="-1">6 CONCLUSION</h2><ul><li>我们提出了一种静态技术来移除Android应用程序中的代码元素。这些代码元素与用户指定的不需要的UI（用户界面）元素相关。</li><li>该方法识别直接引用特定UI元素的程序位置，并应用类型系统来推断可移除的代码元素。每个可达的代码元素都被标记了一个传播的类型。这些类型被用来确定相应的代码元素是否可以移除。除了移除与指定UI元素相关的代码元素外，我们的技术还能够发现相关的后台功能，并对后台功能中的相应代码元素进行类型化，以便它们也可以被移除。</li><li>我们实现了一个原型并在10个现实世界的Android应用程序上进行了评估。结果表明，我们的方法可以准确地识别与指定UI元素相关的可移除代码元素，移除这些功能可以节省大量资源。</li></ul><h2 id="%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93" tabindex="-1">个人总结</h2><ul><li>本文讲述了一个UI驱动的简化方法，应用在安卓APP上，不需要基于源代码。</li><li>简化方法：<ul><li>通过用户确定一个UI组件，找到其调用的相关前端代码，前后端连接代码。</li><li>对于前端代码可以直接删除，对于前后端连接代码需要确定改代码仅用于该前端组件才能删除。</li></ul></li></ul><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ui-driven-andorid-application-reduction&quot; tabindex=&quot;-1&quot;&gt;UI Driven Andorid Application Reduction&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&quot;language-bibte</summary>
      
    
    
    
    <category term="论文" scheme="http://example.com/categories/%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="SoftwareEngineering" scheme="http://example.com/tags/SoftwareEngineering/"/>
    
    <category term="SoftwareDebloating" scheme="http://example.com/tags/SoftwareDebloating/"/>
    
  </entry>
  
  <entry>
    <title>通过不变量的反例引导的定向Fuzzing</title>
    <link href="http://example.com/2024/04/26/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/invariant/%E9%80%9A%E8%BF%87%E4%B8%8D%E5%8F%98%E9%87%8F%E7%9A%84%E5%8F%8D%E4%BE%8B%E5%BC%95%E5%AF%BC%E7%9A%84%E5%AE%9A%E5%90%91Fuzzing/"/>
    <id>http://example.com/2024/04/26/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/invariant/%E9%80%9A%E8%BF%87%E4%B8%8D%E5%8F%98%E9%87%8F%E7%9A%84%E5%8F%8D%E4%BE%8B%E5%BC%95%E5%AF%BC%E7%9A%84%E5%AE%9A%E5%90%91Fuzzing/</id>
    <published>2024-04-26T13:07:01.401Z</published>
    <updated>2024-04-26T13:07:01.401Z</updated>
    
    <content type="html"><![CDATA[<h2 id="counterexample-guided-directed-fuzzing-via-likely-invariant-inference" tabindex="-1">Counterexample-Guided Directed Fuzzing via Likely Invariant Inference</h2><ul><li>引用：Huang H, Zhou A, Payer M, et al. Everything is Good for Something: Counterexample-Guided Directed Fuzzing via Likely Invariant Inference[C], 2024 IEEE Symposium on Security and Privacy (SP). IEEE Computer Society, 2024: 142-142.</li><li>CCF A S&amp;P , IEEE Symposium on Security and Privacy</li><li><a href="https://www.researchgate.net/profile/Heqing-Huang-14/publication/377767294_Everything_is_Good_for_Something_Counterexample-Guided_Directed_Fuzzing_via_Likely_Invariant_Inference/links/65b786ab1bed776ae3138790/Everything-is-Good-for-Something-Counterexample-Guided-Directed-Fuzzing-via-Likely-Invariant-Inference.pdf">链接</a></li></ul><h3 id="1-%E6%91%98%E8%A6%81" tabindex="-1">1 摘要</h3><ul><li>定向模糊有很多应用，如 补丁回归测试[1,2],漏洞重现[3,4],验证静态分析报告[5,6],为各种漏洞生成概念验证输入[7]</li><li>现有定向模糊测试输入许多都与目标无关，我们称为<strong>indirect input generation</strong>。<ul><li>[10,12-16] 使用种子突变，产生95%的输入与目标无关</li><li>[17,18,19] 拒绝了一些输入，但仍然有大量无关输入</li></ul></li><li>本文提出一种高效的，定向灰盒fuzzing技术来解决<strong>indirect input generation</strong>。<ul><li>关键见解是通从可达和不可达的执行输入中推断出可能的不变量，以限制后续输入生成的搜索空间并产生更多可达的输入。</li><li>此外，为了高效的产生输入满足目标状态，我们提出两种策略优化可能的不变量推理，<ul><li>distance-based input selection，减少输入使得不变量推断更加高效</li><li>similarity-based invariant selection，消除不准确的不变量使得输入生成更加高效</li></ul></li></ul></li><li>我们在灰盒fuzzer Halo实现了我们这个输入限制的模糊测试方法<ul><li>使用Magma[20]benchmark</li><li>4种SOTA directed fuzzers:AFLGO[10],Beacon[17],WindRanger[15],SelectFuzz[16]</li><li>4种SOTA non-directed fuzzers:AFL[21],AFL++[22],ParmeSan[23],SymCC[24]</li><li>结果现实，Halo6.2x产生可达输入，漏洞重现快15.3x,并检查出了更多的漏洞</li></ul></li><li>本文贡献总结<ul><li><ol><li>提出利用已执行的输入动态推断可能的不变量，以限制后续输入生成的搜索空间，从而加速定向模糊测试中的漏洞重现过程</li></ol></li><li><ol start="2"><li>设计了两种新颖的选择策略，以提高输入生成的效率，有效地减少了生成的不相关输入的比例</li></ol></li><li><ol start="3"><li>我们提供了实证证据证明我们的方法比SOTA定向模糊器更高效，有效</li></ol></li></ul></li></ul><h3 id="2-%E5%8A%A8%E6%9C%BA" tabindex="-1">2 动机</h3><ul><li>2.1：现有工作的intuition及 justify 他们的弱点</li><li>2.2：陈述我们解决这些问题的动机</li></ul><h4 id="2.1-existing-directed-fuzzers" tabindex="-1">2.1 Existing Directed Fuzzers</h4><ul><li>定向模糊测试的主要目的：examine the program behaviors defined by the targets.</li><li>现在SOTA定向模糊测试中，主要有两种趋势<ul><li><ol><li>通过选择promising seeds来接近目标</li></ol></li><li><ol start="2"><li>消除无法达到目标的输入的不可达执行</li></ol></li></ul></li></ul><h5 id="2.1.1-sophisticated-seed-scheduling" tabindex="-1">2.1.1 Sophisticated Seed Scheduling</h5><ul><li>[10,12,13,14]致力于选择具有最高检测目标行为概率的种子,使用各种使用度函数衡量达到目标的可能性<ul><li>AFLGO[10] 优先考虑与控制流图中目标的最小距离的种子</li><li>Hawkeye[13] 通过考虑从崩溃报告中获得的平均“call-trace-distance”来优化此距离度量</li><li>CAFL[12] 通过必要的指令来细化调用跟踪以触发崩溃</li><li>WindRanger[15] 通过仅收集从控制流偏移块到目标的距离来改进适应度</li><li>SelectFuzz[16] 通过数据依赖仅计算从变量和块到目标的距离。另一种方法是衡量达到目标的困难程度</li><li>MC2[14] 将定向模糊测试转换为蒙特卡罗计数模型，使用每个分支的执行频率来近似达到目标的困难程度，并优先考虑具有最低困难度的种子。</li></ul></li><li>尽管有许多基于优先级的方法帮助fuzzing更快地定位到目标，但主要的输入生成方法依赖随机突变，只有一小部分有限的种子输入，结果导致大量的无关输入被运行</li></ul><h5 id="2.1.2-culling-infeasible-executions" tabindex="-1">2.1.2 Culling Infeasible Executions</h5><ul><li>一些fuzzer-created inputs绝不会达到目标行为，为了减少这些运行，一些fuzzer会在清除知道不会达到目标的时候停止执行[17,18,19]<ul><li>FuzzGuard[18] 使用机器学习模型预测是否可达</li><li>Beacon[17] 推断必要的达到目标的preconditions，如违反则停止执行</li><li>SieveFuzz[19] 提出根据动态反馈自适应地优化可以被除去的路径，减少不可达的执行</li></ul></li><li>尽管拒绝一些输入可以提高效率，但这仍然是一种补偿性措施，因为没有迹象表明可以直接生成针对目标的输入。</li></ul><h4 id="2.2-example-and-key-challenges" tabindex="-1">2.2 Example and Key Challenges</h4><p><img src="/images/%E8%AE%BA%E6%96%87/invariant/2_1.png" alt></p><ul><li>图1中，假设我们有三个种子<ul><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">)</mo><mo>:</mo><mo stretchy="false">(</mo><mn>15</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>10</mn><mo separator="true">,</mo><mn>10</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A(a,b,c,d):(15,5,10,10)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">15</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">10</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">10</span><span class="mclose">)</span></span></span></span></eq></li><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">)</mo><mo>:</mo><mo stretchy="false">(</mo><mn>5</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>10</mn><mo separator="true">,</mo><mn>10</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">B(a,b,c,d):(5,5,10,10)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">10</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">10</span><span class="mclose">)</span></span></span></span></eq></li><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">)</mo><mo>:</mo><mo stretchy="false">(</mo><mn>15</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>10</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C(a,b,c,d):(15,5,10,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">15</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">10</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span></eq></li></ul></li><li>现有fuzzer可以优先选择种子 B 而不是种子 A 和 C，因为种子 B 可以到达第 12 行，而种子 A 和 C 到达第 11 行，但是随机变异种子可能不会快速满足第 11-13 行的紧密路径条件，更不用说满足溢出条件 a + b + c &gt; sizeof(buf)</li><li>虽然种子 B 被优先考虑，但是模糊测试工具仍然可能生成大量违反路径条件的输入，导致探索与目标无关的程序，例如第 18 行的代码块。</li><li>另一方面，消除导致目标的不可行执行并不帮助生成朝向目标的输入。例如，Beacon [17] 可能根据可达性和路径条件终止执行。因此，一旦执行到达第 18 行，模糊测试工具可以停止执行输入。然而，模糊测试工具仍然缺乏如何生成满足第 11-14 行条件的输入的知识</li></ul><h5 id="motivation" tabindex="-1">Motivation</h5><ul><li>存在 <strong>indirect input generation</strong> 的问题的关键原因是输入生成对目标路径条件的无视。我们注意到，即使现有方法可以通过额外的反馈优化种子选择或消除不必要的执行，我们仍必须为 定向模糊测试 特化输入生成，以便更快地到达目标。</li><li>然而，到目前为止，现有方法错过了这个优化机会，具体来说，现有方法仅保留了执行种子时的少量反馈哦，仅占生成输出的一小部分，大多数输入在执行后被丢弃</li><li>例如，下表显示，SOTA AFLGO在Magma基准测试中仅保留了少于0.01%的执行输入反馈，因此在我们4.1AFLGo 不能有效地重现大多数目标（基准测试中的 138 个目标中的 19 个）<br><img src="/images/%E8%AE%BA%E6%96%87/invariant/2_2.png" alt></li><li>因此，我们的想法是利用执行的输入来近似目标条件，这可以限制后续输入生成的搜索空间。</li><li>我们使用图2说明我们的基本想法。输入可以视为从各种程序路径的分布中取样，这些路径的条件（谓语）是区分路径的边界。由于fuzz高效的输入生成速度，我们可以通过大量样本推断这些边界。<ul><li>例如，通过观察上一个例子中对种子A，B，C中的a值进行变异生成的输入，我们可以近似认为达到目标的条件是a&lt;15,其是11行的否定条件的一个值，尽管还没有达到a&lt;10，但之后就不需要生成a&gt;=15的输入。此外，如果发现反例a=10，则可以进一步改进这个近似</li></ul></li><li>目前，有效地近似条件和生成输入面临两个主要挑战：</li><li><strong>Challenge 1. How to infer conditions from executed inputs efficiently?</strong><ul><li>为了实现高效性，模糊测试工具必须以尽可能少的输入准确推断条件。<br>虽然模糊测试工具能够生成大量输入，但为每个输入记录反馈可能会带来显着的开销。<br>因此，需要有效的输入选择策略，仅选择必要的输入进行条件推断，从而最大程度地减轻对模糊测试工具资源的负担。</li></ul></li><li><strong>Challenge 2. How to generate inputs constrained by conditions efficiently?</strong><ul><li>为了有效地重现目标，模糊测试工具应该使用推断的条件高效地生成受限制的输入，而不是持续调用昂贵的约束求解器。</li><li>然而，条件可能各不相同，而并非所有条件都同样有用；例如，条件 b &gt; 1 与条件 a &lt; 10 分别相比对变量 b,a 的搜索空间的约束可能不那么显著。</li><li>条件复杂化不仅可能减慢输入生成速度，还可能导致生成的输入未能达到目标。</li><li>因此，有效地确定推断条件的有用性对于提高输入生成的质量至关重要。</li></ul></li></ul><h3 id="3-counterexample-guided-directed-fuzzing" tabindex="-1">3  Counterexample-guided Directed Fuzzing</h3><ul><li>接下来介绍Halo，一个定向fuzzer可以有效的通过使用条件估计限制输入来生成导向目标的输入</li><li>如图3示，我们的核心功能是基于fuzzers生成的输入的运行来推断出一系列可以代表环境路径的不变量（Section3.1）. 为了有效地推断不变量（Chanllenge 1），我们通过选择具有代表性的可以准确推断不变量的输入，减少了推断引擎的输入数量（Section3.2）.为了更好地生成满足不变量地输出（Challenge 2），我们根据来自模糊测试的自适应执行反馈来降低那些不能精确描述路径条件的不变式的优先级，这样做是为了增加生成可行输入的概率<br><img src="/images/%E8%AE%BA%E6%96%87/invariant/2_4.png" alt></li></ul><h4 id="3.1-intuition%3A-approximating-the-condition-with-dynamic-likely-invariant-inference" tabindex="-1">3.1 intuition: Approximating the Condition with Dynamic Likely-Invariant Inference</h4><ul><li>算法如下图示<ul><li>当fuzzer开始根据所选种子生成输入时，line 2</li><li>Halo通过基于一系列通过种子生成的输入估计导向目标的条件 line3-8</li></ul></li><li>直觉上，路径条件可以被视为一个满足多个输入的不变量，因此，我们的基本直觉是找到可以满足所有输入的不变量作为目标条件的估计。</li><li>根据这个直觉，我们提出了一种轻量级方法，灵感来自[25],不变量作为输入表示的目标路径条件的近似值，可以约束后续输入产生</li></ul><pre><code class="language-Java">Algorithm 1 Counterexample-guided Directed FuzzingRequire: Seeds S, Target t1: repeat2:      s, I_use ← ChooseNext(S) //I_use为使用的不变量3:      if I_use = ∅ or I_use is not effective then4:          Sreach, Sunreach ← InputSelect(s, t) (§3.2)5:          Ireach ← InvInfer(Sreach)6:          Iunreach ← InvInfer(Sunreach)7:          I_use ← InvSelect(Ireach, ¬Iunreach) (§3.3)8:      end if9:      Inputnew ← Sample(I_use)10:     Tracing(Inputnew)11:     Havoc&amp;Splice(s)12: until Timeout is reached</code></pre><h5 id="preliminary-of-invariant-inference" tabindex="-1">Preliminary of Invariant Inference</h5><ul><li>使用一系列输入 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span></eq>  ，推断引擎推断出一组不变量 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span></eq> ，对于 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>x</mi><mo>∈</mo><mi>S</mi><mo separator="true">,</mo><mi>x</mi><mi mathvariant="normal">∣</mi><mo>=</mo><mi>i</mi><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>i</mi><mo>∈</mo><mi>I</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall x \in S , x |= i,(i\in I)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord">∀</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mclose">)</span></span></span></span></eq> ，我们使用I来近似 达到目标所需的条件路径</li><li>现有的不变量推理方法[25,26,27]通过分治搜索来获得精确的肯呢个不变量，并保证算法的种植。具体来说，不变量推理从形式范围 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[min,max]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">min</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mclose">]</span></span></span></span></eq> 的过近似开始，对于一组不变量模板，<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mn>1</mn></msub><msub><mi>t</mi><mn>1</mn></msub><mo>+</mo><msub><mi>c</mi><mn>2</mn></msub><msub><mi>t</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msub><mi>c</mi><mi>n</mi></msub><msub><mi>t</mi><mi>n</mi></msub><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">c_1t_1+c_2t_2...+c_nt_n\geq 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.786em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></eq>,其中包含n的系数c，和关系t，由程序变量的多项式组成，用于近似路径条件</li><li>根据给定输入，推理引擎首先检查输入时候能够在执行时满足当前不变量，如果可以不发生任何变化。否则，算法会根据反例来缩小输入范围，同时，没有有效范围的模板不变量将被丢弃</li><li>因此，不变量推理的准确度取决于给定的输入和模板不变量。随着更多输入的提供，算法逐渐细化不变量得到更高的精度</li><li><strong>Example 3.1</strong><ul><li>假设推断引引擎从 $(-\infty,+\infty) $ 推断三个模板不变量 a,b,a+b,来估计图1中12行的状态</li><li>对于给定输入 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mn>5</mn><mo separator="true">,</mo><mi>b</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a=5,b=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></eq> , 推断引擎通过运行反馈发现其不能满足条，随后缩小不变量的范围 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mo stretchy="false">(</mo><mn>5</mn><mo separator="true">,</mo><mo>+</mo><mi mathvariant="normal">∞</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>b</mi><mo>∈</mo><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mo>+</mo><mi mathvariant="normal">∞</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo>∈</mo><mo stretchy="false">(</mo><mn>5</mn><mo separator="true">,</mo><mo>+</mo><mi mathvariant="normal">∞</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a\in(5,+\infty),b\in(0,+\infty),a+b\in(5,+\infty)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">+</span><span class="mord">∞</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">+</span><span class="mord">∞</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">+</span><span class="mord">∞</span><span class="mclose">)</span></span></span></span></eq> 来提高精确度</li></ul></li><li>本工作的目标不是改进不变量推理算法，而是明确地应用不变量推理改善定向模糊测试<ul><li>具体来首，我们使用SOTA不变量推理引擎Dig[26]. 采用的模板不变式包括常数检查、涉及单个变量的下界检查以及多个变量之间的线性不等式依赖关系(这些在现有不变量推理技术中广泛被作为默认设置[25,26,28,29])</li></ul></li><li>值得注意的，选择理想的不变量模板仍是动态不变量推理的一个挑战，这不是我们的值嗯点，我们将在第5节提供更多工作细节</li></ul><h5 id="input-collection" tabindex="-1">Input Collection</h5><ul><li>通过fuzzing生成的大量测试用例，Halo可以推断不变量来促进更好的输入生成。</li><li>具体的，Halo记录input和他们到达目标的值（算法1中line 4）</li><li>我们使用执行反馈将输入分为两组：可达和不可达的输入，以便推断不变量。Section3.2描述了分组的相关细节</li><li><strong>Example 3.2</strong><ul><li>考虑图一中的程序有五个输入没有触发崩溃<ul><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">)</mo><mo>:</mo><mo stretchy="false">(</mo><mn>15</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>10</mn><mo separator="true">,</mo><mn>10</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A(a,b,c,d):(15,5,10,10)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">15</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">10</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">10</span><span class="mclose">)</span></span></span></span></eq></li><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">)</mo><mo>:</mo><mo stretchy="false">(</mo><mn>6</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mn>10</mn><mo separator="true">,</mo><mn>10</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">B(a,b,c,d):(6,8,10,10)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">10</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">10</span><span class="mclose">)</span></span></span></span></eq></li><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">)</mo><mo>:</mo><mo stretchy="false">(</mo><mn>12</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>30</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C(a,b,c,d):(12,5,30,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">12</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">30</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span></eq></li><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">)</mo><mo>:</mo><mo stretchy="false">(</mo><mn>6</mn><mo separator="true">,</mo><mn>10</mn><mo separator="true">,</mo><mn>12</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">D(a,b,c,d):(6,10,12,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">10</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">12</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span></eq></li><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">)</mo><mo>:</mo><mo stretchy="false">(</mo><mn>6</mn><mo separator="true">,</mo><mn>100</mn><mo separator="true">,</mo><mn>12</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E(a,b,c,d):(6,100,12,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">100</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">12</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span></eq></li></ul></li><li>Halo记录输入字节影响变量abc的及他们的值<ul><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mrow><mi>r</mi><mi>e</mi><mi>a</mi><mi>c</mi><mi>h</mi></mrow></msub><mo>=</mo><mi>B</mi><mo>:</mo><mo stretchy="false">(</mo><mn>6</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mn>10</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>D</mi><mo>:</mo><mo stretchy="false">(</mo><mn>6</mn><mo separator="true">,</mo><mn>10</mn><mo separator="true">,</mo><mn>12</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>E</mi><mo>:</mo><mo stretchy="false">(</mo><mn>6</mn><mo separator="true">,</mo><mn>100</mn><mo separator="true">,</mo><mn>12</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S_{reach} = B:(6,8,10),D:(6,10,12),E:(6,100,12)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">re</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">10</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">10</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">12</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">100</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">12</span><span class="mclose">)</span></span></span></span></eq></li><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mrow><mi>u</mi><mi>n</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>c</mi><mi>h</mi></mrow></msub><mo>=</mo><mi>A</mi><mo>:</mo><mo stretchy="false">(</mo><mn>15</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>10</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>C</mi><mo>:</mo><mo stretchy="false">(</mo><mn>12</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>30</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S_{unreach} = A:(15,5,10),C:(12,5,30)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">re</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">15</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">10</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">12</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">30</span><span class="mclose">)</span></span></span></span></eq></li></ul></li></ul></li></ul><h5 id="invariant-inference" tabindex="-1">Invariant Inference</h5><ul><li><p>通过分组的不变量，我们推断不变量 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mrow><mi>r</mi><mi>e</mi><mi>a</mi><mi>c</mi><mi>h</mi></mrow></msub><mo separator="true">,</mo><msub><mi>I</mi><mrow><mi>u</mi><mi>n</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>c</mi><mi>h</mi></mrow></msub></mrow><annotation encoding="application/x-tex">I_{reach},I_{unreach}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">re</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">re</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 为每个组的输入 （算法1 Line5-6）</p></li><li><p><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mrow><mi>r</mi><mi>e</mi><mi>a</mi><mi>c</mi><mi>h</mi></mrow></msub><mo separator="true">,</mo><msub><mi>I</mi><mrow><mi>u</mi><mi>n</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>c</mi><mi>h</mi></mrow></msub></mrow><annotation encoding="application/x-tex">I_{reach},I_{unreach}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">re</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">re</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 分别表示达到目标的可能条件和没有触发目标的条件，因此，我们新生成的不变量需要满足 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mrow><mi>r</mi><mi>e</mi><mi>a</mi><mi>c</mi><mi>h</mi></mrow></msub></mrow><annotation encoding="application/x-tex">I_{reach}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">re</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 并且满足 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mrow><mi>u</mi><mi>n</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>c</mi><mi>h</mi></mrow></msub></mrow><annotation encoding="application/x-tex">I_{unreach}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">re</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 的反面</p></li><li><p><strong>Example 3.3</strong></p><ul><li><section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>I</mi><mrow><mi>r</mi><mi>e</mi><mi>a</mi><mi>c</mi><mi>h</mi></mrow></msub><mo>=</mo><mi>a</mi><mo>&lt;</mo><mn>7</mn><mo separator="true">,</mo><mi>b</mi><mo>&gt;</mo><mn>7</mn><mo separator="true">,</mo><mi>c</mi><mo>≤</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">I_{reach} = a&lt;7,b&gt;7,c\leq 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">re</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10</span></span></span></span></span></eqn></section></li><li><section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>I</mi><mrow><mi>u</mi><mi>n</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>c</mi><mi>h</mi></mrow></msub><mo>=</mo><mi>a</mi><mo>&gt;</mo><mn>12</mn><mo separator="true">,</mo><mi>b</mi><mo>&lt;</mo><mn>6</mn><mo separator="true">,</mo><mi>c</mi><mo>≥</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">I_{unreach}=a&gt;12,b&lt;6,c\geq 20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">re</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">12</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">20</span></span></span></span></span></eqn></section></li><li>此时我们可以确定输入满足 <section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>a</mi><mo>&lt;</mo><mn>7</mn><mo separator="true">,</mo><mi>a</mi><mo>≤</mo><mn>12</mn><mo separator="true">,</mo><mi>b</mi><mo>&gt;</mo><mn>7</mn><mo separator="true">,</mo><mi>b</mi><mo>≥</mo><mn>7</mn><mo separator="true">,</mo><mi>c</mi><mo>≤</mo><mn>10</mn><mo separator="true">,</mo><mi>c</mi><mo>≤</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">a &lt; 7, a ≤ 12, b &gt; 7, b ≥ 7, c ≤ 10, c ≤ 20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">12</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">10</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">20</span></span></span></span></span></eqn></section></li></ul></li></ul><h5 id="remark-1-%E8%AE%A8%E8%AE%BA1" tabindex="-1">Remark 1 讨论1</h5><ul><li>与传统的通过符号执行推断精确的推断路径条件相比，推断不变量是一种轻量级的估计，尽管比实际路径条件要不准确一些</li><li>然而，通过可达不变量和不可达不变量，也足够用来高效的筛选不可达输入生成</li><li>仅利用执行反馈和输入，在处理复杂程序行为时（如循环）具有更好的延展性。</li><li>此外，与现有动态不变量推理方法不同，后者由于记录执行过程中的中间值而引入了显著的运行时开销，导致了可扩展性问题[26],我们只推断输入之间的关系以解决indirect input generation问题，从而减少了开销</li><li>尽管筛选推断出不变量过滤unreach输入是有效的，但在处理大的输入搜索空间且伴随 （1）爆炸性输入 （2）复杂关系时，使用不变量推理进行模糊测试仍十分困难</li><li>因此，我们的目标是最小化这两个因素在不变量推理中引起的维度爆炸，以提高模糊测试的可扩展性</li></ul><h4 id="3.2-efficient-invariant-inference-with-distance-based-input-selection" tabindex="-1">3.2 Efficient Invariant Inference with Distance-based Input Selection</h4><ul><li>尽管提升输入的数量可以提高不变量推理的准确性，但是这会导致不变量推理引擎的运行时间增加，同时会导致缺陷提升，因为生成的输入可能不会满足目标条件</li><li>为了高效的推断准确的不变量，我们的目标时使用最小化的代表性输入来准确的描绘目标条件。具体的，我们观察到每个输入对准确推断不变量的贡献不同，这将激励我们最小化不变量推断需要的输入集合</li><li><strong>Example 3.4</strong><ul><li>考虑 Example3.2中的输入，我们注意到输入 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span></eq> 没有改变推断结果因为其被 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span></eq> 包括了。因此我们不需要在推断中使用 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span></eq> ，这样可以减少不变量推理的开销</li></ul></li><li>然而，量化不变量推理中输入的有效性是一项具有挑战性的任务。为了解决这个问题，我们可以将输入分布视为数据聚类问题，只有接近条件边界的输入才能有助于推断不变量。原理边界的输入无法有效地描述目标条件。<ul><li>例如，图4中红线所示额的范围之外的输入比红线内的输入更不可能产生精确的不变量。因此，我们可以根据输入距离条件边界的距离来选择输入<br><img src="/images/%E8%AE%BA%E6%96%87/invariant/2_5.png" alt></li></ul></li></ul><h5 id="how-to-select-inputs" tabindex="-1">How to Select Inputs</h5><ul><li><p>基于前面的灵感，我们设计了一种基于距离的输入选择策略来选择可以有效推断不变量的输入</p></li><li><p>距离维度描述了每个输入距离边界条件的接近程度</p></li><li><p>如图2示，路径条件可以视为一个函数 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></eq>, <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></eq> 为相关输入向量。 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f(x)=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></eq> 表示边界条件, <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|f(x)|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mord">∣</span></span></span></span></eq> 为到边界的距离，因此，我们可以通过计算 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|f(x)|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mord">∣</span></span></span></span></eq> 来选择输入</p></li><li><p>具体来说，在第一次突变种子之前，我们使用基于推理的污点分析 (inference-based taint analysis)[30-34]的过程，通过逐个字节地变异来获取影响到目标的输入。</p></li><li><p>We leave potential customization and fine-tuning of taint analysis as future work.</p></li><li><p>在分析过程中，我们还记录了这些相关字节和 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|f(x)|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mord">∣</span></span></span></span></eq></p></li><li><p>为了方便计算，我们使用未出现在循环中的分支条件的值作为 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></eq> 。因此，Halo可以保留一组接近目标且 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></eq> 较小的输入集</p></li><li><p><strong>Example 3.5</strong></p><ul><li><p>假设在图1的程序中，我们有三个输入 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">)</mo><mo>:</mo><mo stretchy="false">(</mo><mn>6</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mn>10</mn><mo separator="true">,</mo><mn>10</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">B(a,b,c,d):(6,8,10,10)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">10</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">10</span><span class="mclose">)</span></span></span></span></eq>, <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">)</mo><mo>:</mo><mo stretchy="false">(</mo><mn>6</mn><mo separator="true">,</mo><mn>10</mn><mo separator="true">,</mo><mn>12</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">B(a,b,c,d):(6,10,12,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">10</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">12</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span></eq>, <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">)</mo><mo>:</mo><mo stretchy="false">(</mo><mn>6</mn><mo separator="true">,</mo><mn>100</mn><mo separator="true">,</mo><mn>12</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C(a,b,c,d):(6,100,12,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">100</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">12</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span></eq>，我们可以结算 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></eq> 为，每个输入在 line 11-13 行条件判断的距离</p><ul><li><section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>f</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mo>=</mo><mn>20</mn><mo>−</mo><mn>12</mn><mo>+</mo><mn>14</mn><mo>−</mo><mn>10</mn><mo>+</mo><mn>20</mn><mo>−</mo><mn>10</mn><mo>=</mo><mn>22</mn></mrow><annotation encoding="application/x-tex">|f (B)| = 20 − 12 + 14 − 10 + 20 − 10 = 22</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">20</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">12</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">14</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">10</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">20</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">22</span></span></span></span></span></eqn></section></li><li><section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>f</mi><mo stretchy="false">(</mo><mi>D</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mo>=</mo><mn>20</mn><mo>−</mo><mn>12</mn><mo>+</mo><mn>16</mn><mo>−</mo><mn>10</mn><mo>+</mo><mn>20</mn><mo>−</mo><mn>12</mn><mo>=</mo><mn>22</mn></mrow><annotation encoding="application/x-tex">|f (D)| = 20 − 12 + 16 − 10 + 20 − 12 = 22</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mclose">)</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">20</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">12</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">16</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">10</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">20</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">12</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">22</span></span></span></span></span></eqn></section></li><li><section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>f</mi><mo stretchy="false">(</mo><mi>E</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mo>=</mo><mn>20</mn><mo>−</mo><mn>12</mn><mo>+</mo><mn>106</mn><mo>−</mo><mn>10</mn><mo>+</mo><mn>20</mn><mo>−</mo><mn>12</mn><mo>=</mo><mn>112</mn></mrow><annotation encoding="application/x-tex">|f (E)| = 20 − 12 + 106 − 10 + 20 − 12 = 112</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">20</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">12</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">106</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">10</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">20</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">12</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">112</span></span></span></span></span></eqn></section></li></ul></li><li>因为 E 的距离里边界最元，我们只选择B和D作为代表性的输入在不变量推断中</li></ul></li><li>然而，对于没有达到目标的输入，我们无法获得距离，因为 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></eq> 无法执行<ul><li>因此，Hao根据是否达到目标来分离用于不变量推理的输入</li><li>在达到目标之前，Halo仅利用不可达的输入来推断所有输入字节的可能不变量，这表明可达输入不应该满足的条件</li><li>通过否定从不可达输入推断出的不变量，fuzzer仍然可以限制生成输入的搜索空间</li></ul></li><li><strong>Example 3.6</strong><ul><li>假设我们有不变量 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mrow><mi>u</mi><mi>n</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>c</mi><mi>h</mi></mrow></msub><mo>:</mo><mo stretchy="false">{</mo><mi>a</mi><mo>&gt;</mo><mn>12</mn><mo separator="true">,</mo><mi>b</mi><mo>&lt;</mo><mn>6</mn><mo separator="true">,</mo><mi>c</mi><mo>≤</mo><mn>20</mn><mo separator="true">,</mo><mi>d</mi><mo>&lt;</mo><mn>10</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">I_{unreach}:\{a&gt;12,b&lt;6,c\leq20,d&lt;10\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">re</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">12</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">20</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">10</span><span class="mclose">}</span></span></span></span></eq>,从Example3.2中不可达的输入中推断出</li><li>尽管我们可能无法在 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mrow><mn>10</mn><mo separator="true">,</mo><mn>11</mn><mo separator="true">,</mo><mn>12</mn></mrow></mrow><annotation encoding="application/x-tex">a∈{10,11,12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord">10</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">11</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">12</span></span></span></span></span></eq> 时使用否定不变量过滤可达输入，因为 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≤</mo><mn>12</mn></mrow><annotation encoding="application/x-tex">a≤12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">12</span></span></span></span></eq> 从 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span></eq> 中的 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>&gt;</mo><mn>12</mn></mrow><annotation encoding="application/x-tex">a&gt;12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">12</span></span></span></span></eq> 不可达，而 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>&lt;</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">a&lt;7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">7</span></span></span></span></eq> 在 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span></eq> 中可达，但模糊器仍然可以有效地过滤来自 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>&gt;</mo><mn>12</mn></mrow><annotation encoding="application/x-tex">a&gt;12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">12</span></span></span></span></eq> 和 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>&gt;</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">c&gt;20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">20</span></span></span></span></eq> 的输入。</li></ul></li></ul><h5 id="how-many-inputs-selected" tabindex="-1">How many Inputs Selected</h5><ul><li>我们基于计算需要的最小采样的统计理论决定选择多少输入来推断不变量[35]</li><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mfrac><mrow><mn>4</mn><msup><mi>Z</mi><mn>2</mn></msup></mrow><msup><mi>ε</mi><mn>2</mn></msup></mfrac><mo>=</mo><mn>385</mn></mrow><annotation encoding="application/x-tex">n = \frac{4Z^2}{ε^2}=385</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3629em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0179em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ε</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">385</span></span></span></span></eq>, 其中 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span></span></span></span></eq> 是 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Z</mi><mo>−</mo><mi>s</mi><mi>c</mi><mi>o</mi><mi>r</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Z-score</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">score</span></span></span></span></eq> 决定错误 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ε</mi><mo>=</mo><mn>0.05</mn></mrow><annotation encoding="application/x-tex">ε=0.05</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ε</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.05</span></span></span></span></eq> 的概率，即 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>95</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">95\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">95%</span></span></span></span></eq> 的置信度</li></ul><h5 id="remark-2" tabindex="-1">Remark 2</h5><ul><li>不像现有定向模糊方法只通过种子存储临时变量，Halo通过从运行输入保留更多运行反馈来限制进一步的输入的搜索空间。</li><li>基于这一直觉，输入选择旨在在数据收集的额外时间成本和推断不变量的准确度之间取得平衡。</li><li>此外，利用从可达和不可达输入推断出不变量不仅提高了方法的可扩展性，而且从两个方向压缩近似搜索空间，有助于提高精确度</li></ul><h4 id="3.3.-effective-input-generation-with-similarity-based-invariant-selection" tabindex="-1">3.3. Effective Input Generation with Similarity-based Invariant Selection</h4><ul><li><p>虽然可能的不变量可以帮助约束后续输入生成的搜索空间，但推理引擎可能会提供多个具有不同精度的潜在不变量，这可能不能平等地过滤掉不可达的输入。</p></li><li><p>根据给定的输入，不变量可能会被过度约束。例如，仅从早期不可达输入推断出的不变量。</p></li><li><p>因此，使用所有不变量进行输入生成可能会引入显着的开销，而没有提供足够的精度。</p></li><li><p><strong>Example 3.7</strong></p><ul><li>Example 3.3中推断的不变量</li><li>与不变量 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>&lt;</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">c &lt; 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10</span></span></span></span></eq> 相比，<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>≤</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">c ≤ 20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">20</span></span></span></span></eq> 可以更精确地描述在第13行的路径条件 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>&lt;</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">c &lt; 20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">20</span></span></span></span></eq></li><li>不变量 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>&lt;</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">a &lt; 7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">7</span></span></span></span></eq> 过度约束，因为可达的 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mrow><mn>7</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mn>9</mn></mrow></mrow><annotation encoding="application/x-tex">a  ∈ {7, 8, 9}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">9</span></span></span></span></span></eq> 被过滤掉了。</li></ul></li><li><p>为了有效地生成受不变量约束的输入，我们的基本直觉是根据新的输入生成 adaptively 地选择和细化不变量。</p></li><li><p>如图5所示，理想情况下，由最精确的不变量生成的输入应始终满足路径条件。精度损失由在近似分布中找到的反例表示。更精确的不变量应生成更少的反例。<br><img src="/images/%E8%AE%BA%E6%96%87/invariant/2_6.png" alt></p></li><li><p>因此，我们利用生成的输入的执行反馈来估计哪个不变量更类似于原始路径条件。</p></li><li><p>相似性可以视为使用推断的不变量生成更多可达输入的概率。Halo根据在后续输入生成中发现的反例比率对推断的不变量进行优先选择。</p></li><li><p>因此，由选定不变量描述的相似搜索空间可以提高生成可达输入的效果。</p></li></ul><h5 id="how-to-select-invariants" tabindex="-1">How to Select Invariants</h5><ul><li><p>我们设计了一种基于相似度的不变量选择方法来自适应地选择生成可达输入最有效的不变量</p></li><li><p>每个不变量的相似度被用于fuzzer选择该不变量的概率，相似度越高越容易被选中。</p></li><li><p>我们用不变量生成可达输入的占比 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Φ</span></span></span></span></eq> 来衡量相似度 <section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>S</mi><mi>i</mi><mi>m</mi><mi>i</mi><mi>l</mi><mi>a</mi><mi>r</mi><mi>i</mi><mi>t</mi><mi>y</mi><mo stretchy="false">(</mo><mi mathvariant="normal">Φ</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mi>n</mi><mi>N</mi></mfrac></mrow><annotation encoding="application/x-tex">Similarity(\Phi)=\frac{n}{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">imi</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord">Φ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.7936em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1076em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></eqn></section> 其中 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></eq>和<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></eq>是生成的可达输入和总输入的数量</p></li><li><p><strong>Example 3.8</strong></p><ul><li>假设我们使用从 Example 3.3中获得的不变量生成输入。Halo可以迅速找到条件 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>≥</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">b\geq 7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">7</span></span></span></span></eq>,单这是对 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span></eq>的过度限制，因为根据图1Line12，其值与 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span></eq> 的值也有关系。</li><li>因此，Halo通过反例降低了该不变量的优先级，来避免生成不可达输入的反例</li></ul></li></ul><h5 id="input-generation-with-adaptive-invariants" tabindex="-1">Input Generation with Adaptive Invariants</h5><ul><li>直观地说，由于我们推断的不变量是线性的，它们可以形成一个多面体，描述了可达输入的搜索空间。</li><li>因此，我们使用了SOTA采样技术，Vaidya walk[36]，它可以在线性复杂度的基础上从在大量不变量组成的多面体中高效地采样生成输入。</li><li>此外，不变量的相似度基于后续的fuzzer输入生成不断地在更新.如果所有推断出的不变量都无法有效地生成优先级较高的可达输入，Halo会收集发现的反例，并推断出一组更具精度的新不变量，以保持输入生成的有效性。</li></ul><h5 id="renmark-3" tabindex="-1">Renmark 3</h5><ul><li>我们从搜索空间的角度来解决有向模糊测试中的输入生成问题，这使我们能够在不解决精确路径条件的情况下有效地对可达输入进行抽样。</li><li>同时，这种想法激励我们通过利用执行的输入作为回归来完善不精确的搜索空间</li><li>于不变量是实际路径条件的近似，精度的潜在损失可能会不准确地扩大或缩小近似的搜索空间，从而阻碍其在生成可达输入方面的有效性。</li><li>此外，与使用现有的不变量推断中的动态程序分析可能导致的潜在运行时开销相比[26]，[28]，[37]，[38]，我们利用模糊测试中可用的大量输入，这些输入近似于搜索空间的分布，作为选择精确不变量的轻量级预测器。因此，在模糊测试过程中，我们可以减少选择的不精确或多余的不变量的数量，从而更有效地生成可达输入</li></ul><h3 id="4-%E8%AF%84%E4%BC%B0" tabindex="-1">4 评估</h3><h3 id="5-discussion" tabindex="-1">5 Discussion</h3><h4 id="5.1-potentials" tabindex="-1">5.1 Potentials</h4><ul><li><strong>Assisting Dynamic Analysis with Fuzzing</strong><ul><li>动态分析已得广泛应用<ul><li>污点分析[43,44]</li><li>程序合成[45,46]</li><li>特征生成[47,48]</li></ul></li><li>与传统的静态分析相比，动态分析可以通过执行反馈提供更精确的结果。</li><li>然而，对于动态分析，在没有足够数量的输入的情况下彻底分析程序具有挑战性[49]</li><li>Halo使用最先进的fuzzer生成足够的输入，以便动态分析来近似程序语义。此外，我们的输入选择策略可以有效地控制输入数量，实现更好的扩展性。</li><li>除了Halo中通过可能的不变量近似的路径条件来处理内存安全问题外，还可以考虑复杂语义，如状态机模型和部分顺序约束，以支持检测涉及逻辑正确性的漏洞。</li></ul></li><li><strong>Semantic Extraction from Inputs</strong><ul><li>虽然模糊测试的主要趋势之一是以不同的粒度提取目标程序的语义，例如使用符号执行来解决路径条件，但Halo中由执行输入推断的不变量指示了模糊测试的另一个潜在方向：利用观察到的不可达执行来防止模糊测试器不断探索无关的程序行为。</li><li>在Halo中，我们还根据不可达输入推断不变量，以约束后续输入生成的搜索空间，从而有效地接近目标漏洞。由于模糊测试器可以生成大量的输入来检查程序，因此除了覆盖范围之外，还可以从执行的输入中提取更多的语义，以引导模糊测试器探索程序。</li></ul></li></ul><h4 id="5.2-limitations" tabindex="-1">5.2 Limitations</h4><ul><li><strong>Scalability of the Invariant Inference</strong><ul><li>虽然动态的可能不变量推断优于符号执行，但其有效性仍可能受到可扩展性问题的影响，例如由于给定输入的过大或候选不变量过多</li><li>为了环节这些问题，Halo选择适当的输入样本进行推断，并声称精确的不变量以生成输入，然而我们尚未优化候选不变量的质量，以提高近似目标条件的精度。因此，Halo的性能在尚未评估的其它项目可能受影响。然而该问题与定向fuzzing无关，参见6.2相关工作</li></ul></li><li><strong>Solving Complex Path Conditions</strong><ul><li>Halo的强大之处在于可以用可达和不可达输入中的不变量来约束搜索空间</li><li>尽管我们在表4中展示了从不可达输入中推断处不变量的有效性，但与使用两类输入的不变量相比，其有效性较低。例如，达到目标的改进比例小于触发时间的改进比例</li><li>为此，可以将Halo与其它输入生成技术结合，例如混合模糊测试与符号执行，以更快地达到目标并收集两个类别的输入。同时，基于AFL++的Halo实现也使得与基于AFL的模糊测试框架集成成为可能。</li></ul></li><li><strong>Support to Rich Semantics</strong><ul><li>除了复杂的路径条件之外，漏洞可能涉及各种丰富的语义。例如，网络服务器中的逻辑错误可能需要程序执行满足特定协议的函数。<br>然而，由于本文的主要重点是路径条件，Halo可能无法有效地复现这种类型的目标漏洞。尽管如此，我们仍然希望将这些问题总结为Halo解决的不同问题，并在今后的工作中讨论，如第5.1节所述。</li></ul></li></ul><h3 id="6-related-work" tabindex="-1">6 Related Work</h3><h4 id="6.1-sophisticated-input-generation" tabindex="-1">6.1 Sophisticated Input Generation</h4><ul><li><strong>Mutaing Relevant Bytes</strong><ul><li>优化突变的一个主要趋势是突变相关的输入偏移以满足未覆盖的分支条件。<ul><li>除随机突变外，Fairfuzz [50]确定了不需要更改值的输入偏移，因此，最小化输入搜索空间提高了突变的效率。</li><li>ngora [51]采用字节级污点跟踪来发现目标条件的相关输入字节，然后应用基于梯度下降的搜索策略。</li><li>Redqueen [32]提出使用中间值作为反馈来修改输入中的值。</li><li>PATA [30]通过区分不同的路径和上下文来提高污点分析的精度。</li><li>Parmesan [23]利用从 santizers [39] 获取的标签来最小化需要被污点分析分析的分支数量。</li></ul></li><li>然而，这些方法都需要特定的分支来找到相关的字节。与基于覆盖引导的模糊测试不同，有向模糊测试无法选择分支，因为确定哪个分支可以更快地达到目标是具有挑战性的。有些分支甚至可能不满足目标的路径条件。因此，明确地为有向模糊测试调整这些方法是具有挑战性的，这也是为什么 Halo 只利用不变量推理来处理输入字节，而不是分析整个程序的原因。</li></ul></li><li><strong>Leveraging the Constraint Solver</strong></li></ul><h4 id="6.2-efficient-invariant-inference" tabindex="-1">6.2 Efficient Invariant Inference</h4><ul><li>不变量推理已经成为程序验证[57,58,59,60],软件测试[38,61,62,63]和属性检查[25,26,28,29,37,64,65,66] 中一种具有潜力的技术。其对于确保软件系统的正确性十分有效，因为不变量可以作为程序与其行为的形式规范。</li><li>不变量推理的主要目标是高效地推断适用于所有程序行为的精确不变量。<ul><li>传统的基于验证的方法旨在准确检测不变量。现有工作的大多数努力[29,57,58,59,60,63]，使用抽象解释和符号执行来静态地逼近程序行为的固定点作为属性。古纳在他们在理论上很准确，但由于符号执行分析故有的扩展性问题，他们的效率受到限制。因此，他们的方法通常设计于具有假设的特定应用场景</li><li>动态不变量推理技术不追求对整个程序的精确假设，并根据给定的输入推断不变量。<ul><li>从Daion[25,64]开始，现有文献监视执行跟踪以验证一组候选不变量并具体化系数和项</li><li>DIDUCE[66]放宽了不变量的假设，因为违规可能导致异常程序行为，并优先处理具有置信度的违规行为以进行故障定位。</li><li>由于推断得到的不变量的质量高度依赖于给定的输入和模板不变量，现有工作利用从执行中提取的更多程序语义来提高不变量的准确性。例如，<ul><li>DySy [37] 利用共轭执行来推理潜在的模板不变量。</li><li>iDiscovery [28] 利用中间符号状态进行增量不变量推理以提高不变量的准确性。</li><li>MRI [38] 提出将推理过程建模为搜索问题，并使用基于挖掘的方法获得精确的不变量。</li><li>Dig [26] 依赖于来自反例的执行反馈来剪枝不变量的不可行范围，并逐渐提高精度。</li></ul></li></ul></li></ul></li><li>Halo使用的不变量推理引擎使用了上述见解，以实现更好的效率。到目前未知，现有工作没有专注于优化给定输入的质量[28]，而这是影响不变量推理效果的关键因素之一。相反，Halo利用模糊测试工具作为输入生成器，以提高不变量的精度，从而最终增强fuzzer本身的输入生成能力</li></ul><h3 id="7-conclusion" tabindex="-1">7 Conclusion</h3><ul><li>我们提出了Halo，通过生成的输入推断出的动态不变量引导的自我优化定向模糊测试，以显著提高生成可触发目标漏洞的可达输入的效果。</li><li>动态不变量有助于限制Halo后续输入的生成的搜索空间，实证结果展示了我们设计的方法带来了显著的改进<ul><li>Halo 在重现目标漏洞方面的速度提升了 15.3 倍<br>生成的可达输入增加了 6.2 倍。<br>此外，Halo 还发现了十个先前未发现的漏洞，涉及到七个以前漏洞的不完整修复，以及 Magma 基准测试中评估项目的最新修补版本的 CVE。</li></ul></li></ul><h3 id="8-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93" tabindex="-1">8 个人总结</h3><ul><li>提出一种SOTA定向方法，方法重点是通过 动态不变量方法 从 已有fuzzing生成的输入中推断出不变量，随后使用这些不变量来约束后续输入生成的搜索空间，从而提高生成可达输入的效果</li><li>本文体现了不变量作为约束条件的使用，对于测试用例生成技术，不变量可以约束生成的空间</li></ul><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;counterexample-guided-directed-fuzzing-via-likely-invariant-inference&quot; tabindex=&quot;-1&quot;&gt;Counterexample-Guided Directed Fuzzing via Like</summary>
      
    
    
    
    <category term="论文" scheme="http://example.com/categories/%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="Invariant" scheme="http://example.com/tags/Invariant/"/>
    
    <category term="Fuzzing" scheme="http://example.com/tags/Fuzzing/"/>
    
  </entry>
  
  <entry>
    <title>不变量作为fuzzers的反馈</title>
    <link href="http://example.com/2024/04/26/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/invariant/%E4%B8%8D%E5%8F%98%E9%87%8F%E4%BD%9C%E4%B8%BAFuzzers%E7%9A%84%E5%8F%8D%E9%A6%88/"/>
    <id>http://example.com/2024/04/26/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/invariant/%E4%B8%8D%E5%8F%98%E9%87%8F%E4%BD%9C%E4%B8%BAFuzzers%E7%9A%84%E5%8F%8D%E9%A6%88/</id>
    <published>2024-04-26T05:17:23.240Z</published>
    <updated>2024-05-11T08:44:49.074Z</updated>
    
    <content type="html"><![CDATA[<h2 id="the-use-of-likely-invariants-as-feedback-for-fuzzers" tabindex="-1">The use of likely invariants as feedback for fuzzers</h2><ul><li>引用：Fioraldi A, D’Elia D C, Balzarotti D. The use of likely invariants as feedback for fuzzers[C], 30th USENIX Security Symposium (USENIX Security 21). 2021: 2829-2846.</li><li>CCF A USENIX Security</li><li><a href="https://www.usenix.org/system/files/sec21-fioraldi.pdf">链接</a></li><li><a href="https://github.com/eurecom-s3/invscov">代码</a></li></ul><h1 id tabindex="-1"><img src="/images/%E8%AE%BA%E6%96%87/invariant/3_3.png" alt></h1><h3 id="0-%E6%91%98%E8%A6%81" tabindex="-1">0 摘要</h3><h4 id="%E5%8A%A8%E6%9C%BA" tabindex="-1">动机</h4><ul><li>模糊测试已经被证明是发现程序漏洞的有效技术，但仍存在一些开放的挑战。<ul><li>其中一个主要挑战是，广受欢迎的基于覆盖率引导的模糊测试会尽可能的将测试用例覆盖程序的不同部分，但仅仅考虑覆盖率可能并不能充分触发程序的漏洞。</li></ul></li><li>在现实中，许多缺陷触发需要具体的程序状态，这不仅需要控制流的参与，还需要考虑一些程序变量的值。<ul><li>然而不幸地，由于状态爆炸的原因，之前提出的探索程序状态的策略在现实中作用很小。</li></ul></li></ul><h4 id="%E8%A7%A3%E5%86%B3" tabindex="-1">解决</h4><ul><li>在本文中，我们提出了一种新的反馈机制，通过考虑常量和程序变量间的关系来增强代码覆盖率。<ul><li>基于这一目的，我们在基本块等级上对变量学习可能的不变量，然后相应的对程序状态进行切分。</li><li>我们的反馈可以辨别一个输入是否违反了一个或多个不变量并对此进行奖励，因此缩小了代码覆盖提供的对程序状态的估计。</li></ul></li><li>我们在INVSCOV原型上实现了这一机制，该原型基于LLVM和AFL++开发。<ul><li>我们的实验展示了我们的方法与完全使用代码覆盖作为反馈的fuzzer相比，可以找到更多不同的缺陷。</li><li>除此之外，我们的试验发现了每天在OSS-fuzzer测试的一个库上的两个漏洞，这两个漏洞在库的最新版本中仍然存在。</li></ul></li></ul><h3 id="1-%E4%BB%8B%E7%BB%8D" tabindex="-1">1 介绍</h3><h4 id="%E8%83%8C%E6%99%AFb" tabindex="-1">背景b</h4><ul><li>fuzzing 成为发现软件漏洞的主要技术，其最初目的是随机生成非法或异常输入，以检测程序中的bug，如今的fuzzing经常依赖于一些启发式的方法来引导输入生成。<ul><li>距今，Coverage-Guided Fuzzing（CGF）是最流行的fuzzing技术之一，其选择可以提升程序代码覆盖率的输入，一般为CFG的唯一路径的数量</li><li>随后，许多方法专注于克服CGF的限制，如<ul><li>使用一些技术来解决复杂路径限制[82,66,7,69,5]</li><li>去除突变测试中非法的测试用例[65,59,3,6,28]</li><li>或者搜寻程序中更有前景的部分[58,57,9]</li></ul></li><li>尽管这些方法减少了到达目标程序不同部分的时间，但需要理解的是，仅仅代码覆盖是发现bug的必要不充分条件。实际上，bug触发时，（1）程序运行到一个给定指令（2）程序状态满足特定状态。</li><li>一方面，因为使用代码覆盖率来奖励探索结果导致模糊测试器没有任何动机去探索更多已经观察到的控制流事实（例如，分支及其频率）的状态。因此，现有工具检测涉及对程序状态复杂约束的bug变得更加困难。</li><li>另一方面，简单地奖励模糊测试器探索新状态（状态覆盖率）也是一个不佳的策略，这通常会降低bug检测率。这是因为对于复杂的应用程序来说，程序状态爆炸</li><li>因此，需要特殊的技术来控制测试时程序的转该，同时保持fuzzer触发bug的能力，如今有一些工作想达到这种平衡。<ul><li>一些fuzzer通过更敏感的反馈来近似程序状态，如使用调用堆栈信息或内存中加载和存储的值来丰富代码覆盖率。</li><li>另一些，如[79]，除考虑控制流外，还有程序状态中的值，更好地近似了程序状态覆盖率，但在发现bug方面效率较低，因为其引发了状态爆炸</li></ul></li><li>为了在避免状态爆炸的同时捕获更丰富状态信息，研究人员还研究了人工辅助的解决方案。<ul><li>如FUZZ FACTORY [60]允许开发人员定义他们的领域特定目标，然后添加waypoints，当生成的测试用例朝这些目标取得进展时（例如，当两个比较操作数之间有更多的位相同），奖励模糊测试器。</li></ul></li><li>在撰写本文时，目前最成功的程序状态覆盖的估计由一个仅由人类专家选择的程序点组成[4]。在这项工作中，状态空间部分手动标注，并且修改了反馈函数以更彻底地探索这样的空间。我们相信，这一过程的自动化是该领域的关键课题。</li></ul></li></ul><h4 id="%E6%96%B9%E6%B3%95%E7%AE%80%E4%BB%8B" tabindex="-1">方法简介</h4><ul><li>本文中，我们提出了一个用于fuzzing的新反馈机制，在完全自动化的情况下，除了考虑代码覆盖率，还考虑了程序的一些有趣的部分，而且不会引发状态爆炸。<ul><li>关键思想是，将边覆盖率–fuzzer使用最广泛和成功的代码覆盖率指标–与“usual”变量值的本地信息差相结合。</li><li>为此，我们通过执行输入语料库并学习所有观察到的执行的变量值和关系的约束来挖掘程序的可能的不变量。一个很重要的点是，基于执行的不变量挖掘产生的约束不一定模拟程序的属性，而是分析输入语料库的本地特征[25],因此，不同的输入可能违反约束</li><li>我们的直觉是，这些本地特征代表了程序状态的一个有趣抽象。因此，我们定义了一种新的反馈函数，当传入的基本块看到一个或多个违反可能不变量的变量值时，会对边进行不同处理。这种方法提升了CFG系统的灵活性，奖励探索代码覆盖率本身无法区分的程序状态。</li></ul></li><li>我们开发了一组启发式方法来生成和细化不变量，并采用了有效的技术使得以很低的性能开销在程序中插装–这是一个很重要的指标。我们将它们实现为一个原型INVSCOV，基于LLVM[43],AFL++[30]</li><li>我们的实验设计了一组经常由其它fuzzer测试的程序，结果表明，我们的反馈机制可以简洁地考虑程序状态信息，除控制流外，还能发现比经典CFG方法更多，不同的漏洞</li></ul><h4 id="%E8%B4%A1%E7%8C%AE" tabindex="-1">贡献</h4><ul><li>我们提出了一种新的反馈机制，用于fuzzing，它结合了代码覆盖率和程序状态的本地信息，而不会引发状态爆炸</li><li>一个我们方法的原型实现，叫INVSCOV，基于LLVM和AFL++</li><li>一个实验评估，展示了我们的方法与经典的上下文敏感的边覆盖比较</li></ul><h3 id="2-%E8%83%8C%E6%99%AF" tabindex="-1">2 背景</h3><h4 id="2.1-%E7%A8%8B%E5%BA%8F%E5%B1%9E%E6%80%A7%E5%92%8C%E4%B8%8D%E5%8F%98%E9%87%8F" tabindex="-1">2.1 程序属性和不变量</h4><ul><li>基于属性的测试是一种软件测试方法，其中程序属性某种形式规范驱动了测试过程，此类规范同时定义了哪些行为是有效的，并作为生成测试用例的基础。</li><li>正确性oracle可以嵌入到程序本身，以一组断言的形式出现来检查每个不变量的合法性[26].然后可以通过违反不变量断言来生成测试用例</li><li>由于将程序属性的识别委托给开发人员也是一个艰巨的任务，因此自动化一直是该领域探索的方向。在其它领域如内存错误检测[37]，自动化不变量学习也是广泛探索的话题</li><li>可以通过静态代码分析来发现不变量<ul><li>RCORE[32]基于抽象解释[14]构建，并在运行时监控不变量，以检测来自内存错误的程序状态穗槐。通常，这样的不变量是可靠的，并且产生的误报有限</li><li>然而静态不变量分析固有的过度近似可能会产生过于粗糙的不变量，无法有效区分程序状态以进行高级分析</li></ul></li><li>因此，一种更精确的发现不变量的方式，同时通过运行时检查程序状态，以更大数量的产生。因此，[35,24,61]中的方法是基于在执行期间动态收集的信息构建不变量的。</li><li>动态方法的缺点是，其产生的不变量是可能的不变量，即，对于分析的程序轨迹是成立的，单不适用于所有输入。因此，当学习到的不变量只捕捉到观察到的执行的局部属性时，可能产生误报</li><li><strong>本文思想</strong><ul><li>在本工作中，我们将动态不变量的局部属性的问题转化为驱动fuzzer的优势。我们通过从测试用例语料库出发，像实际程序一样，该语料库无法满足所有的程序状态，然后我们修改fuzzer，使其对偏离初始语料库得到的不变量的行为更加敏感。此时，学习到的不变量捕捉到的时观察到的执行的属性，而不是程序本身的属性，这时我们用来生成更多样化的输入值集合的关键直觉</li></ul></li></ul><h4 id="2.2-fuzz-testing" tabindex="-1">2.2 Fuzz Testing</h4><ul><li>思想：使用随机生成的测试用例反复测试程序，通常为非法或异常输入，以检测程序中的错误[62,50]</li><li>最朴素的fuzzing：不了解程序任何特征（例如，输入格式或程序执行情况），只提供随机输入。这对传统软件很有效[54]</li><li>近来有许多技术来提升朴素fuzzing的效率[50,62]，我们可以根据以下原则对这些技术进行分组<ul><li><ol><li>需要了解程序信息的程度</li></ol></li><li><ol start="2"><li>生成测试用例的技术</li></ol></li><li><ol start="3"><li>搜索时用的反馈</li></ol></li></ul></li><li>根据第一个原则，我们可以将fuzzers分为三类<ul><li><ol><li>White-box fuzzers：使用程序分析为程序构建完整图像。</li></ol><ul><li>concolic executors like SAGE[33],SYMCC[66] 属于这类。然而，白盒测试分析消耗untenable[62]，难以维持的。</li></ul></li><li><ol start="2"><li>Black-box fuzzers：盲目地生成测试用例来测试。可以了解程序输入的格式，但不了解运行结果[80,52]</li></ol></li><li><ol start="3"><li>Grey-box fuzzers：介于1，3之间，了解有限的信息通过轻量级的插桩，这些信息混合了程序分析和测试状态[62].一个例子是使用从测试用例中提取代码覆盖率如AFL[83],LIBFUZZER[46]</li></ol></li></ul></li><li>根据第二个原则，可分为 generational 和 mutational fuzzers<ul><li>生成式模糊测试器从头开始创建新的测试用例，可以是随机的，也可以依赖于某种形式的格式规范，比如语法或领域特定语言。</li><li>突变式模糊测试器则通过对一组先前的测试用例进行突变来派生新的测试用例；这些突变可以是通用的、针对特定目标的，或者是由用户提供的或推断出的格式规范驱动的。</li></ul></li><li>使用第三个原则，模糊测试器可以根据它们用于驱动探索的信息而进行划分，我们称之为feedback。<ul><li>coverage-based fuzzers:使用代码覆盖率作为搜索反馈</li><li>先前的研究表明，基于覆盖率的模糊测试器通常在发现漏洞方面要有效得多。由于还有其他形式的反馈可能存在，我们将更一般地将这种模糊测试设计称为反馈驱动的模糊测试。</li></ul></li></ul><h4 id="feedback-driven-fuzz-testing" tabindex="-1">Feedback-Driven Fuzz Testing</h4><ul><li>当一个CGF生成的测试用例触发了一个新的策划嗯需的部分时，其任务该测试用例 interesting 并将其添加到一个输入队列（称为种子）中，以供进一步处理。通过将这种技术与突变方法结合起来，我们获得了一个由代码探索驱动的进化算法。</li><li>代码覆盖率可以由不同的方法计算，例如仅考虑基本块，或者包括整个调用上下文[79]。<ul><li>迄今为止，用于覆盖导向的模糊测试器最流行的标准是边覆盖，它最大化了程序函数控制流图（CFG）中访问的边的数量。像AFL这样的模糊测试器通过为边添加一个命中计数（即测试用例执行这些边的次数）来扩展纯边覆盖，以更好地近似程序状态。</li><li>最近，ANKOU进一步发展了这个想法，通过根据在线主成分分析的结果添加等效覆盖的测试用例到队列中，以考虑执行之间的命中计数差异。</li></ul></li><li>如在2.2中所说，还有其它指标可以驱动fuzzer的演化。<ul><li>FUZZ FACTORY最近研究了几种替代方案，例如内存分配大小可以作为一种有用的反馈来暴露内存不足的漏洞，而比较指令的操作数中相同位的数量可以帮助绕过模糊测试的障碍。</li><li>简而言之，所有这些反馈技术都作为领域特定测试目标的捷径，代码覆盖并不是一个足够描述。</li></ul></li><li>一个更一般的方法是，除了控制流外，数据流信息也代表了程序状态。迄今为止，我们所知道的最简单的实现就是“内存”反馈，其中来自内存加载和存储操作的每个新观察到的数据值被视为模糊测试器的新颖因素。不幸的是，这种解决方案很容易导致状态爆炸。</li></ul><h3 id="3-%E6%96%B9%E6%B3%95" tabindex="-1">3 方法</h3><ul><li>本节，我们使用一个现实世界的漏洞展示我们方法的思想。</li><li>该漏洞是关于 libsndfile 中 WAV 文件格式解析的堆溢出，libsndfile 是一个用于操作音频文件的流行库。示例 1 和示例 2 显示了受影响的代码。具体而言，漏洞位于 ms_adpcm.c 文件中的 msadpcm_decode_block 函数中，在示例 2 中的第 9 行报告了此处的漏洞。<br><img src="/images/%E8%AE%BA%E6%96%87/invariant/3_1.png" alt></li><li>值得注意的是，我们在实验中使用的所有基于覆盖率导向的模糊测试器（§5）都能够到达代码中的脆弱点，但是却没有触发该漏洞。尽管易受影响的代码是“易于到达的”，并且 libsndfile 常常被用于模糊测试实验（包括 Google OSS-Fuzz 项目和最近的研究作品，比如 [31] 和 [81]），但是当我们运行实验时仍然存在漏洞。</li><li>这是因为，要触发漏洞，循环应该写入超出 pms-&gt;samples 指针所指内存范围之外的位置，而这个指针引用了 pms 结构末尾的 C99 变量大小数组字段。只有当程序处于特定状态时，才会发生这种情况，这种状态以 pms 缓冲区的分配大小较小（示例 1 中的第 8 行）和足够高的 pms-&gt;blocksize 值（示例 1 中的第 13 行）为特征，迫使循环写入数组的边界之外。</li><li>然而，这些要求都不能从代码覆盖中得出，因为程序中没有涉及这些阈值的分支。相反，其依赖于两个输入派生的值：blockalign 和 samplesperblock。<ul><li>CGF通常无法关心这种漏洞，因为没有引入新的覆盖率，并不会被视为一个有趣的测试用例</li></ul></li><li>这展现了现代fuzzer探索程序状态时遇到的问题。<ul><li>最先进的基于覆盖率导向的模糊测试系统在覆盖率上可能已经饱和，但仍然可能错过在其操作中触及的程序点上的漏洞。</li><li>此外，无法生成测试用例来覆盖未见过的程序点，当这些程序点不仅依赖于控制流可达时</li></ul></li></ul><h4 id="3.1-program-state-partitions" tabindex="-1">3.1 Program State Partitions</h4><ul><li>本文的核心思想是，我们可以通过在处是输入语料库上执行测试用例从中学习可能的不变量，在应用程序代码的多个点将程序空间划分为不同的分区。</li><li>继续以我们的例子为例，假设我们可以使用标准的覆盖率导向模糊测试系统对 libsndfile 进行一定时间的模糊测试，比如 24 小时（我们将在第 3.4 节讨论不同语料库对提取的不变量的影响）。通过调查由模糊器保存的所有种子的变量值，我们将确定 init 函数的两个可能的不变量和易受攻击的解码循环的一个可能不变量。所有不变量都作为注释包含在示例 1 和 2 中。</li><li>这些不变量描述了由fuzzer生成的语料库产生的有限数量的状态。即，每个不变量都表示在测试实验期间fuzzer无法违反的程序状态条件，因此，我们的直觉是，我们可以使用这些不变量将程序状态划分为多个分区，如图1所示init函数<br><img src="/images/%E8%AE%BA%E6%96%87/invariant/3_2.png" alt></li><li>此时，我们可以看到这两个不变量将空间划分为四个不相邻的区域（图中的A到D区域），除第一个区域外，其它区域均未被fuzzer访问到。这些信息使得我们能够向fuzzer提供反馈，以探索新的状态。<ul><li>此外，由于这些状态只能通过违反来达到，我们的直觉是其会将程序带入很少被探索的极端情况，此处漏洞可能长时间未被发现过</li><li>为捕获这些信息，本文提出的方法通过使用在基本块上学习到的可能不变量的违反情况来增强经典的边覆盖反馈。在理想情况下，我们可以学到精确的不变量，并将它们转化为代码覆盖的语句，而使纯覆盖率导向的模糊器能够接收反馈以向这些区域进展。然而，正如 §2.1 中描述的那样，当前的不变量挖掘技术会导致过度或不足的近似。</li></ul></li></ul><h4 id="3.2-using-invariants-as-feedback" tabindex="-1">3.2 Using Invariants as Feedback</h4><ul><li>动态不变量检测的局限性在于，所得到的不变量通常更多地捕获了测试套件的局部属性，而不是程序的静态属性。然而，对于我们的目的来说，这恰恰是我们想要的。<ul><li>事实上，只代表语料库的局部属性的可能不变量是有趣的，因为它们的违反会提示fuzzer程序状态中哪些值组合是不寻常的，理想情况下可能是漏洞所在。</li></ul></li><li>因此，我们将基于不变量的反馈定义为边覆盖与源基本块中违反的可能不变量的信息的组合。<ul><li>为了告知模糊器有趣的方向，我们调整了大多数基于覆盖的系统采用classic novelty search。</li><li>特别地，对于每个被CGF工具检测的控制刘边，我们使其为每个违反的可能不变量的唯一组合生成不同的novelty search。</li></ul></li><li>正如4.2节详细介绍的，我们单独跟踪不变量并在每个基本块独立奖励它们：该选择带来了对程序状态分区，明确但又隐晦的编码。</li><li>不变量能够在不引发状态爆炸的情况下划分程序状态空间也是我们方法的关键见解之一。在每个基本块，N个不变量可以像N条非平行线一样局部地划分状态，将平面划分为N*（N+1）/2+1个区域。实践中，由于每个块通常只操作很少的变量，N为一个很低的值（附录A中的统计数据）</li><li>回到我们的例子，对于 wavlike_msadpcm_init 函数，我们有两个涉及到学习到的不变量的变量：blockalign 和 samplesperblock。触发漏洞的分区是 B——它同时违反了这两个不变量。我们的模糊器找到了一个值分配 {blockalign = 1280，samplesperblock = 8} 来触发漏洞。</li><li>通过基于不变量的反馈来增强敏感性，fuzzer可以分别违反每个不变量，保存这样的测试用例用于分区 A 和 D，并且还可以将这两个测试用例拼接起来生成一个将状态带到 B 的测试用例。更进一步说，我们的方法可以通过组合或变异先前的种子（每个违反一个或多个不同的不变量）来生成违反多个不变量的输入。</li></ul><h4 id="3.3-pruning-the-generated-checks" tabindex="-1">3.3 Pruning the Generated Checks</h4><ul><li><p>通过我们的示例，我们展示了我们如何使用不变量来划分程序状态，然后如何将此信息转变为反馈以驱动fuzzer探索。</p></li><li><p>然而，不是所有的不变量都有用：虽然拥有更多的不变量不会影响我们的方法论（即，探索更多分区不会失去敏感性），但其产生的额外状态会污染我们的反馈，过渡插桩也会影响运行时开销，因此，我们设计了三种修建方法来消除 哪些在其它可用信息光芒下 或 由于其它组成部分的特性 而检查起来毫无意义的不变量</p></li><li><ol><li>第一种丢弃的不变量是<strong>不可能违反的不变量</strong></li></ol><ul><li>如，无符号整数始终大于等于0，这对fuzzer没有意义</li><li>为了识别这些类似情况，我们针对被测程序的每个函数执行值范围分析[36]。最初，参数和全局存储是无约束的，分析为函数变量产生了适用于任何执行的边界。利用范围信息，我们指示我们的不变量挖掘器不要生成在逻辑上比静态发现的不变量更弱的可能不变量。由于这些不变量无法违反，我们可以节省监视它们所需的插桩成本。</li></ul></li><li><ol start="2"><li>第二类无用的不变量是那些<strong>结合不相关变量的</strong></li></ol><ul><li>为了消除这些关系，我们为被测试程序的每个函数计算可比性集：每个变量仅属于一个这样的集合，并且丢弃跨不同集合组合变量的不变量。</li><li>最终，一个可比较集合包括了参与相关计算的变量。有几个例外情况：例如，在数组指针计算中，我们不会合并基元素和索引元素的集合，因为它们不是直接相关的。</li></ul></li><li><ol start="3"><li>每当不同的不变量具有重叠的条件时，通过重用先前计算的值来优化它们的运行时验证。</li></ol><ul><li>这一步针对Daikon在函数节点处枚举模板，如果函数中位操作就不用枚举。</li><li>特别地，我们针对共享某些变量上相同条件的一对可能不变量进行优化。</li><li>如果这两个不变量涉及两个程序点p,p0,其中p0只能在p之后执行，我们使用标准的敏感流分析来确定在p和p0之间是否存在任何涉及变量的中间重新定义。此时，我们只需传播在p处计算的值，从而节省在p0处的计算成本。</li></ul></li><li><p>变量值范围分析和比较集计算会提前预处理，随后传递到不变量推断阶段。重叠条件将在生成程序时处理（即再程序中添加用于简化不变量的代码，这些代码将在测试过程中使用）</p></li></ul><h4 id="3.4-%E8%BE%93%E5%85%A5%E9%9B%86%E9%80%89%E6%8B%A9" tabindex="-1">3.4 输入集选择</h4><ul><li>因程序动态不变量需要大量程序运行轨迹，所以与 evolutionary fuzzer 类似，初始输入集很关键</li><li>一个不明智的做法会 产生 不能很好描述在程序状态中变量的通用性的 不变量。<ul><li>例如，一个常见的实例是在使用fuzzer测试解析器的时候会产生大量给定文件格式的文件，然而大部分是合法的文件格式。如果我们从这个语料库中进行不变量推断，我们会将我们的不变量偏移在有效地文件格式上，在一些情况下这是错误的，因为我们会错过与无效输入有关的程序状态的划分。</li></ul></li><li>同时我们也想解决当fuzzer在覆盖上饱和时找bug不行的问题，我们的一个自然的想法是使用基于覆盖引导的fuzzer的生成输入队列作为程序动态不变量生成的语料库。在该语料库上违反不变量产生的新的输入，可以作为对fuzzer的新颖的反馈，同时缓解基于路径覆盖的饱和度</li><li>为了确认我们的想法，我们为在 $5中测试的程序下载了一个全为有效文件的数据集来生成不变量（即语料库全是好的，不变量会过拟合）。<ul><li>我们随后将这些不变量与使用fuzzer运行24h后的输入队列作为语料库产生的不变量作比较。</li><li>试验显示，使用从过拟合的语料库中提取的不变量比从fuzzer输入队列提取的不变量，在我们的方法中，前者会比后者少发现20%的bug</li></ul></li></ul><h3 id="4-%E5%AE%9E%E7%8E%B0" tabindex="-1">4 实现</h3><ul><li><p>之前章节，我们介绍了动机和我们方法的关键思想。然而，我们有目的性的避免讨论了我们方法的两个重要的方面</p><ul><li><ol><li>我们如何定义我们想从不变量中捕获的<em>状态</em></li></ol></li><li><ol start="2"><li>我们如何在被测试程序中插桩来收集我们技术需要的信息</li></ol></li></ul></li><li><p>我们的方法可以以不同的方式实现：</p><ul><li>可以在目标源码上插桩，或在二进制上进行静态重写[20]或动态翻译[17]，各种方法都有优缺点。</li><li>本研究选择基于编译的实现，使用LLVM[43]和DAIKON[25]在我们invariant-based fuzzing。</li></ul></li><li><p>我们的原型是用C++编写的，并重新利用了Pereira等人[68]提出的用于LLVM的快速函数内整数范围分析，该分析需要渐近线性时间完成。</p></li><li><p>下图2展示了我们原型的结构图。我们为LLVM实现了两个自定义的编译转换阶段。</p><ul><li><em>学习阶段</em>：进行日志记录插桩，收集程序中变量状态，提供给不变量推断工具。</li><li><em>插桩阶段</em>：增强被测试代码，使得不变量可以直接适配基于覆盖的fuzzer<br><img src="/images/%E8%AE%BA%E6%96%87/invariant/3_3.png" alt></li></ul></li><li><p>学习阶段：</p><ul><li>在输入语料库上执行增强版本的被测试程序，输入可有多种方式获得（$3.4;$5中使用24小时的覆盖率引导模糊测试生成种子）</li><li>对于不变量挖掘，使用Daikon。 在每个插桩的位置，不变量挖掘的时间复杂度是变量数量的立方，然而由于我们的技术是在基本块级别上，变量数量为很小的常熟。</li></ul></li><li><p>插桩阶段：</p><ul><li>将推断的不变量信息编码到函数中来将它们暴露给 基于覆盖的模糊测试器。转换后的程序可以直接在任何基于AFL的模糊测试工具上运行。</li></ul></li></ul><h4 id="4.1-%E7%8A%B6%E6%80%81%E4%B8%8D%E5%8F%98%E9%87%8F%E5%AD%A6%E4%B9%A0" tabindex="-1">4.1 状态不变量学习</h4><ul><li><p><strong>原型实现在LLVM的IR上的好处：</strong></p><ul><li>因此容易在程序的基本块级别暴露程序状态。</li><li>此外，IR允许我们避免在源代码级别追踪复杂数据类型时出现未初始化值的问题[1]。</li><li>Daikon的前端Kvasir使用耗费昂贵的动态二进制插桩[17]读取变量并检测内存。然而在IR上，我们可以我们只需等待地址在加载操作的结果中出现在虚拟寄存器中，然后将其用于追踪。</li><li>使用IR的另一个优点：在IR中，指令通常以单一静态赋值（SSA）形式表达[70]。SSA意味着每个变量只能被赋值一次，每个使用必须由一个（唯一的）先前定义到达。</li></ul></li><li><p><strong>SAA相关：</strong></p><ul><li>为了简便，我们忽略了浮点数指令，只对整数的SSA变量建模。</li><li>对于局部变量，由于在IR中一个源级变量可能存在多个SSA变量，我们将我们的分析限制在那些可以直接连接到源级变量的SSA变量上，通过使用来自LLVM前端的调试元数据。</li><li>当程序访问非局部存储或非原始类型的字段时，LLVM将作为当前内容的加载操作的结果引入一个SSA变量。通过对这种IR变量进行仪器化，我们的不变量挖掘也扩展到全局变量、堆存储和结构体的字段。</li><li>由于我们的目标不仅仅是对应用程序的状态进行建模，而是提高<strong>面向安全的测试技术的有效性</strong>，因此我们的分析重点在可能引起安全问题的变量上，根据以下三个规则：<ul><li>该变量是GetElementPtr指令的一部分进行指针计算，除非仅涉及常量索引；</li><li>通过使用Load或Store指令将变量值从内存加载或存储；</li><li>该变量代表函数的返回值。</li></ul></li></ul></li><li><p><strong>LLVM管道</strong></p><ul><li>我们实现了LLVM函数管道收集变量的值，同时完成对感兴趣变量的插桩，并完成了可比较集和值域分析[68]来进行不变量修建。</li><li>管道为每个代码模块创建json文件存储程序点和变量的信息（类型，比较集，范围）。随后将这些文件综合得到Daikon的declaration文件，随后依据比较集和范围提纯不变量（见$3.3）。</li></ul></li><li><p><strong>Daikon使用</strong></p><ul><li>我们指导Daikon在每个输入上运行插桩后程序，找到检测变量的值。</li><li>我们使用Daikon的即时使用模块挖掘不变量，其会从每个执行中依次学习不变量</li></ul></li></ul><h4 id="4.2-%E7%A8%8B%E5%BA%8F%E6%8F%92%E6%A1%A9" tabindex="-1">4.2 程序插桩</h4><p>略</p><h3 id="5-%E8%AF%84%E4%BC%B0" tabindex="-1">5 评估</h3><ul><li><p><strong>研究问题</strong></p><ul><li>RQ1：我们的不变量删除是否有效地减少了不变量的数量？</li><li>RQ2: 我们的反馈机制导致了状态爆炸吗？</li><li>RQ3: 我们的反馈机制可以比单纯基于代码覆盖机制探索更多程序状态吗？</li><li>RQ4: 我们的反馈机制可以比基于覆盖的揭示更多或不同的bug吗？</li><li>RQ5: 我们的反馈机制引入的性能消耗如何？</li></ul></li><li><p><strong>基准程序</strong></p><ul><li>选择8个现实世界的目标程序，工作在不同类型文件上，同时我们为他们在解析阶段的实现使用了不同的策略<ul><li>我们选择了包含bug且广泛应用于之前工作的版本[31,51,69]</li><li>我了更严密的评估，我们也人工增加了bug来评估bug发现能力。</li></ul></li><li>LAVA-M[22]基准不合适我们的方法，因为其包含的错误依赖magic-value ($6.2)比较[38]</li><li>MAGMA [38] 基准也不合适，因为它们的硬编码日志记录原语（用于检查真实情况）分割了基本块，因此与我们的不变式构建和插装的粒度冲突。</li><li>表一展示了实验的程序。这里还展示了感知器，我们使用了AddressSanitizer (ASAN) 和 UndefinedBehaviourSanitizer (UBSAN) 编译时插装。然而，我们不得不为两个应用程序禁用 UBSAN，因为它引入了不想要的副作用，即使使用最简单的测试输入也会使它们崩溃。</li></ul></li><li><p><strong>试验设置</strong></p><ul><li>机器：x86_64，Intel® Xeon® Platinum 8260 CPU 2.4Ghz</li><li>使用AFL<ins>版本2.65d作为我们方法的参考fuzzer，随后与其他配置的AFL</ins>及进行比较</li><li>我们进行了5次实验减小fuzzing误差，使用中位数作为结果，每个实验48h的界限</li><li>从有效文件的初始组出发，我们使用AFL++运行24h获得种子队列作为初始输入，这即会用在提取不变量也会用在fuzzers的种子上。</li><li>剩余部分中，以下为我们的方法对比定义<ul><li>INVSCOV：使用基于不变量插桩的fuzzer</li><li>CODECOV：使用经典代码覆盖的fuzzer</li><li>CTXCOV：使用上下文敏感的增强代码覆盖的fuzzer</li></ul></li></ul></li></ul><h4 id="5.1-rq1%3Ainvariantpruning" tabindex="-1">5.1 RQ1:InvariantPruning</h4><ul><li>计量最后产生的不变量数量对比</li><li>表2展示优化前后数量对比，共三个阶段：无优化，学习阶段优化，插桩阶段优化<br><img src="/images/%E8%AE%BA%E6%96%87/invariant/3_4.png" alt></li><li>尽管看起来不变量数量优化较少，但确实可以增加fuzzer10%的运行效率</li></ul><h4 id="5.2-rq2%3Astateexplosion" tabindex="-1">5.2 RQ2:StateExplosion</h4><h4 id="5.3-rq3%3Aprogram-state-exploration" tabindex="-1">5.3 RQ3:Program State Exploration</h4><h4 id="5.4-rq4%3Abugdetection" tabindex="-1">5.4 RQ4:BugDetection</h4><h4 id="5.5-rq5%3Arun-timeoverhead" tabindex="-1">5.5 RQ5:Run-TimeOverhead</h4><h4 id="5.6-discussion" tabindex="-1">5.6 Discussion</h4><ul><li>我们的实验结果证实了我们的反馈，通过让变量与他们的“寻常值”不同，来提升fuzzer对只代码覆盖不能奖励到的程序状态的敏感度。</li><li>在65个程序bug点只有我们的方法可以触发的情况下，只进行代码覆盖只达到了43个，因为程序没有处在错误地状态。即使用了强化的代码覆盖反馈如上下文敏感，我们的方法也能发现更多bug。</li><li>我们的反馈机制产生的输入队列大小仅增长了62%，远小于内存反馈和一些基于代码的反馈。每个测试用例生成平均而言减缓了8%。这些代价可以被我们多发现的bug偿还。</li><li>与边缘覆盖相比，反馈机制在代码覆盖率方面不是递减的，在某些情况下，它还可以解锁更多的依赖于状态的程序部分以进行进一步探索。在综合场景中进行了简短的实验，发现INVSCOV和细粒度的代码反馈形式可以相互补充。这样的模糊器将能够更好地区分和探索那些受到控制流事实（例如调用路径）影响的状态属性。</li></ul><h3 id="6-%E5%85%B6%E5%AE%83%E7%9B%B8%E5%85%B3%E5%B7%A5%E4%BD%9C" tabindex="-1">6 其它相关工作</h3><ul><li>本节覆盖了安全相关的使用了不变量的作品，还有与我们方法相关的可以增强fuzzing效率的技术。</li></ul><h4 id="6.1-invariants" tabindex="-1">6.1 Invariants</h4><ul><li>不变量在历史上在许多发展的领域如软件测试，软件优化和维护[26]起到了关键的左右。在安全研究的上下文中，许多工作也探索了不变量在其它问题上的应用。</li><li>在畸形检测上下文中，不变量可以作为程序加固的oracle。例如[32,75]通过程序插桩阻止生产环境中的内存损坏利用，因为运行时检查的成本相对较低。Web应用程序也可以从类似的保护中受益，如[15]中使用DAIKON和PHPcode所探索的那样。</li><li>故障定位：当多个不变量被违反时，一个典型的根因定位的工作流程是研究相似的输入来过滤掉不相关的不变量。如[71]，使用 dynamic backward slicing移除更多不变量。[7]对学习到的谓语进行统计学分析。</li><li>在$2.1中我们提到了将不变量作为规范在基于属性的测试中至关重要。QUICKCHECK [12]可能是这类系统中最著名的一个。最近的工作，如ZEST [59]和HYPOTHESIS [48]，分别借鉴了模糊测试的概念，如反馈驱动的变异，以提高它们在测试Java和Python代码库时的效率。</li></ul><h4 id="6.2-%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95" tabindex="-1">6.2 模糊测试</h4><ul><li><p>Fuzz Testing（模糊测试）是学术界和工业界广泛关注的焦点，每年尝试改进其技术各个方面的工作数量呈爆炸式增长[50]。</p></li><li><p>我们认为，除了在$2.2节讨论的反馈进之外，fuzzer最重要的改进包括 绕过代码覆盖率障碍的技术，基于变异的程序路径执行以及捕捉静默错误。</p><ul><li>幸运的是，这些进展和我们的方法是可以结合的。如5.3中利用AFL++的灵活性，我们已经将一些设计和我们的方法结合。</li></ul></li><li><p><strong>Roadblocks</strong></p></li><li><p><strong>Valid Inputs</strong></p></li><li><p><strong>Catching Silent Faults</strong></p></li><li><p><strong>HardTargets</strong></p></li></ul><h3 id="7-%E9%99%90%E5%88%B6%E5%92%8C%E6%9C%AA%E6%9D%A5%E6%96%B9%E5%90%91" tabindex="-1">7 限制和未来方向</h3><ul><li>我们的方法通过违反动态不变量来增强经典的基于代码覆盖的反馈。</li><li>由于我们为了兼容性而发出符合AFL的插桩，在更新覆盖范围时对共享映射进行索引时可能会出现哈希冲突——就像使用AFL一样。AFL++提供了一种无冲突但破坏兼容性的链接时间插桩方案[39]。我们可以设计一个从这种设计中受益的INVSCOV变体，并可能探索将不变和边缘反馈分开的映射</li><li>在方法学方面，我们的方法的一个内在限制是它不是自适应的。我们只学习一次不变量，而在探索过程中通过细化它们来探索新值条件是有可能的。因此，我们方法的后续工作将是设计一个在线不变量挖掘模块。最近的异常检测中的机器学习进展，如[16]，可以为这一目标提供有效的支持。我们认为，一个能够自适应地学习变量上的状态空间划分的模糊器可以产生实际的影响，并可能有助于使OSS-Fuzz等饱和模糊测试活动捕获更多已经用CGF解决方案进行了充分测试的软件中的漏洞。</li><li>最后，由于我们在基本块级别研究数据事实，我们可能的不变量无法捕捉到在任何块中都不会一起处理的变量之间的“隐式”关系。</li></ul><h3 id="8-%E7%BB%93%E8%AE%BA" tabindex="-1">8 结论</h3><ul><li>使用可能的不变量作为fuzzers的反馈，以更好地抽象和探索程序状态。</li><li>过考虑控制程序状态的条件，可以发现一些潜在的漏洞，这些漏洞可能在很长时间内未被发现。</li><li>我们在不引发状态爆炸问题的情况下，实现了这一目标，并且性能开销适度，发现的漏洞数量增加。</li><li>希望这项工作可以为程序状态近似为模糊测试提供反馈的研究铺平道路，。</li></ul><h3 id="9-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93" tabindex="-1">9 个人总结</h3><ul><li>本文使用程序动态不变量，强化了经典的基于代码覆盖的fuzzer，具体地对于fuzzer生成的违反不变量的输入，其会增加他的优先级。</li><li>本文中，不变量在代码块级别生成，同时也晒出了一些无用的不变量，这是我们需要学习的。</li><li>对debloating的思考：直接使用输入集覆盖的代码路径上的不变量作为规约，在程序简化时，简化后程序不能违背该规约，对于错误地简化可以提前发现。</li></ul><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;the-use-of-likely-invariants-as-feedback-for-fuzzers&quot; tabindex=&quot;-1&quot;&gt;The use of likely invariants as feedback for fuzzers&lt;/h2&gt;
&lt;ul&gt;
&lt;</summary>
      
    
    
    
    <category term="论文" scheme="http://example.com/categories/%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="Invariant" scheme="http://example.com/tags/Invariant/"/>
    
    <category term="Fuzzing" scheme="http://example.com/tags/Fuzzing/"/>
    
  </entry>
  
  <entry>
    <title>使用不变量在回归测试和错误定位</title>
    <link href="http://example.com/2024/03/22/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/invariant/%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%8F%98%E9%87%8F%E5%9C%A8%E5%9B%9E%E5%BD%92%E6%B5%8B%E8%AF%95%E5%92%8C%E9%94%99%E8%AF%AF%E5%AE%9A%E4%BD%8D/"/>
    <id>http://example.com/2024/03/22/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/invariant/%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%8F%98%E9%87%8F%E5%9C%A8%E5%9B%9E%E5%BD%92%E6%B5%8B%E8%AF%95%E5%92%8C%E9%94%99%E8%AF%AF%E5%AE%9A%E4%BD%8D/</id>
    <published>2024-03-22T15:46:00.234Z</published>
    <updated>2024-03-24T06:53:43.556Z</updated>
    
    <content type="html"><![CDATA[<h2 id="using-automatically-generated-invariants-for-regression-testing-and-bug-localization" tabindex="-1">Using automatically generated invariants for regression testing and bug localization</h2><ul><li>引用：Sagdeo P, Ewalt N, Pal D, et al. Using automatically generated invariants for regression testing and bug localization[C], 2013 28th IEEE/ACM International Conference on Automated Software Engineering (ASE). IEEE, 2013: 634-639.</li><li>CCF A ASE</li><li><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=6693125">链接</a></li></ul><h3 id="1-%E4%BB%8B%E7%BB%8D" tabindex="-1">1 介绍</h3><ul><li>在软件开发和部署后，检测和定位软件中的错误行为都是具有挑战性的。在这项工作中，我们提出了一种新颖的方法来解决这一挑战，即在软件开发生命周期的不同阶段使用自动生成的程序不变量</li><li>我们在[1]种提出了PRECIS，一种不变量自动生成技术，其实用静态路径信息来引导静态分析，以生成程序不变量。其比[2,3,4]不变量生成技术好，因其表达性，覆盖度和扩展度</li><li>PRECIS对分支点（if/else和switch）语句的谓词值进行插桩，以收集关于程序或函数控制流结构如何影响其行为的动态信息。然后PRECIS利用程序执行期间收集的跟踪数据，动态推断谓词值与函数输入/输出之间的统计显著关系。如论文中的实验结果所示，PRECIS谓词的假阳性率低于10%</li><li>在本文工作中，我们将PRECIS自动化为一键式工具。我们提出了其在软件开发生命周期的不同阶段两个新颖而重要的应用<ul><li><ol><li>回归测试</li></ol></li><li><ol start="2"><li>错误定位</li></ol></li></ul></li><li>我们将驱动PRECIS谓词和不变量应用的总体技术称为PREAMBL。</li></ul><h4 id="regression-testing" tabindex="-1">Regression Testing</h4><ul><li>回归测试通常通过创建一组测试用例和期望输出来完成，这些测试用例涵盖了程序的预期行为[7]，[8]。 用来测试在原本程序种正确运行的功能，在新版本中依旧可以正常运行</li><li>通过PREAMBL，我们介绍了使用不变量进行回归测试的概念。不变量总结了程序的关键功能。而单个测试用例捕获一个程序执行，每个不变量可以捕获多个执行的预期行为，因此，验证不变量的有效性可能比传统测试更全面。</li><li>不变量旨在为输入/输出等价性的传统回归测试提供功能/行为检查的补充。</li><li>然而，不变量进行回归测试的权衡是，与测试不同，其不易跨版本移植。因此我们提出了方法的原则是，原始程序的不变量应该在新版本种也成立，为此需要检查从原始版本种获得的不变量是否还能适用新的版本<br><img src="/images/%E8%AE%BA%E6%96%87/invariant/1_1.png" alt></li></ul><h4 id="bug-localization" tabindex="-1">Bug Localization</h4><ul><li>识别程序中的错误是调试种耗时的部分。</li><li>断言检查通常由于性能原因在软件发布时从程序中移除。因此，与其将断言集成到发布代码中，PREAMBL对程序的分支点进行轻量级插桩，以定位错误</li><li>部署后错误定位和分析的愿景如图2所示. 如果程序无法产生正确的输出，导致失败的分支点序列将用于识别最有可能导致失败的程序路径。通过统计分析确定了与失败高度相关的程序子路径。</li><li>与[12,9]类似，PREAMBL统计分析考虑了在路径上发生的总失败的比例及通过该路径的执行中导致失败的百分比。PREAMBL分析构建了一个路径频率树来识别最大重要性的子路径，使得PREAMBL能够确定与失败高度相关的可变长度子路径。而以往工作只推导了单个函数的固定长度路径，PREAMBL允许在大型函数中进行增强的定位，适用于高度局部化的错误以及根本原因跨越多个函数的错误。<br><img src="/images/%E8%AE%BA%E6%96%87/invariant/1_2.png" alt></li></ul><h3 id="2-%E4%B8%8D%E5%8F%98%E9%87%8F%E7%94%9F%E6%88%90" tabindex="-1">2 不变量生成</h3><ul><li>PRECIS[1]对输入，输出，谓词进行插桩</li><li>执行跟踪数据由输入，谓词，输出具体值得元组组成</li><li>使用上述数据通过谓词聚类的过程生成不变量，详见论文[1]</li><li>本工作中，扩展[1]，以处理更复杂的控制和数据流结构<ul><li>Multiple Output Variables:</li><li>Function calls:</li><li>Loops:</li><li>Arrays and pointers:</li><li>实现：PRECIS插桩程序使用Fjalar[13]，基于Valgrind，最初支持Daikon的不变量生成。</li></ul></li></ul><h3 id="3-%E4%BD%BF%E7%94%A8precis%E4%B8%8D%E5%8F%98%E9%87%8F%E7%9A%84%E5%9B%9E%E5%BD%92%E6%B5%8B%E8%AF%95" tabindex="-1">3 使用PRECIS不变量的回归测试</h3><ul><li>如果在 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mrow><mi>o</mi><mi>r</mi><mi>i</mi><mi>g</mi></mrow></msub></mrow><annotation encoding="application/x-tex">P_{orig}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">or</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></eq> 中的不变量 在 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mrow><mi>n</mi><mi>o</mi><mi>w</mi></mrow></msub><mo separator="true">,</mo><msub><mi>P</mi><mrow><mi>f</mi><mi>u</mi><mi>t</mi><mi>u</mi><mi>r</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">P_{now},P_{future}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">re</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></eq> 上失败，则称测试到了回归</li><li>首先，由于程序新版中谓词变化不大，因此使用程序代码的字符串文字匹配，将新旧版本的谓词进行匹配，创建映射<ul><li>当谓词在版本间发生变化时，PRECIS可以通过程序员提供的注释来描述背后的意图</li><li>我们描述了映射不变式导致的三种情况，具体却决于将他们纳入新版本所需的程序员的工作程度<ul><li>情况1：不变量在两个版本间完全自动映射（需满足所有谓词都可以自动映射）</li><li>情况2：不变式需要一些程序员的努力才能在新版本中有效。这可能是由于需要为谓词添加注释或输入或输出变量名称更改</li><li>情况3：不变式无法在版本之间映射，这是由于基本代码发生了变化。</li><li>我们将在第5节讨论每种情况出现的频率及所得到的覆盖率</li></ul></li></ul></li><li>接下来将展示案例研究，展示了使用PRECIS生成的不变量进行回归测试的PREAMBL的有效性</li></ul><h4 id="a.-case-study" tabindex="-1">A. Case Study</h4><ul><li>下图展示了一个假设的科学计算应用中函数convert_units的实现。<ul><li>接受三个参数，value表示测量值，src表示传递值的单位，tgt表示要转换为的单位。</li><li>返回值是将输入值转换为目标单位的相应值。该函数设置了检查，以捕获整数溢出的情况，以及捕获不支持的转换。在这两种情况下，函数都返回-1，被视为无效值。</li><li>当在convert_units上运行PRECIS时，捕获到以下不变量：<ul><li>（1）(p0 = 1 ∧ p1 = 0) ⇒ (result = 36 × val)</li><li>（2）(p0 = 1 ∧ p1 = 1) ⇒ (result = −1)</li><li>（3）(p0 = 0 ∧ p1 = X) ⇒ (result = −1)</li></ul></li><li>假设开发人员重写了代码，使其更通用，如图所示，将YD_TO_IN定义为35。当开发人员运行测试套件时，不变量(1)将触发，因为当第一个if语句被执行而第二个if语句未执行时，结果不是36 × val。这迅速提醒开发人员代码中的错误。<ul><li>更重要的是，与仅比较应用程序输出值不同，失败的断言还明确告知开发人员特定的上下文（在本例中，是没有溢出的yd. to in.转换），在这种上下文中函数输出（在本例中是convert_unit的结果）出现问题。这有助于开发人员快速有效地隔离错误。<br><img src="/images/%E8%AE%BA%E6%96%87/invariant/1_3.png" alt></li></ul></li></ul></li></ul><h3 id="4-%E4%BD%BF%E7%94%A8precis%E4%B8%8D%E5%8F%98%E9%87%8F%E7%9A%84%E9%94%99%E8%AF%AF%E5%AE%9A%E4%BD%8D" tabindex="-1">4 使用PRECIS不变量的错误定位</h3><ul><li>PREAMBL捕获程序路径信息，通过对控制流分支点（如if语句，case语句等）进行插桩作为谓词。因此，谓词对应于控制流图(CFG)中的节点，谓词的值通过的图的方向。</li><li>对于一个程序运行，一些列谓词及其值表示了程序中经过的路径。本文中，使用格式 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mn>0</mn><mo>=</mo><mi>v</mi><mn>0</mn><mo stretchy="false">)</mo><mo>⇒</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo>⇒</mo><mo stretchy="false">(</mo><mi>p</mi><mi>n</mi><mo>−</mo><mn>1</mn><mo>=</mo><mi>v</mi><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p0 = v0) ⇒ · · · ⇒ (pn−1 = vn−1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇒</span></span><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mpunct">⋅⋅⋅</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></eq> 来表示一个程序路径，如果  <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mn>0</mn><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">v0 = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></eq> ，则采用 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">p0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord">0</span></span></span></span></eq> 分支，如果 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mn>0</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">v0 = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></eq> ，则不采用，然后评估一些其他谓词，最后评估 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">pn−1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></eq> 分支为值 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">vn−1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></eq>。</li><li>每个这样的序列都标记为“成功”（生成期望的输出）或“失败”（未生成期望的输出），取决于给定程序执行的结果。</li><li>为了定量评估路径，PREAMBL使用了 [10]提出[9]也是用的算法。该算法中，我们为每个路径 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span></eq> 收集了4个测量值<ul><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>e</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S_e(p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span></eq> 路径p被执行的成功运行次数</li><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mi>e</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F_e(p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span></eq> 路径p被执行的失败运行次数</li><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>o</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S_o(p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span></eq> 路径p被观察到的成功运行的次数</li><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mi>o</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F_o(p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span></eq> 路径p被观察到的失败运行的次数</li><li>如果所有构成路径的谓词都评估为其指定的值，则认为该路径已执行； 如果路径中的第一个谓词被评估，都视为已被观察到。</li></ul></li><li>利用这些测量值和F，即总失败运行次数。我们计算4个分数来定量判断路径上有bug的指示程度。然而路径运行失败不一定是bug，也可能是几个错误的谓语造成的路径运行失败<ul><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>e</mi><mi>n</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>i</mi><mi>t</mi><mi>y</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><msub><mi>F</mi><mi>e</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Sensitivity(p) = log(F_e(p))/log(F)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">))</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mclose">)</span></span></span></span></eq></li><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>o</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>x</mi><mi>t</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>F</mi><mi>o</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><msub><mi>F</mi><mi>o</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>+</mo><msub><mi>S</mi><mi>o</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Context(p) = F_o(p)/(F_o(p)+S_o(p))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mord">/</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">))</span></span></span></span></eq></li><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>n</mi><mi>c</mi><mi>r</mi><mi>a</mi><mi>s</mi><mi>e</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>F</mi><mi>e</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><msub><mi>F</mi><mi>e</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>+</mo><msub><mi>S</mi><mi>e</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>−</mo><mi>C</mi><mi>o</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>x</mi><mi>t</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Incrase(p) = F_e(p)/(F_e(p)+S_e(p)) - Context(p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.02778em;">cr</span><span class="mord mathnormal">a</span><span class="mord mathnormal">se</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mord">/</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span></eq></li><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>m</mi><mi>p</mi><mi>o</mi><mi>r</mi><mi>t</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>e</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>2</mn><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mi>I</mi><mi>n</mi><mi>c</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>s</mi><mi>e</mi><mo stretchy="false">(</mo><mo stretchy="false">)</mo><mi>p</mi></mrow></mfrac><mo>+</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>S</mi><mi>e</mi><mi>n</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>i</mi><mi>t</mi><mi>y</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Importance(p) = \frac{2}{1/Increase()p} + 1/Sensitivity(p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal">m</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mord mathnormal">t</span><span class="mord mathnormal">an</span><span class="mord mathnormal">ce</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3651em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1/</span><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">cre</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">se</span><span class="mopen mtight">(</span><span class="mclose mtight">)</span><span class="mord mathnormal mtight">p</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1/</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span></eq></li></ul></li><li>PREAMBL 的目标是辨识出对bug敏感的路径。如，该路径与多个失败的运行相关。<ul><li>然而，我们还希望具有特异性，即在许多成功运行中，没有被预测失败的路径</li><li>在信息检索中，结合specificity和sensitivity的标准方法是计算它们的谐波平均，因为这种度量优先考虑两个维度中的高分。度量指标 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>m</mi><mi>p</mi><mi>o</mi><mi>r</mi><mi>t</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>e</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Importance(p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal">m</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mord mathnormal">t</span><span class="mord mathnormal">an</span><span class="mord mathnormal">ce</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span></eq> 正好达到了这个目的</li></ul></li></ul><h4 id="a.-building-the-path-frequency-tree" tabindex="-1">A. building the Path Frequency Tree</h4><ul><li>PREAMBL为有效计算 variable-length paths,需快速决定 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>e</mi></msub><mo separator="true">,</mo><msub><mi>F</mi><mi>e</mi></msub><mo separator="true">,</mo><msub><mi>S</mi><mi>o</mi></msub><mo separator="true">,</mo><msub><mi>F</mi><mi>o</mi></msub></mrow><annotation encoding="application/x-tex">S_e,F_e,S_o,F_o</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 的值，谓词，其使用 path frequency tree 为每个观测到的谓语。<ul><li>每个路径频率树 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><msub><mi>p</mi><mi>i</mi></msub></msub></mrow><annotation encoding="application/x-tex">T_{p_{i}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></eq> 是一个数据结构，其保存了以某个谓词 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">p_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 开头的路径在失败运行 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mi>e</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F_e(p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span></eq> 和 成功运行 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>e</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S_e(p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span></eq> 中被执行的次数。</li><li>路径频率树中的每个节点表示程序路径中单个谓词 (pk = vk) 的值。</li><li>节点的父节点是路径中紧接在节点之前的谓词值。 每个子节点代表当前节点后续直接执行的谓词值</li></ul></li><li>当我们从跟踪文件数据中读取每个执行路径时，我们在给定路径的树上遍历时在每个节点上递增 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>e</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S_e(p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span></eq> 和 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mi>e</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F_e(p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span></eq> 的值。<ul><li>此外，我们根据执行成功或失败递增了树级别的 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>o</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S_o(p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span></eq> 和 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mi>o</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F_o(p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span></eq> 的值。</li></ul></li><li>查找路径(px = vx) ⇒ (py = vy) ⇒ … ⇒ (pz = vz)的这些值，PREAMBL首先会找到px的路径频率树。<ul><li>然后，我们从根节点px = vx的子节点开始遍历树，直到到达对应于pz = vz的节点为止。</li><li>此节点上存储的Se§和Fe§值将指示路径在成功和失败运行中分别执行的次数。我们可以使用这些值以及存储在根节点处的So§和Fo§来计算路径的Increase、Sensitivity和Importance。</li></ul></li><li>生成路径频率树的计算复杂度为O(n × l^2)，其中n是捕获的路径数，l是这些路径的最大长度。在实践中，PREAMBL分析所有测试应用程序所需的时间不到一分钟。<br><img src="/images/%E8%AE%BA%E6%96%87/invariant/1_4.png" alt></li></ul><h4 id="b.-generating-high-importance-sub-paths" tabindex="-1">B. Generating High-importance Sub-paths</h4><ul><li>建立好频率树后，我们遍历树寻找最大Importance路径</li><li>具体来说<ul><li>对于每个节点，我们计算Increase§。对于Increase &lt; 0的路径相应的节点，我们立即丢弃。</li><li>其他的则被添加到一个优先级队列中，该队列按照它们的Importance分数进行排序。</li><li>这个过程持续进行，直到所有路径频率树都被完全分析。</li><li>在这一点上，可以从优先级队列中查询出前几个结果。</li><li>这个过程的最坏时间复杂度是O(n log(n))，其中n是捕获的不同路径数。</li></ul></li></ul><h4 id="c.-mapping-bugs-to-invariants" tabindex="-1">C. Mapping Bugs to Invariants</h4><ul><li>高分的路径可以告诉程序员可能出现bug的路径，但也不一定有。</li><li>因此，PREAMBL将此错误定位信息联系到不变量。这些不变量将总结出希望的输出行为，这将允许用户比起重看代码更容易的理解代码在做什么</li><li>此外，由于生成的不变式是路径特定的，因此只显示与失败路径相关的特定不变式。如果不变式捕获了不良行为，那么以不变式的形式对行为进行总结可能会使开发人员更容易识别实现中的问题。</li></ul><h4 id="d.-case-study" tabindex="-1">D. Case Study</h4><ul><li>现在假设图4中错误已被修复，现在存在一个新函数，如下图，handle_input()将一个长整数，而不是一个整数传递给要转换的值。然而当值足够大的时候，long转int会移除，产生错误，接下来我们将展示如何使用PREAMBL来定位这个错误<br><img src="/images/%E8%AE%BA%E6%96%87/invariant/1_5.png" alt></li><li>当运行PREAMBL时，首先构建以可路径树，该村了成功和失败执行中每个执行路径的频率。如下图示，此时与错误高度相关的路径是(p2 = 1) ⇒ (p0 = 1) ⇒ (p1 = 0)，这准确匹配了bug在convert_units从if语句p2中调用并执行有效的非溢出转换时出现的观察结果<br><img src="/images/%E8%AE%BA%E6%96%87/invariant/1_6.png" alt></li><li>在这个例子中，为convert_units()生成的不变量是(p0 = 1 ∧ p1 = 0) ⇒ (result == 36 × result)。由于这个不变量描述了bug路径上result的行为，其与bug关联在一起呈现给开发人员。<ul><li>因此，PREAMBL向开发人员展示了bug的本地化路径和相应的预期行为。</li><li>此时，她可能会立即注意到传递给convert_units的长整数和使用的整数类型之间的类型不匹配。</li></ul></li></ul><h3 id="5-%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C" tabindex="-1">5 实验结果</h3><ul><li>为评估PREAMBL有效性，我们SIR[15]上进行了测试</li><li>我们使用SIR作为应用程序和bug的标准化存储库，以便与先前的bug检测工具进行比较[10]，[9]。</li></ul><h4 id="a.-invariant-quality" tabindex="-1">A. Invariant Quality</h4><ul><li>为检查PRECIS生成的应用程序的不变量的质量，我们对每个应用程序运行了测试套件的三分之一，生成了跟踪数据，并执行了谓词聚类导出不变量。</li><li>结果显示：生成的不变量数量与程序大小成比例增长，但即使对于大小相似的程序，变化也很大。我们发现这与每个程序的结构有关。<br><img src="/images/%E8%AE%BA%E6%96%87/invariant/1_7.png" alt><ul><li>例如，sed.c这样大量使用全局变量的程序往往生成的不变量数量极高，因为函数输出的数量较多</li></ul></li><li>我们将不变量的控制流图CFG覆盖率定义为 不变量触发的程序路径百分比<ul><li>覆盖率在应用程序间差异很大，对于控制流导向型程序，其中数据流主要通过线性运算符描述，覆盖率最高。</li><li>还检查了不变量的虚假程度，具体来说，我们将不变量的假阳性率定义为PRECIS生成的不变量在一个测试集的三分之一上失效的百分比，而在运行完整的测试集时无效。PRECIS生成的不变量具有很低的假阳性率：在所有情况下都不到10%。</li></ul></li></ul><h4 id="b.-regression-testing" tabindex="-1">B. Regression Testing</h4><ul><li>我们使用每个应用程序buggy版本来回归测试<ul><li>第一步是生成正确版本的不变量</li><li>然后对于每个buggy版本，映射不变量 谓语，输入和输出</li></ul></li><li>为了评估不变量在检测回归方面的有效性，我们运行测试套件同时检查生成的不变量。如果在测试运行期间任何不变量求值为假，则我们已经检测到了回归。<ul><li>对于不同的程序，检测覆盖率差异很大，如果程序控制流发生显著变化，检测覆盖率明显下降</li><li>此外，如果不变量是对指针密集算术的程序生成的，你们不变量将生成在指针的第一个元素上，如果对指针的第二个元素或其他元素进行更改，则检测覆盖率会降低。原则上，可以为所有指针元素生成不变量，但这将导致不变量生成的高开销。</li></ul></li></ul><h4 id="c.-bug-localization" tabindex="-1">C. Bug Localization</h4><ul><li>我们评估了PREAMBL使用的基于路径的定位计数的有效性，并测量了可以与不变量信息相关联的局部化错误百分比。为此，我们测量了这些错误中有多小可以定位到特定的子路径，并提供了关于这些子路径特异性的综合信息。</li><li>具体而言，我们将PREAMBL与先前提出的分析方案进行分析：[9]中使用的固定长度的函数内路径和[11]中使用的简单的单分支分析方案。所有三种技术都通过前5个导出路径的平均重要性得分进行评分。</li><li>表IV显示了几个基准测试的汇总结果。在每种情况下，PREAMBL生成了更高分数的结果。直觉上，按照重要性§度量的定义，路径的更高分数意味着路径对错误的更好预测，因此更好的错误定位，这反过来又意味着开发人员的调试开销更少。与HOLMES和CBI相比，PREAMBL生成的路径的更高分数表明了改进的错误定位。<br><img src="/images/%E8%AE%BA%E6%96%87/invariant/1_8.png" alt></li></ul><h3 id="6-%E7%BB%93%E8%AE%BA" tabindex="-1">6 结论</h3><ul><li>我们提出了一种通过使用程序不变量将错误定位和回归测试结合起来的技术。</li><li>我们建议将程序调试从发布前和发布后的阶段分开，提出了一种流程，在这些阶段中产生的调试信息可以一起使用，以提高软件的可靠性。</li></ul><h2 id="%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93" tabindex="-1">个人总结</h2><ul><li>本文延续它们之前的工作[1],一个动态不变量探测方法，再次扩展，随后提出了PREAMBL，一个使用不变量进行回归测试和错误定位的方法<ul><li>在回归测试中，使用不变量的失败作为回归的标志，需要进行不变量的映射（有时需要程序员的介入）</li><li>在错误定位中，使用路径频率树来统计路径的执行次数，通过计算路径的重要性来定位错误，随后将错误与不变量联系起来，以便开发人员更好的理解错误</li></ul></li></ul><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;using-automatically-generated-invariants-for-regression-testing-and-bug-localization&quot; tabindex=&quot;-1&quot;&gt;Using automatically generated in</summary>
      
    
    
    
    <category term="论文" scheme="http://example.com/categories/%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="Invariant" scheme="http://example.com/tags/Invariant/"/>
    
  </entry>
  
  <entry>
    <title>Daikon论文</title>
    <link href="http://example.com/2024/03/22/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/invariant/daikon%E8%AE%BA%E6%96%87/"/>
    <id>http://example.com/2024/03/22/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/invariant/daikon%E8%AE%BA%E6%96%87/</id>
    <published>2024-03-21T16:59:15.599Z</published>
    <updated>2024-03-21T16:59:55.794Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-the-daikon-system-for-dynamic-detection-of-likely-invariants" tabindex="-1">1 The Daikon system for dynamic detection of likely invariants</h2><ul><li>引用：Ernst M D, Perkins J H, Guo P J, et al. The Daikon system for dynamic detection of likely invariants[J]. Science of computer programming, 2007, 69(1-3): 35-45.</li></ul><h3 id="0-%E6%91%98%E8%A6%81" tabindex="-1">0 摘要</h3><ul><li>Daikon是一个动态检测不变量的工具</li><li>不变量是在程序的某个点或点上保持的属性；这些通常用于assert语句、文档和形式规范。例如包括常数（x = a）、非零（x ≠ 0）、处于范围内（a ≤ x ≤ b）、线性关系（y = ax + b）、排序（x ≤ y）、来自库的函数（x = fn(y)）、包含（x ∈ y）、排序（x 已排序）等。用户可以扩展Daikon以检查其他不变量。</li><li>动态不变量检测运行程序，观察程序计算的值，然后报告在观察到的执行中为真的属性。动态不变量检测是一种可以应用于任意数据的机器学习技术。Daikon可以检测C、C++、Java和Perl程序中的不变量，以及记录结构化数据源；很容易将Daikon扩展到其他应用程序中</li><li>不变量在程序理解和一系列其他应用中非常有用，Daikon的输出已经被用于生成测试用例，预测组建集成中的不完备出，自动化定理证明，修复不一致数据，检查数据流的有效性等</li><li>Daikon完全开源，有广泛的文档 <a href="http://pag.csail.mit.edu/daikon/">网址</a></li></ul><h3 id="1-%E4%BB%8B%E7%BB%8D" tabindex="-1">1 介绍</h3><ul><li>本文介绍Daikon：一个功能齐全，稳健的不变量检测工具</li><li>不变量可以阐释数据结构和算法，对手动和自动的变成人物，从设计到维护都是有用的，例如<ul><li>它们识别了在修改代码时必须保留的程序属性 （<strong>这里和debloating的联系？</strong>）</li></ul></li><li>尽管不变量有很多有点，但他们通常在程序中缺失。期望程序员完全使用不变量对代码进行注释的另一种选择是从程序执行中自动推断可能的不变量。对于某些重要的人物，动态推断的属性比人工编写的规范更可取</li><li>Diakon的输出是一组由执行跟踪在统计上证明的可能的的不变量。其结果可以用作文档，添加到程序源码作为断言，或用作其它工具的输入（见Section 4）</li></ul><h3 id="2-example" tabindex="-1">2 example</h3><ul><li>考虑一个名为<code>StackAr</code>的Java类，实习了一个具有固定大小的栈，其实现如下</li></ul><pre><code class="language-java">Object[] theArray; // Array that contains the stack elements.int topOfStack; // Index of top element. -1 if stack is empty.// 实现方法void push(Object x) // Insert xvoid pop() // Remove most recently inserted itemObject top() // Return most recently inserted itemObject topAndPop() // Remove and return most recently inserted itemboolean isEmpty() // Return true if empty; else falseboolean isFull() // Return true if full; else falsevoid makeEmpty() // Remove all items</code></pre><ul><li>使用<code>StackTester</code>类对该类进行测试，如</li></ul><pre><code class="language-bash">java DataStructures.StackArTester</code></pre><ul><li>随后使用Daikon在java的前端产生运行轨迹</li></ul><pre><code class="language-bash">java daikon.Chicory --daikon DataStructures.StackArTester</code></pre><ul><li>Daikon的输出包括过程的前置条件，后置条件，包括对象不变量，这些条件在每个公共方法的入口和出口出均成立。 下面为输出的部分内容，包括对象不变量和构造函数以及<code>ifFull</code>的方法的过程不变量</li></ul><pre><code class="language-java">    /* Object invariants for StackAr*/this.theArray != null  //在构造函数后，theArray不为null，可以安全地使用this.theArray.getClass() == java.lang.Object[].class // theArray的运行时类型是Object[]，ava允许运行时类型是声明类型的子类，但在StackAr中从未发生过这种情况。this.topOfStack &gt;= -1this.topOfStack &lt;= this.theArray.length - 1 // topOfStack的值在数组的范围内this.theArray[0..this.topOfStack] elements != null //所有的栈元素都不为null，这是因为测试套件的结果，而不是StackAr的实现，这是有意义的，指出了测试套件的不足this.theArray[this.topOfStack+1..] elements == null // 不在栈中的元素都是null，我们可以推断pop后的元素会置为null，方便垃圾回收    /* Pre-conditions for the StackAr constructor*/capacity &gt;= 0 // 在构造函数前，为使用负容量创建StackAr    /* Post-conditions for the StackAr constructor*/orig(capacity) == this.theArray.length //包含栈的数组的大小等于指定的容量。this.topOfStack == -1 // 初始化后，栈为空this.theArray[] elements == null// 初始化后，数组中的所有元素都是null    /* Post-conditions for the isFull method*/this.theArray == orig(this.theArray) //数组的引用没有被修改，仍然与方法调用前相同。this.theArray[] == orig(this.theArray[])//数组的内容没有被修改，仍然与方法调用前相同。this.topOfStack == orig(this.topOfStack)//索引没有被修改，仍然与方法调用前相同。(return == false) &lt;==&gt; (this.topOfStack &lt; this.theArray.length - 1)(return == true) &lt;==&gt; (this.topOfStack == this.theArray.length - 1)// 返回值成立的条件</code></pre><h3 id="3-daikon%E7%9A%84%E5%85%B3%E9%94%AE%E7%89%B9%E5%BE%81" tabindex="-1">3 Daikon的关键特征</h3><h4 id="3.1-%E8%AE%B8%E5%A4%9A%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E5%85%B6%E5%AE%83%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E7%9A%84%E8%BE%93%E5%85%A5" tabindex="-1">3.1 许多编程语言和其它数据格式的输入</h4><ul><li>Daikon可以处理C、C++、Java和Perl程序计算可能的不变量（见5.1）</li><li>Daikon还可以处理来自电子表格（如Excel）的数据，使用CSV（逗号分隔值）格式</li><li>当在非由程序生成的数据上运行Daikon是很方便的</li><li>Daikon支持新的编程语言和数据格式，已经有几个用户这样做了（见第5.3节）。</li></ul><h4 id="3.2-%E4%B8%B0%E5%AF%8C%E7%9A%84%E8%BE%93%E5%87%BA" tabindex="-1">3.2 丰富的输出</h4><ul><li><p>Daikon的主要目标是报告具有表现力和有用的输出。报告的不变量取决于不变量检测器表达的不变量语法，检测的变量，以及检测不变量的程序点。接下来讨论每个因素</p></li><li><p><strong>Grammar of properties 属性语法</strong>：Daikon检查75中不同的不变量，包括摘要中的，同时用户可以轻松的扩展。检查大量的不变量可以增添人工或工具使用不变量的可能性，同时也增加了不变量检查的世界爱你。Daikon进行了性能优化以支持大量的不变量</p></li><li><p>Daikon还包括条件不变量或蕴含式，如 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>h</mi><mi>i</mi><mi>s</mi><mi mathvariant="normal">.</mi><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo mathvariant="normal">≠</mo><mi>n</mi><mi>u</mi><mi>l</mi><mi>l</mi><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi>t</mi><mi>h</mi><mi>i</mi><mi>s</mi><mi mathvariant="normal">.</mi><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi mathvariant="normal">.</mi><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mo>≤</mo><mi>t</mi><mi>h</mi><mi>i</mi><mi>s</mi><mi mathvariant="normal">.</mi><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">this.left \neq null \implies this.left.value \leq this.value</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">hi</span><span class="mord mathnormal">s</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7184em;vertical-align:-0.024em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.01968em;">ll</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">hi</span><span class="mord mathnormal">s</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">t</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">hi</span><span class="mord mathnormal">s</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span></span></span></span></eq>. Daikon具有某些内置谓词，用于查找蕴含式；例如，哪个return语句在过程中被执行以及布尔过程是否返回true和false。此外，Daikon可以从文件中读取谓词，并根据这些谓词查找蕴涵关系[1]。这些谓词可以通过手动或使用Daikon配备的工具生成，例如通过对程序的静态分析或对执行跟踪的值进行集群分析</p></li><li><p><strong>Grammer of variables</strong>：不变量检测器可以表达的不变量必须被实例化为特定的值或其它值。例如 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x\in y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span></eq> 是在两个变量上实例化的，那么第二个必须是集合，Daikon可以处理以下类型不变量</p><ul><li>过程参数和返回值</li><li>前状态值（用orig表示），这运行报告过程副作用和输入输出关系</li><li>全局变量</li><li>字段（给定对象a，有用的附加信息出现在a.f,a.g等中）</li><li>对没有副作用的（pure，observer）的方法，如size()</li><li>衍生变量（共25个），如给定数组a和整数lasti，则对a[lasti]的不变量可能是感兴趣的，即使它不是一个变量，甚至可能不会出现在程序中<ul><li>这些变量类型可以组合使用，例如 a.b[myObject.getX()]。</li><li>Daikon可以控制是否仅考虑公共字段/方法（提供数据结构的外部，客户端试图），或者包括四有字段，方法（提供数据结构内部，实现试图）</li><li>另一个开关控制检查字段和纯方法的调用深度</li></ul></li></ul></li><li><p><strong>程序点</strong>：Daikon在程序的入口和出口检查不变量，从而产生与前置条件和后值条件相对应的可能不变量。</p><ul><li>它在每个过程出口处（即返回语句），和通过个别出口进行概括从而聚合出口处（由客户端视角查看）处计算不变量</li><li>可能的对象或类不变量也在聚合程序点（对象点）处计算，对象点概括了在类的公共方法的入口和出口出观察到的所有对象，在传递到其他类的方法中或从其他类的方法返回的对象，或者存储在对象字段中的对象。</li></ul></li></ul><h4 id="3.3-scalable-%E6%89%A9%E5%B1%95%E6%80%A7" tabindex="-1">3.3 Scalable 扩展性</h4><ul><li>尽管在3.2描述了丰富的输出，Diakon可以扩展到非平凡程序。</li><li>例如，Daikon被用于为 美国宇航局阿姆斯研究中心开发的Center-TRACON自动化系统（CTAS）生成部分一致性规范（见第4.6节）[2]。CTAS是一套超过100万行C和C++代码的空中交通管制工具。</li><li>将Daikon应用到大型程序上，往往需要将其集中在程序的子集上，后减少Daikon考虑的派生变量甚至不变量的数量。所有这些可以通过命令行完成</li></ul><h4 id="3.4-%E4%B8%8D%E5%8F%98%E9%87%8F%E7%AD%9B%E9%80%89" tabindex="-1">3.4 不变量筛选</h4><ul><li>动态不变量检测技术针对观察到的运行时值测试不变性。 与任何动态分析或机器学习技术一样，存在过拟合（泛化过度）的可能性，即在训练中运行为真但在一般情况下不为真的属性。<ul><li>例如，如果对特定变量的观察次数不够，那么观察到的模式可能只是巧合。</li><li>Diakon通过计算零假设测试（一个属性在随机输入中的概率），然后仅在其概率小于用户定义的置信参数时报告该属性，来缓解这个问题。</li></ul></li><li><strong>Redundant invarints</strong>:可以被其它不变量逻辑推出的不变量可以从输出中删除，而不会丢失信息。Daikon尽可能的不计算冗余不变量，这样可以提高性能（见5.2）。 某些优化无法处理的冗余项将在通过post-processing阶段删除。</li><li><strong>Abstract types</strong>：程序中的许多变量之间没有关系。例如。变量temp可能为当前温度，而time为自1970年以来的秒数，尽管存在 temp&lt; time 这个不变量，但这并没有什么意义。Daikon可以使用抽象类型信息[3]将不变量限制为相关变量，Daikon包里包括了计算抽象类型的工具</li></ul><h4 id="3.5-%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F" tabindex="-1">3.5 输出格式</h4><ul><li>Daikon支持多种输出格式，也可以添加新的格式(见5.3)<ul><li>Daikon：默认格式，带有两次和其它功能</li><li>DBC。为Parasoft的Jtest工具设计的契约格式[4]。</li><li>ESC。用于ESC/Java工具的扩展静态检查器格式[5]。</li><li>IOA。用于建模输入/输出自动机的IOA语言，也可以转换为Isabelle定理证明器的语言。</li><li>Java。可在Java程序中使用的Java表达式，例如作为断言。</li><li>JML。Java建模语言[6]格式，被许多工具[7]使用。</li><li>Repair。自动数据结构修复工具[2]使用的格式。</li><li>Simplify。Simplify自动定理证明器的格式[8]。</li></ul></li><li>Daikon附带的annotate工具将可能的不变性插入源代码作为注释。</li></ul><h4 id="3.6-%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%80%A7" tabindex="-1">3.6 可移植性</h4><ul><li>Daikon可以在各种平台上轻松移植<ul><li>Daikon的推理引擎和Java工具由Java编写</li><li>Perl工具是用Perl编写的，这两种语言非常易于移植。</li><li>一个C工具限定Linux/x86平台，另一个可以在任何可用Purify的平台上移植，包括Windows、Linux和几种商业Unix变体。</li></ul></li></ul><h3 id="4-%E4%BD%BF%E7%94%A8" tabindex="-1">4 使用</h3><ul><li>Daion生成的不变量时程序规范的一种动态特征。</li><li>特征被广泛地认为在程序开发过程中是很有价值的，包括设计，编码，验证，测试，优化和维护。它们还增强了程序员对数据结构，算法，和程序操作的理解。然而在实践中，正式的特征规范很少可用，因为他们写起来费时费力，而且即使可用，也无法捕获程序正确执行所依赖的所有属性。</li><li>动态生成的特征与理想静态特征规范不同。动态规范不仅会揭示有关目标行为的信息，还会揭示关于特定实现和在程序运行环境（输入）下的信息。对于许多任务（如改进测试套间或某些调试任务），动态信息甚至比静态信息更有帮助</li></ul><h4 id="4.1-documentation" tabindex="-1">4.1 Documentation</h4><ul><li>不变量表示程序运行的某些方面，并提供了对程序操作，算法，数据结构的文档化。因此，他们可以帮助程序理解,而对程序理解的程度是与每个变成任务的先决条件。而从运行中自动提取的信息一定是最新的。</li><li>即使对已经用注释，断言语句或规范文档化的代码，自动推断不变量也是有用的。推断出的不变量可以检查或细化程序员提供的不变量；程序自我检查通常是过时的，无效的或不正确的[9]</li></ul><h4 id="4.2-avoid-bugs" tabindex="-1">4.2 avoid bugs</h4><ul><li>不变量可以保护程序员对程序正确行为所依赖的假设进行意外更改产生的影响。如果原始不变量没有被记录，更不用说依赖了，那么程序员就很容易违反它们，从而在程序的远程部分引入错误</li><li>程序维护引入的错误[10,11],其中其多是由违反程序不变量引起的。而当程序员参照Daikon输出，可以尽可能的避免破坏这些不变量[12]</li></ul><h4 id="4.3-debugging" tabindex="-1">4.3 Debugging</h4><ul><li>尽管最好是在第一次就避免错误，不变量也可以帮助调试。<ul><li>Raz等人使用Daikon检查数据流中的一致性输入[13]</li><li>许多作者利用 训练运行和实际运行之间推断的不变量的不一致性作为程序错误的指标，应该引起人们的注意[14-16]</li></ul></li><li>动态检测到的不变量也可以帮助理解或定位错误。<ul><li>Groce使用连续成功和失败的运行之间的差异来简介解释测试失败[17]</li><li>Xie比较内部组件的行为，以定位程序版本之间的差异并格里错误[18]</li><li>Libit提供了一种轻量级的方法来确定哪些属性表明存在错误[19]</li><li>Brun使用正确和错误的程序上的机器学习来预测不同程序中最有可能出现的错误[20]</li></ul></li></ul><h4 id="4.4-testing" tabindex="-1">4.4 Testing</h4><ul><li>动态检测到的不变量可以像测试套件一样揭示程序自身，因为这些属性显示了程序在测试套件上的执行情况。这些信息在测试中是有用的。<ul><li>如果测试套件覆盖了程序的每个语句或路径，但对程序值覆盖不足，则存在缺陷。例如，“x&gt;0”可以表示从未尝试过零和副值，“x&lt;10”表明从未尝试过大值</li><li>此外，这些属性还准确指示了测试套件需要改进的输入。 推断的不变量还可以作为一种覆盖度度量指标，例如用于测试选择和优先级排序；更多的覆盖度量指标会产生更好的测试套件[21,22]。动态检测到的不变量还可以帮助删除无意义的测试（违反前提条件）并推断何时失败（违反后置条件）[23]</li></ul></li></ul><h4 id="4.5-verification" tabindex="-1">4.5 Verification</h4><ul><li>动态不变量检测基于程序执行提出可能的不变量，但由此得到的属性不能保证在所有可能的执行中都为真。静态检查可以验证属性是否始终为真，但为静态检查器选择输入目标并注释程序会变得很困难和繁琐。将两种技术结合起来可以克服每种技术的缺点，动态检测到的不变量可以为程序进行注释或提供静态验证的目标，而静态验证可以确认动态工具提出的属性是否正确。</li><li>我们已经尝试过几种程序验证器，对于Java程序和ESC/Java[5]，Daikon的精度（可以证明的属性的百分比）超过95%，其中不能证明的属性通常是由于证明器的不完备性，其召回率（找到用于程序验证的属性百分比）超过90%[24]。此外，使用Daikon输出的用户在程序验证任务上统计表现更好[25]。对于证明助手工具，约90%的引理和策略是自动生成的[26]，用于三种分布式算法的证明。</li></ul><h4 id="4.6-data-structure-and-control-structure-repair" tabindex="-1">4.6 Data structure and control structure repair</h4><ul><li>损坏的数据结构导致程序执行不正确或不可预测。<ul><li>数据结构修复可以更新损坏的数据结构，使得程序能够继续以可接受的方式执行。然而，这需要用户提供规范</li><li>Daikon的输出使得整个过程可以自动化，同时允许人工审查。相对于手动生成而言，使用Daikon可以使得程序更加健壮，成本更低。</li></ul></li><li>另一个相关用途是在根据环境输入动态选择模式的程序中。<ul><li>来自训练集中的运行动态监测到的不变量可以指示哪些模式与外部条件相关联</li><li>在运行时，偶尔覆盖程序（不一致）的行为，在现实世界中可以将性能提升50%以上[27]。</li></ul></li></ul><h3 id="5-architecture" tabindex="-1">5 Architecture</h3><ul><li>Daikon通过对程序进行插装，跟踪特定变量，随后运行程序推断关于插装变量和程序中未显现的衍生变量的不变量。</li><li>所有的步骤都是完全自动（除过运行程序的要求，例如其输入），所以实际上用户只需要发出一个类似于运行原始程序的命令（见 2）</li></ul><h4 id="5.1-instrumenters%EF%BC%88%E6%8F%92%E6%A1%A9%E5%B7%A5%E5%85%B7%EF%BC%89" tabindex="-1">5.1 Instrumenters（插桩工具）</h4><ul><li>Instrumenters是针对特定语言，现在的Daikon提供了对C/C++，Java和Perl的Instrumenters。<ul><li>其中一些Instrumenters是基于源代码的：其会创建一个新版本的源代码，随后进行编译，连接和运行。</li><li>其它的Instrumenters直接操作可执行文件，其更易使用，但更会基于特定平台</li></ul></li><li>Instrumenters的基本任务是向目标程序添加指令，以便它输出变量的值。这些跟踪信息直接传送到推理引擎，避免了磁盘存储的紧张。或者跟踪信息也可以输出到文件中（见3.2），允许对多次运行进行重复处理或组合处理</li><li>为了获得良好的覆盖率，有时需要对目标程序使用多个输入进行多次运行。在类似C/C++语言中，无法仅通过检查指针或数组索引来确定其是否有效。这种情况下，Instrumenters必须增强目标程序，以确定每个指针是否引用了有效的内存以及每个数组的范围。</li></ul><h4 id="5.2-inference-engine" tabindex="-1">5.2 Inference engine</h4><ul><li><p>推理引擎读取Instrumenters输出的跟踪信息，随后推断可能的不变量。将特定与语言的Instrumenters和推理引擎分开使其具有可移植性，并且还使得Daikon可以轻松扩展到新的语言和数据格式。需要注意的是，虽然Daikon是整个系统的命令，但也可以特指推理引擎</p></li><li><p>其基本思想是使用生成和检查算法来针对跟踪数据测试一组潜在的不变量。Daikon报告那些在经过足够检验而没有被推翻的不变量。与其它动态方法（如性能分析）一样，结果的准确性部分取决于测试用例的质量和完整性。即使是一般的测试套件在实践中也能产生良好的结果[25,24]，并且存在创造好的测试套件来推断不变量的方法[21,28,22]。</p></li><li><p>一种简单的动态不变量检测算法明确地将不变量语法中每个不变量表示出来：它最初假设所有潜在不变量都为真，并针对每个样本的每个不变量进行测试。任何被否定的不变量都会丢弃。在处理结束时报告剩余的不变量。然而这种算法的可扩展性步枪</p></li><li><p>Daikon经过一系列优化使其能够适用于大量不变量和复杂程序，这些优化基于一个事实：简单的算法检查并报告了许多不必要的不变量。许多不变量是冗余的，无需检查，这些优化将需要检查的不变量数量减少了99%</p></li><li><p>有四个主要优化：</p></li><li><p><strong>Equql variables 相等变量</strong>:如果两个或多个变量始终相等，则对于其中一个变量为真的任何不变量也适用于其它。如x=y,则对于任何不变量f，f(x)=f(y)</p></li><li><p><strong>Dynamically constant variables 动态常量变量</strong>：动态常量变量在每个观察样本具有相同的值。不变量x=a（a为常量）使得对x的任何其它不变量都是多余的。如x=5，则odd(x),x&gt;=5。对于变量组合也是如此：x=5,y=6,则x&lt;y,x=y-1</p></li><li><p><strong>Variable Hierarchy 变量的层次结构</strong>某些变量值会对多个程序点的不变量产生影响。例如，在(公共)方法退出时观察到的值不仅影响方法后值条件，还影响对象不变量。对于两个程序点A和B，如果B的样本也出现在A，则A为真的任何不变量在B处也为真，则在B处是多余的</p></li><li><p><strong>Suppression of weaker invariants 抑制较弱的不变量</strong>：如果一个不变量在逻辑上被其它不变量蕴含，则该不变量会被抑制（前三个例子都是该条件的特里）。例如x&gt;y则x&gt;=y,及0&lt;x&lt;y和z=0则x div y = 0</p></li></ul><h4 id="5.3-extensibility" tabindex="-1">5.3 Extensibility</h4><ul><li>Daikon的主要设计目标就是可扩展性，因为动态不变量检测是一个新型活跃的领域，Daikon以以下方式进行扩展</li><li><strong>Instrumenters 插装工具</strong>：对于新语言或其它数据，只需要输出Daikon输入格式的文件即可。例如，已经为电子表格数据，Linux库调用[30],Java PathFinder模型检查器[17]和在线数据源[13]添加了插装工具</li><li><strong>不变量</strong>：Diakon不变量语法中的每个属性都作为Invariant抽象基类的子类实现，进一步的子类将相似不变量分组。这些子类提供了不变量所需的大部分代码。一个新的不变量必须提供基本功能，例如check modified方法，该方法检查一个元组的值是否和不变量一致</li><li><strong>派生变量</strong>：是Daikon视为变量的表达式，见3.2。与不变量一样，类结构使得通过几个方法即可添加新的派生变量</li><li><strong>输出格式</strong>：新的输出格式(见3.5)只需为每个不变量添加一个新的格式方法即可</li><li><strong>抑制</strong>：如5.2所述，如果某个不变量在逻辑上蕴含了其它不变量，则被蕴涵的不变量被抑制。每种不变量都可以指定一组可能的抑制。每个抑制都是一组前提不变量，共同推出一个结论不变量。通过列出勾成抑制的前提不变量，则不变量被抑制</li><li><strong>模块化</strong>：Daion的设计使其易于作为另一个工具的另一部分使用。其入口处都有一个相应的mainHelper方法，可以以编程方式调用，且永远不会调用System.exit。肯呢个的不变量被写入序列化文件，便于编程使用。有超过100个配置选项可以控制Daikon的行为，Daikon为开源的，允许用户进行更改，并向Daikon贡献新的代码</li></ul><h3 id="6-%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B" tabindex="-1">6 开发过程</h3><ul><li>Daikon被设计为一个长期的，功能健全的，健壮的研究工具。尽管学术研究环境充满挑战（例如，许多短期开发人员，每个人都有非常具体的工作重点），但其开发过程的设计确保其设计目的。该过程关键有<ul><li>月度发布：Daikon每个月会发布一个新版本，这确保构建过程是干净的，文档是最新的，其还有一个及时解决问题的激励</li><li>文档：Daikon有广泛的用户和开发者手册，此外还有描述其算法和使用的技术论文，手册的部分内容是从源代码文档自动创建的，以确保正确性</li><li>支持：存在几个由版主管理的邮件列表，用于用户和开发者的交流。大多数问题会在几天内得到恢复。</li><li>回归测试：每晚会对推理引擎和插装工具进行回归测试，并且在提交代码更改之前由开发人员进行测试。由于其CVS历史和回归测试，Daikon在许多论文中被用作测试对象</li></ul></li></ul><h3 id="7-%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%E6%AF%94%E8%BE%83" tabindex="-1">7 相关工具比较</h3><ul><li>由Agitar开发的Agitator产评受到了Daikon的启发[31].Agitar执行动态不变量检测，以便向用户通报测试情况，并改进这些测试。结果称之为“观察”，其包括等式x=y,范围-10&lt; x &lt; y,非空 x！=null，等式.equal，以及从用户源代码收集的属性。Agitar获得了《华尔街日报》2005年软件技术创新奖</li><li>DIDUCE工具[14]用于Java程序，检查一个一元不变量，该不变式会指出所有以前见过的值的每一位的值。在每个程序点（字段或数组引用，或过程调用），都会检查该不变量的三个值：变量当前值，上一个值，二者间茶之。随着不变量的弱化（在观察位置发现新值），打印一条信息。用户可以寻找错误运行中或错误发生之前打印不变量的弱化，发现罕见的边界错误。该工具被用于解释几个已知错误，并揭示了两个新错误。</li><li>IODINE工具[32]使用动态分析从硬件设计中提取可能的设计属性，它寻找如状态机协议，请求-确认对，信号之间的互斥这样的属性。IODINE被用来为双核SPARCTM处理器的一个模块寻找动态不变量</li><li>Remote program sampling[19]是一种轻量化的方法,用于评估C程序中的两种属性，并计算满足每种属性的次数。这些属性是概率性检查的：在大多数程序的执行点中，属性检查会被跳过。其它任何实现都可以进行类似的扩展,牺牲在测试套件上的准确性，但提高了性能。结果通过统计分析进行处理，因此可能导致错误。</li><li>Henkel和Diwan [33,34]构建了一个工具，用于发现代数规范，这些规范描述了代码操作序列的含义，如pop(push(x,stack))=stack。该工具从Java类的签名生成许多术语（测试用例），并根据测试结果提出方程式。该工具还提出并测试泛化。</li><li>SPIN模型检查器已经扩展到检查两个变量是否由=、&lt;、&gt;、≤或≥相关联[35]。输出是一个节点上有变量、边缘上带有比较关系的图。</li><li>一些研究人员从程序或系统跟踪中推断出有限状态自动机，表示允许的转换[36-39]。以自动机形式编写的规范与动态不变量检测器生成的基于公式的程序属性相辅相成。</li><li>Perracotta [40]与此类似，只是它寻找响应属性模式的一组扩展，而不是自动机。</li></ul><h3 id="8-%E7%BB%93%E8%AE%BA" tabindex="-1">8 结论</h3><ul><li>Daikon是一个功能齐全、可扩展且健壮的动态不变量检测工具。它支持多种编程语言，并且可以很容易地扩展到其他语言和数据源。它生成的可能不变量已经在从重构到测试到数据结构修复等多个上下文中使用过。</li><li>Daikon可以从http://pag.csail.mit.edu/daikon/ 免费下载。该发行版包括源代码和大量文档，而且Daikon的许可证允许无限制使用。</li></ul><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-the-daikon-system-for-dynamic-detection-of-likely-invariants&quot; tabindex=&quot;-1&quot;&gt;1 The Daikon system for dynamic detection of likely in</summary>
      
    
    
    
    <category term="论文" scheme="http://example.com/categories/%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="Invariant" scheme="http://example.com/tags/Invariant/"/>
    
  </entry>
  
  <entry>
    <title>人工分类动态不变量的用户研究</title>
    <link href="http://example.com/2024/03/21/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/invariant/%E4%BA%BA%E5%B7%A5%E5%88%86%E7%B1%BB%E5%8A%A8%E6%80%81%E4%B8%8D%E5%8F%98%E9%87%8F%E7%9A%84%E7%94%A8%E6%88%B7%E7%A0%94%E7%A9%B6/"/>
    <id>http://example.com/2024/03/21/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/invariant/%E4%BA%BA%E5%B7%A5%E5%88%86%E7%B1%BB%E5%8A%A8%E6%80%81%E4%B8%8D%E5%8F%98%E9%87%8F%E7%9A%84%E7%94%A8%E6%88%B7%E7%A0%94%E7%A9%B6/</id>
    <published>2024-03-21T08:46:16.243Z</published>
    <updated>2024-03-21T16:54:03.119Z</updated>
    
    <content type="html"><![CDATA[<h2 id="understanding-user-understanding%3A-determining-correctness-of-generated-program-invariants" tabindex="-1">Understanding user understanding: determining correctness of generated program invariants</h2><ul><li>引用：Staats M, Hong S, Kim M, et al. Understanding user understanding: determining correctness of generated program invariants[C]，Proceedings of the 2012 International Symposium on Software Testing and Analysis. 2012: 188-198.</li><li>等级：CCF A ISSTA</li><li><a href="https://orbilu.uni.lu/bitstream/10993/10975/1/staats-invariant-understanding-issta-2012.pdf">链接</a></li></ul><h3 id="1-%E4%BB%8B%E7%BB%8D" tabindex="-1">1 介绍</h3><ul><li>问题：软件测试涉及两部分，test input 和 test oracle，测试输入有很多自动化方法，而test oracle没有</li><li>最近：出现程序不变量推断的相关研究，可以帮助生成test oracle</li><li>问题：现有不变量推断方法需要人为参与，存在以下两个原因：<ul><li><ol><li>不变量应该是一种规范，但是是从我们需要验证的源代码中产生的</li></ol></li><li><ol start="2"><li>许多现有方法是动态的，只是从有限的运行轨迹中推测出可能的不变量。</li></ol><ul><li>一项研究表明，0-60%的不变量在现实软件中是错误的，平均有10%[26]</li></ul></li><li>因此，自动不变量生成技术产生的不变量不适合做oracle，最后还得人工筛选不变量</li></ul></li><li>综上，当 user classification effectiveness，用户分类不变量的能力（分辨正确不变量的能力）好的时候，自动不变量生成技术才能真正发挥作用。<strong>然而，目前关注很少</strong>。<ul><li>早些工作探讨了用户使用动态不变量生成作为静态验证辅助工具的能力，得出的结论是区分正确和错误的不变量对用户来说是“相对容易的”[23]。遗憾的是，这项研究没有严格考虑用户的有效性，并且它是使用静态分析工具进行的，这些工具并不总是可用的</li></ul></li><li>本论文中展示两项经验性研究的成果，30人参与用户分类有效性的研究。这项工作目标有两个<ul><li><ol><li>确定使用动态不变量生成技术产生的不变量的用户分类有效性</li></ol></li><li><ol start="2"><li>了解导致分类成功或失败的原因</li></ol></li><li>实验内容：<ul><li><ol><li>给参与者提供3个Java程序之一，用Daikon生成不变量，要求参与者判断不变量是否正确</li></ol></li><li><ol start="2"><li>分析评估有效性的因素</li></ol></li></ul></li><li>关键结果：<ul><li><ol><li>与先前研究结果相反，用户在正确分类不变量方面遇到了困难</li></ol><ul><li>因此，为了减少人工检测不正确不变量的需求，除改进不变量生成技术外，还可以通过开发帮助用户理解不变量为何是正确的工具来改进</li></ul></li><li><ol start="2"><li>导致不变量错误分类的因素很微妙</li></ol></li></ul></li></ul></li><li>本文贡献<ul><li><ol><li>两项用户调研，调查用户准确分类，动态不变量检测中不变量的能力</li></ol></li><li><ol start="2"><li>证据表明：用户很难对正确的和不正确的不变量进行分类，与先前工作矛盾</li></ol></li><li><ol start="3"><li>对影响用户有效性的几个因素进行了分析</li></ol></li><li><ol start="4"><li>对结果讨论，讨论影响有效性的因素，突出了改善动态不变量生成的可用性的潜在方法</li></ol></li></ul></li></ul><h3 id="2-%E7%9B%B8%E5%85%B3%E5%B7%A5%E4%BD%9C" tabindex="-1">2 相关工作</h3><ul><li>介绍了不变量生成技术</li><li>上一个不变量用户研究[23]，其使用静态分析工具，得出的结果是好的，不适用于本文</li></ul><h3 id="3-%E7%A0%94%E7%A9%B6%E8%AE%BE%E8%AE%A1" tabindex="-1">3 研究设计</h3><ul><li>3个问题<ul><li>RQ1 How effective are users at classifying correct and incorrect invariants?</li><li>RQ2 How is user classification effectiveness influenced by program complexity/size?</li><li>RQ3 How does the difficulty of classifying invariants vary?</li></ul></li></ul><h4 id="3.1-%E5%AE%9E%E9%AA%8C%E6%80%BB%E8%A7%88" tabindex="-1">3.1 实验总览</h4><ul><li>用户研究实验细则，过</li></ul><h4 id="3.2-java%E6%A0%B7%E4%BE%8B%E7%A8%8B%E5%BA%8F" tabindex="-1">3.2 Java样例程序</h4><h4 id="3.3-%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E4%B8%8D%E5%8F%98%E9%87%8F%E7%94%9F%E6%88%90" tabindex="-1">3.3 使用动态不变量生成</h4><ul><li>使用Daikon的原因<ul><li><ol><li>First, Daikon is the most mature and well documented freely available toolset, with a large body of related research [9, 10, 23, 26].</li></ol></li><li><ol start="2"><li>Second, Daikon supports Java, which is familiar to our study participants</li></ol></li><li><ol start="3"><li>Third, Daikon’s approach has been adopted by commercial tools, specifically Agitator [3], and thus represents a tool likely to be used in practice.</li></ol></li><li><ol><li>Daikon是最成熟且文档全面可用的工具，有很多相关研究</li></ol></li><li><ol start="2"><li>可以使用在Java，参与者熟悉</li></ol></li><li><ol start="3"><li>已应用在实际</li></ol></li></ul></li><li>使用Randoop test input generation tool [24]生成测试用例，因为其是Java生成测试用例的成熟工具。每个程序生成1000个测试用例。 为什么是1000，因为不变量正确性在 64.7% - 83.3%，需要足够多的测试用例来产生一些错误的不变量</li><li>Diakon可以产生3种类型的不变量：<ul><li>method precondition</li><li>method postcondition</li><li>class invariant</li><li>本实验中去除了method precondition，因为其不容易理解</li></ul></li><li>Diakon输出采用 Java Modeling Language（JML）<ul><li>因其容易理解，且可以使用 JML 扩展编译 Java 来在测试期间检测到不变量的违规</li></ul></li></ul><h4 id="3.4-determining-invariant-correctness" tabindex="-1">3.4 Determining Invariant Correctness</h4><h4 id="3.5-experiment-procedure" tabindex="-1">3.5 Experiment Procedure</h4><h4 id="3.6-threats-to-validity" tabindex="-1">3.6 Threats to Validity</h4><h3 id="4-results" tabindex="-1">4 Results</h3><h4 id="rq1" tabindex="-1">RQ1</h4><ul><li>假设和零假设 Hypothesis &amp; null Hypothesis<ul><li>Hypothesis: 用户在分类正确不变量时比分类错误不变量时有效</li><li>null Hypothesis: 用户对不正确和正确不变量的正确分类百分比分布相同。</li></ul></li><li>假设成立</li></ul><h4 id="rq2" tabindex="-1">RQ2</h4><ul><li>Hypothesis:小的简单的程序比大的复杂的程序更容易分类</li><li>null Hypothesis:程序大小和复杂度不同的程序不变量正确分类分布相同</li><li>现有结果二者均不能明显支持（TODO：我还没看程序大小到底多大）</li></ul><h4 id="rq3" tabindex="-1">RQ3</h4><ul><li>我们预期不变量往往要么显然正确或错误，因此非常容易分类，要么非常难分类，因此大多数用户都会错误分类。换句话说，我们预期每个子图都呈双峰分布，大多数不变量几乎被所有用户正确分类（接近100%，“容易”），或者几乎没有被任何用户正确分类（接近0%，“困难”），中间很少。</li><li>然而，图中显示，我们的预期在任何研究、案例示例或不变量正确性的组合中都没有得到满足。</li><li>因此，似乎没有一些特定的生成不变量类型X会导致所有用户都遇到困难的子集，需要确定与用户分类困难相关的因素</li></ul><h3 id="5-discussion" tabindex="-1">5 Discussion</h3><p>在本节中，我们将研究与用户效果和不变量难度相关的其他潜在因素。在接下来的部分，我们将讨论我们结果的含义。</p><h4 id="5.1-establishing-a-pattern-of-difficulty-%E5%BB%BA%E7%AB%8B%E9%9A%BE%E5%BA%A6%E6%A8%A1%E5%BC%8F" tabindex="-1">5.1 Establishing a Pattern of Difficulty 建立难度模式</h4><ul><li>本研究的主要目标之一是确定与用户效果相关的因素。<ul><li>然而，我们需要首先确定是否存在这样的因素<ul><li>为此我们首先确定用户现过与不变量分类之间的难度是否存在关系（以用户错误分类的百分比衡量），难得不变量不易分类，简单的不变量容易分类</li></ul></li><li>由于没有难易不变量得存在，因此，我们无法确定与用户效果相关的因素</li></ul></li><li>为此我们根据以下假设建立难度模式，并进行实验验证，结果不是很明显</li><li>Hypothesis: 不变量I的错误分类用户百分比与所有检查I的用户的平均总体效果正相关</li></ul><h4 id="5.2-statistical-analysis" tabindex="-1">5.2 Statistical Analysis</h4><ul><li>在单一因素和组合因素下，没有产生强有力的预测关系</li></ul><h4 id="5.3-manual-analysis" tabindex="-1">5.3 Manual Analysis</h4><ul><li>在我们的初步分析之后，我们对每个不变量进行了手动检查，试图找出用户误分类不变量的定性原因。特别是，我们对高比例的用户（&gt;80%）倾向于误分类的不正确生成的不变量感兴趣。每位作者都独立进行了这项任务，发现了几种在这种情况下出现的模式<ul><li>模式1：对于信号异常状态的特定返回值的非排他性使用。</li><li>模式2：直接、未经检查地操纵类变量值。</li><li>模式3：不变量实用函数的潜在意外行为。</li></ul></li><li>由此推断，当使用动态不变量生成时，应注意<ul><li><ol><li>用户理解不变量语义</li></ol></li><li><ol start="2"><li>了解在应用程序的角落，特殊情况下，不变量可能不成立</li></ol></li></ul></li></ul><h3 id="6-implications-%E5%AF%B9%E6%9C%AA%E6%9D%A5%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%BD%B1%E5%93%8D" tabindex="-1">6 implications 对未来工作的影响</h3><ul><li>虽然我们的研究是从软件测试的角度进行的，但所研究的方面适用于任何用户必须理解动态不变量生成结果的情境</li></ul><h4 id="6.1-crack-the-code-%E7%A0%B4%E8%A7%A3%E4%BB%A3%E7%A0%81" tabindex="-1">6.1 Crack the Code 破解代码</h4><ul><li>我们以为不变量要么易于分类，要么难以分类，实际上大部分处于中间地带</li><li>从统计分析上无法看到不变量分类的难度模型，手动分析只表明了一些导致不变量被错误分类的情景。</li><li>我们的研究没有破解代码，说明仍需要改进，该技术仍具有挑战性</li><li>然而，在4.3节中我们注意到不变量通常可以按难度排序，而难度与用户有效性有关。未来的工作，可能需要更大的样本量，才能找出原因。</li></ul><h4 id="6.2-generation-with-explanation-and-better-invariant-filtering-%E7%94%9F%E6%88%90%E5%B8%A6%E6%9C%89%E8%A7%A3%E9%87%8A%E7%9A%84%E4%B8%8D%E5%8F%98%E9%87%8F%E5%92%8C%E6%9B%B4%E5%A5%BD%E7%9A%84%E4%B8%8D%E5%8F%98%E9%87%8F%E8%BF%87%E6%BB%A4" tabindex="-1">6.2 Generation with Explanation and Better Invariant Filtering 生成带有解释的不变量和更好的不变量过滤</h4><ul><li><p>本研究表明，用户很难对正确的和不正确的不变量进行分类，因此有必要改进以帮助他们理解正确的不变量</p></li><li><p>目前，动态不变量生成是一个黑匣子，以程序轨迹作为输入，产生的程序不变量作为输出。</p></li><li><p>然而，如果不变量生成能够提供更好地理解每个不变量为何生成，用户可能</p><ul><li><ol><li>更快地理解为什么一个不变量是正确的，减少证明时间</li></ol></li><li><ol start="2"><li>识别论证中的缺陷，从而改进识别不正确不变量的过程</li></ol></li></ul></li><li><p>目前在Daikon种使用的使不变量失效的方法可以扩展使用更强大的技术。</p><ul><li>因为动态不变量生成依赖于程序轨迹，因此许多潜在有用的信息来源和分析技术未被使用</li><li>包括：<ul><li>程序覆盖信息（覆盖的方法，探索的路径）</li><li>静态分析技术，特别是证伪程序断言的技术[13]</li><li>动态分析技术，符号/共模执行[27]</li></ul></li><li>通过以上技术，可以减少生成不正确不变量的数量</li></ul></li></ul><h4 id="6.3-quantify-the-impact-of-user-error" tabindex="-1">6.3 Quantify the Impact of User Error</h4><ul><li>不变量分类错误有两类<ul><li>将正确的不变量分类为不正确<ul><li>此情况用户会想办法进行反正，花费用户时间</li></ul></li><li>将不正确的不变量分类为正确<ul><li>此情况较为严重，导致测试出现问题，造成对不变量信任缺失</li></ul></li></ul></li><li>平均而言<ul><li>正确生成的不变量有9.1%至31.7%被错误分类</li><li>而不正确生成的不变量有26.1%-58.6%被错误分类。</li></ul></li><li>本研究对用户能否实际使用这些不变量提出了质疑，在未来的工作中，了解用户错误如何对测试过程产生负面影响（确定不变量是否正确所需的时间，纠正测试中的假阳性所需的时间）是必要的，以了解动态不变量生成是否是一种成本效益的Oracle生成方法</li></ul><h3 id="7-%E7%BB%93%E8%AE%BA" tabindex="-1">7 结论</h3><ul><li>进行亮相研究评估一个在动态不变量生成中关键的方面：用户理解并正确分类生成不变量的能力</li><li>我们结果展示用户经常出错，与先前工作相冲突。</li><li>进一步分析表明，尽管用户效率和分类不变量的困难度存在一些模式，但不变量困难度与其他因素之间的关系是微妙的。<ul><li>诸如程序复杂性、不变量大小、引用的类变量数量等因素并没有强相关性。</li><li>然而，手动分析确实表明，与异常处理不当相关的某些边界情况可能导致几乎所有用户都错误地对复杂的不变量进行分类。</li></ul></li><li>为此，我们提出一些建议，弥补动态不变量生成技术和用户能力之间的差距<ul><li>通过额外的研究，进一步完善我们对不变量复杂性的理解；</li><li>扩展现有技术，以支持用户理解为什么不变量是正确的，并减少生成的不正确不变量的数量；</li><li>量化用户错误对不变量生成实际效果的影响。</li><li>评估必须量化生成test oracle的潜在有效性，及用户应用它们的能力</li></ul></li></ul><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;understanding-user-understanding%3A-determining-correctness-of-generated-program-invariants&quot; tabindex=&quot;-1&quot;&gt;Understanding user unders</summary>
      
    
    
    
    <category term="论文" scheme="http://example.com/categories/%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="user_study" scheme="http://example.com/tags/user-study/"/>
    
    <category term="Invariant" scheme="http://example.com/tags/Invariant/"/>
    
  </entry>
  
  <entry>
    <title>Software Debloating 论文阅读 (10)</title>
    <link href="http://example.com/2024/03/21/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/SoftwareDebloating/Software%20Debloating%20%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB(10)/"/>
    <id>http://example.com/2024/03/21/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/SoftwareDebloating/Software%20Debloating%20%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB(10)/</id>
    <published>2024-03-21T07:33:53.314Z</published>
    <updated>2024-03-21T07:34:23.770Z</updated>
    
    <content type="html"><![CDATA[<h2 id="(10)-occam%3Aautomated-software-winnowing%C2%B7" tabindex="-1">(10) OCCAM:Automated Software Winnowing·</h2><p>Malecha G, Gehani A, Shankar N. Automated software winnowing[C],Proceedings of the 30th Annual ACM Symposium on Applied Computing. 2015: 1504-1511.</p><p>SAC’15 April 13-17, 2015, Salamanca, Spain<br>Symposium on Applied Computing 2015</p><p><img src="https://github.com/SRI-CSL/OCCAM" alt="开源地址"></p><h3 id="0-%E6%91%98%E8%A6%81" tabindex="-1">0 摘要</h3><ul><li>为了解决代码膨胀问题,我们介绍一个OCCAM工具.<ul><li>OCCAM结合了部分求值和类型理论的技术，旨在减少部署应用中的代码。</li><li>OCCAM可以在不对程序源代码进行注释或以其他方式修改的情况下使用。</li><li>它利用配置时间信息生成一个根据将要部署的上下文进行专门定制的应用程序版本。</li></ul></li><li>我们介绍了我们的算法、实现和实验评估。</li></ul><h3 id="1-%E4%BB%8B%E7%BB%8D" tabindex="-1">1 介绍</h3><ul><li>模块化软件库 通过为图形,文件操作和网络提供 可复用功能,使得编写复杂应用更加容易,然而,为了实现通用性,库往往比应用程序所需要的功能更多<ul><li>如 libpng[10]提供了复杂的接口进行图像转换,但许多都用不到</li></ul></li><li>这个问题也涉及了软件栈的多个层次,由跨层依赖引入的开销<ul><li>如 miniblog[13]运行在PHP上,而PHP历来与libc,libc中许多函数仅被miniblog不使用的PHP代码使用. 这些函数包含在静态链接的二进制文件中,存储在磁盘中,执行期间需要内存,多余的代码甚至会被反向导向编程利用</li></ul></li><li>尽管大多数系统不是资源限制的,但 目前普遍的实现中,即使是 二进制文件中 不用的功能 和共享库也会影响性能,可靠性和安全.<ul><li>为此,我们提出了一种将代码特化到实际使用中并简化掉未使用功能的方法</li></ul></li><li>我们提出了 winnnowing(筛选),一种使用部分求值的静态分析和代码特化工具<ul><li>该过程保留了原始程序的正常语义,即原始程序在指定输入上的行为与精简程序的行为相同</li><li>无效的执行,如缓冲区溢出,会以不同方式执行</li></ul></li><li>在基本层次上,程序的功能对应于潜在的执行的适量,如C标准库中的socket函数</li></ul><pre><code class="language-C">int socket(int domain, int type, int protocol);</code></pre><ul><li>该函数接收3个int值,有大量潜在行为,但大多数组合不会被特定程序使用.<ul><li>如Web 服务器通常打开AF_INET和AF_INET6套接字，但不需要AF_APPLETALK或AF_ATMPVC套接字。</li><li>Winnowing的目标是从软件堆栈中删除未使用的行为,减少需要分析的代码,同时保留需要的功能</li></ul></li></ul><h4 id="%E5%8A%A8%E6%9C%BA" tabindex="-1">动机</h4><ul><li><p>筛选部署二进制文件的4个原因</p></li><li><p><strong>专用服务器</strong>:虚拟机的出现使得 高度专业化的服务器称为常态</p><ul><li>如Web服务器通常仅托管单个站点,而虚拟机中过于通用的库只会引入代码膨胀,即虚拟机之间的隔离破坏了共享代码的好处</li></ul></li><li><p><strong>自定义库</strong></p><ul><li>在嵌入式平台上,能够简化库,意味着开发人员可以通过删除不用的功能以使用更大更成熟的库.</li><li>许多应用程序在提供 编译时配置 来移除大块代码. 然而这种方法又开发者定义而不是使用者,因此对开发人员来说增加了维护不同构建配置的负担</li><li>上述方法也无法提供对应用程序获取内容的精确控制<ul><li>如,即使是间接地使用大型组件中的单个函数,也需要整个组件的存在</li><li>此外,为管理员增加了工作量,因为他们必须及时更新系统,这会涉及与应用程序无关的补丁,因为很难确定应用程序是否使用了有缺陷的函数,尤其在使用动态语言时</li></ul></li></ul></li><li><p><strong>简化分析</strong></p><ul><li>在安全重要的系统中,含有大型库是一种负担</li><li>更小的应用程序,较少的配置选项,更少更通用功能的库,更容易进行静态分析.</li><li>此外,部分估值的代码通常更简单,使得静态分析对上下文感知更有效</li></ul></li><li><p><strong>二进制多样性</strong></p><ul><li>专用库使得缓冲区溢出更难以利用</li><li>PHP等平台在可预测的地方包含相同的功能集</li><li>特化每个应用的部署实例,不仅可以移除不需要的功能,还可以移动和改变遗留的功能. 这对剩余功能的攻击更加困难</li></ul></li></ul><h4 id="%E8%B4%A1%E7%8C%AE" tabindex="-1">贡献</h4><ul><li><p>我们讨论了简化单个应用程序的思想和方法,我们的方法对所有同质的应用程序是相同的,即所有代码都可以编译成LLVM[7]位码格式的应用程序.</p></li><li><p>我们选择LLVM框架,因为该框架包括几种流行语言的前端,包括C,C++,Java,其有着明确的中间表示,支持静态和动态编译</p></li><li><p>我们的工作提供了以下内容</p><ul><li>一种用于大幅减少代码功能(包括库和应用程序)的工具. 可以用于实际的大型,工业程序中</li><li>一种将外部信息纳入简化过程的模块化方法. 这可以来用执行策略,如&quot;不应调用邮件&quot;或&quot;系统只能用字符串 ls 调用&quot;,类似面向切面的编程</li><li>关于 简化 对 二进制大小 和 执行性能 影响的 实质分析. 结果标明,简化的二进制文件在性能上没有额外的开销,根据不同的应用程序可以显著减少二进制文件的大小</li><li>一种工具 透明地增强大型软件项目的比那一过程,如Php,SQLite,以生成LLVM为嘛和本机目标文件</li></ul></li></ul><h3 id="2-winnowing" tabindex="-1">2 winnowing</h3><p>本节介绍了我们的方法的一个实例<br>2.1 描述筛选一个单独的编译片段,用LLVM调用模块<br>2.2 描述多模块筛选,使之可在更大的库和动态加载中使用</p><h4 id="2.1-%E6%A8%A1%E5%9D%97%E5%86%85%E7%B2%BE%E7%AE%80" tabindex="-1">2.1 模块内精简</h4><p><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(10)_1.png" alt></p><ul><li>LLVM的基本编译单元是模块,对于简单的程序,通常包含在一个单独的模块中,此时可以用上图的方法进行简化程序<ul><li>下面以简化C语言正则表达式库为例(仅使用C进行说明,所有的分析和转换都在LLVM位码上进行)</li></ul></li></ul><pre><code class="language-C">int regcomp ( regex_t ∗preg , const char ∗regex ,int cflags )&#123; /∗ . . . regcomp code . . . ∗/ &#125;void main ( int argc , char∗ argv[ ] ) &#123;  regex_t re;  regcomp (&amp;re,argv[1] , REG_EXTENDED|REG_ICASE ) ;  . . .&#125;</code></pre><ul><li><p>算法过程如下</p></li><li><p><strong>0. 编译</strong>:将源码编译为LLVM位码. 第三部分将讨论我们的工具,他能自动化的构建LLVM位码,通过指导构建Unix系统的脚本,如GNU的自动化工具</p></li><li><p><strong>1. 部分估值</strong>:winnower的核心是部分估值器,由两个阶段组成,winnower交错并迭代执行这两个阶段</p><ul><li><strong>1.1 优化</strong>:<ul><li>部分求值始于简化代码。其目标是暴露在编译时可确定的常量，消除死代码，并减少已知的控制流。将部分求值器应用于我们的代码片段将减少按位或运算，得到以下结果：<pre><code class="language-C">void main ( int argc , char∗ argv[ ] ) &#123;  regex_t re;  regcomp (&amp;re,argv[1] , REG_EXTENDED|REG_ICASE ) ;  . . .&#125;</code></pre></li><li>正如 Fujita [2] 和 Smowton [12] 所指出的那样，LLVM 优化器的激进性使其成为一个合理的程序内部部分求值器。</li><li>我们使用LLVM的 -O3 优化配置文件,包含了一些列简化,如 局数值编号、启发式循环展开、稀疏条件常数传播、常数折叠以及已知函数简化（简化对 libc 函数的调用，如 strlen 和 memcpy）。此优化传递还对局部函数执行一些保守的程序间优化，例如内联小函数和消除未使用的参数。</li></ul></li><li><strong>1.2 特化</strong><ul><li>优化阶段后,使用启发式方法 更 激进地在跨函数边界进行特化,在这个过程中寻找编译时已知参数的函数调用. 例如,regcomp的最后一个参数指定选项,如不区分大小写或是否支持扩展正则表达式. 该选项在编译时已知,因此可以进行特化,用已知的常量进行替代,删除不需要的参数<pre><code class="language-C">int regcomp ( regex_t ∗preg , const char ∗regex  )&#123; /∗ . . . regcomp with cflags=3 . . . ∗/ &#125;</code></pre></li><li>再将优化运用到这个特化后的函数上,可以通过简化对cflags的分支语句来删除四代码,还有可能将常量推送到其它参数的位置上,进行更进一步地特化</li><li>如果原始地使用,这两个阶段的迭代可能会增加代码的大小,但可以通过各种启发式方法来控制这一点.<ul><li>一种启发式方法是仅在未特化版本可以删除时特化函数,这个启发式方法完全对应减少功能的情况,是一种理想情况</li><li>实际上,我们发现 需要更激进地进行特化,以揭示有益的低级特化. 我们目前的启发式方法是贪婪的,只要看到一个支持的常量就进行特化,同时忽略可变参数函数.  除了整数之外，我们的专门化过程还支持浮点数、常量字符串、任何类型的空值以及全局变量和函数的地址。</li></ul></li><li><strong>递归</strong>:函数特化的主要困难是调用图中的循环,如果没有递归,我们可以限制特化的数量,因为我们指导LLVM优化器不会无限展开训话,然而,在有递归的情况下,我们必须检测特化何时会发散,考虑如下简单递归函数<pre><code class="language-C">int foo(int start,int end)&#123;  if(start&gt;end)&#123;return start-end;&#125;  return foo(start+1,end);&#125;int bar(ing x)&#123;  return foo(1,x);&#125;//特化后int foo_1(int end)&#123;  if(1&gt;end)&#123;return 1-end;&#125;  return foo_1(2,end);&#125;</code></pre><ul><li>此时foo_1(2,end)仍然可以特化,此时特化将无法停止,因为不知道end的值. 因此我们当前的实现选择不特化递归函数.</li><li>值得注意的是,部分评估器通过实践绑定分析[1,5]解决了这个问题,同时确实存在递归函数的部分评估技术[4]</li></ul></li></ul></li></ul></li><li><p><strong>2 消除</strong>:在部分评估稳定,或二进制文件变得过大而无法处理时,我们会删除不再需要的内部全局变量.</p><ul><li>在优化删除无法访问的代码时,全局变量可能变得没用.如果全局函数被特化,并且其所有被调用的位置都可以被特化的实例替代,则将删除这些全局函数.</li><li>我们使用LLVM的三个优化器实现了这个阶段: globaldce, globalopt, strip-dead-prototypes</li></ul></li><li><p><strong>3 链接</strong>:在迭代到固定点之后，我们使用 LLVM 工具将精简后的代码链接在一起构建二进制文件。这</p></li><li><p>模块内的简化算法构建了输入模块的语义等效版本，同时努力消除不必要的功能。</p></li><li><p>该算法可应用于任何单个编译单元，包括静态库和共享对象，因为它不通过删除导出的函数或更改其名称或类型来修改外部可见接口（在 LLVM 的抽象层面）。</p></li><li><p>然而，部分评估可能会极大地改变程序的内部结构，使得在代码中未表现的监控行为（如堆栈检查）失效。</p></li></ul><h4 id="2.2-%E6%A8%A1%E5%9D%97%E9%97%B4%E7%B2%BE%E7%AE%80" tabindex="-1">2.2 模块间精简</h4><ul><li>模块内精简效果好,因为大多数应用程序可以在精简之前通过静态链接库构建为单个模块。,但大型程序必须要与共享库进行交互,因此需要模块间精简</li><li>跨模块的精简的难点在于 代码的分离 和 维护兼容的二进制接口. 此外,我们希望特化是可重用的.<ul><li>如,我们会构建标准库的自定义版本,该版本通过仅包含这些应用程序所需的功能来支持多个应用程序。</li><li>然后，我们希望能够自动重写客户端应用程序以重用相同的精简库</li></ul></li><li>原理上,我们将模块间精简分为三个任务<ul><li>2.2.1 计算模块间依赖关系,使模块间的独立精简称为可能</li><li>2.2.2 对模块进行特化,</li><li>2.2.3 根据生成的规范进行重写</li><li>2.2.4 封存模块,隐藏其它模块未使用的符号,以便在链接时优化期间消除未使用的函数</li></ul></li><li>简化构成迭代 模块特化和封存 步骤,以产生完整的二进制文件</li><li>处于解释目的,我们考虑特化以下简单的代码片段，其中 bar 是在另一个模块中实现的。</li></ul><pre><code class="language-C">extern void bar(int,int);int main(int argc, char* argv[])&#123;  bar(argc,5);  bar(2,argc);  return 0;&#125;</code></pre><h5 id="2.2.1-%E4%BE%9D%E8%B5%96%E8%AE%A1%E7%AE%97" tabindex="-1">2.2.1 依赖计算</h5><ul><li>核心的组合机制是计算和使用模块的（函数和全局变量）依赖关系。<ul><li>在但模块内 简化时,有bar的代码可以立即特化</li><li>此时bar在另一个模块中定义,我们只能将foo记录未客户端模块的依赖</li></ul></li><li>为了对函数进行有意义的特化,我们需要知道关于参数值的信息。我们使用单例类型系统来表达这些信息 [8,16]。<ul><li>单例类型系统支持使用相等谓词对类型进行细化. 例如C 类型系统只能表达变量 x 是整数（int x）。使用单例类型，我们可以细化这个类型，不仅说明 x 是一个整数，而且其值为 5（int=5 x）。因此，我们简单程序的依赖关系如下：<pre><code class="language-C">bar(int=?, int=5)// 使用int=?表示未知的int值bar(int=2, int=?)</code></pre></li></ul></li><li>为了计算一个模块的依赖项,我们从模块的入口遍历调用图,并寻找外部符号引用.<ul><li>直接引用和调用点很简单；我们确定目标函数并记录信息</li><li>间接函数调用和函数指针则更为复杂。我们依赖于 LLVM 工具计算调用图，这些工具采用标准的程序分析技术，如别名分析和控制流和数据流分析。这些分析提高了 OCCAM 解析间接函数调用的能力。<ul><li>当我们无法静态确定调用的目标时，我们必须记录对每个可能的目标函数的最一般化（即未特化）调用。这是因为我们可能在不进行全局代码重写情况下,更改二进制接口。例如，如果代码将 bar 的地址存储在函数指针中，我们必须保守地记录最一般的依赖关系：</li></ul></li><li>在某些情况下，模块内部剔除期间进行的部分评估将简化这个结构，使我们能够静态解析函数。虽然这阻止了进一步的特化，但在一般情况下是不可避免的，例如，当被特化的程序在表中查找函数指针时。</li></ul></li><li>要计算整个应用程序的依赖项，我们从包含程序入口点的模块开始，并遍历代码链接的库，如下图所示。为了处理循环模块依赖的一般情况，我们迭代这个过程，直到后续的依赖计算不产生额外的依赖项<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(10)_2.png" alt="image"></li></ul><h5 id="2.2.2-%E7%89%B9%E5%8C%96" tabindex="-1">2.2.2 特化</h5><p><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(10)_3.png" alt="image"></p><ul><li>特化,使用每个客户模块的依赖性来决定要特化的函数</li><li>如上图示,遍历依赖文件中的调用列表，确定是否以及如何特化每个函数。函数特化的工作方式与模块内情况相同</li><li>即，复制函数体，删除常量参数，并将它们替换为函数体中。</li><li>区别在,与模块内简化不同,我们无法访问函数调用点以重写它们来调用专门的函数. 因此,我们生成了一份重写规范,详细说明客户端如何修改以使用更具体地接口.</li><li>以之前bar的特化举例,生成以下重写,此时只需调用一个参数</li></ul><pre><code class="language-C">&quot;bar&quot;(int=?1, int=5) -&gt; &quot;bar_x_5&quot;(int=?1)&quot;bar&quot;(int=2, int=?2) -&gt; &quot;bar_2_x&quot;(int=?2)</code></pre><h5 id="2.2.3-%E9%87%8D%E5%86%99" tabindex="-1">2.2.3 重写</h5><ul><li>特化后,使用重写规范更新客户端模块. 我们遍历所有外部定义函数的调用点,并查找与调用点匹配的最精确的重写,更新调用点以使用新的函数名和参数</li><li>例如之前的例子变为</li></ul><pre><code class="language-C">int main(int argc, char* argv[])&#123;  bar_x_5(argc);  bar_2_x(argc);  return 0;&#125;</code></pre><ul><li>特化步骤不会删除任何未特化的函数,因为不匹配任何规则的调用点将继续调用未专门化的函数</li><li>重写本质上与模块内特化修改调用者相同,但需要向模块内添加新的函数原型,并从重写规范中重新读取.</li><li>因为我们没有修改通用函数的数显,因此我们可以安全地忽略间接调用和将外部符号存储在变量中</li></ul><h5 id="2.2.4-%E5%B0%81%E5%AD%98" tabindex="-1">2.2.4 封存</h5><ul><li><p>重写完成后，模块内和跨模块的消除即可等效。在此步骤中，我们将对外部世界没有直接引用的符号变为内部，有效地覆盖了其他模块可以与我们的模块进行交互的漏洞。这允许模块内精简删除不可达代码并更激进地优化函数，因为它可以静态分析所有潜在的调用点。</p></li><li><p>使用我们的接口，封装模块非常简单，如下图所示。我们只需迭代所有外部符号，并将任何未在接口中引用的符号变为内部。值得注意的是，拥有准确的接口对于此步骤的正确性至关重要，因为如果我们尝试在另一个模块中引用内部符号，链接将失败。</p></li></ul><p><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(10)_4.png" alt="image"></p><h4 id="2.3-%E5%8A%A8%E6%80%81%E6%A3%80%E6%9F%A5" tabindex="-1">2.3 动态检查</h4><ul><li>当我们能够在组件中静态确定接口的时候，简化效率最高。</li><li>然而在某些情况下，比如通过函数指针进行调用时，确定函数如何调用将会变得困难。例如，在面向对象语言中进行动态分派或在动态语言的解释器中查找函数表时，以下说明一个实例</li></ul><pre><code class="language-C">extern int (*foo)(int);extern int (*bar)(int);void go(bool foobar) &#123;    int (*f)(int) = foobar ? foo : bar;    f(2);     f(3);&#125;</code></pre><ul><li>此代码中，我们只知道 foo 和 bar 会以参数2，3调用，但重写代码并不简单，因为我们在对f的调用中要实用不同的函数。 在这里，我们必须要构建一个包装函数来检查参数并根据需要调度到特化版本，或者在违反接口时发出错误信号，以保持相同的二进制级别的接口。</li><li>这里有两个潜在位置执行动态检查，在调用点或者函数定义处，各有不同的好处</li></ul><h5 id="2.3.1-%E9%87%8D%E5%86%99%E5%AE%A2%E6%88%B7%E7%AB%AF" tabindex="-1">2.3.1 重写客户端</h5><p>第一种选择是重写客户端，即在调用点执行检查。<br>此时，库只导出特化函数（foo_2 和 foo_3 ），但客户端同时需要非特化的。为此，我们必须通过测试其参数并将其分配到合适的特化函数中来实现通用函数。如在客户端模块实现foo如下</p><pre><code class="language-C">extern int foo_2();extern int foo_3();inline int foo(int x) &#123;    if (x == 2) return foo_2(); // foo(2)    if (x == 3) return foo_3(); // foo(3)    exit(1);&#125;</code></pre><ul><li>对客户端进行部分估值将导致该调用被内联，并且在x是静态已知的情况下删除条件。对于调用不符合接口的代码，将执行fall-through并发出错误信号</li></ul><h5 id="2.3.2-%E9%87%8D%E5%86%99%E5%BA%93" tabindex="-1">2.3.2 重写库</h5><ul><li>另一种选择是重写库中的目标函数，这对于强制执行，无法静态验证的 库的接口很有用<br>。它还可以在单独模块中进行使用，以解决间接调用的困难那，为此，OCCAM复制了旧的foo实现并进行重写</li><li>我们将导出的函数foo替换为一个检查参数的函数（以强制执行foo只能用2，3调用），并相应的进行委托或终止客户端。 由于oldfoo在库中是内部的，有static修饰，模块内的简化将对其进行特化并最终从执行文件中删除通用版本</li></ul><pre><code class="language-C">int foo(int x) &#123;    if (x == 2) return oldfoo(2);    if (x == 3) return oldfoo(3);    exit(1);&#125;static int oldfoo(int x) &#123; /* foo code */ &#125;</code></pre><h3 id="3-%E5%AE%9E%E7%8E%B0" tabindex="-1">3 实现</h3><ul><li><p>我们实现了我们描述的所有技术，并应用于多个实例，以了解在实际应用中实用简化技术的实用性</p></li><li><p>我们的代码作为一组LLVM编译器传递实现的。我们通过一组Python包装器实用LLVM opt程序运行它。这意味着简化的每个简短都会产生一个新的程序文件（或接口文件）。虽然这种方法不如纯C但不实体化中间结果的效率高，但它能够灵活地尝试其它转化和特化的启发式方法，我们的代码发布提供了一个教程，演示了我们如何使用我们的工具对应用程序进行简化</p></li><li><p>为了创建程序的bit码，我们开发了一组脚本来包装现有的构建工具，这是因为大型应用程序的构建过程通常使用各种工具，如autoconf，libtool，cmake，make。 虽然这些工具支持各种平台和配置，但不支持将LLVM bit码作为目标架构</p></li><li><p>为了与检查依赖项的现有构建脚本集成，我们的工具将每个命令翻译成两个命令（如调用gcc或ld）。</p><ul><li>第一个编译产生一个修改的版本来获取LLVMbit码</li><li>第二个生成ELF标准版本，生成ELF对象确认构建成功，并确保所有的依赖选项都存在。</li></ul></li><li><p>虽然在构建速度方面不太理想，但我们的脚本相当健壮，能够编译大型程序和库，如PHP，SQLite，uClibc</p></li></ul><h3 id="4-%E4%BE%8B%E5%AD%90%E7%A0%94%E7%A9%B6" tabindex="-1">4 例子研究</h3><ul><li><p>首先回顾我们的目标</p></li><li><p>首先，我们希望减少代码的功能，但这不一定意味着代码的减少；相反，它可能意味着减少可能的执行次数，复制一个函数会增加代码大小，但不会增加复杂性。同样地。在一个参数上特化一个函数，可以通过限制传递的值来减少其可能的行为。为了衡量这一点，我们可以查看应用程序在简化前后的调用图。</p></li><li><p>次要目标是代码大小的减少和配置复杂性。</p><ul><li>大型库支持在粗粒度上启用功能，例如PHP中支持MySQL。</li><li>简化为库用户提供了一种自动化方式，来精确地选择它们想要地功能。为衡量这一点，我们可以将简化与现有技术进行比较，例如使用库地静态链接（仅使用存档中的必要对像）</li></ul></li><li><p>我们的例子研究包括两个web服务器，nweb[3],thttpd[9],及两个web应用程序使用的PHP解释器</p></li></ul><h4 id="nweb" tabindex="-1">nweb</h4><ul><li><strong>nweb</strong>是一个静态内容Web服务器，只有200多行C代码，它的大小和架构并不是简化的理想对象（小且配置少），但其可以展示简化的实际效果。 因为nweb仅依赖于libc，且非常简单，uClibc足以满足它的需求 （libc和uClibc都是C标准库，但uClibc是面向嵌入式系统的轻量级库）</li><li>由于nweb通过命令行进行配置，我们根据我们希望提供的参数对main函数进行特化。为此我们使用命令<code>nweb 8080 /root</code> 告诉nweb监听端口并从root提供文件<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(10)_5.png" alt="image"></li><li>上图展示了简化对nweb调用图的影响，图中的粗灰色框表示特化的函数。 简化前有27个函数，简化后只有17个，其余10个被特化或内联到11个不同的函数中，每个特化都减少了至少一个参数。这些特化包括<ul><li><ol><li>log函数被复制了三次，每次都因不同的状态可以打印日志。通用函数已被删除，特化实例的部分求值去除了怪异的控制流，变成straight-line code程序（只有顺序结构），使其可以直接调用sprint，open，write</li></ol></li><li><ol start="2"><li>libc中设置socket的函数（bind，listen和socket）每个被特化为处理TCP请求。其中socket函数最有趣，被特化为 面向 Internet（AF_NET） 和 面向流的socket（SOCK_STREAM）</li></ol></li><li><ol start="3"><li>libc中处理软件中断的函数（signal）被特化两次以处理SIGCHLD和SIGHUP，这些特化可以使得其他工具可以轻松地确认程序仅以有限的方式响应中断</li></ol></li></ul></li></ul><h4 id="thttpd" tabindex="-1">thttpd</h4><ul><li><strong>thttpd</strong>是另一个考虑的Web服务器。其有许多功能，约8500行C代码，支持CGI，在启动时使用chroot，在内存中缓存，使用htpasswd身份验证。除了核心的libc功能外，thttpd还连接到libcrypt以保护其.htpasswd文件，httpd可以在运行时通过命令行参数配置，也可以在编译时使用一个头文件进行配置，该头文件同构一组49个宏控制代码生成。这些宏包括我们希望在简化中公开的，如.htpasswd的路径存储在AUTH_FIL宏中</li><li>对thttpd进行简化会产生125个特化函数，主要分为三类<ul><li>定时器创建（tmr_create）的特化：所有这些调用都会被特化，包括在计时器到期时运行的函数指针。 这可以防止数据攻击。</li><li>缓冲区分配（httpd_realloc_str）:一个调用扩展了用于存储标头的缓冲区大小，该调用对前领个参数进行了特化，因为二者都是全局变量的地址 。<code>httpd_realloc_str(&amp;header, &amp;maxheader, sizeof(headerstr) + strlen(realm) + 3);</code></li><li>错误代码的特化。 因为我们的特化框架不支持可变参数函数，因此我们无法特化错误函数中对 snprintf的调用。 然而，常量的传播可以进行，因此，可以通过额外的特化来注入这些常量所需的特化</li></ul></li></ul><h4 id="php" tabindex="-1">PHP</h4><ul><li>PHP [14] 是一个用于网站的流行编程语言。它附带了一个庞大的标准库，涵盖了从简单的字符串和日期操作到像chroot这样的POSIX系统调用的各种功能。这种“一揽子式”方法对于快速启动新应用程序非常有用。同时，这也为攻击提供了广泛的攻击面，特别是对于使用eval的应用程序。为了解决这个问题，我们可以对托管应用程序不需要的 PHP 运行时功能进行剪裁。</li><li>为了演示这一点，我们构建了一个minblog[13]专用的PHP解释器，这是一个用PHP编写的小型博客框架。我们用我们的工具链自动地构建PHP解释器的LLVM二进制位码。在编译后，我们需要确定miniblog需要的接口，这里有两个复杂问题<ul><li><ol><li>首先PHP以文本形式提供给PHP解释器，这意味着我们无法使用LLVM通道来确定运行应用程序所需要的接口。PHP的静态评估超出了本文的范围。因此我们使用正则表达式来捕捉与PHP函数调用语法相对应的文本模式。之后，我们人工地检查结果，这个过程可以由语义的静态分析和在程序运行时记录跟踪的工具来替代。即便使用这些工具，我们认为由手动审核此列表仍然是有用的，以查看底层系统所依赖的内容。</li></ol><ul><li>从静态分析我们可以确定miniblog依赖于PHP标准库中地52个函数，包括包括字符串和文件操作以及 MySQL 函数。为了比较，我们编译了可以使用 PHP 的编译选项配置的最小解释器（包括 PHP 标准库和 MySQL 扩展）的解释器。这包含 1029 个函数，包括可能危险的函数，如 system 和 mail。一些被消除的函数包含过去 PHP 版本中的漏洞（CVE-2011-1148 和 CVE-2010-2191）。这些漏洞在已经进行了精简的 PHP 部署中将不再存在。</li></ul></li><li><ol start="2"><li>第二个问题是PHP解释器的架构。PHP解释器讲库函数实现存储在一个可以动态调度的表中。因此，通过此表中的函数进行的所有调用都太过保守，所有函数都有可能是目标。即使我们可以使用类似 Smowton [12] 开发的技术将 PHP 代码拉入部分评估期间，使用 LLVM 优化器很难实现解决通过此表调用所需的部分评估。取而代之的是，我们注意此表的结构并使用第 2.3 节中描述的技术修改函数。在标准的 PHP 解释器中，每个库例程 Xxx 都在函数 zif_Xxx 中实现。因此，我们可以轻松编写钩子，将未使用的函数重写为错误。</li></ol></li></ul></li><li>对简化miniblog，生成了997个形如<code>zif_system(?) =&gt; fail</code>的重写，处于审计和调试的目的，我们实现fail函数时记录了违规的函数调用</li></ul><h3 id="5-%E8%AF%84%E4%BC%B0" tabindex="-1">5 评估</h3><h4 id="%E6%80%A7%E8%83%BD" tabindex="-1">性能</h4><ul><li><p>我们比较了使用专门化和不使用专门化构建的每个服务器在请求率上的表现，以了解运行时的影响。</p></li><li><p>性能以每秒请求数来衡量，用于提供单个小型静态页面。</p></li><li><p>为了控制网络带宽，我们在 localhost:8080 上执行了测试。</p></li><li><p>我们使用 Apache 基准测试工具 ab 来生成请求。</p></li><li><p>我们运行了 40 次试验，每次对服务器进行 5000 次请求。</p></li><li><p>测试在一台轻度负载的 Intel Core 2 四核桌面上运行，时钟频率为 2.4 GHz，配备 4 GB 的 RAM 和 Linux 2.6.38，并使用 TuxOnIce 补丁集</p></li><li><p>为了进行公平比较，基线在链接之前使用LLVM-O3进行优化，两个版本都静态链接到uClibc-0.9.32，使用OCCAM构建并使用uClibc构建的标准配置选项进行优化（使用-O2）。</p></li><li><p>下图显示了nweb和thttpd的比较结果<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(10)_6.png" alt="image"></p></li><li><p>nweb中差异在样本中变化较大，不具有统计意义</p></li><li><p>thttpd中，简化版本在95%的置信度上高于基线版本。这种性能改善可能有两个原因造成</p><ul><li>简化使用-O3作为其部分求值器，而标准配置使用-O2。这种差异可能会导致简化版本的代码更快。</li><li>函数的复制暴露了常量，创造了更多的编译时优化机会</li></ul></li></ul><h4 id="%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%B0%8F" tabindex="-1">代码大小</h4><ul><li>我们在简化中使用的激进特化策略导致httpd模块大小增加了45%，如下图示，这是部分评估技术已知的问题，其中大部分由于报错函数特化参数的复制引起的。这个问题可以使用更保守地启发式搜索解决，如果产生了显著的差异，其只会保留一个特化，</li></ul><p><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(10)_7.png" alt="image"></p><ul><li>libcrypt和libc模块的二进制大小在简化后几乎没有增加，这是因为大多数函数都是叶子例程（例如字符串操作）或它们立即调用操作系统。因此，在这些单独的模块中，很少有机会内联或特化函数。额外的大小是由于对库的特化调用减去了静态链接器引入，但thttpd模块未使用的额外函数和常量。在高度优化的低级别库中，这些都不是显著的，因为档案中的每个对象通常只定义了最小数量的函数。</li></ul><p><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(10)_8.png" alt="image"></p><ul><li>许多常见的库，如libc，通常被编译为共享对象（或系统等效物），而不是静态链接。正常的共享对象包含整个库，与这样的库动态链接的任何应用程序都会引入大量不相关的功能。通过在构建共享对象之前应用精简，我们可以大大减少这种情况。</li></ul><p><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(10)_9.png" alt="image"></p><ul><li>图9展示了应用第4节技术于PHP的结果。<ul><li>min表示使用PHP编译配置选项可以构建的最小PHP模块。它的大小为5.5 MB，其中4.0 MB（用虚线标记）是解释器（没有导出的PHP函数）。剩下的1.5 MB是标准库。</li><li>+mysql表示添加了MySQL支持的二进制文件。它需要额外的4%存储（不包括MySQL库）。</li><li>+mysql-sys是添加了一个策略以阻止对11个危险的PHP函数的调用后的二进制文件。</li><li>miniblog表示在对miniblog的接口进行精简之后得到的解释器版本。在模块内精简之后，LLVM比特码的大小从5.8 MB缩小到4.2 MB，减少了27%；这只比核心解释器大5.5%。从精简中减小PHP解释器二进制大小的效果类似于我们在thttpd案例中看到的libc共享对象的最小化（如图8所示）。</li></ul></li></ul><h3 id="6-%E7%BB%93%E8%AE%BA" tabindex="-1">6 结论</h3><ul><li>我们开发了OCCAM工具,用于将应用程序特化到其部署环境</li><li>我们解释了为什么我们的工具可以精确地从应用程序中移除功能</li><li>我们还认为,少量的手动工作可以用于解决优于信息的不完整引起的困难(如,不知道解释器正在运行的程序或不精确的别名分析)</li></ul><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;(10)-occam%3Aautomated-software-winnowing%C2%B7&quot; tabindex=&quot;-1&quot;&gt;(10) OCCAM:Automated Software Winnowing·&lt;/h2&gt;
&lt;p&gt;Malecha G, Gehani A,</summary>
      
    
    
    
    <category term="论文" scheme="http://example.com/categories/%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="SoftwareEngineering" scheme="http://example.com/tags/SoftwareEngineering/"/>
    
    <category term="SoftwareDebloating" scheme="http://example.com/tags/SoftwareDebloating/"/>
    
  </entry>
  
  <entry>
    <title>Software Debloating 论文阅读 (8)</title>
    <link href="http://example.com/2024/03/21/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/SoftwareDebloating/Software%20Debloating%20%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB(8)/"/>
    <id>http://example.com/2024/03/21/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/SoftwareDebloating/Software%20Debloating%20%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB(8)/</id>
    <published>2024-03-21T07:32:31.553Z</published>
    <updated>2024-03-21T07:32:57.083Z</updated>
    
    <content type="html"><![CDATA[<h2 id="carve%3A-practical-security-focused-software-debloating-using-simple-feature-set-mappings" tabindex="-1">CARVE: Practical Security-Focused Software Debloating Using Simple Feature Set Mappings</h2><p>FEAST’19: Proceedings of the 3rd ACM Workshop on Forming an Ecosystem Around Software</p><p>Brown M D, Pande S. Carve: Practical security-focused software debloating using simple feature set mappings[C],Proceedings of the 3rd ACM Workshop on Forming an Ecosystem Around Software Transformation. 2019: 1-7.</p><h3 id="0-%E6%91%98%E8%A6%81" tabindex="-1">0 摘要</h3><ul><li>现有技术对普通用户不实用存在创造不稳定程序和引入漏洞的风险，而且不适用于debloating网络协议实现等复杂软件</li><li>本文我们提出了CARVE，这是一种简单而有效的以安全为重点的debloating技术<ul><li>采用静态源代码注释来映射软件特性源代码,在debloating过程中消除了对高级软件分析的需求，降低了用户所需的整体技术水平</li><li>CARVE通过引入替代debloating技术超越了现有技术，该技术能够保留软件的互操作性并减轻创建不稳定程序或引入漏洞的风险</li><li>我们在12个debloating场景中评估了CARVE，并展示了满足或超过现有技术的安全性和性能改进。</li></ul></li></ul><h3 id="1-%E4%BB%8B%E7%BB%8D" tabindex="-1">1 介绍</h3><ul><li>软件膨胀对几乎所有软件都产生负面影响，在安全性和性能方面产生各种问题[1,6,7]</li><li>膨胀的主要来源是功能蔓延，即软件包随着时间的推移积累新功能的趋势[8]</li><li>膨胀的另一个来源是软件工程实践，这些实践倾向于重用模块化的软件库。程序通常仅使用每个外部库提供的功能的一个小子集[1]，然而，在运行时，整个库都加载到程序的内存空间中。</li><li>现有技术[2-5,9-10,18]存在限制</li></ul><h4 id="1.1-%E5%8A%A8%E6%9C%BA" tabindex="-1">1.1 动机</h4><ul><li>基于功能的简化方法基于复杂的规范和先进的分析技术,有很高的技术门槛,一般用户难以使用<ul><li>Chisel[3]需要用户提供测试脚本,脚本需要编译源代码并包含对生成程序的测试,且消耗时间长</li><li>TOSS[2]和TRIMMER[4]要求用户和LLVM,angr,TEMU等复杂工具进行交互以简化</li></ul></li><li>以上技术只能删除代码,无法保留良好的软件属性,如优雅的错误处理、用户体验、规范合规性和互操作性<ul><li>如ChiselBench中Chisel的简化结果会产生无意义的输出</li><li>TOSS简化的服务器软件对请求无法以规范协议响应</li></ul></li><li>现有方法在安全性上也存在限制<ul><li>使用动态分析引导去膨胀的技术，如 CHISEL 和 TOSS，由于对与功能相关的代码识别的不精确方式，可能导致产生不稳定的程序并引入新的漏洞 [18]</li><li>在源代码级别操作且只能进行代码删除的去膨胀工具（例如 CHISEL）也可能由于功能特定代码与与功能无关的代码之间的交互而引入新的漏洞</li><li>正如 Brown 和 Pande [22] 所示,改变程序的表示会以不可预测的方式引入新的Gadget,产生安全影响,多次简化和分析迭代可以减缓这种影响,而简化慢的工具不适合这项任务(如Chisel)</li></ul></li></ul><h4 id="1.2-%E8%B4%A1%E7%8C%AE" tabindex="-1">1.2 贡献</h4><ul><li><p>提出CARVE:一种简单有效以安全为中的的简化方法 <img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(8)_1.png" alt></p><ul><li>CARVE 不使用动态分析来识别与功能相关的代码,相反,用户使用简单灵活的基于注释的映射,将功能静态的映射到实现它们的源代码</li><li>这些功能映射允许用户进行稳健的、细粒度的去膨胀，可以选择用保留高级程序属性的替代代码替换去膨胀的代码，例如协议兼容性，并防止引入漏洞</li><li>CARVE 在预处理步骤中去膨胀软件，将具有特定功能映射源代码 和 识别不需要的功能的配置文件 作为输入</li><li>CARVE扫描源代码并智能地删除与不需要的功能相关联的代码，并根据映射插入替代代码。</li><li>其简化高效,因为与特征映射解耦,最终产品是一个仅包含所需功能的源代码的精简版本，可以在不更改构建链的情况下进行处理。</li></ul></li><li><p>我们通过使用CARVE从四个不同程度的侵略性的网络协议实现中去膨胀功能来评估CARVE</p><ul><li>这类软件具有输入/输出复杂性、规范合规性、跨平台互操作性和状态性质，去膨胀这类软件是具有挑战性的。</li><li>我们分析了我们的方法产生的去膨胀变体，并观察到安全性和性能方面的好处，包括消除漏洞、减少代码重用小工具集效用、减小代码大小和消除外部依赖</li></ul></li><li><p>下面第2节讨论Carve实现细节,第3节提供评估结果,第4节确定未来工作</p></li></ul><h3 id="2-%E8%AE%BE%E8%AE%A1" tabindex="-1">2 设计</h3><ul><li><p>基于特征的简化将软件特征映射到相应源代码并随后删除不需要的代码</p><ul><li>现有方法通过动态方法 处理映射,即使用具体输入执行程序,即Cov;</li><li>这些方法存在显著局限性<ul><li>它们要求用户提供复杂的规范或依赖于先进的软件分析工具生成映射。</li><li>它们难以识别非确定性特征、由外部条件触发的特征（例如拥塞控制）或没有可观察输出的特征（例如性能特征）。</li><li>简化软件的规模:因为确保生成的映射的正确性可能需要大量执行，这些方法的成本随着输入空间和执行时间的增加而上升，可能在处理大型、功能丰富的程序时变得不切实际。</li></ul></li></ul></li><li><p>CARVE通过静态特征映射克服了这些限制,其中用户直接将映射放置在目标程序的源代码中</p><ul><li>基于注释的特征映射是程序员熟悉的技术,这种方法在 自动化软件文档工具Doxygen,Sphinx[24,25] 中使用<ul><li>类似于C/C++预处理器指令(如 #ifdef)</li><li>且不仅限于输入触发的特征,也可以在指令级别防止</li></ul></li><li>缺点:<ul><li>需要手动进行注释进行特征映射,工作量可能大;</li><li>然而现代软件大部分重视代码质量,因此大多数软件特征可以直接映射到其关联的源代码</li></ul></li><li>针对缺点<ul><li>CARVE 通过整合几个设计元素来减少用户生成映射的工作量,由此减轻了缺点</li><li>由于特征映射为静态且在源代码中持久存在,因此生成映射的工作量仅需一次</li><li>此外,软件特征可以嵌套在特征结构中,简化了将 某个代码段 映射到多个相关特征的任务</li><li>CARVE还支持隐式特征映射,对常见代码结构进行语法感知进行简化,自动处理因为代码移除造成的控制流影响. 隐式映射提供了比预处理指令方案更丰富的简化支持</li></ul></li></ul></li></ul><h4 id="2.1-%E7%89%B9%E5%BE%81%E6%98%A0%E5%B0%84%E5%89%96%E6%9E%90" tabindex="-1">2.1 特征映射剖析</h4><ul><li>下图展示内嵌映射,由三部分组成<ul><li><ol><li>用户配置标记(///),将注释和特征映射分开</li></ol></li><li><ol start="2"><li>紧随标记,用户标明一个或多个特证明,用[] 包裹</li></ol></li><li><ol start="3"><li>可选操作符,用来区分 显式文件映射,显式段映射,隐式段映射<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(8)_2.png" alt></li></ol></li></ul></li></ul><h4 id="2.2-%E6%98%BE%E5%BC%8F%E7%89%B9%E5%BE%81%E6%98%A0%E5%B0%84" tabindex="-1">2.2 显式特征映射</h4><ul><li>支持两种显式映射(图中蓝色标记)<ul><li><ol><li>文件映射使用 <code>!</code> 操作符,指导简化器移除文件所有代码如果特征不需要</li></ol></li><li><ol start="2"><li>段显式映射,使用 <code>~</code>操作符,指导简化器移除到下一个<code>///~</code>之间的代码段,如果该功能不需要</li></ol><ul><li>对于段显式映射,还可以在两个替换标记之间<code>///^</code>指定替换代码段 ,例如，第13行的带替换映射指示debloater移除第17-19行的代码，并用第15行的代码替换它。</li></ul></li></ul></li></ul><h4 id="2.3-%E9%9A%90%E5%BC%8F%E7%89%B9%E5%BE%81%E6%98%A0%E5%B0%84" tabindex="-1">2.3 隐式特征映射</h4><ul><li>图中绿色标出,其通过将两个关键任务从简化器中去除,减少了生成特征映射所需的工作量<ul><li>首先,隐式特征映射不需要 终止标签来标记代码段的结束: 隐式映射指示简化器分析映射后的代码,从而确定其机构,进而确定因嘎嘎i删除的代码</li><li>隐式映射 消除了使用 替代代码的显式映射, 来处理与控制流影响<ul><li>例如:switch语句或条件分支 的隐式映射指示简化器分析删除映射代码的控制流影响,以产生 不产生意外控制流的简化代码<ul><li>图二中,第9行映射时,简化器将知道简化代码仅为一条语句,仅删除第10行</li><li>第22行和第25行的映射函数定义,此时,简化器将扫描和函数定义相关联的右括号,以确认要删除哪些行,对于这些映射,简化器将删除第23行和26-32行</li></ul></li></ul></li><li>下图展示了具有控制流的简化结构实例,右侧代码时左侧代码移除Feature_B后的结果 <img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(8)_3.png" alt="隐式映射"><ul><li>在对第4行switch语句进行语法感知分析时,简化器将确定由于缺少break语句,6,7行的映射代码是可到达的,此时,简化器无法删除这些行,只能删除case标签</li><li>对第12,13行条件分支语句进行分析,确定分支构造中的else块的存在 组织删除12行,为了保持else块的正确分支,只能删除else if块部分</li></ul></li><li>在简化器中处理隐形映射需要对不同PL进行特定的语法感知分析,因此,CARVE的设计支持使用自定义语言的简化模块. 针对C/C++的简化器支持单个语句,函数和结构定义,switch case以及条件分支的隐式映射</li></ul></li></ul><h4 id="2.4-%E8%A1%A8%E8%BE%BE%E8%83%BD%E5%8A%9B" tabindex="-1">2.4 表达能力</h4><ul><li>我们发现隐式特征映射在大多数情况下足够表达,能够正确识别某个功能的代码.</li><li>但由于高级PL的灵活性,有时候隐式映射无法表达,此时如果有必要需要使用显式映射并使用替代代码. 此时通过删除和替代代码,任何简化操作都足够表达</li><li>在我们4个基准测试中, 不得不使用显式映射+替换的比例为 5/668</li></ul><h4 id="2.5-%E7%AE%80%E5%8C%96%E5%99%A8%E6%93%8D%E4%BD%9C" tabindex="-1">2.5 简化器操作</h4><ul><li>CARVE使用的静态特征映射方案将 特征映射到代码 与 代码简化 解耦. 因此简化变得简易</li><li>CARVE流程<ul><li><ol><li>CARVE 以一个单独的配置文件作为输入</li></ol><ul><li>文件指定了特征映射源代码的未知</li><li>代码所使用语言(指示语法感知模块)</li><li>简化特征的层次结构</li><li>用户希望简化的特征列表</li></ul></li><li><ol start="2"><li>执行时,简化器复制指定的源代码目录,并扫描特征映射的源代码,当发现特征映射时,简化器将于指定的简化特征进行比较,如果是需要简化特征的子集,简化器将处理该映射,否则继续扫描,直到所有文件都被扫描完毕</li></ol></li></ul></li></ul><h4 id="2.6-%E5%8F%AF%E9%9D%A0%E6%80%A7" tabindex="-1">2.6 可靠性</h4><ul><li>当用户提供的特征映射(包括替代代码)是正确的,Carve会是一种可靠的简化技术<ul><li>简化器执行的所有转换在语法和控制流上将会都是正确的</li><li>静态特征映射是 细粒度的,将特征对应到源代码,因此映射可以精准对应到特征; 而对于动态方法,由于其不可预测性,可能会产生不正确的映射<ul><li>如Chisel被证明简化的程序引入了新的漏洞并产生了额外的意外行为[18]</li><li>TOSS使用的特征识别机制不能保证识别所有特征代码, 需要对期望的功能和不期望的功能进行 去噪模糊测试以检测不可靠的变体 [2]</li></ul></li></ul></li><li>高级程序语言表达是高度抽象的,所以在简化时具有挑战性,删除代码时有时不得不产生漏洞<ul><li>下面代码中,从switch语句中删除任一case都不影响语义,但会在会授权的情况执行受保护的函数</li><li>CARVE通过支持 替代 代码来缓解这一问题,本例子中可以替代异常处理代码</li></ul></li></ul><pre><code class="language-C">switch(auth_type)&#123;  case 1:perform_auth_1(creds);break;  case 2:perform_auth_2(creds);break;&#125;protected_function();</code></pre><ul><li>于编写源代码类似,编写特征映射也可能出错<ul><li>在实践中,创建特征映射发生的错误可以使用 确保源代码正确的工具 来检测</li><li>导致违反语言语义映射的错误会被编译器捕获</li><li>成功编译的代码中存在的映射错误可以通过常见的测试技术,如单元测试和集成测试来识别</li><li>使用Coverity [26] 这样的常见静态分析工具可以识别安全问题，比如无意中删除边界检查</li></ul></li></ul><h3 id="3-%E8%AF%84%E4%BC%B0" tabindex="-1">3 评估</h3><ul><li>选择4个网络协议软件包,这些软件包在大小,特征密度和复杂性方面都各不相同,简化这些软件时调整性的,因为其涉及复杂的交互和严格的规范,软件包括<ul><li>libmodbus v3.1.4，一个工业协议库。</li><li>Bftpd v4.9，一个FTP服务器实用程序。</li><li>libcurl v7.61.0，一个数据传输实用程序库。</li><li>mongoose v.6.8，一个嵌入式Web服务器库。</li></ul></li><li>对每个软件包,我们手动创建了各种粒度的特征信息,以及三种不同的简化配置,以适应不同的场景<ul><li>保守（C）：对软件包中的一些外围特征进行简化</li><li>中等（M）：对软件包中的一些外围特征和一些核心特征进行简化</li><li>激进（A）：对软件包中除了一小部分核心特征之外的所有可简化特征进行简化</li></ul></li><li>每种情景中<ul><li>我们使用CARVE对软件包进行简化,使用默认的软件包构建配置 和 GCC v7.3.0 构建了结果变体,所有软件在同一平台上构建,每个构建保持不变</li><li>我们使用开发者提供的测试脚本和自定义测试脚本来测试所有变体,以确保其保留特征的正确性,并且调用简化掉的特征时不会导致变体崩溃</li></ul></li></ul><h4 id="3.1-%E5%AE%89%E5%85%A8%E6%8F%90%E5%8D%87" tabindex="-1">3.1 安全提升</h4><ul><li>简化可以消除漏洞<ul><li><ol><li>在CVE库中搜索了选择软件包的已知漏洞</li></ol><ul><li>对libmodbus和Bftpd,没有CVE,libcurl有6个,mongoose有17个</li><li>随后分析简化后漏洞的消除情况,结果如图</li></ul></li><li><ol start="2"><li>软件抵抗代码重用攻击</li></ol><ul><li>该攻击将执行重定向到内存中现有的指令，以引发恶意效果</li><li>在基于小工具的代码重用攻击方法（如ROP、JOP和COP）中，执行被重定向到程序中存在的有序短指令序列（小工具），以构造恶意有效载荷而无需注入代码。</li><li>评估基于 Gadget的安全 是复杂的,因为再简化后可能引入新的. 我们使用Brown和Pande [22]提出的度量来衡量CARVE对基于小工具的攻击的有效性，即特殊用途小工具的可用性和小工具集表达性。我们的结果显示在表1的分组列中。</li></ul></li></ul></li><li>总体而言,CARVE在减少小工具集表达性方面是有效的，针对三个不同表达性水平 [20, 21]<ul><li>在十二个情景中的七个中，简化减少了整体小工具集的表达性</li><li>在三个情景中简化没有效果</li><li>在两个情景中产生了负面影响<ul><li>我们结果中观察到的负面副作用与CHISEL [22]和TRIMMER [4]中观察到的负面副作用一致。由于CARVE易于重新配置且去噪速度快，因此它非常适合使用迭代去噪来缓解这些负面副作用 [22]。</li></ul></li></ul></li></ul><p><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(8)_4.png" alt></p><h4 id="3.2-%E5%A4%A7%E5%B0%8F%E5%87%8F%E5%B0%8F" tabindex="-1">3.2 大小减小</h4><ul><li>减小效果如下图<ul><li>二进制减小高于预期,因为对简化代码编译器效果优化的提升</li><li>简化还消除了部分外部库的依赖,降低了运行时内存消耗<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(8)_5.png" alt="减小效果"></li></ul></li></ul><h4 id="3.3-%E6%80%A7%E8%83%BD%E5%BC%80%E9%94%80" tabindex="-1">3.3 性能开销</h4><ul><li>CARVE的解耦涉及将简化开支最小化,每个情景的简化均不超过5s,同时也方便扩展<ul><li>技术的主要开销在功能映射上,创建和维护映射有很多工作量,包括对软件的输入程度,特征密度及目标软件的复杂性</li><li>在实践中,我们发现在用户对源代码的了解有限的情况下，创建初始特征映射并会因成本而放弃</li><li>软件工程实践倾向于模块化和分离软件包,这将帮助减少生成合理映射所需要的工作量</li></ul></li><li>对于我们的基准软件,生成密度如下(mappings/KLOC)<ul><li>ibmodbus为61.5 m/KLOC</li><li>Bftpd为24.2 m/KLOC</li><li>mongoose为13.4 m/KLOC</li><li>libcurl为4.9 m/KLOC</li><li>且很少使用替代映射,libmodbus需要17个，libcurl需要20个,另外两个不需要</li></ul></li><li>这标明创建特征映射的一次性成本是合理的。</li></ul><h3 id="4-%E8%AE%A8%E8%AE%BA" tabindex="-1">4 讨论</h3><ul><li><strong>与现有技术比较</strong><ul><li>Chisel[2]和TOSS[3] 平均减少代码大小 86%,43.8%在ChiselBench中,Carve与其相当</li><li>Trimmer[4]平均减少代码大小 21% 在复杂的基于网络的软件中; 此时Carve性能优于Trimmer</li><li>消除CVE方面,CARVE与CHISEL相当</li><li>CARVE在减少和引入新 gadgets方面与Chisel和Trimmer相当</li></ul></li><li><strong>限制</strong>:<ul><li>仅对源代码操作,不适用于闭源软件</li><li>可以用于任何基于文本且支持注释的软件,但目前只支持 C/C++ 语言</li></ul></li><li><strong>未来工作</strong><ul><li>基于创建其它语言的简化模块</li><li>开发静态分析工具,帮助用户快速生成可靠的特征映射; 这些工具将实时分析用户创建的映射,提供建议的新映射,并识别个别简化时潜在的可靠性问题</li></ul></li></ul><h3 id="5-%E7%BB%93%E8%AE%BA" tabindex="-1">5 结论</h3><ul><li>本文介绍Carve,一种简单而强大的软件瘦身技术，它克服了现有方法的缺点<ul><li>在不需要先进软件分析的情况下实现有效简化</li><li>同时保留了如 交互性和规范性 等理想软件特性</li></ul></li><li>评估显式<ul><li>CARVE适合于解决网络协议的简化问题,在4个协议简化中,安全性和性能都很出色</li><li>在12个场景中,CARVE消除了漏洞,减少了代码工具重用</li><li>并使用了 易于用户使用的简单技术,缩减了代码大小,与现有方法相当</li></ul></li></ul><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;carve%3A-practical-security-focused-software-debloating-using-simple-feature-set-mappings&quot; tabindex=&quot;-1&quot;&gt;CARVE: Practical Security-F</summary>
      
    
    
    
    <category term="论文" scheme="http://example.com/categories/%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="SoftwareEngineering" scheme="http://example.com/tags/SoftwareEngineering/"/>
    
    <category term="SoftwareDebloating" scheme="http://example.com/tags/SoftwareDebloating/"/>
    
  </entry>
  
  <entry>
    <title>Software Debloating 论文阅读 (6)</title>
    <link href="http://example.com/2024/03/21/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/SoftwareDebloating/Software%20Debloating%20%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB(6)/"/>
    <id>http://example.com/2024/03/21/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/SoftwareDebloating/Software%20Debloating%20%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB(6)/</id>
    <published>2024-03-21T07:30:49.171Z</published>
    <updated>2024-03-21T07:31:31.563Z</updated>
    
    <content type="html"><![CDATA[<h2 id="subdomain-based-generality-aware-debloating" tabindex="-1">Subdomain-Based Generality-Aware Debloating</h2><p>ASE 20 ,CCF A会<br>Xin Q, Kim M, Zhang Q, et al. Subdomain-based generality-aware debloating[C],Proceedings of the 35th IEEE/ACM International Conference on Automated Software Engineering. 2020: 224-236.</p><h3 id="0-%E6%91%98%E8%A6%81" tabindex="-1">0 摘要</h3><ul><li><p>程序膨胀降低性能和安全</p></li><li><p>为了突破基于输入的方法过拟合输入集的限制,我们提出了 <strong>DOMGAD</strong> ,有两个主要优点超过现有方法</p><ul><li><ol><li>其生成的简化程序保证在子域上工作,而不是输入</li></ol></li><li><ol start="2"><li>使用随机优化简化程序,以在简化和通用性(即简化程序能够正确处理整个域中输入的程度)上实现权衡</li></ol></li></ul></li><li><p>在ChiselBench上评估,50%的代码减少和95%的通用性,高于目前两种SOTA</p></li></ul><h3 id="1-%E4%BB%8B%E7%BB%8D" tabindex="-1">1 介绍</h3><ul><li><p><strong>DOMGAD</strong>两个优点</p><ul><li><ol><li>生成的简化程序保证在子域上工作,而不是输入;</li></ol><ul><li>即DomGad生成的程序对属于这些子域的每一个输入都能正确运行;</li><li>对不属于当前子域的输入都会禁止运行防止异常行为; 与此相对基于输入的方法仅能保证在特定输入下正确运行,因此阻止异常行为的唯一方法是阻止未知输入的执行</li></ul></li><li><ol start="2"><li>DOMGAD不仅考虑了简化,也考虑了在通用性上的权衡</li></ol></li></ul></li><li><p>我们的方法中,使用路径 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span></eq> 来符号化 程序 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></eq> 的子域,使用符号 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">D</mi><mo stretchy="false">(</mo><mi>π</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{D}(\pi)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mclose">)</span></span></span></span></eq> 来指示所有属于该子域的输入.</p></li><li><p>为了正确运行子域内所有输入,DOMGAD保守地保留 运行运行路径上的代码</p></li><li><p>DOMGAD的目标是生成一个可以处理子域的简化程序,并实现简化和通用之间的权衡. 即,假设输入在程序中均匀分布,我们的方法生成尽可能小的程序同时处理子域内尽可能多的输入</p></li><li><p>为了实现这一目标,我们将简化为顶定义为一个优化为题,定义一个目标函数,量化 reduction 和 generality,并使用随机优化算法来解决它</p></li><li><p>量化通用性很难,我们提出了一种基于关键洞察的实际技术，即可以对程序域的底层输入分布进行建模并利用基于采样的方法</p><ul><li>具体来说,DOMGAD<ul><li><ol><li>从输入分布中抽取样本,来识别出一组有限的路径集合 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∏</mo></mrow><annotation encoding="application/x-tex">\prod</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∏</span></span></span></span></eq> ,这些路径集合覆盖了程序域的大部分输入</li></ol></li><li><ol start="2"><li>基于导致该路径的采样输入数量,估计每个路径 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo>∈</mo><mo>∏</mo></mrow><annotation encoding="application/x-tex">\pi \in \prod</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∏</span></span></span></span></eq> 相对应的子域大小. 尽管我们的采样方法只能计算通用性的近似值,但可以通过计算,界定解的误差. 因此通过足够的样本,我们的方法误差将会非常小</li></ol></li></ul></li></ul></li><li><p>我们总的简化过程如下</p><ul><li>输入程序 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></eq> , 一个输入采样器 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">IS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span></eq> , 该采样器模拟 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></eq> 域中的输入分布 并生成输入样本,给定这些输入,DOMGAD进行三个主要步骤: (1) 路径识别 (2)路径量化 (3) 随机优化</li><li><ol><li>路径识别:DOMGAD调用 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">IS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span></eq> 生成输入样本,并识别出一组路径 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∏</mo></mrow><annotation encoding="application/x-tex">\prod</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∏</span></span></span></span></eq> ,这些路径覆盖了程序域的大部分输入</li></ol></li><li><ol start="2"><li>路径量化:DOMGAD再次调用 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">IS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span></eq> 生成额外的样本用于估计每个路径 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo>∈</mo><mo>∏</mo></mrow><annotation encoding="application/x-tex">\pi \in \prod</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∏</span></span></span></span></eq> 相对应的子域大小. 基于这些估计,DOMGAD计算每个生成的简化程序的通用性. 在这一步中,同时也比较 reduction 和工具面</li></ol></li><li><ol start="3"><li>随机优化:DOMGAD使用MCMC随机优化算法,来实现生成 通用性和简化之间的权衡</li></ol></li></ul></li><li><p>使用ChiselBench评估DOMGAD,与Chisel和DEBOP进行比较.</p></li><li><p>本文主要贡献如下</p><ul><li><ol><li>一个新的,基于子域的,注重通用性的简化技术DOMGAD, 使用随机优化算法来生成简化程序来达到简化和通用性之间的权衡</li></ol></li><li><ol start="2"><li>通过实验评估展示我们技术的效果,并证实了进行注重泛化的简化是可行的</li></ol></li><li><ol start="3"><li>提供了DOMGAD的原型实现,并<a href="https://sites.google.com/view/domgad/">开源</a></li></ol></li></ul></li></ul><h3 id="2-%E7%A4%BA%E4%BE%8B" tabindex="-1">2 示例</h3><h3 id="3-%E5%88%9D%E6%AD%A5%E5%AE%9A%E4%B9%89" tabindex="-1">3 初步定义</h3><h3 id="4-%E6%88%91%E4%BB%AC%E7%9A%84%E6%96%B9%E6%B3%95%3Adomgad" tabindex="-1">4 我们的方法:DOMGAD</h3><h3 id="5-%E8%AF%84%E4%BC%B0" tabindex="-1">5 评估</h3><h3 id="6-%E7%9B%B8%E5%85%B3%E5%B7%A5%E4%BD%9C" tabindex="-1">6 相关工作</h3><h4 id="%E7%A8%8B%E5%BA%8F%E7%AE%80%E5%8C%96" tabindex="-1">程序简化</h4><ul><li><p>DOMGAD与一系列[22,41,45,55,57] 依赖 使用配置文件的简化技术相关</p><ul><li>TRIMMER [55] 通过激进的编译器优化实现简化</li><li>OOCAM [38] 通过部分估值实现简化</li><li>C-Reduce[45],Perses[57],CHISEL[22] 是基于delta-debugging的简化技术</li><li>J-Reduce[20] 使用依赖信息来改进delta-debugging</li><li>RAZOR [41] 采用基于代码覆盖,推理,和二进制重写的简化方法</li></ul></li><li><p>与上述技术不同</p><ul><li>DOMGAD是基于子域的,而不是具体的输入</li><li>DOMGAD不是单纯的简化导向,而是在简化和通用性之间进行权衡</li></ul></li><li><p>DEBOP[61] 是我们之前提出的方法,但其是基于输入的,并且在语句级别操作,而不是路径级别.如我们结果显示,这对其简化和效率产生了影响</p></li><li><p>DomGad也和一些基于静态分析来删除死代码或未使用代码的技术相关[1, 24, 26, 27, 29, 42],以及对应特别程序(例如 容器[44] 或 web应用[3]),或特殊目的(例如安全检测[15]) 而执行简化的技术有关</p></li><li><p>更广泛地硕,DOMGAD和膨胀检测[4,62,63],识别不必要代码[21],以及通过程序切片识别感兴趣代码的技术有关[60]</p></li></ul><h4 id="%E6%A8%A1%E5%9E%8B%E8%AE%A1%E6%95%B0%E5%92%8C%E6%A6%82%E7%8E%87%E5%88%86%E6%9E%90" tabindex="-1">模型计数和概率分析</h4><ul><li>因为DOMGAD使用静态采样方法,因此其与 模型技术有关[2,7,32],这些技术旨在量化满足给定公式的模型数量</li><li>处于类似原因,其也与概率软件分析[5,16,51] 有关,这些技术旨在量化程序的概率行为</li><li>与统计模型检验技术[35]有关,该技术通过验证统计方法验证概率事件的属性</li></ul><h4 id="mcmc%E5%92%8C%E4%BC%98%E5%8C%96" tabindex="-1">MCMC和优化</h4><ul><li>DOMGAD使用基于MCMC的,以此其和使用MCMC解决其它问题的技术间接有关,如优化[52]、漏洞查找[8,33]基于模型的GUI测试[56]和程序混淆[36]。最后，DomGad与资源适应[12]、能量减少[53]、程序修复[34]以及更广泛的软件改进[40]的优化技术有松散的关联。</li></ul><h3 id="7-%E7%BB%93%E8%AE%BA%E5%92%8C%E6%9C%AA%E6%9D%A5%E5%B7%A5%E4%BD%9C" tabindex="-1">7 结论和未来工作</h3><ul><li>结论<ul><li>现有基于输入的方法容易过拟合输入,且只考虑简化</li><li>我们提出了一种新的,基于子域的,注重通用性的简化技术DOMGAD, 使用随机优化算法,来生成简化程序来达到简化和通用性之间的权衡,通过一个综合这两个相互冲突度量的目标函数执行随机优化</li><li>结果显示我们的技术可以生成显著的代码减少（平均50%），同时保持高泛化性（平均95%）</li><li>与SOTA比较,DOMGAD表现良好</li></ul></li><li>未来工作<ul><li><ol><li>扩展我们的评估</li></ol><ul><li>(1) 使用 DOMGAD 应用于更广泛的程序集,来评估我们现在的结果是否具有普遍性</li><li>(2) 进行用户研究,评估现实环境中通用性的价值</li></ul></li><li><ol start="2"><li>探究提升路径识别和量化 效率的新方法</li></ol><ul><li>具体而言,将考虑 分层抽样[47],顺序抽样[58] 等方法</li><li>以及研究基于共享输入样本 ,同时执行路径识别和量化的可能性</li></ul></li><li><ol start="3"><li>考虑其它随机方法</li></ol><ul><li>例如 Gibbs Sampling[17],来改进优化结果</li></ul></li><li><ol start="4"><li>研究推断程序输入分布的方法</li></ol><ul><li>可能基于使用配置文件,自动构建输入样本生成器.为此,可以考虑基于 概率程序合成[39],概率密度估计[59],分布估计[30]和深度生成模型[43, 46]的方法。</li></ul></li></ul></li></ul><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;subdomain-based-generality-aware-debloating&quot; tabindex=&quot;-1&quot;&gt;Subdomain-Based Generality-Aware Debloating&lt;/h2&gt;
&lt;p&gt;ASE 20 ,CCF A会&lt;br&gt;
Xi</summary>
      
    
    
    
    <category term="论文" scheme="http://example.com/categories/%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="SoftwareEngineering" scheme="http://example.com/tags/SoftwareEngineering/"/>
    
    <category term="SoftwareDebloating" scheme="http://example.com/tags/SoftwareDebloating/"/>
    
  </entry>
  
  <entry>
    <title>基于程序不变量计算软件可靠性</title>
    <link href="http://example.com/2024/03/19/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/invariant/%E5%9F%BA%E4%BA%8E%E7%A8%8B%E5%BA%8F%E4%B8%8D%E5%8F%98%E9%87%8F%E8%AE%A1%E7%AE%97%E8%BD%AF%E4%BB%B6%E5%8F%AF%E9%9D%A0%E6%80%A7/"/>
    <id>http://example.com/2024/03/19/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/invariant/%E5%9F%BA%E4%BA%8E%E7%A8%8B%E5%BA%8F%E4%B8%8D%E5%8F%98%E9%87%8F%E8%AE%A1%E7%AE%97%E8%BD%AF%E4%BB%B6%E5%8F%AF%E9%9D%A0%E6%80%A7/</id>
    <published>2024-03-18T17:22:57.662Z</published>
    <updated>2024-03-21T08:50:14.829Z</updated>
    
    <content type="html"><![CDATA[<h2 id="%E5%9F%BA%E4%BA%8E%E7%A8%8B%E5%BA%8F%E4%B8%8D%E5%8F%98%E9%87%8F%E8%AE%A1%E7%AE%97%E8%BD%AF%E4%BB%B6%E5%8F%AF%E9%9D%A0%E6%80%A7" tabindex="-1">基于程序不变量计算软件可靠性</h2><ul><li>引用：周远, 丁佐华. 基于程序不变量计算软件可靠性[J]. 软件学报, 2015, 26(12): 3075-3087.</li></ul><h3 id="0-%E4%BB%8B%E7%BB%8D" tabindex="-1">0 介绍</h3><ul><li>软件可靠性的计算依赖于可靠性模型的选取以及所获得的软件失效数据</li><li>失效数据的获取对可靠性及模型有非常大的影响[20]，因此我们必须考虑是小数据的质量和收集失效数据的方案</li><li>目前应用最广泛的针对各个开发阶段失效数据收集的方法是软件测试技术，软件测试包括 3 个要素:选择输入域、执行测试用例和比较输出[22].学者们提出了多种测试方法来获得软件失效数据[23],然而这些方法都是通过比较实际输出结果与期望输出结果得到诸如失效次数、失效用例等的失效数据,而忽略了软件的实时行为和内部结构,从而导致这些数据并不能真实反映软件的真实行为,如:<ul><li><ol><li>存在假性正确现象：即偶然正确，如软件的输出结果与期望输出结果一致,但软件的内部结构和行为并不正确</li></ol></li><li><ol start="2"><li>测试不能显示一个输入有多个错误的输出情况.</li></ol></li><li><ol start="3"><li>不同测试方法会影响到失效数据的获取比例,从而影响可靠性的计算.</li></ol><ul><li>Chen 等人[24]通过实验指出,不同的测试方法(随机测试、功能测试、分块测试)获得的失效数据会产生不同的可靠性.作者认为:这是因为这样获得的失效数据并没有真正反映程序的内部信息,仅反映了在所选测试用例下粗糙的程序的信息,所以计算出来的可靠性也是不准确的,无法反映软件真实的可靠性.</li></ul></li></ul></li><li>因此，通过测试阶段的输入/输出所获取的失效数据并不充分，无法准确反映程序内部存在的问题，为此我们需要程序的内部数据来计算软件的可靠性，一个解决方案是：<ul><li>通过观察和分析测试过程中程序的执行轨迹从中提取程序的内部信息(例如内部结构、动态行为)。这里使用Daikon工具提取不变量，从这些不好的不变量中获得不好的不变量，利用这些不好的不变量计算可靠性</li><li>在前人工作下，本文对使用不变量计算可靠性进行了可行性分析</li></ul></li><li>与现有的可靠性方法比较，两种方法差别很小，不依赖于对测试方法的选择，而进一步的方差说明：所提方法波动更小，更平稳，更接近系统的真实可靠性</li></ul><h3 id="4-%E5%A4%B1%E6%95%88%E6%95%B0%E6%8D%AE%E7%9A%84%E8%8E%B7%E5%8F%96-%E5%8F%8A-%E5%8F%AF%E8%A1%8C%E6%80%A7%E5%88%86%E6%9E%90" tabindex="-1">4 失效数据的获取  及 可行性分析</h3><ul><li>文章例子是改变程序中的数组，产生新的不变量，与原来的不变量进行比较，产生变化的不变量即失效数据</li><li>失效数据获取例子：<ul><li>我们通过 3 种不同的方法来选取测试用例集 T1(随机选取)、T2(基于分块覆盖选取)、T3(基于分支覆盖选取).</li><li>分别运行正确版本程序 C 与 T1、C 与 T2、C 与 T3 得到程序不变量 TI1,TI2 和 TI3</li><li>运行错误版本程序 F 与 T1、F 与 T2、F 与 T3 得到程序不变量 FI1,FI2 和 FI3.</li><li>比较 TI1 与 FI1、TI2 与 FI2 以及 TI3 与 FI3 的不同,分别得到各自的失效数据.</li></ul></li><li>可行性分析：<ul><li>每种方法所获得的失效数据百分比,可以发现不同方法获得的失效数据百分比基本相近,误差不大.</li><li>可以得到结论不同测试方法得到不同的不变量;但是就失效数据的百分比来说,它们之间相差较小,比较稳定.</li></ul></li></ul><h3 id="5-%E5%8F%AF%E9%9D%A0%E6%80%A7%E8%AE%A1%E7%AE%97%E5%92%8C%E7%BB%93%E6%9E%9C%E5%88%86%E6%9E%90" tabindex="-1">5 可靠性计算和结果分析</h3><ul><li>可靠性计算：使用Nelson模型计算，不好的不变量作为失效数据，不同方法法算出的可靠性虽然不一样,但相差较小；使用方差刻画，基于不变量的可靠性计算结果方差较小</li><li>综上所述<ul><li>在不同测试方法下,由不变量计算出的可靠性不是完全相等,还有一定的误差,其原因是有些不好的</li><li>不变量之间还有一定的依赖性;</li></ul></li></ul><h3 id="6-%E5%8F%AF%E8%A1%8C%E6%80%A7%E5%88%86%E6%9E%90" tabindex="-1">6 可行性分析</h3><ul><li><p>用现有计算可靠性的方法计算7个程序的可靠性（Nelson模型），比较不便令计算出的可靠性和现有方法计算出的可靠性之间的差异</p><ul><li>二者在不同测试方法下差异不大</li><li>可靠性方差都不是太大;但是相比较而言,现有方法的可靠性波动远大于不变量计算出的可靠性波动<ul><li>因为现有方法计算出的可靠性一定程度上依赖于测试方法,反映软件的局部行为计算出的可靠性是在该测试方法下的可靠性，所以在不同测试方法下,可靠性会有一定的波动；而不变量是整体的行为，,虽然不同的测试方法会产生不同的不变量,但这些不变量的合成效果却是一样的,都反映软件整体的行为,所以不变量计算出的可靠性是软件的整体可靠性,其波动产生的原因在于有些失效数据(不好的不变量)之间还有一定的相关性.</li></ul></li></ul></li><li><p>综述所述:相对于现有的计算可靠性方法,我们还可以利用不变量来计算软件的可靠性;且利用不变量计算的可靠性更接近软件的实际可靠性</p></li></ul><h3 id="8-%E7%BB%93%E8%AE%BA" tabindex="-1">8 结论</h3><ul><li><p>本文说明可以使用程序不变量计算软件的可靠性</p><ul><li><ol><li>在同一测试方法下,不变量计算出的可靠性和现有方法计算出的可靠性相差不大</li></ol></li><li><ol start="2"><li>在不同测试方法下,不变量计算出的可靠性波动较小,更接近软件的实际可靠性.</li></ol></li><li><ol start="3"><li>从不变量的角度来刻画软件可靠性,使我们对软件的整体行为和软件可靠性有更深刻的认识,有利于软件可靠性的评估和预测.</li></ol></li></ul></li><li><p>未来工作：</p><ul><li><ol><li>针对不变量中的相关性：如果不好的不变量之间存在相关性,会增加失效数据,影响计算结果.我们应尽量去掉这种相关性,使得剩下的不变量尽可能独立.一种办法是建立数据流的依赖图</li></ol></li><li><ol start="2"><li>在实际应用中,我们并不知道正确的程序,这样我们就不能通过比较来获得不好的不变量,而必须通过一定的方法,根据已有的测试用例信息和已获得的不变量信息来确定不好的不变量,这将是我们接下来要解决的关键问题之一.</li></ol></li></ul></li></ul><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;%E5%9F%BA%E4%BA%8E%E7%A8%8B%E5%BA%8F%E4%B8%8D%E5%8F%98%E9%87%8F%E8%AE%A1%E7%AE%97%E8%BD%AF%E4%BB%B6%E5%8F%AF%E9%9D%A0%E6%80%A7&quot; tabi</summary>
      
    
    
    
    <category term="论文" scheme="http://example.com/categories/%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="Invariant" scheme="http://example.com/tags/Invariant/"/>
    
  </entry>
  
  <entry>
    <title>不变量与程序修复相关论文</title>
    <link href="http://example.com/2024/03/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/invariant/%E4%B8%8D%E5%8F%98%E9%87%8F%E4%B8%8E%E7%A8%8B%E5%BA%8F%E4%BF%AE%E5%A4%8D%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/"/>
    <id>http://example.com/2024/03/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/invariant/%E4%B8%8D%E5%8F%98%E9%87%8F%E4%B8%8E%E7%A8%8B%E5%BA%8F%E4%BF%AE%E5%A4%8D%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/</id>
    <published>2024-03-14T16:40:54.811Z</published>
    <updated>2024-03-22T06:00:30.085Z</updated>
    
    <content type="html"><![CDATA[<h2 id="%E2%85%B0-invariant-based-program-repair" tabindex="-1">Ⅰ Invariant-based Program Repair</h2><ul><li>引用：Al-Bataineh O I. Invariant-based Program Repair[J]. arXiv preprint arXiv:2312.16652, 2023.</li></ul><h3 id="0-%E6%91%98%E8%A6%81" tabindex="-1">0 摘要</h3><ul><li><p>本论文描述了一种 基于程序中ivariants概念的正式通用的自动化程序修复框架。</p></li><li><p>在上述框架中，动态分析缺陷程序的运行踪迹，推断出特征 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mrow><mi>c</mi><mi>o</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>c</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\varphi_{correct}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">correc</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 和 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mrow><mi>v</mi><mi>i</mi><mi>o</mi><mi>l</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\varphi_{violated}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>，其中 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mrow><mi>c</mi><mi>o</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>c</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\varphi_{correct}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">correc</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 表示可能不变量（良好模式）的集合，这些不变量是运行成功所需的，而 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mrow><mi>v</mi><mi>i</mi><mi>o</mi><mi>l</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\varphi_{violated}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 表示可能可疑不变量（错误模式），导致瑕疵程序中的错误。</p></li><li><p>随后，利用严格的程序分析技术来对这些规范进行精炼，这些技术还可以引导修复过程生成可用补丁，随后评估这些补丁的正确性</p></li><li><p>通过开发一种基于invariants的高效修复bug的修复系统，我们展示了使用invariants在APR中的实用性</p></li><li><p>初步分析证明，基于不变量的APR在处理bug的性能方面是有效的，能够生成 确保程序效率提升且不对其功能产生不利影响的补丁</p></li><li><p><strong>KeyWord</strong>：</p><ul><li>Automated program repair</li><li>Invariant learning and refinement</li><li>Patch overfitting</li><li>Program verifier</li><li>CPAChecker</li><li>Performance bug</li></ul></li></ul><h3 id="1-%E4%BB%8B%E7%BB%8D" tabindex="-1">1 介绍</h3><ul><li>Automated program repair (APR) 最近引起了很大的关注，其通过自动生成 瑕疵程序的补丁来显著减少手动调试工作。 现代化的修复工具已经被证明在修复许多实际程序中的错误方面是有效的.然而自动生成的补丁质量不佳[11]，仍然是软件从业者采用自动化程序修复的主要障碍</li></ul><h4 id="%E9%97%AE%E9%A2%98" tabindex="-1">问题</h4><p>当前APR工具自动生成的补丁质量较低的主要原因是缺乏预期行为的规范。大多数程序修复系统依赖于测试行为作为正确性标准，因为软件开发者没有明确提供正式规范。因此，当前的APR方法产生的补丁可能是合理的，但仍然在部署前进行手动检查。因此，目前无法保证生成的补丁通常是正确的，并且不会引入新的错误。</p><h4 id="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95" tabindex="-1">解决方法</h4><ul><li>程序验证技术使开发人员能够在部署之前证明程序的正确性。<ul><li>支持这项技术的关键之一是推断程序invarant,一个作为程序的抽象规范的逻辑表示。开发人员可以通过程序不变量显著受益，以确定修改代码必须要保留的程序属性。</li><li>不幸的是，这些invariants通常在代码中确实，导致了不严格的APR方法（如动态APR）占据主导地位；以及众所周知的补丁过拟合问题</li></ul></li><li>我们认为，通过使用测试用例和基于可达性的分析技术，可以获得准确的invarants集合，用于生成高质量的补丁，即 CPAChecker<br>[3] and PathFinder [15]之类的程序验证工具可用于优化生成invariants的过程<ul><li>首先，我们使用测试用例来分析程序的运行轨迹推断invariant集合，随后，使用程序验证器对这些候选就行优化以获得更准确的invariants。目标是推断出两个规范<ul><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mrow><mi>c</mi><mi>o</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>c</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\varphi_{correct}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">correc</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 表示成功运行需要的良好模式集合</li><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mrow><mi>v</mi><mi>i</mi><mi>o</mi><mi>l</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\varphi_{violated}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 表示导致目标错误的不良模式集合</li></ul></li></ul></li><li>基于invariant的APR提供了两个关键优点<ul><li><ol><li>将APR导向潜在可行的补丁</li></ol></li><li><ol start="2"><li>使得可以使用程序验证器对合理的补丁惊醒正式验证</li></ol></li></ul></li></ul><h4 id="viability-of-invariant-based-apr-%E5%8F%AF%E8%A1%8C%E6%80%A7%E5%88%86%E6%9E%90" tabindex="-1">Viability of Invariant-based APR 可行性分析</h4><ul><li>程序invariant在多个应用中展现了效率，如程序理解，错误定位和形式验证。</li><li>invariant之所以高效，是因为功能正确性与程序的最终结构相关，而不是特定的实现。 因此，他们可以帮助抽象出许多具体的执行步骤，从而极大的减少了理解补丁正确性所需的工作量。<ul><li>事实上，那些尝试修复一个没有形式规范的错误没有文档的程序（即未经过深思编写的程序）的开发人员可以发现，基于不变量的APR对他们的修复工作很有帮助。</li></ul></li><li>成熟的自动不变量检测工具如Daikon[4]和实用的软件验证工具如CPAChecker和PathFinder的可用性使基于不变量的程序修复技术成为可能。</li><li>乍一看，使用软件验证工具来优化不变量似乎成本太高，然而由于软件验证的巨大进步[2]，实际上，基于invariant的验证变得非常高效。<ul><li>特别是，软件分析框架CPAChecker，支持多种可达性分析，已经被有效地用于验证多达50k行的C程序的各种可达性查询。这使得可达性分析成为一种有前途的技术，可以用来显著减少补丁的过拟合问题并产生高质量补丁</li></ul></li></ul><h3 id="2-%E5%9F%BA%E4%BA%8Einvariant%E7%9A%84apr%E6%A1%86%E6%9E%B6" tabindex="-1">2 基于invariant的APR框架</h3><ul><li>本节将使用程序invariant的概念重新阐释APR问题。</li><li>然后，我们描述了如何分析无故障运行的执行跟踪，推断出程序预期行为的可能规范，以及分析有故障运行的执行跟踪，推断出可能导致故障行为的可疑不变量。再进一步进行前，然我们介绍一些定义</li></ul><h4 id="definition-1-%EF%BC%88fault-free-vs-fault-runs%EF%BC%89" tabindex="-1">Definition 1 （fault-free vs fault runs）</h4><ul><li>令 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></eq> 为一个bug程序，<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span></eq> 是 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></eq> 的运行集合，<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mrow><mi>b</mi><mi>e</mi><mi>h</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\varphi_{beh}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 是程序P的预期行为属性。 我们定义一个运行 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>∈</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">r\in R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span></eq> 是一个成功的运行（i.e. <strong>fault-free run</strong>）当 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>φ</mi><mrow><mi>b</mi><mi>e</mi><mi>h</mi></mrow></msub></mrow><annotation encoding="application/x-tex">P(r)=\varphi_{beh}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> ,否则，<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>∈</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">r \in R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span></eq> 是一个失败的运行（i.e. <strong>fault run</strong>）,当 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mo mathvariant="normal">≠</mo><msub><mi>φ</mi><mrow><mi>b</mi><mi>e</mi><mi>h</mi></mrow></msub></mrow><annotation encoding="application/x-tex">P(r)\neq \varphi_{beh}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq></li></ul><p>根据定义1我们可以注意到，通过分析从无故障运行中提取的信息，可以推断出程序预期行为的行为规范。 类似的，通过分析故障运行中的执行信息，可以推断出导致错误的错误invariant。 这是因为无故障运行表示保持程序invariant的运行，而有故障的运行表示违反某些程序invariant的运行。</p><h4 id="definition-2-%EF%BC%88invariant-based-apr-problem%EF%BC%89" tabindex="-1">Definition 2 （Invariant-based APR problem）</h4><ul><li><p>令 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></eq> 为一个包含bug <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span></eq> 的程序 并且 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>T</mi><mi>P</mi></msub><mo>∪</mo><msub><mi>T</mi><mi>F</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T=(T_P \cup T_F)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq> 为一个测试套件，<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>P</mi></msub></mrow><annotation encoding="application/x-tex">T_P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>表示通过的测试而 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>F</mi></msub></mrow><annotation encoding="application/x-tex">T_F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>表示失败的测试。 令 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span></eq> 表示动态invariant推断工具如Daikon，<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></eq> 表示程序验证工具如CPAChcker，基于invariant的APR过程包含以下步骤：</p><ul><li><ol><li><strong>Invariant 提取</strong>：使用 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span></eq> 生成程序 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></eq> 的初始invariant集合 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">I</mi></mrow><annotation encoding="application/x-tex">\mathcal{I}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.07382em;">I</span></span></span></span></eq></li></ol></li><li><ol start="2"><li><strong>Invariant 精炼</strong>:使用 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></eq> 精炼集合 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">I</mi></mrow><annotation encoding="application/x-tex">\mathcal{I}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.07382em;">I</span></span></span></span></eq> 产生规范 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mrow><mi>c</mi><mi>o</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>c</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\varphi_{correct}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">correc</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 和 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mrow><mi>v</mi><mi>i</mi><mi>o</mi><mi>l</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\varphi_{violated}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>。 这可以通过在程序感兴趣的位置断言不变量，并使用任何生成的反例来对其进行精炼来完成。</li></ol></li><li><ol start="3"><li><strong>错误定位</strong>：通过分析 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mrow><mi>c</mi><mi>o</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>c</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\varphi_{correct}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">correc</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 和 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mrow><mi>v</mi><mi>i</mi><mi>o</mi><mi>l</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\varphi_{violated}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>,计算可能产生有效补丁的可疑语句列表</li></ol></li><li><ol start="4"><li><strong>补丁生成</strong>：构造代码，纠正错误的不变量，同时保持程序其它的不变量，通过使用类似搜索或基于语义的补丁生成过程来执行</li></ol></li><li><ol start="5"><li><strong>补丁验证</strong>：使用 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></eq> 验证生成的补丁的正确性</li></ol></li></ul></li><li><p>根据正在修复的bug类型和分析程序的结构，不同的程序位置可能与属性 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mrow><mi>c</mi><mi>o</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>c</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\varphi_{correct}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">correc</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 和 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mrow><mi>v</mi><mi>i</mi><mi>o</mi><mi>l</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\varphi_{violated}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 相关联。 示例包括不同函数的前置条件和后置条件，或者某些程序的循环不变量。 需要注意，根据定义2描述的基于不变量的APR过程的前两个步骤对于增加生成的补丁精度是必要的，该过程的实际修复步骤，即3-5步，可以正式陈述如下：</p><ul><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>t</mi><mo>=</mo><mi>F</mi><mi>V</mi><mo stretchy="false">(</mo><mi>P</mi><mi>G</mi><mi>V</mi><mo stretchy="false">(</mo><mi>F</mi><mi>L</mi><mo stretchy="false">(</mo><msub><mi>φ</mi><mrow><mi>c</mi><mi>o</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>c</mi><mi>t</mi></mrow></msub><mo separator="true">,</mo><msub><mi>φ</mi><mrow><mi>v</mi><mi>i</mi><mi>o</mi><mi>l</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi></mrow></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>T</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mi>φ</mi><mrow><mi>c</mi><mi>o</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>c</mi><mi>t</mi></mrow></msub><mo separator="true">,</mo><msub><mi>φ</mi><mrow><mi>v</mi><mi>i</mi><mi>o</mi><mi>l</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">pt = FV(PGV(FL(\varphi_{correct},\varphi_{violated}),T),\varphi_{correct},\varphi_{violated})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">pt</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathnormal">PG</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">correc</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">correc</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq></li><li>上式中，<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>L</mi></mrow><annotation encoding="application/x-tex">FL</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">L</span></span></span></span></eq> 是基于不变量的错误定位，</li><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mi>G</mi><mi>V</mi></mrow><annotation encoding="application/x-tex">PGV</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">PG</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></eq> 是使用测试套件进行补丁生成和验证过程</li><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>V</mi></mrow><annotation encoding="application/x-tex">FV</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></eq> 表示使用验证工具V进行正式补丁验证的过程。<ul><li>如果未找到合理的补丁，或者找到的补丁是不正确的，则修复过程返回失败。</li><li>如果合理的补丁通过了工具V执行的验证步骤，该过程将返回一个补丁</li></ul></li></ul></li><li><p>接下来讨论如何通过分析使用通过和失败的测试运行程序P产生规范 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mrow><mi>c</mi><mi>o</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>c</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\varphi_{correct}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">correc</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 和 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mrow><mi>v</mi><mi>i</mi><mi>o</mi><mi>l</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\varphi_{violated}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>，对无故障和有故障运行的分析产生了以下模式</p><ul><li><ol><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mrow><mi>c</mi><mi>o</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>c</mi><mi>t</mi></mrow></msub><mo>=</mo><msub><mi mathvariant="script">I</mi><mrow><mi>g</mi><mi>o</mi><mi>o</mi><mi>d</mi></mrow></msub><mo>=</mo><mi>V</mi><mo stretchy="false">(</mo><mi>D</mi><mo stretchy="false">(</mo><mi>P</mi><mo separator="true">,</mo><msub><mi>T</mi><mi>P</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\varphi_{correct} = \mathcal{I}_{good}=V(D(P,T_P))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">correc</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="mord mathnormal mtight">oo</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">))</span></span></span></span></eq>,只是用成功运行推断不变量，这些不变量表示程序 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></eq> 的预期行为</li></ol></li><li><ol start="2"><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mrow><mi>f</mi><mi>a</mi><mi>u</mi><mi>l</mi><mi>t</mi><mi>y</mi></mrow></msub><mo>=</mo><msub><mi mathvariant="script">I</mi><mrow><mi>m</mi><mi>i</mi><mi>x</mi></mrow></msub><mo>=</mo><mi>V</mi><mo stretchy="false">(</mo><mi>D</mi><mo stretchy="false">(</mo><mi>P</mi><mo separator="true">,</mo><msub><mi>T</mi><mi>F</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\varphi_{faulty} = \mathcal{I}_{mix}=V(D(P,T_F))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">lt</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">mi</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">))</span></span></span></span></eq>,使用失败运行推断不变量，注意到 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">I</mi><mrow><mi>m</mi><mi>i</mi><mi>x</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\mathcal{I}_{mix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">mi</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 可能同时包含好的和坏的模式，这取决于目标错误如何影响 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></eq> 的不同功能。</li></ol></li><li><ol start="3"><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mrow><mi>v</mi><mi>i</mi><mi>o</mi><mi>l</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi></mrow></msub><mo>=</mo><msub><mi mathvariant="script">I</mi><mrow><mi>m</mi><mi>i</mi><mi>x</mi></mrow></msub><mi mathvariant="normal">/</mi><msub><mi mathvariant="script">I</mi><mrow><mi>g</mi><mi>o</mi><mi>o</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\varphi_{violated} = \mathcal{I}_{mix} / \mathcal{I}_{good}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">mi</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="mord mathnormal mtight">oo</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></eq>, 与错误相关的违反不变量的集合</li></ol></li></ul></li><li><p>将推断的不变量分类和区分为好的和坏的模式是很重要的，特别是在处理有多个功能要求的程序时。</p><ul><li>这将有助于在修改代码时确定要维持的期望不变量集合和要修复的冲突的不变量集合。</li><li>同时也将帮助识别与分析bug相关的不变量集合</li></ul></li><li><p>推断出的 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mrow><mi>c</mi><mi>o</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>c</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\varphi_{correct}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">correc</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 和 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mrow><mi>v</mi><mi>i</mi><mi>o</mi><mi>l</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\varphi_{violated}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 的准确性很大程度上取决于所使用不变量推断工具的准确性和不变量精炼过程的准确性，通过可达性分析增加程序行为的覆盖范围，可以增加 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mrow><mi>c</mi><mi>o</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>c</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\varphi_{correct}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">correc</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 和 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mrow><mi>v</mi><mi>i</mi><mi>o</mi><mi>l</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\varphi_{violated}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 为真的可能性</p></li></ul><h4 id="definition-3-%EF%BC%88patch-validation-in-invariant-based-apr%EF%BC%89" tabindex="-1">Definition 3 （Patch validation in invariant-based APR）</h4><ul><li><p>令 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></eq> 为一个包括 bug <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span></eq> 的程序，<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span></eq> 是一个包含至少一个失败测试和一个正确测试的测试套件。 假设 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">pt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">pt</span></span></span></span></eq> 是一个合理的补丁使得 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></eq> 通过了 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span></eq> 中的所有测试用例。 补丁 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">pt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">pt</span></span></span></span></eq> 的有效性可以按照以下形式进行检查 <section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi><mi>i</mi><mi>d</mi><mi>i</mi><mi>t</mi><mi>y</mi><mo>=</mo><mi>V</mi><mo stretchy="false">(</mo><mi>p</mi><mi>t</mi><mo separator="true">,</mo><msub><mi>φ</mi><mrow><mi>c</mi><mi>o</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>c</mi><mi>t</mi></mrow></msub><mo stretchy="false">)</mo><mo>∧</mo><mi mathvariant="normal">¬</mi><mi>V</mi><mo stretchy="false">(</mo><mi>p</mi><mi>t</mi><mo separator="true">,</mo><msub><mi>φ</mi><mrow><mi>v</mi><mi>i</mi><mi>o</mi><mi>l</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">validity = V(pt,\varphi_{correct}) \wedge \neg V(pt,\varphi_{violated})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathnormal">pt</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">correc</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">¬</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathnormal">pt</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></eqn></section> 其中 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo stretchy="false">(</mo><mi>p</mi><mi>t</mi><mo separator="true">,</mo><msub><mi>φ</mi><mrow><mi>c</mi><mi>o</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>c</mi><mi>t</mi></mrow></msub><mo stretchy="false">)</mo><mo>∈</mo><mo stretchy="false">{</mo><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi><mo separator="true">,</mo><mi>f</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">V(pt,\varphi_{correct}) \in \{true,false\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathnormal">pt</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">correc</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">se</span><span class="mclose">}</span></span></span></span></eq> , 工具的响应取决于正在检查的程序是否满足或违反了规范</p></li><li><p>为了提高对生成补丁有效性的信心，我们选择针对 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mrow><mi>c</mi><mi>o</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>c</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\varphi_{correct}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">correc</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 和 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mrow><mi>v</mi><mi>i</mi><mi>o</mi><mi>l</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\varphi_{violated}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 进行验证。 然而，为了降低调用验证器 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></eq> 的成本，我们打算实施一个三步的补丁验证方法，首先使用测试套件，然后在使用程序验证器，生成合理的补丁是通过使用测试用例在第一步完成的，第二步设计对合理补丁针对不良模式集合（属性 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mrow><mi>v</mi><mi>i</mi><mi>o</mi><mi>l</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\varphi_{violated}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> ）进行检查，通过前两步的补丁在第三步针对良好模式集合（属性 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mrow><mi>c</mi><mi>o</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>c</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\varphi_{correct}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">correc</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> ）进行检查</p></li></ul><h3 id="3-%E4%BD%BF%E7%94%A8invariant%E7%9A%84apr%E4%BF%AE%E5%A4%8D-performance-bugs" tabindex="-1">3 使用invariant的APR修复 Performance Bugs</h3><ul><li>性能bug是导致系统性能显著下降的编程错误。经验表明，许多广泛使用的商业软件都存在性能问题[13,6,10].</li><li>因此，这里需要开发一个严格的性能错误修复框架，确保在不影响功能的情况下提高效率。<ul><li>与功能错误相比，性能错误的一个独特特征是性能错误不会影响程序的功能性（即程序在语义上是正确的，但效率低下），因此可以使用不变量推断工具自动推断程序的与其行为</li></ul></li><li>本节描述了一个针对性能错误的基于不变量的APR系统，并演示了如何通过生成可以确保提高效率而不牺牲功能性的补丁来处理性能错误</li></ul><h4 id="3.1-%E9%92%88%E5%AF%B9%E6%80%A7%E8%83%BDbug%E7%9A%84%E5%9F%BA%E4%BA%8E%E4%B8%8D%E5%8F%98%E9%87%8F%E7%9A%84%E4%BF%AE%E5%A4%8D%E6%A1%86%E6%9E%B6" tabindex="-1">3.1 针对性能bug的基于不变量的修复框架</h4><ul><li><p>在本节，我们描述解决性能bug的基于不变量的修复框架，框架主要包含以下部分</p><ul><li><ol><li>通过测试集：包含使程序运行快速的测试用例。</li></ol></li><li><ol start="2"><li>失败测试集：包含导致程序运行缓慢的测试用例。</li></ol></li><li><ol start="3"><li>运行时监视器：用于跟踪程序的执行时间，并区分快速运行和缓慢运行。</li></ol></li><li><ol start="4"><li>自动不变量推断工具（例如Daikon或CPAChecker）和自动不变量验证工具（例如PVS、Z3求解器或CPAChecker）。</li></ol></li></ul></li><li><p>接下来讨论如何定义通过测试和失败测试的概念，以及针对性能错误，生成和验证补丁的过程</p></li></ul><h5 id="%E9%92%88%E5%AF%B9%E6%80%A7%E8%83%BD%E9%94%99%E8%AF%AF%E7%9A%84%E9%80%9A%E8%BF%87%E5%92%8C%E5%A4%B1%E8%B4%A5%E6%B5%8B%E8%AF%95" tabindex="-1">针对性能错误的通过和失败测试</h5><ul><li>性能错误在运行时不会产生debug信息：不会产生崩溃，异常或不正确的结果。 因此我们使用一个含有预定义定时器的运行时监视器来重新定义通过和失败测试的概念</li><li>我们将导致快速运行的测试用例视为通过测试，而导致缓慢运行的测试用例视为失败测试。</li><li>一个修复方案，可以将缓慢运行转换为快速运行，同时保持原程序的期望行为，有效的修复</li></ul><h5 id="%E9%92%88%E5%AF%B9%E6%80%A7%E8%83%BD%E9%94%99%E8%AF%AF%E7%9A%84%E8%A1%A5%E4%B8%81%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5" tabindex="-1">针对性能错误的补丁生成策略</h5><ul><li>因为我们处理的是语义上正确但效率底下的程序，因此通常可以通过重构原始程序的基本组件来创建程序的高效版本。</li><li>我们的初步分析表明，遗传修复工具（如GenProg）在处理性能错误方面是有效的。这表明，通过相对简单的更改，可以修复具有性能错误的程序。例如，可以使用遗传修复工具使用的移动，交换，删除和插入等变异操作符来修复各种性能错误</li><li>因此，我们的目标是将我们的修复框架和基于遗传的补丁生成工具结合起来</li></ul><h5 id="%E9%92%88%E5%AF%B9%E6%80%A7%E8%83%BD%E9%94%99%E8%AF%AF%E7%9A%84%E8%A1%A5%E4%B8%81%E9%AA%8C%E8%AF%81" tabindex="-1">针对性能错误的补丁验证</h5><ul><li>需要注意的是，不变量推断工具也可以用于推导与程序非功能属性相关的。这可以通过向被修复的程序添加额外的非功能变量来实现。</li><li>假设我们有一个程序 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></eq> 带有一组变量 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></eq> ，其中包含一个性能错误。 我们需要检查为程序 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></eq> 生成的补丁是否修理了性能错误，同时没有引入新的功能错误。为此，我们需要生成并验证与程序效率属性相关的断言，如下所述<ul><li><ol><li>添加一个新变量值 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>f</mi><mi>v</mi></mrow><annotation encoding="application/x-tex">nfv</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span></eq> , 其值不会影响 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></eq> 的行为。正在处理的性能错误的类型决定了如何使用 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>f</mi><mi>v</mi></mrow><annotation encoding="application/x-tex">nfv</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span></eq> 来模拟程序的效率。然而，对于我们考虑的循环程序，<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>f</mi><mi>v</mi></mrow><annotation encoding="application/x-tex">nfv</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span></eq> 的作用像一个计数器，每次迭代增加一次，换句话说，这是循环迭代次数作为效率的模型</li></ol></li><li><ol start="2"><li>使用不变量推断工具 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span></eq> 来推断原始版本和补丁版本的不变量上的数量，分别表示为 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">I</mi><mo stretchy="false">(</mo><mi>P</mi><mo separator="true">,</mo><mi>n</mi><mi>f</mi><mi>v</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi mathvariant="script">I</mi><mo stretchy="false">(</mo><mi>p</mi><mi>t</mi><mo separator="true">,</mo><mi>n</mi><mi>f</mi><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{I}(P,nfv),\mathcal{I}(pt,nfv)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="mopen">(</span><span class="mord mathnormal">pt</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span></eq>,前者表示 涉及变量 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>f</mi><mi>v</mi></mrow><annotation encoding="application/x-tex">nfv</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span></eq> 的程序 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></eq> 的不变量集合</li></ol></li><li><ol start="3"><li>比较 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">I</mi><mo stretchy="false">(</mo><mi>P</mi><mo separator="true">,</mo><mi>n</mi><mi>f</mi><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{I}(P,nfv)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span></eq> 和 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">I</mi><mo stretchy="false">(</mo><mi>p</mi><mi>t</mi><mo separator="true">,</mo><mi>n</mi><mi>f</mi><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{I}(pt,nfv)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="mopen">(</span><span class="mord mathnormal">pt</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span></eq> 中的 数值 断言，确定补丁版本是否比原始版本更有效率</li></ol></li></ul></li><li>为简单起见，我们假设我们处理的程序只有一个循环。然而，分析程序中的循环数量决定了需要多少个额外变量，因此，不变量推断工具 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span></eq> 用于推断关于 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo>∪</mo><mo stretchy="false">{</mo><mi>n</mi><mi>f</mi><mi>v</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">V\cup \{nfv\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">}</span></span></span></span></eq> 的不变量，然后我们区分以下类型的断言<ul><li><ol><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">I</mi><mo stretchy="false">(</mo><mi>P</mi><mo separator="true">,</mo><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{I}(P,V)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose">)</span></span></span></span></eq>： 与程序功能相关的断言</li></ol></li><li><ol start="2"><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">I</mi><mo stretchy="false">(</mo><mi>P</mi><mo separator="true">,</mo><mi>n</mi><mi>f</mi><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{I}(P,nfv)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span></eq>：与程序效率相关的断言</li></ol></li></ul></li><li>使用生成的断言，可以用以下方法检测补丁的有效性 <section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi><mi>i</mi><mi>d</mi><mi>i</mi><mi>t</mi><mi>y</mi><mo stretchy="false">(</mo><mi>p</mi><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>S</mi><mi>E</mi><mi>M</mi><mi>A</mi><mi>E</mi><mi>Q</mi><mo stretchy="false">(</mo><mi mathvariant="script">I</mi><mo stretchy="false">(</mo><mi>P</mi><mo separator="true">,</mo><mi>V</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mi mathvariant="script">I</mi><mo stretchy="false">(</mo><mi>p</mi><mi>t</mi><mo separator="true">,</mo><mi>V</mi><mo stretchy="false">)</mo><mo>∧</mo><mi>P</mi><mi>R</mi><mi>E</mi><mi>D</mi><mi>S</mi><mi>M</mi><mo stretchy="false">(</mo><mi mathvariant="script">I</mi><mo stretchy="false">(</mo><mi>p</mi><mi>t</mi><mo separator="true">,</mo><mi>n</mi><mi>f</mi><mi>v</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi mathvariant="script">I</mi><mo stretchy="false">(</mo><mi>P</mi><mo separator="true">,</mo><mi>n</mi><mi>f</mi><mi>v</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">validity(pt)=SEMAEQ(\mathcal{I}(P,V)),\mathcal{I}(pt,V) \wedge PREDSM(\mathcal{I}(pt,nfv),\mathcal{I}(P,nfv))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathnormal">pt</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">SEM</span><span class="mord mathnormal">A</span><span class="mord mathnormal">EQ</span><span class="mopen">(</span><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose">))</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="mopen">(</span><span class="mord mathnormal">pt</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">PRE</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.10903em;">SM</span><span class="mopen">(</span><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="mopen">(</span><span class="mord mathnormal">pt</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">))</span></span></span></span></span></eqn></section> 其中 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>E</mi><mi>M</mi><mi>A</mi><mi>E</mi><mi>Q</mi></mrow><annotation encoding="application/x-tex">SEMAEQ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">SEM</span><span class="mord mathnormal">A</span><span class="mord mathnormal">EQ</span></span></span></span></eq> 是一个bool操作来检查给定的不变量集合是否语义相同，<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mi>R</mi><mi>E</mi><mi>D</mi><mi>S</mi><mi>M</mi></mrow><annotation encoding="application/x-tex">PREDSM</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">PRE</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.10903em;">SM</span></span></span></span></eq> 是一个bool操作来检查与修补版本相关的谓词中的上界是否小于与原始程序相关的谓词中的上界。</li><li>我们现在描述两种正式的程序，使用可用的程序验证工具验证合理补丁的有效性<ul><li><ol><li>Daikon-PVS：在这个补丁验证过程中，Daikon用于生成和程序 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo separator="true">,</mo><mi>p</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">P,pt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">pt</span></span></span></span></eq> 功能和效率相关的断言。 如果 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">I</mi><mo stretchy="false">(</mo><mi>P</mi><mo separator="true">,</mo><mi>V</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi mathvariant="script">I</mi><mo stretchy="false">(</mo><mi>p</mi><mi>t</mi><mo separator="true">,</mo><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{I}(P,V),\mathcal{I}(pt,V)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="mopen">(</span><span class="mord mathnormal">pt</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose">)</span></span></span></span></eq> (即与功能属性相关的断言)不相同，则可能需要检查这些集合中的谓词之间的等价和蕴含关系，以确定 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></eq> 和 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">pt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">pt</span></span></span></span></eq> 是否在语义上等价。通过查询定理证明器 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mi>V</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">PVS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span></eq> ，可以完成这项任务。</li></ol></li><li><ol start="2"><li>CPAChecker-PVS:CPACheck的一个有趣特性是它以GraphML格式产生正确性证明，并且在这些证明中，可以分析程序的不变量。可以利用这个特性生成原始程序和相应的合理程序的不变量集合。如果两个程序的不变量集合不相同，则可能需要调用 PVS来检查这两个不变量集合之间的等价和蕴含关系。</li></ol></li></ul></li></ul><h4 id="3.2-%E4%BD%BF%E7%94%A8%E5%9F%BA%E4%BA%8E%E4%B8%8D%E5%8F%98%E9%87%8F%E7%9A%84apr%E4%BF%AE%E5%A4%8D%E7%8E%B0%E5%AE%9E%E4%B8%96%E7%95%8C%E7%9A%84%E6%80%A7%E8%83%BDbug" tabindex="-1">3.2 使用基于不变量的APR修复现实世界的性能bug</h4><ul><li>本节，我们将展示基于不变量的APR可以用于解决现实世界的性能bug。处于空间的原因，我们只考虑一个有趣的性能bug的实例，如下代码。这个bug是基于真实事件Apache的一个真实缺陷，也被其它研究人员研究过</li></ul><pre><code class="language-C">int found = -1;while ( found &lt; 0 ) &#123;// Check if string source [] contains target []  char first = target [0];  int max = sourceLen - targetLen ;  for (int i = 0; i &lt;= max; i++) &#123;    // Look for first character .    if ( source [i] != first) &#123;      while (++i &lt;= max &amp;&amp; source[i] != first );    &#125;   // Found first character    if (i &lt;= max) &#123;      int j = i + 1;      int end = j + targetLen - 1;      for (int k=1; j&lt;end &amp;&amp; source [j]== target[k]; j++, k ++);        if (j == end) &#123;        /* Found whole string target . */          found = i;          break;        &#125;      &#125;  &#125;  // append another character ; try again  source [ sourceLen ++] = getchar ();&#125;</code></pre><h5 id="%E5%AF%B9%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90" tabindex="-1">对程序分析</h5><ul><li>该程序旨在确定给定的（目标）字符串是否包含在另一个（源）字符串中。如果在源字符串中找到了目标字符串，程序设置变量<code>found</code>设置为目标字符串的第一个字符的索引。</li><li>但是，该程序存在一个很大的性能缺陷：<ul><li>当目标字符串位于源字符串的开头时，运行速度很快；</li><li>当字符串接近源字符串末尾时，运行速度缓慢，这是因为有大量冗余计算的增加，错误在于for循环控制的循环变量i的初始化语句在第6行应该放在主while循环外，就在变量<code>found</code>初始化之后</li></ul></li></ul><h4 id="3.3-%E7%BB%93%E6%9E%9C%E5%92%8C%E5%88%86%E6%9E%90" tabindex="-1">3.3 结果和分析</h4><ul><li>为了处理3.2中的性能bug，我们选择了两种APR工具，这两种工具都是修复C代码的通用修复工具，可以用于修复一系列程序错误，包括循环程序错误<ul><li>基于搜索的GenProg[7]</li><li>基于语义的FAnglix[16]</li></ul></li><li>GenProg成功生成了一个合理的补丁，但FAnglix没有。<ul><li>为了避免原始程序中的重复计算，GenProg将变量i的初始化语句移动到了第6行for循环之外，即修补版本的程序以变量i的初始化语句开始，此时生成的补丁同构了测试用例，因为i不再每次循环接收新字符时被设置为0</li></ul></li><li>为了检查GenProg生成的合理补丁的有效性，我们使用了工具Daikon，比较了原始程序和合理补丁版本的功能和效率断言。 Daikon生成了与功能变量相关的相同不变量集合（即，原始版本和修补版本都有与程序变量相关的相同不变量），这表明补丁保持了原始程序的功能行为</li></ul><h5 id="%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90" tabindex="-1">代码分析</h5><ul><li>代码中包含了4个的循环<ul><li>第2行的while循环</li><li>第6行的for循环</li><li>第9行的while循环</li><li>第15行的for循环</li></ul></li><li>为了评估原始程序和修补程序的效率，需要计算迭代次数的上界，因为补丁不会通过添加或删除操作修改任何循环的逻辑，即在两个程序中，四个循环的每次迭代都涉及相同数量的操作，因此，我为每个循环添加四个迭代计数器(cnt2,cnt6,cnt9,cnt15)来模拟每个循环的效率。 在分析缺陷和修补版本的效率断言中，我们得出以下观察结果<ul><li>对于有缺陷和修补版本中的cnt2，cnt15生成的不变量时相同的，这表明补丁不会影响第2，15行循环的迭代次数</li><li>cnt9只在缺陷版本中递增，并且cnt9&lt;=500499，修补版本不再使用第9行的while循环是一个重大的改进</li><li>Daikon为有缺陷版本生成了不变量cnt6&lt;=1001，而修补版本生成了不变量cnt6&lt;=501，这表明修补版本的第6行循环的迭代次数比原始代码中少了50%</li></ul></li><li>上述发现，以及原始版本和修补版本的衍生功能断言时相同的事实，增强了我们对GenProg工具生成补丁有效性的信心</li></ul><h3 id="4-%E7%9B%B8%E5%85%B3%E5%B7%A5%E4%BD%9C" tabindex="-1">4 相关工作</h3><h4 id="apr%E4%B8%AD%E8%BF%87%E6%8B%9F%E5%90%88%E9%97%AE%E9%A2%98" tabindex="-1">APR中过拟合问题</h4><ul><li>目前已有多种解决方法来缓解APR中的过度拟合问题<ul><li>例如符号规范推断[8]</li><li>基于机器学习的补丁优先级排序[1]</li><li>基于模糊测试的测试套件增强[5]和合成路径探索[12]</li><li>这些措施依赖于有限的不完整的测试用例，不能保证补丁的普遍正确性。</li></ul></li><li>与基于生成测试输入的方法相比面积与不变量的APR在修改代码时自动生成并精炼需要保持的不变量即需要修复的问题不变量，这使得该方法比现有修复方法更可靠。</li><li>现在通用的APR工具依赖于符号执行或合成执行来发现反例并生成修复补丁[9,12],然而这些修复方法需要手动检查生成的补丁是否正确或与开发者的补丁相同，这可能存在错误。 基于不变量的APR使得可以应用自动化验证技术来缓解过拟合问题，并通过与开发者补丁相比较来正式和系统地检查生成的补丁的准确性</li></ul><h4 id="%E8%A7%A3%E5%86%B3%E6%80%A7%E8%83%BD%E9%94%99%E8%AF%AF" tabindex="-1">解决性能错误</h4><ul><li>目前已经进行了许多尝试，使用动态，静态，混合分析方法来检测和修复程序中的性能错误[13,6,10]。<ul><li>[10]对性能错误进行了实证调查，并提出了一个用于识别它们的效率规则。</li><li>[13]中，使用动态-静态分析技术，开发了几种修复策略来识别和解决性能问题。</li></ul></li><li>然而我们的方法与先前的研究不同之处在于，它是一种更通用和精确的技术，利用程序不变量来解决循环程序的性能问题，并产生可靠的补丁。因为系统不变量，原始程序的效率可以系统的和修补版本进行比较</li></ul><h3 id="5-%E7%BB%93%E8%AE%BA-%E5%92%8C-%E6%9C%AA%E6%9D%A5%E5%B7%A5%E4%BD%9C" tabindex="-1">5 结论 和 未来工作</h3><h4 id="%E7%BB%93%E8%AE%BA" tabindex="-1">结论</h4><ul><li>我们描述了一个基于程序不变量概念的新型自动程序修复(APR)系统。<ul><li>基于不变量的APR有望处理比其它APR方法更广泛的错误，并生成更可靠的补丁，这是由于基于不变量的修复系统依赖于更强的正确性指标，而不是测试套件。</li><li>我们通过开发了一个针对性能缺陷的不变量修复系统来展示APR中利用不变量的实用性。 初步结果现实，基于不变量的APR可以帮助生成高质量的补丁，这些补丁可以确保程序效率提高而不会对其功能产生不利影响。</li></ul></li></ul><h4 id="%E6%9C%AA%E6%9D%A5%E5%B7%A5%E4%BD%9C" tabindex="-1">未来工作</h4><ul><li>为了完善此处开始的基于不变量的APR研究，我们确定了以下未来工作的关键方向<ul><li>首先，我们的主要目的是进行深入的实证分析，以确定基于不变量的APR在处理程序中功能性和非功能性缺陷方面的表现如何，这还涉及评估当前可访问的不变量推断和验证工具</li><li>准确的不变量生成是确保基于不变量的APR生成的补丁有效性的关键，我们推测可达性分析可以帮助解决这个复杂的计算任务，我们的目标是将基于不变量的APR与支持不变量生成和精炼的程序验证工具（如CPAChecker和PathFinder）相结合</li></ul></li></ul><h2 id="%E2%85%B1-invalidator%3A-automated-patch-correctness-assessment-via-semantic-and-syntactic-reasoning" tabindex="-1">Ⅱ Invalidator: Automated Patch Correctness Assessment Via Semantic and Syntactic Reasoning</h2><ul><li>引用：Le-Cong T, Luong D M, Le X B D, et al. Invalidator: Automated patch correctness assessment via semantic and syntactic reasoning[J]. IEEE Transactions on Software Engineering, 2023.</li><li>CCF A TSE</li><li><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=10066209">链接</a></li></ul><h3 id="4.1-%E4%BB%8B%E7%BB%8Da" tabindex="-1">4.1 介绍a</h3><ul><li>本论文介绍名为INVALIDATOR的新技术，它结合了语义和语法推理来自动评估由自动程序修复（APR）技术生成的补丁的正确性。<ul><li>利用程序不变量推理程序的语义属性</li><li>使用预训练语言模型捕捉程序语法，该模型从大量代码语料库中学习语言语义。</li></ul></li><li>与其他自动化补丁正确性评估（APAC）技术类似，INVALIDATOR利用APR修补过的程序与真实正确程序之间的行为差异来确定补丁的正确性。然而<ul><li>例如DIFFTGEN [65]、PATCHSIM [66]或RANDOOP [18]、[46]。这些技术生成新测试以增强当前测试套件，其中每个测试生成一个执行，执行次数与生成测试用例成正比</li><li>INVALIDATOR仅使用当前测试套件，并推断出自然泛化超出测试套件的程序不变量，程序不变量的泛化运行INVALIDATOR高效且在语义上推理程序的正确性，此外，INVALIDATOR融入语法推理来增强其有效性，进一步增强语义推理</li></ul></li></ul><h3 id="4.2-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B" tabindex="-1">4.2 工作流程</h3><ul><li><ol><li><strong>基于语义的分类器</strong>：</li></ol><ul><li>由两个高级直观概念构成<ul><li>a. 程序不变量在错误版本和正确版本都保持不变，可以作为程序的正确规范</li><li>b. 只在错误版本存在但在正确版本不存在的程序不变量可能表示程序的错误规范</li></ul></li><li>如果自动生成的不定违反了正确的规范或保留了错误的规范，INVALIDATOR会判断过拟合</li><li>INVALIDATOR首先使用DAIKON根据原始测试套件自动推断每个程序的可能不变式。然后，INVALIDATOR构造正确和错误的规范集合，这些规范作为被测程序的近似规范。根据推断出的规范，如果从机器修补的程序中推断出的不变式违反了正确的规范或保留了错误的规范，INVALIDATOR就会判断补丁过拟合。</li></ul></li><li><ol start="2"><li><strong>基于语法的分类器</strong></li></ol><ul><li>在基于不变式的规范推断无法确定过拟合补丁的情况下，INVALIDATOR进一步通过机器生成的补丁与其错误版本和正确版本之间的语言语义差异来识别过拟合补丁。</li><li>具体使用使用预训练的语言模型，即CODEBERT，从每个程序的源代码中提取源语法特征。然后，INVALIDATOR通过一系列比较函数（例如，减法或相似度）来衡量差异。最后，INVALIDATOR使用从标记数据训练的模型来估计基于语法接近度的机器生成补丁是否过拟合的可能性。</li></ul></li></ul><h3 id="4.3-%E4%B8%BB%E8%A6%81%E5%86%85%E5%AE%B9" tabindex="-1">4.3 主要内容</h3><ul><li><p>在本文中，我们使用Daikon[7]——一个流行的用于挖掘可能不变式的工具，作为我们的动态不变式推断技术。Daikon观察程序的执行轨迹，并将它们与一组模板进行匹配，以推断出在所有或大多数执行中成立的可能不变式。Daikon可以从多达311个模板的大型集合中（参见Daikon手册文档1的细节），检测出广泛概括超出用于产生执行轨迹的测试套件的各种不变式[49]。</p></li><li><p>APR技术的作者通常通过以下两种方式评估补丁的正确性：</p><ul><li>(1) 使用与修复时所用测试套件不同的独立测试套件来测试生成补丁的泛化能力；</li><li>(2) 通过与真实情况进行比较的手动检查来评估APR生成的补丁。</li></ul></li><li><p>Le等人表明，通过独立测试套件进行的自动验证不如手动验证有效，但使用手动验证存在人为偏见的潜在风险。此外，手动验证需要重复且昂贵的任务，而自动验证可以弥补这一点。</p></li></ul><h2 id tabindex="-1"></h2><p>Mesbah A, Van Deursen A, Roest D. Invariant-based automatic testing of modern web applications[J]. IEEE Transactions on Software Engineering, 2011, 38(1): 35-53.</p><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;%E2%85%B0-invariant-based-program-repair&quot; tabindex=&quot;-1&quot;&gt;Ⅰ Invariant-based Program Repair&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;引用：Al-Bataineh O I. Invariant</summary>
      
    
    
    
    <category term="论文" scheme="http://example.com/categories/%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="SoftwareRepair" scheme="http://example.com/tags/SoftwareRepair/"/>
    
    <category term="Invariant" scheme="http://example.com/tags/Invariant/"/>
    
  </entry>
  
  <entry>
    <title>不变量推断论文</title>
    <link href="http://example.com/2024/03/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/invariant/%E4%B8%8D%E5%8F%98%E9%87%8F%E6%8E%A8%E6%96%AD%E8%AE%BA%E6%96%87/"/>
    <id>http://example.com/2024/03/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/invariant/%E4%B8%8D%E5%8F%98%E9%87%8F%E6%8E%A8%E6%96%AD%E8%AE%BA%E6%96%87/</id>
    <published>2024-03-14T16:40:54.806Z</published>
    <updated>2024-03-22T15:46:55.007Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-%E5%9F%BA%E4%BA%8E%E5%8A%A8%E6%80%81%E5%88%86%E6%9E%90%E7%9A%84%E8%BD%AF%E4%BB%B6%E4%B8%8D%E5%8F%98%E9%87%8F%E7%BB%BC%E5%90%88%E6%8A%80%E6%9C%AF-(%E5%8A%A8%E6%80%81%E4%B8%8D%E5%8F%98%E9%87%8F%E7%BB%BC%E8%BF%B0)" tabindex="-1">0 基于动态分析的软件不变量综合技术 (动态不变量综述)</h2><ul><li>引用：Wang B, Lu SR, Jiang JJ, Xiong YF. Survey of Dynamic Analysis Based Program Invariant Synthesis Techniques[J]. Journal of Software, 2020, 31(6): 1681-1702(in Chinese). <a href="http://www.jos.org.cn/1000-9825/6014.htm">http://www.jos.org.cn/1000-9825/6014.htm</a></li><li>软件学报</li></ul><h2 id="2-searching-for-invariants-using-genetic-programming-and-mutation-testing" tabindex="-1">2 Searching for invariants using genetic programming and mutation testing</h2><ul><li>引用：Ratcliff S, White D R, Clark J A. Searching for invariants using genetic programming and mutation testing[C]//Proceedings of the 13th annual conference on Genetic and evolutionary computation. 2011: 1907-1914.</li><li>CCF C GECCO</li><li><a href="https://dl.acm.org/doi/epdf/10.1145/2001576.2001832">链接</a></li></ul><h3 id="1.0-%E6%91%98%E8%A6%81" tabindex="-1">1.0 摘要</h3><ul><li>本文贡献<ul><li>进化搜索可以用来找到程序不变量，就像Daikon发现的那样</li><li>进化搜索能够考虑比基于模板的工具更广泛的不变量范围</li><li>通过将突变测试与进化搜索相结合，可以识别出有趣的不变量</li></ul></li></ul><h3 id="1.1-%E4%B8%BB%E8%A6%81%E5%86%85%E5%AE%B9" tabindex="-1">1.1 主要内容</h3><ul><li>现有生成不变量工具的问题：Daikon的方法可以看作一个根据数据驱动暴力构造不变量的方法。尽管目前有许多启发式方法可以来减少不变量的生成数量，并向程序员展示最有用的不变量，但Daikon由于只能产生与模板对应的不变量，所有存在Daikon找不到有用不变量的情况</li><li>突变测试<ul><li>原理：如果使用测试集T来测试程序p，那么假设p是正确的，它应该通过T中的所有测试。然而，如果对程序p进行小的语法更改（即突变）以产生p’，那么除非p和p’在语义上等价，否则p’应该无法通过测试集</li><li>目的：评估测试套件的效力。它通过对源代码进行有意义的修改，即“突变”，然后运行测试套件来检测这些变化是否能够被检测到，从而评估测试用例的质量。</li><li>不变量与突变测试的关系：使用不变量生成来消除语义等家从而提升突变测试的效率[21]；<br><strong>本文使用突变测试来提高不变量生成效率，同时进行排序</strong></li></ul></li></ul><h2 id="3.-automatic-requirement-extraction-from-test-cases" tabindex="-1">3. Automatic Requirement Extraction from Test Cases</h2><ul><li>引用：Ackermann C, Cleaveland R, Huang S, et al. Automatic requirement extraction from test cases[C]， Runtime Verification: First International Conference, RV 2010, St. Julians, Malta, November 1-4, 2010. Proceedings 1. Springer Berlin Heidelberg, 2010: 1-15.</li></ul><h3 id="0-%E6%91%98%E8%A6%81" tabindex="-1">0 摘要</h3><ul><li>本论文描述了一种从测试中提取功能需求的方法，其中测试采用输入向量（提供给系统）和输出（系统响应输入而产生）的形式。<ul><li>该方法使用数据挖掘技术从测试数据中推断不变式，并利用自动验证技术来确定这些提出的不变式中哪些确实是不变的，因此可以被视为需求。</li><li>来自涉及汽车电子应用的试点研究的实验结果表明，使用完全覆盖软件结构的测试比结构性不可知的黑盒测试能够产生更完整的不变式。</li></ul></li></ul><h3 id="1-%E4%BB%8B%E7%BB%8D" tabindex="-1">1 介绍</h3><ul><li><p>本文提出并评估了一种基于数据挖掘的方法，用于自动从可执行软件构件中提取需求。这项工作的动机是使需求文档更加准确和完整。</p></li><li><p>用于遵循读-执行-写行为模型的软件</p><ul><li>首先，使用自动化测试生成器生成按照几种结构覆盖标准覆盖模型的输入序列集合；每个输入向量产生的输出结果也被收集</li><li>然后，将数据挖掘工具应用于测试数据，以推断在整个测试集上保持不变的输入和输出变量之间的关系（不变式）</li><li>在后续的验证步骤中，使用自动化工具检查哪些提出的不变式确实是不变的；通过这一步骤的不变式随后被提议作为需求。</li></ul></li><li><p>本文结构</p><ul><li>第2节提供了关于数据挖掘、不变式推理以及用于进行本研究的工具和验证技术的背景。</li><li>第3节更详细地概述了我们的方法</li><li>第4节和第5节介绍了涉及生产级汽车应用程序的试点研究结果</li><li>第6节讨论了相关工作</li><li>最后一节包含了我们的结论和未来工作的想法。</li></ul></li></ul><h3 id="2-%E8%83%8C%E6%99%AF" tabindex="-1">2 背景</h3><ul><li>本项工作受到了Raz等人[18, 17]的启发，他们使用数据挖掘工具从运行系统的执行轨迹中推断不变式，用于异常检测的目的。我们的动机不同在于，我们的工作旨在从模型驱动开发的汽车系统程序测试数据中重建需求。</li></ul><h4 id="2.1-%E4%BB%8E%E8%BF%90%E8%A1%8C%E4%B8%AD%E6%8E%A8%E6%96%AD%E4%B8%8D%E5%8F%98%E9%87%8F" tabindex="-1">2.1 从运行中推断不变量</h4><h4 id="2.3-%E5%9F%BA%E4%BA%8E%E4%BB%AA%E5%99%A8%E7%9A%84%E9%AA%8C%E8%AF%81" tabindex="-1">2.3 基于仪器的验证</h4><h3 id="3-%E6%8F%90%E5%8F%96%E9%9C%80%E6%B1%82" tabindex="-1">3 提取需求</h3><ul><li>步骤如下，依赖于使用覆盖测试和数据挖掘工具，从模型的模拟执行运行生成的测试数据中提出不变式，以及对这些不变式的随后验证。</li><li><strong>1 测试用例生成</strong>：通过自动化，基于覆盖的测试生成工具，在设计模型上运行生成的输出</li><li><strong>2 不变量推理</strong>：使用关联规则挖掘工具在第1步的测试数据中发现不变式。该工具提出了一组被认为是被检查模型的不变式的关联规则。我们只报告强度值等于1.0的不变式，这是强度分数可以达到的最大值[22]。这等价于意味着任何报告的不变式在观察到的数据中没有反例，即它是对执行推理的证据的真实不变式。</li><li><strong>3 不变式验证</strong>：模型覆盖度量仅仅保证关键元素（块、条件、决策等）在测试套件中至少执行了一次。当然，它们不能强制覆盖所有可能行为的完整覆盖（即路径覆盖）。这就是为什么推断出的不变式不能假设为真正的需求，并且必须进一步验证以便作为需求报告<ul><li>在Raz等人[18,17]这个验证是手动进行的。我们改为通过将每个候选要求转换为监控模型，并使用IBV来确定提出的不变式是否可以被证明无效，来自动化这个验证步骤。</li><li>在执行这个验证时，验证工具将生成一个新的测试套件，该测试套件在其尝试最大化模型覆盖的过程中，将尝试违反监控模型。如果监控模型不满足，那么它所代表的假定不变式并非对所有轨迹都成立，因此被丢弃。如果监控模型满足，那么我们可以说，具有很高信心水平地，已经从设计模型中推断出一个有效的不变式，并且可以视为一个需求。</li></ul></li></ul><h3 id="6-%E7%9B%B8%E5%85%B3%E5%B7%A5%E4%BD%9C" tabindex="-1">6 相关工作</h3><ul><li>Ernst等人提出的Daikon系统[8]在C、C++、Java和Perl编写的程序中动态检测“可能的不变式”。该方法的早期步骤使用代码插装器获取跟踪数据，这些数据被传递到其推理算法中。这些跟踪数据不能保证对检查中的程序有良好的覆盖；Ernst等人指出，可能需要对检查中的程序进行多次运行并结合。Daikon提出的不变式会检查冗余，但对于除了所提供的跟踪数据之外的测试用例，很难验证不变式的正确性</li></ul><h3 id="7-%E7%BB%93%E8%AE%BA" tabindex="-1">7 结论</h3><ul><li>本文提出了一个从可执行软件工件（例如遵循读-计算-写行为模型的控制软件）中重建需求的框架。该方法依赖于对结构覆盖工件的测试数据应用数据挖掘技术，以导出形式为不变式的建议需求，表达输入和输出之间的关系。然后，该方法使用自动化验证步骤来识别假的不变式。该方法在一个用Simulink建模的生产汽车照明控制应用程序上进行了试点；实验数据表明，使用全覆盖测试数据比随机测试数据产生更好的不变式集，并且迭代应用该方法可以进一步改进这些不变式。</li><li>作为未来的工作，我们希望进一步试验该方法，使用其他与汽车相关的Simulink模型。我们还希望研究使用不同的覆盖标准（如决策覆盖、MC/DC等）对不变式集质量的影响。最后，本研究中研究的不变式缺乏时间方面的内容；我们有兴趣追求允许推断包含时间元素的需求（例如“如果a发生，则b必须在x时间单位内发生”）的需求生成策略。</li></ul><h2 id="4-dig" tabindex="-1">4 Dig</h2><ul><li>引用：Nguyen T V, Kapur D, Weimer W, et al. DIG: A dynamic invariant generator for polynomial and array invariants[J]. ACM Transactions on Software Engineering and Methodology (TOSEM), 2014, 23(4): 1-30.</li><li>CCF A TOSEM</li></ul><h2 id="5-feedback-driven-dynamic-invariant-discovery" tabindex="-1">5 Feedback-driven dynamic invariant discovery</h2><ul><li>引用：Zhang L, Yang G, Rungta N, et al. Feedback-driven dynamic invariant discovery[C]，Proceedings of the 2014 International Symposium on Software Testing and Analysis. 2014: 362-372.</li><li>CCF A ISSTA</li><li><a href="https://doi.org/10.1145/2610384.2610389">链接</a></li></ul><h2 id="6-dysy%3A-dynamic-symbolic-execution-for-invariant-inference" tabindex="-1">6 Dysy: Dynamic symbolic execution for invariant inference</h2><ul><li>引用：Csallner C, Tillmann N, Smaragdakis Y. DySy: Dynamic symbolic execution for invariant inference[C]，Proceedings of the 30th international conference on Software engineering. 2008: 281-290.</li><li>CCF A ICSE</li></ul><h2 id tabindex="-1"></h2><p>N. Tillmann, F. Chen, and W. Schulte. Discovering likely<br>method specifications. Formal Meth. Softw. Eng., pages<br>717–736, 2006.</p><h2 id="-1" tabindex="-1"></h2><p>Y. Wei, C. Furia, N. Kazmin, and B. Meyer. Inferring better<br>contracts. In Int’l Conf. Softw. Eng., pages 191–200, 2011.</p><h2 id="(%E7%96%91%E4%BC%BC%E4%B9%9F%E6%98%AF%E7%94%A8%E6%88%B7%E7%A0%94%E7%A9%B6%EF%BC%9F)" tabindex="-1">(疑似也是用户研究？)</h2><p>[26] N. Polikarpova, I. Ciupa, and B. Meyer. A comparative study<br>of programmer-written and automatically inferred contracts.<br>In Int’l Symp. Softw. Test. Analy., pages 93–104, 2009.</p><h2 id="%EF%BC%88%E4%B9%9F%E6%9C%89%E7%94%A8%E6%88%B7%E7%A0%94%E7%A9%B6%EF%BC%89" tabindex="-1">（也有用户研究）</h2><p>J. W. Nimmer and M. D. Ernst. Automatic generation of<br>program specifications. In Int’l Symp. Softw. Test. Analy.,<br>pages 232–242, July 2002.</p><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;0-%E5%9F%BA%E4%BA%8E%E5%8A%A8%E6%80%81%E5%88%86%E6%9E%90%E7%9A%84%E8%BD%AF%E4%BB%B6%E4%B8%8D%E5%8F%98%E9%87%8F%E7%BB%BC%E5%90%88%E6%</summary>
      
    
    
    
    <category term="论文" scheme="http://example.com/categories/%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="Invariant" scheme="http://example.com/tags/Invariant/"/>
    
  </entry>
  
  <entry>
    <title>不变量代表功能能力相关论文阅读</title>
    <link href="http://example.com/2024/03/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/invariant/%E4%B8%8D%E5%8F%98%E9%87%8F%E4%BB%A3%E8%A1%A8%E5%8A%9F%E8%83%BD%E8%83%BD%E5%8A%9B%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>http://example.com/2024/03/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/invariant/%E4%B8%8D%E5%8F%98%E9%87%8F%E4%BB%A3%E8%A1%A8%E5%8A%9F%E8%83%BD%E8%83%BD%E5%8A%9B%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</id>
    <published>2024-03-14T16:40:54.803Z</published>
    <updated>2024-03-21T16:58:16.355Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h2 id="%E2%85%B0-automatic-test-case-and-test-oracle-generation-based-on-functional-scenarios-in-formal-specifications-for-conformance-testing" tabindex="-1">Ⅰ Automatic test case and test oracle generation based on functional scenarios in formal specifications for conformance testing</h2><ul><li>TODO:还挺难的，慢慢看吧</li><li>引用：Liu S, Nakajima S. Automatic test case and test oracle generation based on functional scenarios in formal specifications for conformance testing[J]. IEEE Transactions on Software Engineering, 2020, 48(2): 691-712.</li><li>CCF A TSE</li><li><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=9108630">链接</a></li></ul><h3 id="1-%E4%BB%8B%E7%BB%8D" tabindex="-1">1 介绍</h3><h4 id="%E5%8A%A8%E6%9C%BA" tabindex="-1">动机</h4><ul><li>因为用户更关注程序的行为而非内部结构，specification-based testing是一种有效的测试方法来检查conformance</li><li>由于一个功能通常有程序中一个或一组程序路径实现，因此理想情况下，conformance testing应该覆盖specification中归能的所有可能的路径,然而，这提出了一种挑战<ul><li>原则上，specification-based testing 仅根据specification生成测试用例，不考虑程序结构，这将导致需要的功能被检查但有的路径没有被测试。</li><li>一种解决方法是进行结构测试，在此过程中故意生成满足路径覆盖的测试用例。目前，有许多从业者希望此类conformance testing可以自动化。正如业界公认的[15]，自动化结构测试很难，尤其在复杂代码中。符号执行在小规模程序中提供了有限的解决方案，但在复杂大规模的程序时遇到了严重的困难[16]。</li><li>另一种解决方法是formalize用户的需求，达到每个功能都使用形式化符号精确定义的水平[17].此时，不仅可以自动生成测试用例[18]，还可以自动推导出用于测试解雇分析的明确定义的测试oracle。</li><li>但一个有趣的尚未解决的问题是，<strong>如何仅仅基于specification自动生成测试用例，以便执行specification中所有功能，又能覆盖相应程序中所有相关的程序路径</strong></li></ul></li></ul><h4 id="%E6%96%B9%E6%B3%95" tabindex="-1">方法</h4><ul><li>本文提出了一种 <strong>functional scenario-based vibration test case generation method（基于功能的情景振动测试用例生成方法</strong>。称为Vibration-Method或简称V-Method，反映在测试用例生成时“振动这一特征”<ul><li>该方法适用于数据类型丰富的信息系统的测试。其基本原则是将formal specification中的转换为等效的functional scenarios，然后基于这些functional scenarios以“振动的方式”生成测试用例</li><li>测试用例生成和“振动”是我们方法的组成部分，决定了方法的有效性</li><li>一个操作的 functional scenario 定义了其输入和输出的具体关系，在formal specification的背景下,功能场景被表达为一个谓词表达式，通过pre-condition和post-condition来形成，并期望定义用户需求specification中（通常为自然语言）中的一个所需功能</li><li>正如2.1中所解释的，使用我们之前的工作[11],[21]中提出的算法自动推导出一个操作的所有功能场景，我们所倡导的策略是，生成的测试用例应覆盖所有的功能场景，同时覆盖程序中所有represntative program paths （REP），REP是通过将循环展开为条件执行语句得到的所有可执行语句的子集</li></ul></li></ul><h4 id="%E8%B4%A1%E7%8C%AE" tabindex="-1">贡献</h4><ul><li><strong>1.</strong>:基于functional scenarios 提出了两个新的测试用例生成标准。<ul><li>a. 一个要求生成足够的测试用例以覆盖specification中的所有功能场景，这与[2,22,23]中基于specification的测试方法不同</li><li>b. 另一个需要测试用例每一个功能场景的更多细节</li><li>这两个标准 可以通过 input和output驱动的生成策略来实现<ul><li>input-driven strategy: 选择输入变量的值（即测试用例），随后从specification中导出输出的期望值</li><li>output-driven strategy: 选择输出输出变量的期望值，随后根据所选的预期结果生成输入变量的相应测试用例。</li></ul></li><li>Matinnejad等人在[24]、[25]中提出了在测试用例生成中考虑输出多样性的想法，但现有工作中缺乏从给定输出值派生测试用例的具体而准确的方法。我们的方法提供一具体和明确的基于形式化规格的方法，改进了这一点。</li></ul></li><li><strong>2.</strong>：描述了一系列自动测试用例生成的算法，部分算法在之前工作提出过[23]，但许多部分是在本工作中新开发的</li><li><strong>3.</strong>：开发了一个名为V-Step的“振动”步骤，用于启发生成测试用例，目的是覆盖所有的REP。</li><li><strong>4.</strong>：基于功能情景提出了一种分析测试结果自动派生oracle的机制。现有的类似方法使用整个前置和后置田间来形成每个测试结果分析的测试oracle，但我们的方法仅适用相关功能场景，只是前置和后置条件的一部分，来进行测试结果分析，更加高效</li></ul><h3 id="2-%E6%B5%8B%E8%AF%95%E7%AD%96%E7%95%A5%E5%92%8C%E6%A0%87%E5%87%86" tabindex="-1">2 测试策略和标准</h3><ul><li>整体策略：从formal specification自动化生成测试用例，以覆盖specification中所有的功能场景，同时尽可能的实现程序覆盖</li></ul><h4 id="2.1-%E5%8A%9F%E8%83%BD%E5%9C%BA%E6%99%AF" tabindex="-1">2.1 功能场景</h4><ul><li>一个specification的操作S定义为 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo stretchy="false">(</mo><msub><mi>S</mi><mrow><mi>i</mi><mi>v</mi></mrow></msub><mo separator="true">,</mo><msub><mi>S</mi><mrow><mi>o</mi><mi>v</mi></mrow></msub><mo stretchy="false">)</mo><mo stretchy="false">[</mo><msub><mi>S</mi><mrow><mi>p</mi><mi>r</mi><mi>e</mi></mrow></msub><mo separator="true">,</mo><msub><mi>S</mi><mrow><mi>p</mi><mi>o</mi><mi>s</mi><mi>t</mi></mrow></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">S(S_{iv},S_{ov})[S_{pre},S_{post}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">re</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">os</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></eq><ul><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mrow><mi>i</mi><mi>v</mi></mrow></msub></mrow><annotation encoding="application/x-tex">S_{iv}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>: 在操作后输入变量中未改变的值</li><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mrow><mi>o</mi><mi>v</mi></mrow></msub></mrow><annotation encoding="application/x-tex">S_{ov}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>: 在操作后操作产生或修改的值</li><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mrow><mi>p</mi><mi>r</mi><mi>e</mi></mrow></msub><mtext>，</mtext><msub><mi>S</mi><mrow><mi>p</mi><mi>o</mi><mi>s</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">S_{pre}，S_{post}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">re</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">os</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></eq>: 操作的前置，后置条件（为简化问题，假设相关的不变量已经并入前置和后置条件中，并且前置和后置条件都不含量化表达式）</li></ul></li><li>为了编写操作的前置和后置条件，采用了机构化面向形式语言SOFL[28]，其整合了VDM-SL[29]和数据刘图。</li><li>令 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></eq> 为实现操作 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span></eq> 的程序,为了确保 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></eq> 实现正确，应保证 <section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi mathvariant="normal">∀</mi><mrow><mi>σ</mi><mo>∈</mo><mo>∑</mo></mrow></msub><mo separator="true">⋅</mo><msub><mi>S</mi><mrow><mi>p</mi><mi>r</mi><mi>e</mi></mrow></msub><mo stretchy="false">(</mo><mi>σ</mi><mo stretchy="false">)</mo><mo>⇒</mo><msub><mi>S</mi><mrow><mi>p</mi><mi>o</mi><mi>s</mi><mi>t</mi></mrow></msub><mo stretchy="false">(</mo><mi>σ</mi><mo separator="true">,</mo><mi>P</mi><mo stretchy="false">(</mo><mi>σ</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mtext>（</mtext><mn>1</mn><mtext>）</mtext></mrow><annotation encoding="application/x-tex">\forall_{\sigma \in \sum } · S_{pre}(\sigma) \Rightarrow  S_{post}(\sigma,P(\sigma)) （1）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3552em;"></span><span class="mord"><span class="mord">∀</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">σ</span><span class="mrel mtight">∈</span><span class="mop op-symbol small-op mtight" style="position:relative;top:0em;">∑</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">re</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">os</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="mclose">))</span><span class="mord cjk_fallback">（</span><span class="mord">1</span><span class="mord cjk_fallback">）</span></span></span></span></span></eqn></section>,其中 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∑</mo></mrow><annotation encoding="application/x-tex">\sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span></span></span></span></eq> 表示 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span></eq> 所有可能的状态，<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span></eq> 可以看作程序 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></eq> 的一种抽象，其总体上是一个状态转换系统,像一个函数，从初始状态映射到结束状态。该公式成立需要满足条件，所有初始状态 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span></eq> 都满足 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mrow><mi>p</mi><mi>r</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">S_{pre}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">re</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></eq> 时，最终状态状态 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span></eq> 下的输出满足 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mrow><mi>p</mi><mi>o</mi><mi>s</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">S_{post}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">os</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></eq></li><li>理论上，使用测试验证公式（1）需要穷尽测试，尝试 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span></eq> 所有可能的输入，这是不现实的。我们的方法旨在对specification <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span></eq> 生成足够的测试用例，以覆盖用户独特功能需求中所定义的所有功能。这样的功能可以由下面的功能场景定义给出。</li></ul><h5 id="definition-1%3Afunctional-scenario" tabindex="-1">Definition 1:functional scenario</h5><ul><li>令 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mrow><mi>p</mi><mi>o</mi><mi>s</mi><mi>t</mi></mrow></msub><mo>≡</mo><mo stretchy="false">(</mo><msub><mi>G</mi><mn>1</mn></msub><mo>∧</mo><msub><mi>D</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>∨</mo><mo stretchy="false">(</mo><msub><mi>G</mi><mn>2</mn></msub><mo>∧</mo><msub><mi>D</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>∨</mo><mo stretchy="false">(</mo><msub><mi>G</mi><mi>n</mi></msub><mo>∧</mo><msub><mi>D</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S_{post} \equiv (G_1 \wedge D_1) \vee (G_2 \wedge D_2).. \vee(G_n \wedge D_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">os</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">..</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq>,其中 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>i</mi><mo>∈</mo><mo stretchy="false">{</mo><mn>1</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G_i(i \in \{1,...,n\})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">})</span></span></span></span></eq> 表示一个成为守卫条件的谓词，不包含在 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mrow><mi>o</mi><mi>v</mi></mrow></msub></mrow><annotation encoding="application/x-tex">S_{ov}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>的输出中， <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">D_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 是一个定义的条件包括至少一个在 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mrow><mi>o</mi><mi>v</mi></mrow></msub></mrow><annotation encoding="application/x-tex">S_{ov}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 中的输出变量，但不包含守卫条件。 然后，一个功能场景的定义为一个合取 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mrow><mi>p</mi><mi>r</mi><mi>e</mi></mrow></msub><mo>∧</mo><msub><mi>G</mi><mi>i</mi></msub><mo>∧</mo><msub><mi>D</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">S_{pre} \wedge G_i \wedge D_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">re</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>,同时 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>S</mi><mrow><mi>p</mi><mi>r</mi><mi>e</mi></mrow></msub><mo>∧</mo><msub><mi>G</mi><mn>1</mn></msub><mo>∧</mo><msub><mi>D</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>∨</mo><mo stretchy="false">(</mo><msub><mi>S</mi><mrow><mi>p</mi><mi>r</mi><mi>e</mi></mrow></msub><mo>∧</mo><msub><mi>G</mi><mn>2</mn></msub><mo>∧</mo><msub><mi>D</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>∨</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>∨</mo><mo stretchy="false">(</mo><msub><mi>S</mi><mrow><mi>p</mi><mi>r</mi><mi>e</mi></mrow></msub><mo>∧</mo><msub><mi>G</mi><mi>n</mi></msub><mo>∧</mo><msub><mi>D</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(S_{pre} \wedge G_1 \wedge D_1) \vee (S_{pre} \wedge G_2 \wedge D_2) \vee ... \vee (S_{pre} \wedge G_n \wedge D_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">re</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">re</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">re</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq> 被称为操作 S 的功能场景形式（functional scenario form FSF）</li><li>将 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mrow><mi>p</mi><mi>r</mi><mi>e</mi></mrow></msub><mo>∧</mo><msub><mi>G</mi><mi>i</mi></msub><mo>∧</mo><msub><mi>D</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">S_{pre} \wedge G_i \wedge D_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">re</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 视为一个功能场景，因为其定义了一个独特的功能：当初始状态满足 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mrow><mi>p</mi><mi>r</mi><mi>e</mi></mrow></msub><mo>∧</mo><msub><mi>G</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">S_{pre} \wedge G_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">re</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> (或者直观的说，输入满足时)，最终状态有 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">D_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 定义。 将定义条件与 pre-条件和守卫条件的合取分开，将便于我们基于这个合取生成测试数据，并基于合取和定义条件形成测试oracle。</li></ul><h5 id="definition-2%3Acomplete-specification" tabindex="-1">Definition 2:complete specification</h5><ul><li>令 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>S</mi><mrow><mi>p</mi><mi>r</mi><mi>e</mi></mrow></msub><mo>∧</mo><msub><mi>G</mi><mn>1</mn></msub><mo>∧</mo><msub><mi>D</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>∨</mo><mo stretchy="false">(</mo><msub><mi>S</mi><mrow><mi>p</mi><mi>r</mi><mi>e</mi></mrow></msub><mo>∧</mo><msub><mi>G</mi><mn>2</mn></msub><mo>∧</mo><msub><mi>D</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>∨</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>∨</mo><mo stretchy="false">(</mo><msub><mi>S</mi><mrow><mi>p</mi><mi>r</mi><mi>e</mi></mrow></msub><mo>∧</mo><msub><mi>G</mi><mi>n</mi></msub><mo>∧</mo><msub><mi>D</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(S_{pre} \wedge G_1 \wedge D_1) \vee (S_{pre} \wedge G_2 \wedge D_2) \vee ... \vee (S_{pre} \wedge G_n \wedge D_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">re</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">re</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">re</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq>，则 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span></eq> 完备当且仅当 $G1 \vee G2 \vee … \vee Gn \Leftrightarrow true $恒成立</li><li>注意，这里对操作规范的完全性定义可能与传统理解不同，传统理解要求规范定义用户的所有需求。相反，我们的定义要求任何满足前条件的输入必须满足其中一个守卫条件（例如，G1），从而保证只要所有的定义条件都是可满足的，操作的输出就可以由相应的定义条件（例如，D1）定义。正如我们将在后续的第4.5节中讨论的，规范的完全性影响了我们测试方法的有效性。</li></ul><h5 id="example-1%3A-check-triangle" tabindex="-1">Example 1: Check Triangle</h5><ul><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>h</mi><mi>e</mi><mi>c</mi><msub><mi>k</mi><mi>T</mi></msub><mi>r</mi><mi>i</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi>l</mi><msub><mi>e</mi><mrow><mi>i</mi><mi>v</mi></mrow></msub><mo>=</mo><mo stretchy="false">{</mo><mi>d</mi><mn>1</mn><mo separator="true">,</mo><mi>d</mi><mn>2</mn><mo separator="true">,</mo><mi>d</mi><mn>3</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">Check_Triangle_{iv}=\{d1,d2,d3\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">h</span><span class="mord mathnormal">ec</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">ian</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">d</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord">3</span><span class="mclose">}</span></span></span></span></eq></li><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>h</mi><mi>e</mi><mi>c</mi><msub><mi>k</mi><mi>T</mi></msub><mi>r</mi><mi>i</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi>l</mi><msub><mi>e</mi><mrow><mi>o</mi><mi>v</mi></mrow></msub><mo>=</mo><mo stretchy="false">{</mo><msub><mi>t</mi><mrow><mi>t</mi><mi>y</mi><mi>p</mi><mi>e</mi></mrow></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">Check_Triangle_{ov}=\{t_{type}\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">h</span><span class="mord mathnormal">ec</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">ian</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span></eq></li><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>h</mi><mi>e</mi><mi>c</mi><msub><mi>k</mi><mi>T</mi></msub><mi>r</mi><mi>i</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi>l</mi><msub><mi>e</mi><mrow><mi>p</mi><mi>r</mi><mi>e</mi></mrow></msub><mo>=</mo><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Check_Triangle_{pre}=true</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">h</span><span class="mord mathnormal">ec</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">ian</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">re</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span></span></span></span></eq></li><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>h</mi><mi>e</mi><mi>c</mi><msub><mi>k</mi><mi>T</mi></msub><mi>r</mi><mi>i</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi>l</mi><msub><mi>e</mi><mrow><mi>p</mi><mi>o</mi><mi>s</mi><mi>t</mi></mrow></msub><mo>=</mo><mo stretchy="false">(</mo><mi>d</mi><mn>1</mn><mo>=</mo><mi>d</mi><mn>2</mn><mtext>  </mtext><mi>a</mi><mi>n</mi><mi>d</mi><mtext>  </mtext><mi>d</mi><mn>2</mn><mo>=</mo><mi>d</mi><mn>3</mn><mtext>  </mtext><msub><mi>t</mi><mrow><mi>t</mi><mi>y</mi><mi>p</mi><mi>e</mi></mrow></msub><mo>=</mo><mi mathvariant="normal">&quot;</mi><mi>e</mi><mi>q</mi><mi>u</mi><mi>i</mi><mi>l</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>a</mi><mi>l</mi><mtext>  </mtext><mi>t</mi><mi>r</mi><mi>i</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi>l</mi><mi>e</mi><mi mathvariant="normal">&quot;</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">Check_Triangle_{post}=(d1=d2 \; and \;d2=d3 \; t_{type}=&quot;equilateral\;triangle&quot;...</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">h</span><span class="mord mathnormal">ec</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">ian</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">os</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">an</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">d</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord mathnormal">d</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">&quot;</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord mathnormal">u</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">ian</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord">&quot;...</span></span></span></span></eq></li><li>根据以上specification可以得到以下功能场景<ul><li>（1）<ul><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>1</mn></msub><mo>:</mo><mi>d</mi><mn>1</mn><mo>=</mo><mi>d</mi><mn>2</mn><mtext>  </mtext><mi>a</mi><mi>n</mi><mi>d</mi><mtext>  </mtext><mi>d</mi><mn>2</mn><mo>=</mo><mi>d</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">G_1:d1=d2 \; and\; d2=d3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">an</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">d</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mord">3</span></span></span></span></eq></li><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>1</mn></msub><mo>:</mo><msub><mi>t</mi><mrow><mi>t</mi><mi>y</mi><mi>p</mi><mi>e</mi></mrow></msub><mo>=</mo><mi mathvariant="normal">&quot;</mi><mi>e</mi><mi>q</mi><mi>u</mi><mi>i</mi><mi>l</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>a</mi><mi>l</mi><mtext>  </mtext><mi>t</mi><mi>r</mi><mi>i</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi>l</mi><mi>e</mi><mi mathvariant="normal">&quot;</mi></mrow><annotation encoding="application/x-tex">D_1:t_{type} = &quot;equilateral\;triangle&quot;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9012em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">&quot;</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord mathnormal">u</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">ian</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord">&quot;</span></span></span></span></eq></li><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><msub><mi>S</mi><mn>1</mn></msub><mo>:</mo><msub><mi>G</mi><mn>1</mn></msub><mtext>  </mtext><mi>a</mi><mi>n</mi><mi>d</mi><mtext>  </mtext><msub><mi>D</mi><mn>1</mn></msub><mtext>  </mtext><mo stretchy="false">(</mo><mo>⇔</mo><mi>C</mi><mi>h</mi><mi>e</mi><mi>c</mi><msub><mi>k</mi><mi>T</mi></msub><mi>r</mi><mi>i</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi>l</mi><msub><mi>e</mi><mrow><mi>p</mi><mi>r</mi><mi>e</mi></mrow></msub><mtext>  </mtext><mi>a</mi><mi>n</mi><mi>d</mi><mtext>  </mtext><mi>G</mi><mn>1</mn><mtext>  </mtext><mi>a</mi><mi>n</mi><mi>d</mi><mtext>  </mtext><mi>D</mi><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">FS_1:G_1\; and\;D_1 \; (\Leftrightarrow Check_Triangle_{pre}\; and \; G1 \; and\;D1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">an</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">(</span><span class="mrel">⇔</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">h</span><span class="mord mathnormal">ec</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">ian</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">re</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">an</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">G</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">an</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></eq></li></ul></li><li>（2）<ul><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>2</mn></msub><mo>:</mo><mi>d</mi><mn>1</mn><mo>=</mo><mi>d</mi><mn>2</mn><mtext>  </mtext><mi>o</mi><mi>r</mi><mtext>  </mtext><mi>d</mi><mn>2</mn><mo>=</mo><mi>d</mi><mn>3</mn><mtext>  </mtext><mi>o</mi><mi>r</mi><mtext>  </mtext><mi>d</mi><mn>1</mn><mo>=</mo><mi>d</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">G_2:d1=d2 \; or \; d2=d3 \; or \; d1=d3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">d</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">d</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mord">3</span></span></span></span></eq></li><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>2</mn></msub><mo>:</mo><msub><mi>t</mi><mrow><mi>t</mi><mi>y</mi><mi>p</mi><mi>e</mi></mrow></msub><mo>=</mo><mi mathvariant="normal">&quot;</mi><mi>i</mi><mi>s</mi><mi>o</mi><mi>s</mi><mi>c</mi><mi>e</mi><mi>l</mi><mi>e</mi><mi>s</mi><mtext>  </mtext><mi>t</mi><mi>r</mi><mi>i</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi>l</mi><mi>e</mi><mi mathvariant="normal">&quot;</mi></mrow><annotation encoding="application/x-tex">D_2:t_{type} = &quot;isosceles\;triangle&quot;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9012em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">&quot;</span><span class="mord mathnormal">i</span><span class="mord mathnormal">sosce</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">es</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">ian</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord">&quot;</span></span></span></span></eq></li><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><msub><mi>S</mi><mn>2</mn></msub><mo>:</mo><msub><mi>G</mi><mn>2</mn></msub><mtext>  </mtext><mi>a</mi><mi>n</mi><mi>d</mi><mtext>  </mtext><msub><mi>D</mi><mn>2</mn></msub><mtext>  </mtext></mrow><annotation encoding="application/x-tex">FS_2:G_2\; and\;D_2 \;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">an</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span></span></span></eq></li></ul></li><li>（3）<ul><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>3</mn></msub><mo>:</mo><mi>d</mi><mn>1</mn><mo>≠</mo><mrow></mrow><mi>d</mi><mn>2</mn><mtext>  </mtext><mi>o</mi><mi>r</mi><mtext>  </mtext><mi>d</mi><mn>2</mn><mo>≠</mo><mrow></mrow><mi>d</mi><mn>3</mn><mtext>  </mtext><mi>o</mi><mi>r</mi><mtext>  </mtext><mi>d</mi><mn>1</mn><mo>≠</mo><mrow></mrow><mi>d</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">G_3:d1\not ={}d2 \; or \; d2\not ={}d3 \; or \; d1\not ={}d3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">d</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span></span><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"></span><span class="mord mathnormal">d</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">d</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span></span><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"></span><span class="mord mathnormal">d</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">d</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span></span><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"></span><span class="mord mathnormal">d</span><span class="mord">3</span></span></span></span></eq></li><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>3</mn></msub><mo>:</mo><msub><mi>t</mi><mrow><mi>t</mi><mi>y</mi><mi>p</mi><mi>e</mi></mrow></msub><mo>=</mo><mi mathvariant="normal">&quot;</mi><mi>o</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi>r</mi><mtext>  </mtext><mi>t</mi><mi>r</mi><mi>i</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi>l</mi><mi>e</mi><mi mathvariant="normal">&quot;</mi></mrow><annotation encoding="application/x-tex">D_3:t_{type} = &quot;other \;triangle&quot;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9012em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">&quot;</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">ian</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord">&quot;</span></span></span></span></eq></li><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><msub><mi>S</mi><mn>3</mn></msub><mo>:</mo><msub><mi>G</mi><mn>3</mn></msub><mtext>  </mtext><mi>a</mi><mi>n</mi><mi>d</mi><mtext>  </mtext><msub><mi>D</mi><mn>3</mn></msub><mtext>  </mtext></mrow><annotation encoding="application/x-tex">FS_3:G_3\; and\;D_3 \;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">an</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span></span></span></eq></li></ul></li><li>（4）<ul><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>4</mn></msub><mo>:</mo><mi>d</mi><mn>1</mn><mo>≤</mo><mn>0</mn><mtext>  </mtext><mi>o</mi><mi>r</mi><mtext>  </mtext><mi>d</mi><mn>2</mn><mo>≤</mo><mn>0</mn><mtext>  </mtext><mi>o</mi><mi>r</mi><mtext>  </mtext><mi>d</mi><mn>3</mn><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">G_4:d1\leq 0 \; or \; d2\leq 0 \; or \; d3\leq 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord mathnormal">d</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">d</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">d</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></eq></li><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>4</mn></msub><mo>:</mo><msub><mi>t</mi><mrow><mi>t</mi><mi>y</mi><mi>p</mi><mi>e</mi></mrow></msub><mo>=</mo><mi mathvariant="normal">&quot;</mi><mi>n</mi><mi>o</mi><mi>w</mi><mo>−</mo><mi>t</mi><mi>r</mi><mi>i</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi>l</mi><mi>e</mi><mi mathvariant="normal">&quot;</mi></mrow><annotation encoding="application/x-tex">D_4:t_{type} = &quot;now-triangle&quot;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9012em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord">&quot;</span><span class="mord mathnormal">n</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">ian</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord">&quot;</span></span></span></span></eq></li><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><msub><mi>S</mi><mn>4</mn></msub><mo>:</mo><msub><mi>G</mi><mn>4</mn></msub><mtext>  </mtext><mi>a</mi><mi>n</mi><mi>d</mi><mtext>  </mtext><msub><mi>D</mi><mn>4</mn></msub><mtext>  </mtext></mrow><annotation encoding="application/x-tex">FS_4:G_4\; and\;D_4 \;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">an</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span></span></span></eq></li></ul></li></ul></li></ul><h4 id="2.2-%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E7%94%9F%E6%88%90%E6%A0%87%E5%87%86" tabindex="-1">2.2 测试用例生成标准</h4><h5 id="define-3-test-data" tabindex="-1">Define 3 test data</h5><ul><li>测试数据是对所有输入变量从其类型中分配值的一种赋值。</li></ul><h5 id="define-4-test-case" tabindex="-1">Define 4 test case</h5><ul><li>测试用例是测试数据和期望输出值的组合</li><li>令 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mrow><mi>i</mi><mi>v</mi></mrow></msub><mo>=</mo><mo stretchy="false">{</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">}</mo><mo separator="true">,</mo><msub><mi>S</mi><mrow><mi>o</mi><mi>v</mi></mrow></msub><mo>=</mo><mo stretchy="false">{</mo><msub><mi>y</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>y</mi><mi>m</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">S_{iv} = \{x_1,x_2,...x_n\},S_{ov}=\{y_1,y_2..y_m\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">..</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span></eq> 为操作 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span></eq> 的所有输入集和输出集. 令 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>y</mi><mi>p</mi><mi>e</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Type(z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal">p</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span></eq> 表示输入变量或输出变量的类型，<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>∈</mo><mo stretchy="false">{</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>x</mi><mi>n</mi></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>y</mi><mi>m</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">z\in\{x_1,x_2..x_n,y_1,y_2..y_m\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">..</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">..</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span></eq>.</li><li>一个测试用例，用 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">tc</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">c</span></span></span></span></eq> 表示，是一个从集合 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mrow><mi>i</mi><mi>v</mi></mrow></msub></mrow><annotation encoding="application/x-tex">S_{iv}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 到集合 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mrow><mi>o</mi><mi>v</mi></mrow></msub></mrow><annotation encoding="application/x-tex">S_{ov}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 的映射，即 <section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>t</mi><mi>c</mi><mo>:</mo><msub><mi>S</mi><mrow><mi>i</mi><mi>v</mi></mrow></msub><mo>∪</mo><msub><mi>S</mi><mrow><mi>i</mi><mi>v</mi></mrow></msub><mo>→</mo><mi>V</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">tc: S_{iv} \cup S_{iv} \rightarrow Values</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">Va</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">es</span></span></span></span></span></eqn></section> <section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>t</mi><mi>c</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>T</mi><mi>y</mi><mi>p</mi><mi>e</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">tc(z) \in Type(z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">c</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal">p</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span></span></eqn></section>,其中 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mi>s</mi><mo>=</mo><mi>T</mi><mi>y</mi><mi>p</mi><mi>e</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>∪</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi>T</mi><mi>y</mi><mi>p</mi><mi>e</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mo>∪</mo><mi>T</mi><mi>y</mi><mi>p</mi><mi>e</mi><mo stretchy="false">(</mo><msub><mi>y</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>∪</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi>T</mi><mi>y</mi><mi>p</mi><mi>e</mi><mo stretchy="false">(</mo><msub><mi>y</mi><mi>m</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Values=Type(x_1)\cup ...Type(x_n)\cup Type(y_1) \cup .. Type(y_m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">Va</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">es</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal">p</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">...</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal">p</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal">p</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">..</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal">p</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq></li><li>一个测试用例经常被表示为一组 输入变量或输出变量和相应的值的组合，例如 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>c</mi><mo>=</mo><mo stretchy="false">{</mo><mo stretchy="false">(</mo><mi>x</mi><mn>1</mn><mo separator="true">,</mo><mn>5</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>x</mi><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>y</mi><mn>1</mn><mo separator="true">,</mo><mn>8</mn><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">tc=\{(x1,5),(x2,3),(y1,8)\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{(</span><span class="mord mathnormal">x</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">8</span><span class="mclose">)}</span></span></span></span></eq></li></ul><h5 id="define-5-test-set" tabindex="-1">Define 5 test set</h5><ul><li>一个测试集合是一组测试用例的集合。通常表示为一组成对的集合。</li><li>一个测试套件是一个预期用于特定目的的测试集合。</li></ul><h5 id="define-6-test-condition" tabindex="-1">Define 6 test condition</h5><ul><li>令 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mrow><mi>p</mi><mi>r</mi><mi>e</mi></mrow></msub><mo>∧</mo><mi>G</mi><mo>∧</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">S_{pre}\wedge G \wedge D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">re</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span></eq> 为操作 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span></eq> 的一个功能场景，随后 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mrow><mi>p</mi><mi>r</mi><mi>e</mi></mrow></msub><mo>∧</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">S_{pre}\wedge G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">re</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span></eq> 称为功能场景的 <strong>测试条件</strong></li><li>由于测试条件 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mrow><mi>p</mi><mi>r</mi><mi>e</mi></mrow></msub><mo>∧</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">S_{pre}\wedge G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">re</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span></eq> 只包含操作的输入数据，因此用于检查条件 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span></eq> 是否正确实现的测试数据（或没有预期结果的测试用例）仅基于测试条件生成。 定义条件形成了测试oracle，如2.3所述</li></ul><h5 id="define-7-restricted-domain" tabindex="-1">Define 7 restricted domain</h5><ul><li>操作S的受限域是操作域的子集，在每个子集中，每个值都满足操作规范的前置条件。</li></ul><h5 id="define-8-program" tabindex="-1">Define 8 program</h5><ul><li>一个程序是一个5元组 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>S</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>S</mi><mi>N</mi><mo separator="true">,</mo><mi>C</mi><mi>N</mi><mo separator="true">,</mo><mi>R</mi><mo separator="true">,</mo><mi>T</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(S_0,SN,CN,R,T)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">SN</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">CN</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mclose">)</span></span></span></span></eq> , <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">S_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 是开始节点， <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">SN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">SN</span></span></span></span></eq> 状态节点集合，<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">CN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">CN</span></span></span></span></eq> 条件节点集合，<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span></eq> 关系中节点，<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span></eq> 是终止节点，它们满足以下条件<ul><li><ol><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mn>0</mn></msub><mo>∈</mo><mi>S</mi><mi>N</mi><mo>∪</mo><mi>C</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">S_0 \in SN \cup CN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">SN</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">CN</span></span></span></span></eq></li></ol></li><li><ol start="2"><li>$R:(SN\cup CN) \times (SN\cup CN)  $</li></ol></li><li><ol start="3"><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>∈</mo><mi>S</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">T \in SN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">SN</span></span></span></span></eq></li></ol></li></ul></li><li>一个程序可以被表示为一个由五个元素 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>S</mi><mi>N</mi><mo separator="true">,</mo><mi>C</mi><mi>N</mi><mo separator="true">,</mo><mi>R</mi><mo separator="true">,</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">S_0,SN,CN,R,T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">SN</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">CN</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span></eq> 组成的语义等价图，满足上述三个条件。<ul><li>程序中的每个语句，包括空语句（用 skip 表示），都由 SN 中的一个节点表示，称为语句节点。</li><li>每个条件（一个谓词）都由 CN 中的一个节点表示，称为条件节点。</li><li>节点之间的连接（包括语句节点和条件节点），反映了语句之间的控制流，由关系 R 表示。</li><li>起始节点 S0 表示程序的第一个语句或条件。</li><li>终止节点 T 中的节点表示在程序的执行中必须最后执行的语句。</li><li>一个程序还具有这样的特点，即每个条件节点都与另外两个唯一的节点相连接，每个节点都是一个语句节点或条件节点</li></ul></li></ul><h5 id="define-8-program-path" tabindex="-1">Define 8 program path</h5><ul><li>令 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>S</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>S</mi><mi>N</mi><mo separator="true">,</mo><mi>C</mi><mi>N</mi><mo separator="true">,</mo><mi>R</mi><mo separator="true">,</mo><mi>T</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P=(S_0,SN,CN,R,T)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">SN</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">CN</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mclose">)</span></span></span></span></eq> 为程序，一个程序路径 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span></eq> 一个节点序列 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><msub><mi>S</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>n</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>n</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>n</mi><mi>m</mi></msub><mo stretchy="false">]</mo><mo separator="true">,</mo><msub><mi>n</mi><mi>m</mi></msub><mo>∈</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">[S_0,n_1,n_2,...n_m],n_m\in T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span></eq>.</li><li>我们令 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mo stretchy="false">(</mo><msub><mi>S</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>n</mi><mn>1</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><msub><mi>n</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>n</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo stretchy="false">(</mo><msub><mi>n</mi><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>n</mi><mi>m</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">E(p) = \{(S_0,n1),(n_1,n_2),...(n_{m-1},n_m)\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)}</span></span></span></span></eq></li><li>程序路径是由节点序列组成的，从程序的起始节点开始，以一个终止节点结束。这条路径也可以被视为由路径上所有边构成的关系。为了避免任何可能的混淆，我们使用 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E(p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span></eq> 来表示路径对应的关系。</li></ul><h5 id="define-9-representative-program-path" tabindex="-1">Define 9 representative program path</h5><ul><li>令 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>S</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>S</mi><mi>N</mi><mo separator="true">,</mo><mi>C</mi><mi>N</mi><mo separator="true">,</mo><mi>R</mi><mo separator="true">,</mo><mi>T</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P=(S_0,SN,CN,R,T)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">SN</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">CN</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mclose">)</span></span></span></span></eq> 为程序，使用 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>p</mi><mi>p</mi><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Rpp(P)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">Rpp</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mclose">)</span></span></span></span></eq> 表示程序的代表性路径集合，需要满足下面两个条件<ul><li>(1) <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">∀</mi><mrow><mi>e</mi><mo>∈</mo><mi>R</mi><msub><mi mathvariant="normal">∃</mi><mrow><mi>p</mi><mo>∈</mo><mi>P</mi><mi>p</mi><mi>p</mi><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo></mrow></msub><mo separator="true">⋅</mo><mi>e</mi><mo>∈</mo><mi>E</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow></msub></mrow><annotation encoding="application/x-tex">\forall_{e\in R \exist_{p\in Ppp(P)} · e \in E(p)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1333em;vertical-align:-0.4388em;"></span><span class="mord"><span class="mord">∀</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span><span class="mord mtight"><span class="mord mtight">∃</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3448em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5357em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight">Ppp</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3695em;"><span></span></span></span></span></span></span><span class="mpunct mtight">⋅</span><span class="mord mathnormal mtight">e</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">E</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">p</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4388em;"><span></span></span></span></span></span></span></span></span></span></eq></li><li>(2) <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">∀</mi><mrow><mi>p</mi><mo>∈</mo><mi>R</mi><mi>p</mi><mi>p</mi><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo></mrow></msub><mo separator="true">⋅</mo><mi mathvariant="normal">¬</mi><msub><mi mathvariant="normal">∃</mi><mrow><msub><mi>p</mi><mn>1</mn></msub><mo>∈</mo><mi>R</mi><mi>p</mi><mi>p</mi><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo></mrow></msub><mo separator="true">⋅</mo><mi>E</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>⊆</mo><mi>E</mi><mo stretchy="false">(</mo><mi>p</mi><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall_{p\in Rpp(P)} · \neg \exist_{p_1\in Rpp(P)} · E(p) \subseteq E(p1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3552em;"></span><span class="mord"><span class="mord">∀</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight">Rpp</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">¬</span><span class="mord"><span class="mord">∃</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight">Rpp</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></eq></li></ul></li><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>p</mi><mi>p</mi><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Rpp(P)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">Rpp</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mclose">)</span></span></span></span></eq> 并不代表 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></eq> 的唯一一组代表程序路径，根据定义，它包含了覆盖 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></eq> 的所有控制流边的所有程序路径，如条件 (1) 所示，并且不包含在其相应关系中重叠控制流边的不同程序路径，如条件 (2) 所暗示的。在本文中，我们总是使用 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>p</mi><mi>p</mi><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Rpp(P)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">Rpp</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mclose">)</span></span></span></span></eq> 来表示基于测试需求确定的感兴趣的代表程序路径集合。</li></ul><h5 id="define-10-traversd-path" tabindex="-1">Define 10 traversd path</h5><ul><li>令 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>S</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>S</mi><mi>N</mi><mo separator="true">,</mo><mi>C</mi><mi>N</mi><mo separator="true">,</mo><mi>R</mi><mo separator="true">,</mo><mi>T</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P=(S_0,SN,CN,R,T)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">SN</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">CN</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mclose">)</span></span></span></span></eq> 为程序，<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></eq> 的一个路径 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span></eq> 被称为被遍历的，当 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></eq> 被执行时，如果 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span></eq> 中的所有节点都按照它们在路径上出现的顺序被执行（在语句的情况下）或评估（在条件的情况下），我们说 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span></eq> 被遍历了。</li><li>根据以上10个定义，即可为测试用例生成定义标准</li></ul><h5 id="criterion-1%3Ascenario-path-coverage-(spc)" tabindex="-1">Criterion 1:scenario-path coverage (SPC)</h5><ul><li>令 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></eq> 为实现操作 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span></eq> 的程序，<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>S</mi><mrow><mi>p</mi><mi>r</mi><mi>e</mi></mrow></msub><mo>∧</mo><msub><mi>G</mi><mn>1</mn></msub><mo>∧</mo><msub><mi>D</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>∨</mo><mo stretchy="false">(</mo><mo stretchy="false">)</mo><msub><mi>S</mi><mrow><mi>p</mi><mi>r</mi><mi>e</mi></mrow></msub><mo>∧</mo><msub><mi>G</mi><mn>2</mn></msub><mo>∧</mo><msub><mi>D</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>∨</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>∨</mo><mo stretchy="false">(</mo><msub><mi>S</mi><mrow><mi>p</mi><mi>r</mi><mi>e</mi></mrow></msub><mo>∧</mo><msub><mi>G</mi><mi>n</mi></msub><mo>∧</mo><msub><mi>D</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(S_{pre}\wedge G_1 \wedge D_1) \vee ()S_{pre}\wedge G_2 \wedge D_2) \vee ... \vee (S_{pre}\wedge G_n \wedge D_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">re</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">(</span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">re</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">re</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq> 为操作 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span></eq> 的FSF. 令 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span></eq> 为从 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span></eq> 中生成的测试集。 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span></eq> 满足以下4个条件<ul><li>(1) <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">∀</mi><mrow><mi>i</mi><mo>∈</mo><mo stretchy="false">{</mo><mn>1</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi>n</mi><mo stretchy="false">}</mo></mrow></msub><msub><mi mathvariant="normal">∃</mi><mrow><mi>t</mi><mi>c</mi><mo>∈</mo><mi>T</mi></mrow></msub><mo separator="true">⋅</mo><msub><mi>S</mi><mrow><mi>p</mi><mi>r</mi><mi>e</mi></mrow></msub><mo stretchy="false">(</mo><mi>t</mi><mi>c</mi><mo stretchy="false">)</mo><mo>∧</mo><msub><mi>G</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>t</mi><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall_{i\in\{1,...n\}} \exist_{tc\in T} · S_{pre}(tc)\wedge G_i(tc)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3552em;"></span><span class="mord"><span class="mord">∀</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">∈</span><span class="mopen mtight">{</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mtight">...</span><span class="mord mathnormal mtight">n</span><span class="mclose mtight">}</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord">∃</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">c</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1774em;"><span></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">re</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mord mathnormal">c</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mord mathnormal">c</span><span class="mclose">)</span></span></span></span></eq></li><li>(2) <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">¬</mi><mo stretchy="false">(</mo><msub><mi>G</mi><mn>1</mn></msub><mo>∨</mo><msub><mi>G</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>∨</mo><msub><mi>G</mi><mn>3</mn></msub><mo>⇔</mo><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi><mo stretchy="false">)</mo><mo>⇒</mo><msub><mi mathvariant="normal">∃</mi><mrow><mi>t</mi><mi>c</mi><mo>∈</mo><mi>T</mi></mrow></msub><mo separator="true">⋅</mo><msub><mi>S</mi><mrow><mi>p</mi><mi>r</mi><mi>e</mi></mrow></msub><mo stretchy="false">(</mo><mi>t</mi><mi>c</mi><mo stretchy="false">)</mo><mo>∧</mo><mi mathvariant="normal">¬</mi><mo stretchy="false">(</mo><msub><mi>G</mi><mn>1</mn></msub><mo>∨</mo><msub><mi>G</mi><mn>2</mn></msub><mo>∨</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>G</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>t</mi><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\neg (G_1 \vee G_2 ... \vee G_3 \Leftrightarrow true) \Rightarrow \exist_{tc\in T} · S_{pre}(tc)\wedge \neg (G_1\vee G_2 \vee ...G_n)(tc)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">¬</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇔</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord">∃</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">c</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1774em;"><span></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">re</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mord mathnormal">c</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">¬</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">...</span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mord mathnormal">c</span><span class="mclose">)</span></span></span></span></eq></li><li>(3) <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">∃</mi><mrow><mi>t</mi><mi>c</mi><mo>∈</mo><mi>T</mi></mrow></msub><mo separator="true">⋅</mo><mi mathvariant="normal">¬</mi><mo stretchy="false">(</mo><msub><mi>S</mi><mi>p</mi></msub><mi>r</mi><mi>e</mi><mo stretchy="false">(</mo><mi>t</mi><mi>c</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\exist_{tc\in T} · \neg (S_pre(tc))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord">∃</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">c</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1774em;"><span></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">¬</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord mathnormal">re</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mord mathnormal">c</span><span class="mclose">))</span></span></span></span></eq></li><li>(4) <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">∀</mi><mrow><mi>p</mi><mo>∈</mo><mi>P</mi><mi>p</mi><mi>p</mi><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo></mrow></msub><msub><mi mathvariant="normal">∃</mi><mrow><mi>t</mi><mi>c</mi><mo>∈</mo><mi>T</mi></mrow></msub><mo separator="true">⋅</mo><mi>t</mi><mi>r</mi><mi>a</mi><mi>v</mi><mi>e</mi><mi>r</mi><mi>s</mi><mi>e</mi><mi>d</mi><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><mi>t</mi><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall_{p\in Ppp(P)} \exist_{tc\in T} · traversed(p,tc)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3552em;"></span><span class="mord"><span class="mord">∀</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight">Ppp</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord">∃</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">c</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1774em;"><span></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">erse</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">c</span><span class="mclose">)</span></span></span></span></eq></li></ul></li><li>该标准称为场景路径覆盖SPC。 该标准建议生成的测试集覆盖规范中的所有功能场景和程序中的所有代表程序路径。具体来说满足以4个条件<ul><li>(1)对于每个功能场景，必须存在一个在 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span></eq> 中的测试用例满足功能场景的测试条件</li><li>(2)如果所有守卫条件的析取不能覆盖操作的受限域，那么必须存在一个在 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span></eq> 中的测试用例满足所有守卫条件析取的否定</li><li>(3)必须存在一个违反前置条件的测试用例</li><li>(4)对于每个代表性程序路径，必须存在一个测试用例在程序中遍历了这个路径，用 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>a</mi><mi>v</mi><mi>e</mi><mi>r</mi><mi>s</mi><mi>e</mi><mi>d</mi><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><mi>t</mi><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">traversed(p,tc)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">erse</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">c</span><span class="mclose">)</span></span></span></span></eq> 表示</li></ul></li><li>该测试标准中<ul><li>(1)(2)共同体现了基于精确定义的功能性测试场景测试条件的等价类划分技术来生成测试用例[30,31]</li><li>(3)不能帮助确定测试用例是否发生了错误，因为SOFL中的置-后置风格规范允许在违反前置条件时程序的任何行为，这与完善的精化理论[32]一致，但它可以起到类似于健壮性测试技术[33]的作用，并帮助测试者或开发者判断在这种情况下程序的行为对用户来说是否可接受。</li><li>(4) 对应于简单路径覆盖测试[31]</li></ul></li></ul><h5 id="criterion-2" tabindex="-1">Criterion 2</h5><h2 id tabindex="-1"></h2><p>P. W. O’Hearn, “Continuous reasoning: Scaling the impact of formal<br>methods,” in Proceedings of the 33rd annual ACM/IEEE symposium<br>on logic in computer science, 2018, pp. 13–25.</p><h2 id="-1" tabindex="-1"></h2><p>Krka, I.; Brun, Y.; Medvidovic, N. Automatically Mining Specifications from Invocation Traces and Method Invariants; Technical Report; Citeseer; Center for Systems and Software Engineering, University of Southern California: Los Angeles, CA, USA, 2013. [Google Scholar]</p><h2 id="-2" tabindex="-1"></h2><p>De Caso, G.; Braberman, V.; Garbervetsky, D.; Uchitel, S. Automated abstractions for contract validation. IEEE Trans. Softw. Eng. 2010, 38, 141–162. [Google Scholar] [CrossRef]</p><h2 id="-3" tabindex="-1"></h2><p>David R. MacIver, Zac Hatfield-Dodds, and Many Other<br>Contributors. Hypothesis: A new approach to property based testing. Journal of Open Source Software,<br>4(43):1891, 2019.</p><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;%E2%85%B0-automatic-test-case-and-test-oracle-generation-based-on-functional-scenarios-in-formal-specifications-for-con</summary>
      
    
    
    
    <category term="论文" scheme="http://example.com/categories/%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="Invariant" scheme="http://example.com/tags/Invariant/"/>
    
  </entry>
  
  <entry>
    <title>不变量与测试用例相关论文</title>
    <link href="http://example.com/2024/03/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/invariant/%E5%8F%98%E9%87%8F%E4%B8%8E%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/"/>
    <id>http://example.com/2024/03/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/invariant/%E5%8F%98%E9%87%8F%E4%B8%8E%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/</id>
    <published>2024-03-14T16:40:54.798Z</published>
    <updated>2024-03-24T07:02:17.326Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2-the-oracle-problem-in-software-testing%3A-a-survey" tabindex="-1">2 The Oracle Problem in Software Testing: A Survey</h2><ul><li>引用：Barr E T, Harman M, McMinn P, et al. The oracle problem in software testing: A survey[J]. IEEE transactions on software engineering, 2014, 41(5): 507-525.</li><li>CCF A TSE</li><li><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=6963470">链接</a></li></ul><h3 id="2.0-%E6%91%98%E8%A6%81" tabindex="-1">2.0 摘要</h3><ul><li><p>本文提供了对测试预言问题的当前方法的全面调查，以及在这一重要的软件测试研究和实践领域的分析趋势。</p></li><li><p>在软件测试的许多工作中，我们试图将测试过程尽可能地自动化，以使测试更快、更便宜和更可靠。为此，我们需要一个测试预言，这是一种能够区分被测系统（System under Testing SUT）的正确行为和错误行为的. 然而，目前程序自动化测试预言的问题关注的少</p></li><li><p>如何利用测试预言（test oracle）来自动化地验证被测系统（SUT）的行为是否符合预期，有以下两种情况</p><ul><li>如果SUT的开发遵循了良好的测试设计原则，并且有详细正式的规范描述了预期行为，那么测试预言的成本问题可以通过自动化的测试语言解决，无需人工干预</li><li>如果SUT没有完整的规范，但存在部分规范，可以构建一个部分测试预言来回答某些输入的问题。这种部分测试预言可以使用形态测试（metamorphic testing）来构建（基于已知的期望行为之间的关系），或者从执行或文档中推导出神谕信息。</li></ul></li><li><p>在工业界，普遍没有完整的规范，因此测试人员需要为所有测试用例手动检查系统行为，此时，自动化测试方法必须人工解决oracle成本问题。本文旨在通过提供对测试预言问题的现有文献的全面回顾和分析，帮助应对这一挑战。</p></li><li><p>我们为解决测试预言问题的四个广泛类别的解决方案绘制了增长趋势，我们在第4、5、6和7节中对这些进行了调查。这四个类别包括：</p><ul><li>可以指定测试预言的方法（第4节）；</li><li>可以派生测试预言的方法（第5节）；</li><li>可以从隐性信息构建测试预言的方法（第6节）；以及</li><li>没有可用的自动化预言，但仍然可以减少人类努力的情况（第7节）。</li><li>最后，第8节以结束语作为结论。</li></ul></li></ul><h3 id="2.1-%E9%87%8D%E8%A6%81%E5%86%85%E5%AE%B9" tabindex="-1">2.1 重要内容</h3><h4 id="derived-test-oracles-%E6%B4%BE%E7%94%9F%E6%B5%8B%E8%AF%95oracle" tabindex="-1">DERIVED TEST ORACLES 派生测试Oracle</h4><ul><li>指通过各种工件（如，文档，系统运行）或 北侧系统的属性或其它版本的信息中区分系统的正确与错误行为。</li></ul><h4 id="system-executions-%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C-%26-invariant-detection" tabindex="-1">System Executions 系统运行 &amp; Invariant Detection</h4><ul><li>系统执行跟踪可以用来派生测试oracle,或者通过将不正确的执行与预期执行对齐降低人工测试成本</li><li>接下来讨论从系统运行跟踪中的两种技术： 不变量检测和规范挖掘</li><li>不变量检测在计算上可能是昂贵的，因此采用了增量[22]、[171]和轻量级静态分析[39]、[63]。一份技术报告总结了各种动态分析技术[157]。模型推断[90]、[187]也可以被视为一种不变量生成的形式，其中不变量被表达为一个模型（通常是一个FSM）。Ratcliff等人使用基于搜索的软件工程(SBSE) [84]来寻找不变量，[153]由突变测试指导。</li></ul><h2 id="3-the-use-of-likely-invariants-as-feedback-for-fuzzers" tabindex="-1">3 The use of likely invariants as feedback for fuzzers</h2><ul><li>引用：Fioraldi A, D’Elia D C, Balzarotti D. The use of likely invariants as feedback for fuzzers[C], 30th USENIX Security Symposium (USENIX Security 21). 2021: 2829-2846.</li><li>CCF A USENIX Security</li><li><a href="https://www.usenix.org/system/files/sec21-fioraldi.pdf">链接</a></li><li><a href="https://github.com/eurecom-s3/invscov">代码</a></li></ul><h3 id="3.0-%E6%91%98%E8%A6%81%26%E4%BB%8B%E7%BB%8D" tabindex="-1">3.0 摘要&amp;介绍</h3><ul><li>模糊测试是发现软件错误的很有效的方法，一个主要限制是目前流行的基于覆盖率引导的模糊测试优化了对程序不同部分的访问，担当仅凭可达性不可以触发漏洞时，就会遇到困难。</li><li>本文提出一种反馈机制，通过考虑程序变量之间的通常值和关系来增强代码覆盖。谓词，我们在基本块级别学习可能的不变量，并划分程序状态空间。我们的反馈机制可以区分输入何时违反了一个或多个不变量并对其进行建立，从而改进代码覆盖通常提供的程序状态相似。</li><li>我们在一个名为INVSCOV的原型上使用了我们的技术，该原型基于LLVM和AFL++基础上进行开发。</li><li>我们的实验表明，与使用纯代码覆盖反馈的模糊器相比，我们的方法可以发现更多且不同类型的错误。</li><li>本文贡献：<ul><li>一种新的反馈机制，结合了控制流和从挖掘的不变量中抽象出的程序状态；</li><li>基于LLVM和AFL++的我们方法的一个原型实现，名为INVSCOV；</li><li>针对经典和上下文敏感的边覆盖率，对我们方法的有效性进行了评估。</li></ul></li></ul><h3 id="3.1-%E4%B8%BB%E8%A6%81%E5%86%85%E5%AE%B9" tabindex="-1">3.1 主要内容</h3><ul><li><p>我们从一组测试用例语料库开始，就像在实际情况下的真实应用程序一样，这些测试用例不能代表所有的应用状态，然后我们修改fuzzer使其对偏离初始语料库的不变量的行为更加敏感。</p></li><li><p>我们这么做的直觉是：此时，不变量代表的是执行的属性，而不是程序本身的属性。</p></li><li><p>设计三类不变量剪枝原则</p><ul><li><ol><li>舍弃不可能违反的不变量</li></ol></li><li><ol start="2"><li>舍弃结合了不相关变量的不变量</li></ol></li><li><ol start="3"><li>当不变量重叠时，舍弃更弱的不变量</li></ol></li></ul></li></ul><h3 id="3.2-%E5%AE%9E%E7%8E%B0" tabindex="-1">3.2 实现</h3><ul><li><p>使用LLVM [43]和DAIKON [25]可能不变式系统进行基于不变式的模糊测试。</p></li><li><p>分为两个阶段</p><ul><li><strong>学习阶段</strong>：记录进行不变量挖掘所需要的有关程序状态的信息，通过在增强的程序上运行输入来实现。输入可从集中方式获得（我们的实验中从24小时覆盖率引导的模糊测试会话生成的种子）。不变量挖掘使用Daikon，由于我们的技术应用于基本块级别，故不变量计算成本线性依赖于基本块的数量</li><li><strong>插桩阶段</strong>：随后将可能的不变式信息编码到程序函数中，以将它们暴露给覆盖率引导的模糊器。我们转换后的程序可以在任何基于AFL的模糊器上开箱即用。</li></ul></li><li><p>状态不变量学习：修改Daikon使用适配LLVM IR（有点工作）</p></li></ul><h2 id="5-automated-patch-correctness-assessment%3A-how-far-are-we" tabindex="-1">5 Automated patch correctness assessment: How far are we</h2><ul><li>引用：Wang S, Wen M, Lin B, et al. Automated patch correctness assessment: How far are we?[C], Proceedings of the 35th IEEE/ACM International Conference on Automated Software Engineering. 2020: 968-980.</li><li>CCF A ASE</li><li><a href="https://dl.acm.org/doi/abs/10.1145/3324884.3416590">链接</a></li></ul><h2 id tabindex="-1"></h2><p>H. Ye, M. Martinez, T. Durieux, and M. Monperrus, “A comprehensive<br>study of automatic program repair on the quixbugs benchmark,” in Proc.<br>IEEE 1st Int. Workshop Intell. Bug Fixing, 2019, pp. 1–10</p><h2 id="-1" tabindex="-1"></h2><p>J. Yang, A. Zhikhartsev, Y. Liu, and L. Tan, “Better test cases for better<br>automated program repair,” inProc. 11th Joint Meeting Found. Softw. Eng.,<br>2017, pp. 831–841.</p><h2 id="-2" tabindex="-1"></h2><p>Gordon Fraser and Andrea Arcuri. 2011. Evosuite: automatic test suite generationfor object-oriented software. InESEC/FSE. 416–419.</p><h2 id="-3" tabindex="-1"></h2><p>Z. Y. Ding, Y. Lyu, C. Timperley, and C. L. Goues, “Leveraging program<br>invariants to promote population diversity in search-based automatic program repair</p><h2 id="-4" tabindex="-1"></h2><p>G. Yang, C. S. Pas˘ areanu, and S. Khurshid, “Memoized symbolic ˘<br>execution,” in Proceedings of the 2012 International Symposium on<br>Software Testing and Analysis, 2012, pp. 144–154.</p><h2 id="-5" tabindex="-1"></h2><p>D. Schuler, V. Dallmeier, and A. Zeller. EfficientMutation Testing by Checking Invariant Violations. InISSTA ’09, pages 69–80. ACM, 2009</p><h2 id="combined-static-and-dynamic-automated-test-generation" tabindex="-1">Combined static and dynamic automated test generation</h2><ul><li>引用：Zhang S, Saff D, Bu Y, et al. Combined static and dynamic automated test generation[C]//Proceedings of the 2011 international symposium on software testing and analysis. 2011: 353-363.</li><li>CCF A ISSTA</li><li><a href="https://dl.acm.org/doi/epdf/10.1145/2001420.2001463">链接</a></li></ul><h2 id="-6" tabindex="-1"></h2><p>J. Zhang, J. Chen, D. Hao, Y. Xiong, B. Xie, L. Zhang, and H. Mei,<br>“Search-based inference of polynomial metamorphic relations,” in<br>Proceedings of the 29th ACM/IEEE International Conference on<br>Automated Software Engineering, ser. ASE ’14. New York, NY,<br>USA: Association for Computing Machinery, 2014, p. 701–712.<br>[Online]. Available: <a href="https://doi.org/10.1145/2642937.2642994">https://doi.org/10.1145/2642937.2642994</a></p><h2 id="-7" tabindex="-1"></h2><p>动态检测到的不变量还可以帮助删除无意义的测试（违反前提条件）并推断何时失败（违反后置条件）[23]<br>C. Pacheco, M.D. Ernst, Eclat: Automatic generation and classification of test inputs, ECOOP (2005) 504–527</p><h2 id="-8" tabindex="-1"></h2><p>S. Artzi, M. D. Ernst, A. Kiezun, C. Pacheco, and J. H. Perkins, _<br>“Finding the needles in the haystack: Generating legal test inputs<br>for object-oriented programs,” in Proc. 1st Workshop Model-Based<br>Testing Object-Oriented Syst., Oct. 23, 2006.</p><h2 id="from-daikon" tabindex="-1">From Daikon</h2><p>例如用于测试选择和优先级排序；更多的覆盖度量指标会产生更好的测试套件[21,22]</p><p>M. Harder, J. Mellen, M.D. Ernst, Improving test suites via operational abstraction, ICSE (2003) 60–71.<br>T. Xie, D. Notkin, Tool-assisted unit test selection based on operational violations, ASE (2003) 40–48.</p><h2 id="a-survey-on-automatic-test-data-generation-1999-8%E9%A1%B5" tabindex="-1">A Survey on Automatic Test Data Generation 1999 8页</h2><p><a href="https://faculty.cc.gatech.edu/~harrold/6340/cs6340_fall2009/Readings/test.data.genration.survey.pdf">https://faculty.cc.gatech.edu/~harrold/6340/cs6340_fall2009/Readings/test.data.genration.survey.pdf</a></p><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;2-the-oracle-problem-in-software-testing%3A-a-survey&quot; tabindex=&quot;-1&quot;&gt;2 The Oracle Problem in Software Testing: A Survey&lt;/h2&gt;
&lt;ul&gt;
&lt;li</summary>
      
    
    
    
    <category term="论文" scheme="http://example.com/categories/%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="Invariant" scheme="http://example.com/tags/Invariant/"/>
    
  </entry>
  
  <entry>
    <title>daikon使用</title>
    <link href="http://example.com/2024/03/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/invariant/daikon%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"/>
    <id>http://example.com/2024/03/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/invariant/daikon%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</id>
    <published>2024-03-14T16:40:54.794Z</published>
    <updated>2024-03-21T08:46:57.869Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-%E4%BB%8B%E7%BB%8D" tabindex="-1">1 介绍</h2><ul><li><p>Daikon是一个动态检测不变量的工具</p></li><li><p>不变量是程序中某个特定点上保持为真的属性，这些通常出现在断言语句，文档和形式化规范中。</p></li><li><p>不变量在程序理解和其它许多应用中都非常有用，例如，不变量可以是</p><ul><li>x.field &gt; abs(y)</li><li>y = 2 * x + 3</li><li>数组a是有序的</li><li>对于所有的列表对象lst，kst.next.prev = lst</li><li>等等，用户可以扩展Daikon以添加新的属性</li></ul></li><li><p>动态不变量检测通过运行程序，观察程序计算的值，然后报告在观察到的执行过程中始终为真的属性。</p><ul><li>Daikon可以在C、C++、C#、Eiffel、F#、Java、Perl和Visual Basic程序中检测属性</li><li>在spreedsheet文件中</li><li>以及其它数据源中（动态不变量监测是一种可以应用于任意数据的机器学习技术）</li></ul></li><li><p>Daikon完全开源</p></li><li><p>Daikon详情参考<a href="https://plse.cs.washington.edu/daikon/download/doc/daikon.html#Introduction">daion用户手册</a></p></li><li><p>本文记录本人使用daikon过程</p></li></ul><h2 id="2-%E4%B8%8B%E8%BD%BDdaikon" tabindex="-1">2 下载Daikon</h2><ul><li>照着用户手册下载即可</li><li>注意daikon需要的shell环境变量</li></ul><pre><code class="language-bash">export DAIKONDIR=daikonparent/daikon-5.8.18 # daikon的安装目录source $DAIKONDIR/scripts/daikon.bashrc</code></pre><h2 id="3-%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B" tabindex="-1">3 使用案例</h2><h3 id="c%2Fc%2B%2B" tabindex="-1">C/C++</h3><ol><li>需要使用 <code>gcc</code> 和 编译选项 <code>-gdwarf-2 -no-pie</code>产生可执行文件<ul><li>对于通过<code>./configure</code>生成的Makefile,在<code>./configure</code>前加入<code>CC=gcc CFLAGS=&quot;-gdwarf-2 -no-pie&quot;</code>即可</li></ul></li><li>使用 kvasir 前端产生daikon需要的文件，对于单次运行，只需要在正常运行指令前加上 <code>kvasir-dtrace</code>即可，示例<ul><li><code>kvasir-dtrace ./wordplay -f words.txt 'Daikon Dynamic Invariant Detector'</code></li></ul></li><li>随后使用daikon进行分析</li></ol><pre><code class="language-bash">java -cp $DAIKONDIR/daikon.jar daikon.Daikon \    daikon-output/wordplay.decls daikon-output/wordplay.dtrace</code></pre><h4 id="%E7%A8%8B%E5%BA%8F%E5%A4%9A%E6%AC%A1%E8%BF%90%E8%A1%8C%E8%BD%A8%E8%BF%B9" tabindex="-1">程序多次运行轨迹</h4><ul><li>对于多次运行的程序，需要将多次运行的轨迹合并，此时可以将各个轨迹分开，或者合成一个轨迹文件</li><li>分开轨迹文件（此种写法更好一些）</li></ul><pre><code class="language-bash">kvasir-dtrace --dtrace-file=daikon-output/wordplay1.dtrace \    ./wordplay -f words.txt 'daikon dynamic invariant detector'kvasir-dtrace --no-dyncomp --dtrace-file=daikon-output/wordplay2.dtrace \    ./wordplay -f words.txt 'better results from multiple runs'kvasir-dtrace --no-dyncomp --dtrace-file=daikon-output/wordplay3.dtrace \    ./wordplay -f words.txt 'more testing equals better testing'java -Xmx3600m -cp $DAIKONDIR/daikon.jar daikon.Daikon \  # 这里-Xmx3600m是为了增加java的堆栈大小,在大数据量的情况下需要    daikon-output/wordplay*.dtrace daikon-output/wordplay.decls # 这里的*是通配符</code></pre><ul><li>合并轨迹文件</li></ul><pre><code class="language-bash">kvasir-dtrace --dtrace-file=daikon-output/wordplay-all.dtrace \    ./wordplay -f words.txt 'daikon dynamic invariant detector'kvasir-dtrace --no-dyncomp --dtrace-append \    --dtrace-file=daikon-output/wordplay-all.dtrace \    ./wordplay -f words.txt 'better results from multiple runs'kvasir-dtrace --no-dyncomp --dtrace-append \    --dtrace-file=daikon-output/wordplay-all.dtrace \    ./wordplay -f words.txt 'more testing equals better testing'java -Xmx3600m -cp $DAIKONDIR/daikon.jar daikon.Daikon \    daikon-output/wordplay-all.dtrace daikon-output/wordplay.decls</code></pre><h4 id="%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" tabindex="-1">注意事项</h4><ul><li>在示例中，很重要的一个示范是</li></ul><pre><code class="language-bash">java -cp $DAIKONDIR/daikon.jar daikon.Daikon \     --config_option daikon.derive.Derivation.disable_derived_variables=true \     daikon-output/wordplay.decls daikon-output/wordplay.dtrace</code></pre><ul><li>这里通过配置选项禁止派生变量的生成，大大减少了运算时间，而这派生变量许多都是无用的，这在第五部分Daikon输出中会有所说明</li></ul><h2 id="4-%E8%BF%90%E8%A1%8Cdaikon" tabindex="-1">4 运行Daikon</h2><ul><li>运行Daikon使用以下命令：</li></ul><pre><code class="language-bash">java -jar daikon.jar --input=&lt;dtrace文件路径&gt; &lt;其他选项&gt;</code></pre><ul><li>其中&lt;dtrace文件路径&gt;是你要分析的.dtrace文件的路径</li><li>&lt;其他选项&gt;是可选的命令行参数，用于配置Daikon的行为。例如，你可以使用–output=&lt;输出文件路径&gt;选项来指定输出文件的路径，或者使用–help选项来查看所有可用的命令行选项。</li><li>各Daikon的前端使用各不相同，详见手册</li><li>spinfo文件是用于检测条件不变量（Conditional invariants）的分割信息文件。这些文件是可选的，可以自动创建或手动创建。</li></ul><h3 id="4.1-%E6%8E%A7%E5%88%B6daikon%E8%BE%93%E5%87%BA%E7%9A%84%E9%80%89%E9%A1%B9" tabindex="-1">4.1 控制Daikon输出的选项</h3><ul><li><strong>–help</strong></li><li><strong>-o inv_file</strong>:将序列化的不变量输出到指定文件，默认生成与dtrace文件同名的.inv.gz文件</li><li><strong>–no_text_output</strong>:不将不变量作为文本输出</li><li><strong>–format name</strong>：以给定格式生成输出，有关Daikon支持的输出列表参阅invariant语法</li><li><strong>–show_progress/–no_show_progress</strong>:打印或不打印执行Daikon主要部分的时间信息</li><li><strong>–show_detail_progress</strong>:同上，还包括不变量的详细信息</li><li><strong>–noversion</strong>:禁止打印版本信息</li><li><strong>–output_num_samples</strong>:输出不变量和程序点的数值和样本数量，这是一个调试选项，帮助理解Daikon产生了怎样的输出</li><li><strong>–files_from filename</strong>：从给定的文本文件中读取一系列.decls、.dtrace或.spinfo文件名，作为在命令行上提供文件名的替代方法</li><li><strong>–server dirname</strong>：Daikon的服务器模式，在该模式下，它会读取dirname中的文件（按字典顺序排序），直到找到一个以“.end”结尾的文件，然后计算并输出不变量</li></ul><h3 id="4.2-%E6%8E%A7%E5%88%B6%E4%B8%8D%E5%8F%98%E9%87%8F%E6%8E%A2%E6%B5%8B%E7%9A%84%E9%80%89%E9%A1%B9" tabindex="-1">4.2 控制不变量探测的选项</h3><ul><li><strong>–conf_limit val</strong>：是一个命令行选项，用于设置Daikon在证明不变量的置信度限制。只有当给定的不变量置信度大于这个值Daikon才会输出<ul><li>val在0到1之间，.99为默认值，越大的值过滤越强</li><li>每种类型的不变量都有自己确定置信度的方法，参见Java 源代码中的 invariant 的 computeConfidence 方法。</li><li>考虑不变量a，有两种打印不变量置信度的方法<ul><li>使用Diff（参见invariant Diff） <code>java -cp $DAIKONDIR/daikon.jar daikon.diff.Diff MyFile.inv.gz</code></li><li>使用PrintInvariants (参见 Printing invariants)<code>java -cp $DAIKONDIR/daikon.jar daikon.PrintInvariants --dbg daikon.PrintInvariants.repr \     MyFile.inv.gz</code></li></ul></li><li>要打印被丢弃的每个不变量的置信度，请使用 --disc_reason all 命令行选项运行 Daikon（参见 Daikon Daikon debugging options）</li></ul></li><li><strong>–list_type classname</strong>:表示给定的类实现了java.util.List接口。See ListImplementors declaration</li><li><strong>–user-defined-invariant classname</strong>:使用在给定类中定义的用户定义的不变量，而不是内置在Daikon中的不变量。</li><li><strong>–disable-all-invariants</strong>：禁用所有已知的不变量：那些内置在Daikon中的不变量，以及到目前为止通过–user-defined-invariant指定的所有不变量。在此选项指定后，可以重新启用某个不变量，参见启用/禁用特定不变量的选项。</li><li><strong>–nohierarchy</strong>：避免在数据流层次结构中连接程序点。</li><li><strong>–suppress_redundant</strong>：使用Simplify自动定理证明器抑制逻辑上多余的不变量的显示。</li></ul><h3 id="4.3-%E6%93%8D%E4%BD%9C%E9%83%A8%E5%88%86trace%E6%96%87%E4%BB%B6" tabindex="-1">4.3 操作部分trace文件</h3><ul><li><strong>–ppt-select-pattern=ppt_regexp</strong>：仅处理名称与正则表达式匹配的程序点。–ppt-omit-pattern参数优先于此参数</li><li><strong>–ppt-omit-pattern=ppt_regexp</strong>：不处理名称与正则表达式匹配的程序点。此参数优先于–ppt-select-pattern参数</li><li><strong>–var-select-pattern=var_regexp</strong>：仅处理名称与正则表达式匹配的变量（无论是在跟踪文件还是在派生中）。–var-omit-pattern参数优先于此参数。</li><li><strong>–var-omit-pattern=var_regexp</strong>：忽略名称与正则表达式匹配的变量（无论是在跟踪文件还是在派生中）。此参数优先于–var-select-pattern参数。</li><li>将以上命令传给前端工具，可以让目标程序运行得更快，跟踪文件更小</li></ul><h3 id="4.4-daikon%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9" tabindex="-1">4.4 Daikon配置选项</h3><ul><li><strong>–config filename</strong>: 从指定的文件中读取配置选项。更多信息参见 Configuration options</li><li><strong>–config_option name=value</strong>:指定一个配置选项</li></ul><h3 id="4.5-daikon%E8%B0%83%E8%AF%95%E9%80%89%E9%A1%B9" tabindex="-1">4.5 Daikon调试选项</h3><ul><li>更多参见后续 Debugging options</li><li><strong>–dbg category 和 --debug</strong>：这两个选项用于启用特定部分的Daikon的调试输出（日志输出）。可以通过多次指定–dbg category来实现对调试输出的细粒度控制。–debug选项会打开所有调试标志，这会产生很多输出！</li><li><strong>–track class&lt;var1,var2,var3&gt;@ppt</strong>：此选项用于在指定的类、变量和程序点上启用调试信息。</li><li><strong>–disc_reason inv_class&lt;var1,var2,…&gt;@ppt</strong>：此选项打印指定程序点处被丢弃的inv_class类的不变量，以及简短的原因和解释为什么它们不值得打印。</li><li><strong>–mem_stat</strong>：此选项将内存使用情况统计信息打印到当前目录中名为stat.out的文件中</li></ul><h2 id="5-daikon%E8%BE%93%E5%87%BA" tabindex="-1">5 Daikon输出</h2><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-%E4%BB%8B%E7%BB%8D&quot; tabindex=&quot;-1&quot;&gt;1 介绍&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Daikon是一个动态检测不变量的工具&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不变量是程序中某个特定点上保持为真的属性，这些通常出现在断言语句，文档</summary>
      
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Invariant" scheme="http://example.com/tags/Invariant/"/>
    
  </entry>
  
  <entry>
    <title>Software Debloating 论文阅读 （12）</title>
    <link href="http://example.com/2024/02/04/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/SoftwareDebloating/Software%20Debloating%20%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB(12)/"/>
    <id>http://example.com/2024/02/04/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/SoftwareDebloating/Software%20Debloating%20%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB(12)/</id>
    <published>2024-02-04T08:13:57.509Z</published>
    <updated>2024-03-18T17:23:52.566Z</updated>
    
    <content type="html"><![CDATA[<h2 id="sok%3A-a-broad-comparative-evaluation-of-software-debloating-tools" tabindex="-1">SoK: A Broad Comparative Evaluation of Software Debloating Tools</h2><ul><li>SOK2.0</li><li>引用：Brown M D, Meily A, Fairservice B, et al. SoK: A Broad Comparative Evaluation of Software Debloating Tools[J]. arXiv preprint arXiv:2312.13274, 2023.</li></ul><h3 id="0-%E6%91%98%E8%A6%81" tabindex="-1">0 摘要</h3><ul><li><p>软件简化工具旨在通过删除被称为“膨胀”（bloat）的不必要的代码来提高程序的安全性和性能。尽管已经提出了许多技术，但它们的应用还存在一些障碍。</p><ul><li>瘦身工具高度专业化，这使得采用者难以找到符合他们需求的合适工具</li><li>同时缺乏统一的评估标准，这使得采用者难以评估工具的优劣</li></ul></li><li><p>为了弥补则以差距，我们对近简化文献和集中目前正在商业开发的工具进行了广泛的调查</p></li><li><p>随后我们的10种简化工具进行了评估，确定其优势和劣势。我们的评估是在20个不同基准程序的多样化集合上进行的，涵盖了16个性能、安全性、正确性和可用性指标</p></li><li><p>我们的评估揭示了一些令人担忧的发现，这些发现与debloating文献中的主流叙述相矛盾</p><ul><li>首先，简化工具缺乏在实际软件中的使用，在中高复杂性基准的的成功率仅有21%</li><li>其次，简化工具的健壮还曾度存在问题，通过我们的差异模糊检测工具DIFFER，只有13%的简化生成了强壮的简化工具</li><li>最后，我们的结果表明，简化工具通常无法显著改善膨胀程序的性能或安全状况</li></ul></li><li><p>我们相信本文的贡献将会帮助潜在的使用者更好的理解工具，并激发未来对简化的研究和开发，为此我们开源了我们的基准集，数据和自定义工具</p></li></ul><h3 id="1-%E4%BB%8B%E7%BB%8D" tabindex="-1">1 介绍</h3><ul><li><p>软件简化是一个新兴的领域，关注于通过删除程序中不必要的代码（即膨胀）来增强程序的安全性和性能，这些不必要的代码通常以<strong>不必要的功能</strong>和<strong>多余的库代码</strong>的形式出现。</p></li><li><p>由于entrenched的软件实践（如 可重用性代码）和 一些趋势（范围蔓延），现代程序中普遍存在<strong>膨胀</strong>。为了面对这一问题，许多简化方法已经被提出，针对软件生命周期的各个阶段，然而由于一些原因，这些技术实际的实用没有跟上研究</p><ul><li><ol><li><strong>简化工具高度特化</strong>：每个工具面向不同类型的膨胀，软件类型（编译，解释，内核等），生命周期的阶段（源码，中间代码，二进制），并且有自己独特的分析方法。这使得使用者不能根据具体问题选择具体方法</li></ol></li><li><ol start="2"><li><strong>缺乏统一度量标准</strong>：这将导致关于不同方法如何提高性能和安全性的声明不清晰，不完整，且可能具有误导性，这是因为作者使用或创建的方法本身就是有问题的[12,48]，最终，使用者难以理解可以获得哪些期望的好处，因为看不出哪些度量标准是有用的或相关的。这一问题被相关简化文献中对健全性风险的肤浅讨论加剧，使得使用者更难以理解简化结果之间的权衡。</li></ol></li><li><ol start="3"><li><strong>缺少工具的比较评估</strong>：这使得使用者难以理解工具的优劣，尽管之前有研究在 膨胀的普遍性[14,50,51],简化权衡[73],安全度量标准研究[8,12,21]，但最近只有一项研究评估了软件简化工具本身，且只有4个工具[4]</li></ol></li></ul></li><li><p><strong>动机</strong>：迄今为止，在软件简化生态中没有工具，度量标注你，基准集，使用案例的全面回顾，分类，分析和评估。我们弥补通过进行一项调查和比较软件简化工具来弥补这一差距，并完成以下研究问题</p><ul><li><ol><li>软件简化工具如何分类？</li></ol></li><li><ol start="2"><li>哪些安全性，健全性，性能 指标是有用的？还需要什么新指标？</li></ol></li><li><ol start="3"><li>哪些基准测试和配置提供了对去膨胀工具的全面评估？</li></ol></li><li><ol start="4"><li>同一类别内的工具如何比较？</li></ol></li><li><ol start="5"><li>不同类别之间的去膨胀工具如何比较？</li></ol></li></ul></li><li><p><strong>贡献总结</strong>：</p><ul><li>第二节介绍我们对简化文献的调查结果</li><li>第三节描述我们评估简化工具及结果的实验方法</li><li>第四节展示评估结果</li><li>第五节讨论我们研究的主要发现</li></ul></li></ul><h3 id="2-%E8%BD%AF%E4%BB%B6%E7%AE%80%E5%8C%96%E5%B7%A5%E5%85%B7%E8%B0%83%E7%A0%94" tabindex="-1">2 软件简化工具调研</h3><ul><li><p>我们调查了从2013年至今超过60篇关于软件简化，特化和定制化的学术文章。此外，为了全面覆盖该领域的广度，我们还调查了各个开发阶段的各种商用技术和正在使用的技术。在我们调查的早期阶段，使用了一个广义的“软件简化”定义。因此，我们调查了许多许多传统上不视为软件的技术成果的简化方法，如容器[53],操作系统及其API[23,24,27,37]，测试用例[34,55,64]，硬件[16,76]，依赖构建[45]和其它[29,41,43,49,77]。</p></li><li><p>在接下来的部分中，我们建立了一个简化分类方法，该分类定义了膨胀的类型，简化工作流，简化技术，度量标准和基准测试。</p></li></ul><h4 id="2.1-%E8%86%A8%E8%83%80%E7%9A%84%E7%B1%BB%E5%9E%8B" tabindex="-1">2.1 膨胀的类型</h4><ul><li>总体上，简化工具尝试移除或终合两种类型的不必要代码，我们定义为I型膨胀和Ⅱ型膨胀<ul><li><strong>I型膨胀</strong>：是普遍不必要的，可以在不影响最终程序行为的情况下移除。最常见表现是在运行时动态加载到进程地址空间的库代码，但永远不会被调用。尽管比较罕见，但一些针对OS的简化工具中的I型膨胀，可以通过删除来防止恶意使用。四代码和不可达代码也属于I型膨胀，但是这些代码通常在编译时被删除，简化工具并不过多过关注</li><li><strong>Ⅱ型膨胀</strong>：该类型膨胀与最终用途相关，代码是否为Ⅱ型膨胀取决于用户如何使用程序。类型Ⅱ通常为不必要功能代码的形式，例如在图像处理软件中支持混淆或过时文件格式。处理操作系统和Web浏览器交互中的平台相关代码是Ⅱ型膨胀的一种形式，这种膨胀通常由构建系统和脚本引擎解决而不是简化工具</li></ul></li></ul><h4 id="2.2-%E7%AE%80%E5%8C%96%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%92%8C%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B" tabindex="-1">2.2 简化工作流和使用案例</h4><ul><li><p>尽管在技术上存在差异，但几乎所有简化工具都共享一个通用的高级六级段用户工作流</p><ul><li><ol><li>规范化（Specification）：用户创建一个特定于工具的规范，概述应该保留或消除的程序行为。</li></ol></li><li><ol start="2"><li>输入（Input）：用户提供规范和程序给去膨胀工具。</li></ol></li><li><ol start="3"><li>分析（Analysis）：工具使用规范中的信息来分析程序，并标记代码（例如，是否为不必要的，或作为某一功能的一部分）。</li></ol></li><li><ol start="4"><li>转换（Transformation）：工具修改程序，将膨胀代码与有用代码分开（例如，剪切、重构、附加标签）。</li></ol></li><li><ol start="5"><li>输出（Output）：工具产生一个修改后的程序，该程序要么不包含膨胀，要么包含必要的标签，以在运行时删除膨胀。</li></ol></li><li><ol start="6"><li>验证（Validation）：用户通过手动测试或他们选择的自动化工具（例如，模糊测试器）验证修改后的程序是否健全并按预期行为。如果输出无效，用户可能会重新开始工作流程。</li></ol></li></ul></li><li><p>尽管存在一个共同的高级工作流程，但许多工具为潜在的用户提供了不同的使用案例。</p><ul><li>针对I型膨胀：尽可能地消除膨胀</li><li>针对Ⅱ型膨胀，包含三个常用案例<ul><li><ol><li><strong>Arrressive</strong>：除所需要的单个功能外删除所有其它功能，例如，激进地简化一个文件压缩工具可能被定义为删除不必要的代码，只留下压缩文件并将结果写入磁盘的部分</li></ol></li><li><ol start="2"><li><strong>Miderate</strong>：保留几个核心和外围功能，简化其它部分。对于文件压缩工具该案例会保留压缩，解压缩和测试压缩文件完整性的代码</li></ol></li><li><ol start="3"><li><strong>Conservative</strong>：只删除少数外围功能</li></ol></li></ul></li></ul></li></ul><h4 id="2.3-%E7%AE%80%E5%8C%96%E6%8A%80%E6%9C%AF%E5%88%86%E7%B1%BB" tabindex="-1">2.3 简化技术分类</h4><p>我们将调查的软件简化工具分为5个类别，这些类别主要是通过在简化过程中各个阶段所做的设计进行分类的</p><h5 id="source-to-source-(s2s)" tabindex="-1">Source-to-Source (S2S)</h5><ul><li>S2S工具简化源代码，他们呢主要针对类型Ⅱ膨胀，尽管他们可以很容易的移除库中的I型膨胀。</li><li>简化 信息丰富 的源代码 与 其它级别表示（即IR和二进制）相比有<strong>两个优点</strong><ul><li><ol><li>开发者在分析阶段可以有很多选择：S2S简化器可以使用代码覆盖率[30,71–73]、模糊测试[9]、构建系统分析[28,69]和手动注释[11]技术来产生特性与代码的映射</li></ol></li><li><ol start="2"><li>源代码更容易进行转换，而不损坏程序完好性，因为编译器还未剥离高级信息并用及其语义代替它，在源代码转换后，编译器在这种情况下检查错误和优化也非常有用</li></ol></li></ul></li><li>尽管有以上优点，但由于其表达的灵活性（如syntactic sugar）编译器不支持直接转换源代码，转换源代码可能在技术上变得复杂。</li></ul><h5 id="compiler-based-specializers-(cbs)" tabindex="-1">Compiler-Based Specializers (CBS)</h5><ul><li>与S2S类似，接收源代码为输入，主要针对Ⅱ型膨胀。</li><li>但与之间简化源代码不同，CBS [2,3,38,39,42,58,61]在分析和转换阶段使用编译器（如LLVM）将源码降级为IR，根据用户的规范将关键输入参数或值替换为编译时常量，通过内置的编译器优化（如常量椽笔，循环展开和死代码去除）简化。</li><li>这种方法通过使用高可靠的编译通道而不是自定义转化程序来解决完整性。</li><li>作为一种权衡，CBS只支持arrgessive简化用例，不适合另外两种，或者在运行时触发功能的场景</li></ul><h5 id="binary-to-binary-(b2b)" tabindex="-1">Binary-to-Binary (B2B)</h5><ul><li>概念上与S2S相似，但B2B只针对二进制文件(ELF,Java字节码[13,32,33,65])</li><li>仅二进制的方法容易除左且充满挑战，但其具有简化旧的或闭源二进制文件的<strong>优势</strong>。</li><li>B2B方法简化器在分析阶段的选择有限，它们必须以来固有的不准确的二进制分析技术，例如执行测试用例的执行跟踪[5,15,22,26,40,48,57,67,74]和二进制提升[5,22,26,40,57,70,74]以及启发式[40,48]来生成特性到代码的映射。</li><li>由于二进制格式的独特性（例如，程序指令和数据的混合，简介分支等），转化阶段同样困难，因为在一般情况下回复一个二进制是不可判定的，B2B简化器必须小心地处理二进制输入，而不违反原始布局，通过空出没有操作或无效的代码[15,74]或将去膨胀版本的程序作为新的代码部分放在原始代码旁边[5,67]。</li><li>最终，B2B简化器的<strong>主要缺点</strong>也是二进制分析限制的后果：很难产生完整的简化二进制，并且需要高质量的二进制恢复才能有效（例如，Egalito [70]需要position-independent code以确保恢复）。</li></ul><h5 id="%E4%BB%A5%E4%B8%8A%E4%B8%89%E7%B1%BB%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93" tabindex="-1">以上三类工具总结</h5><ul><li>对于这三类工具，有<strong>两个常见的限制和挑战</strong><ul><li><ol><li><strong>验证简化程序是留给用户的任务</strong>：一些工具包含验证例程[67,75]，但只验证保留的功能，并未验证是否确实去除了多余的特性和/或尝试调用这些特性是否得到了妥善处理。 验证和重要，因为简化可能会引入额外的漏洞，这些漏洞的引入大于简化带来的潜在安全好处。</li></ol></li><li><ol start="2"><li><strong>在实际场景使用是困难的</strong>：需要额外的人工努力，通常是列举测试用例，对于复杂的程序，需要用例来确保保留所有所需的功能、错误处理和边缘情况。</li></ol></li></ul></li></ul><h5 id="static-library-(sl)" tabindex="-1">Static Library (SL)</h5><ul><li>SL工具针对I型膨胀</li><li>由于工具在静态的情况下可以直接分析计算目标程序的调用图并识别所需要库函数集合，这类工具不需要规范。</li><li>SL简化器使用各种转换方法，包括通过重写创建专用库以删除[7,31,35,54,62,66,75,78]或使用无操作或无效指令空出未使用的函数[1,59]，对库进行分片[51]，对可执行文件进行重写以静态链接库函数[26]，以及使用存根替换不必要的库函数[68]。</li><li><strong>优势</strong>：通过将其范围限制在Type I膨胀上，SL简化器避免了其他类工具所经历的许多挑战。<ul><li><ol><li>SL不会有创建不健全程序的风险，尽管有些工具可能无法处理如反射和间接引用等编程方法。</li></ol></li><li><ol start="2"><li>除目标程序外，SL简化器几乎不需要使用额外的人工，但这种设计导致这类工具不适用于Ⅱ型膨胀</li></ol></li></ul></li></ul><h5 id="runtime" tabindex="-1">Runtime</h5><ul><li>运行时简化器和SL相似，主要区别在它们的转换和输出阶段</li><li>为了避免对库进行永久性更改，运行时简化器记录所需的库函数作为程序元数据，并在执行期间干预动态链接过程，以从进程内存中去除不必要的库函数。</li><li>方法各不相同<ul><li>Piecewise Compilation and Loading (PCL) [52] 在二进制文件中嵌入调用图信息，并使用自定义加载器在运行时将不必要的函数重写为无效指令</li><li>BlankIt [47] 和Decker [46] 则采用相反的方法，根据当前执行点将仅必要的函数加载到程序的运行时内存中。</li><li>其他方法使用来自构建系统的信息，如配置选项 [36] 和包依赖性 [44] 来去除膨胀。</li></ul></li><li>除了SL去膨胀器的优点外，运行时去膨胀器还具有不干扰静态代码的优点，从而对结果的健全性有很高的信心。代价是管理进程内存需要的高运行时开销。</li></ul><h4 id="2.4-%E7%AE%80%E5%8C%96%E7%9A%84%E5%88%86%E6%9E%90%E6%8C%87%E6%A0%87" tabindex="-1">2.4 简化的分析指标</h4><ul><li><p>没有统一的指标，一般情况下这些指标都是从类似的程序转化技术中适应过来的（如代码优化），但在一些情况也引入了新的指标</p></li><li><p>总体上，我们注意到了30种不同的指标，我们将其分为三类在本节描述。这些指标包含了大多数典型的功能性和非功能性软件数据。</p></li><li><p>然而目前没有作品尝试衡量工具可用性，我们这位这个维度很重要，因为仅供专业人士使用的工具不会被主流采纳</p></li><li><p><strong>性能</strong>：</p><ul><li>衡量简化本身及产生的简化程序的资源消耗。</li><li>在衡量简化后的程序时，性能需要与源程序相比。</li><li>常用指标包括：CPU运行时间、内存开销、静态二进制大小、所需的外部资源数量，使用工具所需的人工努力。</li></ul></li><li><p><strong>正确性和鲁棒性</strong></p><ul><li>衡量简化后程序的稳定性和鲁棒性</li><li>通常，使用测试套件或模糊器来运行简化后程序，来识别错误的输出，崩溃及其它不良结果。 有趣的是我们看到的工作仅对简化后程序收集了它们，并未对原程序使用，然而正确性和鲁棒性的问题可能在原程序就存在，这里需要对比试验。</li><li>Crystal和Casinghino的[20]比较二进制分析工具使用基于SMT的最弱前置条件方法来证明两个程序二进制的等价性或突出它们行为上的差异，为简化场景提供了一个高保证度的正确性指标。</li></ul></li><li><p><strong>安全性</strong></p><ul><li>衡量简化后程序的安全性改进，在我们的调查中我们注意到了两个主要的安全类别：<strong>漏洞消除和代码重用预防code-reuse prevention</strong>。表面上，这些指标用于宣称结果的理想，如消除潜在的漏洞、减少程序的攻击面和减少代码重用攻击。然而，这些指标在实际应用中的实用性仍有待商榷。</li><li><strong>漏洞消除措施</strong><ul><li>可以为简化有已知漏洞的旧版本（如在MITRE的CVE数据库[17]中报告的漏洞）并显示该漏洞已删除。虽然这样展示了简化带来的好处，但没有预测能力，不具有普遍性，不能用于在实际场景中证明对未知漏洞的安全一处。</li><li>可以提出一个论点：已知漏洞对于难以修补的系统构成风险，但修补远比简化简单，侵入性小，风险小。</li><li>此外，使用这类指标可能会导致不准确或不完整，例如<ul><li>Qian等人[48]表明，之前声称在Type II膨胀[30]中消除漏洞的工作也重新引入了其他历史漏洞。</li><li>PCL [52]声称在Type I膨胀中消除已知的漏洞。但是，这些漏洞位于程序静态不可达的库函数中</li></ul></li><li>因此，它们只在极端或刻意的情况下是可利用的。</li></ul></li><li><strong>代码重用预防</strong><ul><li>工具面减少和代码重用预防度量单位：代码重用小工具（是存在于被攻击程序中的链式代码小片段，攻击者在被阻止直接使用shell时，可以利用小工具注入攻击）</li><li>常用的衡量安全改进的指标是减少攻击者可用的小工具总数，然而Brown和Pande [12]已经证明这不恰当，因为许多简化工具在大量减少小工具数量的同时，以很高的速率引入新的小工具，而大幅度减少小工具数量很可能对攻击者影响有限</li><li>反过来，Brown和Pande提出了用于衡量对攻击者实施利用施加的成本的定性小工具集度量标准（例如，小工具集表达能力、可组合性、特殊功能和局部性）以及一个用于计算它们的静态分析工具，即GSA（小工具集分析器）。</li></ul></li></ul></li></ul><h4 id="2.5-benchmark" tabindex="-1">2.5 Benchmark</h4><ul><li>大多数研究采用了在程序分析中常用的基准测试集，例如GNU Coreutils [25]、SPEC CPU 2006/2017 [18,19]和DaCapo[10]。此外，还有几项工作提供了自己的基准如CHISELBench [6]和OCCAM基准测试 [63]，这些基准可能互有交叉。</li><li>大多数基准复杂度不高，它们具有命令行用户界面，很少使用多线程，网络接口等，并且通常只使用一组输入运行到终止。这些基准程序amenable（经得起）简化所需的复杂跟踪和转换操作</li><li>许多工作还在bfptd、cUrl和httpd等中等复杂性基准上评估了他们的工具，但数量和频率较少。这样的基准测试的特点是使用复杂的输入、多线程、网络套接字等。尽管很少见，但一些工作 [48,49] 也在高复杂性软件上评估了他们的工具，如网络浏览器和文档阅读器。</li></ul><h3 id="3-%E8%AF%84%E4%BC%B0%E6%96%B9%E6%B3%95%E8%AE%BA" tabindex="-1">3 评估方法论</h3><p>详细说明方法，配置，指标，基准在评估中的选择</p><h4 id="3.1-%E5%B7%A5%E5%85%B7%E9%80%89%E6%8B%A9" tabindex="-1">3.1 工具选择</h4><ul><li>由于简化工具系统的多样性和规模，我们首先将我们的评估范围限定为支持用户空间C/C++程序和x86/x86-64机器的库的工具。这个基准配置是最广泛支持的，并且拥有最多的候选工具。</li><li>总共，我们在过滤掉继任者工具（例如，OCCAM-v2 [42] 相对于 OCCAM-v1 [39]）后确定了31个候选工具。<ul><li>我们通过公共仓库或向作者请求，成功地获得了24个工具的源代码，并能够成功地构建和运行其中的17个。我们为七个失败的工具付出了大量的努力来解决问题，但由于不可调和的技术问题 [9,44,52,72]或未响应的作者[15,61,74]，我们没有成功。</li><li>剩下17个中<ul><li>因需要IDA Pro [51]的商业许可证排除一个。</li><li>因一个工具将其基准硬编码 [69]而排除</li><li>四个工具需要耗时且需要手动预处理步骤来适应新的基准 [11,46,47,73]</li><li>以及一个工具有技术限制 [22]</li></ul></li></ul></li><li>最后下表中展示了我们选择的10个工具，其中3个工具是商业公司开发的学术工具的专门版本。为了避免混淆，我们在工具标题中使用商业公司的缩写并用连字符连接：CHISEL-GT (GrammaTech, Inc.)、BinRec-ToB (Trail of Bits) 和 LMCAS-SIFT (Smart Information Flow Technologies)。<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(12)_1.png" alt></li><li>对于每个工具，我们都准备了一个隔离的环境（即虚拟机或docker容器），配置有工具支持的最新操作系统和所有使用工具及操作我们基准程序所需的必要资源。</li></ul><h4 id="3.2-%E5%9F%BA%E5%87%86%E9%80%89%E6%8B%A9" tabindex="-1">3.2 基准选择</h4><ul><li>我们选择了20个基准程序程序（表2），在在大小、复杂性和功能上都有所不同<ul><li>为了代表低复杂性基准，我们使用了CHISELBench [6]，因为它在去膨胀文献中常常被使用，并为之前的工作提供了一个常见的比较点。</li><li>我们进一步添加了六个中等复杂性和四个高复杂性的基准，这些基准来自其他基准集 [56,63]。</li></ul></li><li>为了为这些基准构建64位ELF二进制文件，我们在Ubuntu Linux v20上使用了Clang/LLVM v10，并指定了两个构建选项：位置无关代码（-fPIC）和优化级别3（-O3）。</li><li>然而，由于各种工具和基准的特定限制，我们使用了不同的方法来构建一些参考二进制文件。我们在Debian Buster上为RAZOR和CHISEL构建了参考二进制文件。构建ImageMagick需要使用GCC v9.4 (Ubuntu)和GCC v8.3 (Debian Buster)而不是Clang/LLVM。最后，我们为BinRec-ToB构建了32位ELF二进制文件，因为它不支持64位程序。</li></ul><p><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(12)_2.png" alt></p><h4 id="3.3-%E7%AE%80%E5%8C%96%E9%85%8D%E7%BD%AE" tabindex="-1">3.3 简化配置</h4><ul><li>由于各工具对简化用例的支持各不相同，我们使用三种策略进行配置<ul><li><ol><li>对于SL工具，不需要规范</li></ol></li><li><ol start="2"><li>采用中等去膨胀案例，这在文献中最为普遍，用于S2S和B2B简化器</li></ol></li><li><ol start="3"><li>采用了arrgessive激进，因为这是CBS简化其唯一支持的</li></ol></li></ul></li><li>对于每个基准程序，我们创建一个通用的与工具无关的简化规范<ul><li>包括要保留的几个核心和外围功能（即moderate中等使用案例）</li><li>我们为每个功能定义了一个描述性名称和一个或多个样本指令（即测试用例），该基准程序可以执行该功能</li><li>随后我们可以进一步简化该规范，向激进版本靠近</li></ul></li><li>使用通用规范作为指南，我们然后为每个基准程序创建了工具特定的配置文件。</li><li>总的来说，我们为评估创建了160个不同的简化规范。</li></ul><h4 id="3.4-%E6%8C%87%E6%A0%87%E9%80%89%E6%8B%A9" tabindex="-1">3.4 指标选择</h4><ul><li>我们选择了16个指标（表3），来评估去简化器本身以及它们产生的去膨胀程序/库<ul><li>其中12个指标来自于第2.4节中概述的三个类别中常用的指标。通常我们选择从程序二进制文件的分析中计算的指标，因为这是所有去膨胀工具的共同程序表示<ul><li>值得注意的是，由于其较差的预测能力（不具有普遍性），我们选择不在我们的评估中使用CVE消除作为安全指标。</li></ul></li><li>我们进一步添加了四个工具可用性指标，以记录配置和使用去膨胀工具的主要差异。我们在第4节中提供了每个指标是如何计算以及我们的评估结果的详细信息。<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(12)_3.png" alt></li></ul></li></ul><h3 id="4-%E8%AF%84%E4%BC%B0%E7%BB%93%E6%9E%9C" tabindex="-1">4 评估结果</h3><ul><li>我们按照指标类别组织了我们的评估结果。<ul><li>首先，我们展示了工具本身的可用性和性能结果</li><li>然后是通过分析它们产生的去膨胀程序的性能、正确性和安全性指标。</li></ul></li><li>请注意，我们在本节中讨论了每个指标的重要发现和结果，但将整体和跨类别的分析留给第5节。</li></ul><h4 id="4.1-%E5%B7%A5%E5%85%B7%E5%8F%AF%E7%94%A8%E6%80%A7%E5%92%8C%E6%80%A7%E8%83%BD" tabindex="-1">4.1 工具可用性和性能</h4><ul><li>简化工具的一个主要目标是非专家用户可以使用来转换软件。<ul><li>每个工具的设计和用户界面影响其实现此目标的能力。我们提供的前六个指标，集中在简化工具的面向用户的方向：它们的可用性和性能。</li><li>我们假设用户已在适当的计算环境中为其安装了该工具，部署去膨胀的程序不再我们评估的范围</li><li>我们认为软件简化所需的所有工作都在面向用户的评估范围内<ul><li><ol><li>配置工具</li></ol></li><li><ol start="2"><li>使用基准集</li></ol></li><li><ol start="3"><li>运行工具</li></ol></li><li><ol start="4"><li>维护程序的简化版本以面对未来的变化</li></ol></li></ul></li></ul></li></ul><h5 id="usability-1%EF%BC%9A%E9%85%8D%E7%BD%AE%E5%B7%A5%E5%85%B7%E7%9A%84%E6%97%B6%E9%97%B4" tabindex="-1">Usability-1：配置工具的时间</h5><p>-为了比较用户配置简化的体验，我们记录了每个工具创建和验证具体简化规范所需的时间。在创建规范之前，我们通过它们的文档和示例熟悉了这些工具及其规范格式。这些测量只旨在为生成规范所需的努力提供大致的估计。</p><ul><li>表4显示了创建规范所需的平均时间，四舍五入到最近的分钟。我们根据第3.2节定义的三个基准复杂性级别计算平均值。<ul><li>在针对Type II膨胀的工具中，CBS工具生成规格所需的时间最短，因为其为激进的用例，规范仅包括一个测试用例。</li><li>B2B简化工具通常要15min到1h，其时间与测试用例数量成比例</li><li>S2S对于低复杂度基准配置简单，而中高复杂度需要几个小时。<ul><li>这主要由Chisel的设计引起，Chisel为了确定可删除代码，通过ML引导的Delta Debugging算法迭代地删除代码片段，然后编译运行修改后的代码看是否能通过测试用例。正确的Oracle是关键，因为会生成可以编译但运行错误的程序</li></ul></li><li>这些工具还需要额外的测试用例，来确保不删除必要的但不影响通过测试用例（例如安全控制和错误处理）的代码。其他工作已经提出了这样的问题，并显示当它们的补丁未被执行时，CHISEL会重新引入历史上的CVE[48]。<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(12)_4.png" alt></li></ul></li></ul><h5 id="usability-2%EF%BC%9A%E5%9F%BA%E5%87%86%E4%BD%BF%E7%94%A8%E6%97%B6%E9%97%B4" tabindex="-1">Usability-2：基准使用时间</h5><ul><li>三个简化工具需要用户的额外努力来使用基准程序，我们认为这与创建规范无关的，将其单独提出来。<ul><li>Chisel和Chisel-GT在中高复杂度基准集中无法在48h内结束运行，这是其代码设计的问题。为了评估这些工具超出ChiselBench（即低复杂度基准集）的表现，我们与工具的开发者何坐，实现了一个并行化框架以提高性能，使其满足我们对合理运行时的标准（48h）。最后需要26h完成</li><li>LMCAS-SIFT引入了一个“程序颈”的概念，定义为程序的配置逻辑（即 命令行 或/和 配置文件解析代码）和主逻辑（程序的其余部分）之间的边界。 LMCAS-SIFT要求在简化前识别一个合适的“颈”，并为此提供了一个叫neck miner的工具，然而这个工具不总是成功识别颈，导致简化失败，此时用户必须手动识别。<ul><li>在我们的评估中，neck miner未能自动为gzip、mkdir、sort、tar和uniq放置颈，并且平均需要8分钟手动放置它。8min发生在低复杂度基准测试上。在更复杂的基准测试上手动放置颈部可能需要更多时间</li></ul></li></ul></li></ul><h5 id="performance-1%EF%BC%8C2%EF%BC%9A%E5%B7%A5%E5%85%B7%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%E5%92%8C%E5%B3%B0%E5%80%BC%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8" tabindex="-1">Performance-1，2：工具运行时间和峰值内存使用</h5><ul><li>在完成工具配置和手动调整基准集后，接下来测量工具在基准上测试时的性能。</li><li>我们在表5中总结了这些工具在每个复杂度级别的所有基准测试上的平均CPU运行时间（以分钟为单位）和峰值内存使用情况。<ul><li>请注意，我们在这些计算中包括了失败的去膨胀操作。我们仅排除那些与该工具不兼容的基准测试，原因可能是该工具不支持C++代码、多线程程序等。</li><li>表5中的第一组列显示了每个复杂度级别上每个工具的兼容基准测试数量，总共有10个低复杂度、6个中等复杂度和4个高复杂度的基准测试。</li><li>除明显的异常值（objdump）外，所有简化工具在平均20min内完成简化。</li><li>CHISEL和CHISEL-GT分别需要CPU小时和CPU天来运行，因为其方法设计原因。</li><li>在内存小号方面，简化工具通常需要与目标程序相当的内存，除了使用RAZOR简化高复杂度程序需要使用31GB外，所有其他工具峰值为6GB甚至更少<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(12)_5.png" alt></li></ul></li></ul><h5 id="usability-3%EF%BC%9A%E6%93%8D%E4%BD%9C%E5%91%98%E6%89%80%E9%9C%80%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86" tabindex="-1">Usability-3：操作员所需专业知识</h5><ul><li>配置工具，运行工具，调试基准集都需要不同的专业知识，我们根据以下三个定义定义该指标<ul><li><strong>Low</strong>：操作员不需要了解工具或软件的内部工作原理就可以有效地进行去膨胀。</li><li><strong>Medium</strong>：操作员需要了解软件的内部工作原理，但不需要了解工具就可以有效地进行去膨胀。</li><li><strong>High</strong>：操作员需要了解工具和目标软件的内部工作原理才能有效地进行去膨胀</li></ul></li><li>我们在表6中展示了评估结果<ul><li>SL简化工具需要的专业只是最少，因为其不需要规范</li><li>CBS简化工具需要低级的专业知识，因为用户只需要熟悉软件的运行方式，但由于技术限制（即，OCCAM需要枚举链接库的构建选项，LMCAS-SIFT可能需要手动放置“neck”），实际上只有TRIMMER需要低级别的专业知识。</li><li>B2B简化工具需要枚举测试用例，以确保在分析阶段使用的动态跟踪具有足够的覆盖范围，从而产生合适的简化文件，所以需要中等级别的专业知识</li><li>Chisel和Chisel-GT由于需要专业的测试用例和验证脚本，需要最高级别的专业知识<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(12)_6.png" alt></li></ul></li></ul><h5 id="usability-4%EF%BC%9A%E7%BB%B4%E6%8A%A4%E9%9A%BE%E5%BA%A6" tabindex="-1">Usability-4：维护难度</h5><ul><li>评估简化后的程序长期维护的影响，主要考虑更新后修改简化规范并重新运行简化工具的难度，同时也考虑简化后的程序本身是否可以维护（例如，直接将补丁用于简化后的版本），我们定义这个指标如下<ul><li><strong>Low</strong>：工具可以在每次构建时运行，对用户来说成本微乎其微（即编译时间）。</li><li><strong>Medium</strong>：工具对程序表示进行了永久性更改，可以在去膨胀后进行维护。</li><li><strong>High</strong>：工具可能需要重新配置，并且每次原始程序更改时都必须完全重新运行。</li></ul></li><li>结果在表6中<ul><li>SL简化工具具有低维护难度，因为其对用户可以完全透明，并在程序更新时轻松重新运行</li><li>CBS去膨胀工具同样易于维护，因为它们对编译器施加了影响，但由于可能需要对原始程序的更改进行工具重新配置，我们评估它们的维护难度为中等。</li><li>CHISEL和CHISEL-GT评为中等维护难度，因为它们产生的是简化的源代码输出，这些代码可以在简化后直接修补或更新。</li><li>B2B简化工具标记为高难度，因为当原始程序进行上游更改时，它们必须重新配置和重新运行。值得注意的是，B2B去膨胀工具主要用于与旧版二进制文件一起使用，因此它们的维护难度可能不是它们使用的主要缺点。</li></ul></li></ul><h4 id="4.2-%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD" tabindex="-1">4.2 程序性能</h4><ul><li>软件简化旨在再进，或者至少移除代码后不会对程序的性能产生负面影响。<strong>主要期望</strong>是简化后的程序再磁盘上和运行时内存都占用更少空间。如果简化的程序结构得到，其中不必要的代码经常被执行，那么简化后执行的更快是不切实际的。相反，简化操作可能降低运行时性能。</li><li>本节提供了四个性能指标，这些指标基于使用这些工具产生的简化二进制文件和库</li></ul><h5 id="performance-5%EF%BC%9A%E9%9D%99%E6%80%81%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%A4%A7%E5%B0%8F" tabindex="-1">Performance-5：静态二进制大小</h5><ul><li>我们记录了每个成功简化的二进制文件在磁盘上的大小，并将其与原始程序的二进制文件大小进行比较。<ul><li>由于LMCAS-SIFT和SL简化工具在实现上的差异，我们对计算进行了修改。</li><li>Libfilter生成了基准程序的链接库的新的精简版本；因此，我们将简化后的库的总大小与原始库进行比较。</li><li>由LMCAS-SIFT和Binary Reduce (Static)创建的简化程序都是静态链接的二进制文件。对于这些文件，我们将静态链接二进制文件的大小与原始二进制文件及其动态链接库的总大小进行比较。</li></ul></li><li>我们用百分比表示大小变化，低于100%即大小减小。我们计算了3个复杂度基准下二进制文件大小变化，如图7示,第一组列为成功简化的程序数量。BinRec-ToB无法成功地去膨胀任何基准程序，因此我们在评估中从这个和所有后续表格中排除了它。<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(12)_7.png" alt></li><li>上表揭示了一些有趣的结果<ul><li>在所有复杂性级别上，RAZOR和Libfilter产生的去膨胀二进制文件平均较大。因为RAZOR将程序的去膨胀版本缝合到原始二进制文件的新代码部分，并标记原始代码部分为非可执行，而不是真正删除它。同样，Libfilter将不可达函数重写为HLT指令，而不是删除它们</li><li>总体上，其他工具对低复杂度基准实现了大幅减少，但在高复杂性基准上效果差异明显。这与在高复杂性基准程序上的低成功率（只有10个工具中的3个成功处理了所有四个）相结合，表明这些工具可能过度拟合于低和中复杂性基准程序。</li></ul></li></ul><h5 id="performance-6%EF%BC%9A%E9%93%BE%E6%8E%A5%E5%BA%93%E6%95%B0%E9%87%8F" tabindex="-1">Performance-6：链接库数量</h5><ul><li>记录简化前后基准程序链接的外部库数量。<ul><li>我们在这次评估中排除了LMCAS-SIFT和SL去膨胀工具，因为它们直接操作库。我们的结果仅供参考，因为通过去膨胀消除库在很大程度上取决于规范。</li><li>Binary Reduce (Dynamic)、CHISEL和CHISEL-GT在中等和高复杂性基准程序中通常成功地消除了一个或多个库，基于其设计，这是合理的</li><li>然而在TRIMMER和OCCAM在简化后的程序中引入了新的库。引入的库通常是libc++、libgcc和libm，这可能是由于工具使用其自定义的LLVM编译器转换通道对程序进行的更改所导致的。这些库相当大且计算复杂。根据用户简化的目标（例如，最小化代码大小或可重用性），引入这样的新依赖可能会适得其反。</li></ul></li></ul><h5 id="performance-3%EF%BC%8C4%EF%BC%9A%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%E5%92%8C%E5%B3%B0%E5%80%BC%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8" tabindex="-1">Performance-3，4：程序运行时间和峰值内存使用</h5><ul><li><p>为每个基准程序创建测试套件，根据我们的规范（中等和激进）对保留的功能进行测试。这些测试套件旨在尽可能地进行严格和长时间的运行。</p></li><li><p>我们对每个基准程序的参考二进制文件以及每个成功简化的二进制文件运行这些测试套件，记录总运行时间（以CPU秒为单位）和峰值内存消耗（以MB为单位）。</p></li><li><p>在许多情况下，简化的程序由于崩溃，无限执行或运行时错误无法完成测试，我们排除了这些失败</p></li><li><p>我们计算运行时间和峰值内存的变化百分比，其中值低于100%表示减少。然后我们计算了每个复杂度级别的平均值，如图8所示。第一列显示了每个工具在每个复杂性级别上成功完成性能测试的去膨胀基准程序数量。注意到我们排除了CHISEL的3个中等复杂性和2个高复杂性基准程序，因为CHISEL在没有修改源代码的情况下“成功”处理了这些基准程序（大概是没跑出结果）。<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(12)_8.png" alt></p></li><li><p>我们的评估揭示了一些重要的发现：</p><ul><li>对于中高复杂度的基准程序，所有的简化工具失败率都很高。总体上，简化的成功率只有22%，这对用于实际软件的简化技术提出了疑问</li><li>对于低复杂度的基准程序成功率也低于预期，尽管CHISELBench在文献中被广泛使用，但只有OCCAM和RAZOR成功地简化了所有的低复杂性基准程序。相反，BinRecToB和Binary Reduce (Dynamic)没有成功简化任何低复杂性基准程序。</li></ul></li><li><p>关于我们的性能指标，我们观察到只有少数简化的程序的性能明显差于其未修改的对应程序。</p><ul><li>除了CHISEL的一个异常值外，只有TRIMMER和OCCAM在多个复杂性级别上都显示出了一致且显著的（&gt;4%）对运行时间或内存消耗的负面影响。</li><li>其中最显著的是TRIMMER简化高复杂性基准程序运行时间增加了29.4%，以及OCCAM简化的低复杂性基准程序运行时间增加了18.3%。</li></ul></li></ul><h4 id="4.3-%E7%A8%8B%E5%BA%8F%E5%AE%89%E5%85%A8" tabindex="-1">4.3 程序安全</h4><ul><li>除性能改进外，简化文献经常提及程序安全的改进（如攻击面的减少）作为一个主要激励目标。然而攻击面减少的具体定义有很大的差异，并缺乏合理有效的标准来度量。鉴于其它常用度量标准的缺陷（如消除已知的漏洞），我们采用了四个度量指标，重点关注code re-usability prevention（代码重用预防）。</li><li>我们使用GSA[12]来分析我们简化二进制文件及未修改的对应部分，计算我们的度量指标，这些指标反映了在 W⊕X 和 ASLR 等常见安全控制存在的情况下，攻击者可以如何轻易地重复使用程序及其链接库中的代码来制造漏洞。</li><li>在没有事先知道程序中实际存在的漏洞的情况下，这些度量标准为简化的卫全好处提供了定性评估。</li></ul><h5 id="security-1%EF%BC%8C2-%E5%B0%8F%E5%B7%A5%E5%85%B7%E9%9B%86%E7%9A%84%E8%A1%A8%E8%BE%BE%E8%83%BD%E5%8A%9B%E5%92%8C%E8%B4%A8%E9%87%8F" tabindex="-1">Security-1，2 小工具集的表达能力和质量</h5><ul><li><p>前两个度量标准关注于程序二进制文件中可用的功能代码重用小工具的集合属性。攻击者会像在编程语言中的指令那样，将功能代码重用小工具链接在一起，以编写并启动一个攻击，而无需注入代码。</p></li><li><p><strong>小工具集表达能力</strong>：度量了二进制文件中功能小工具的集体表达能力，以确定它们是否足以启动实用的攻击。</p><ul><li>GSA 定义了 11 种不同的功能类别，小工具集中的小工具必须满足这些类别才能达到这一标准，并以满足类别的数量来报告表达能力</li></ul></li><li><p><strong>小工具集质量</strong>：度量了集合中小工具的平均链式能力，以确定它们可以多么容易地组合。</p><ul><li>对于攻击者有用的小工具，它们通常包含对其目的无关的机器指令，但可能对创建小工具链产生副约束（即，改变堆栈指针）。</li><li>GSA通过使用0.0的起始分数并为每个检测到的副约束增加这个分数来度量每个小工具的质量。整体集质量是计算为所有小工具的平均分数。</li></ul></li><li><p>对于这两个度量标准，GSA将简化的二进制文件与原始文件进行比较，并报告值变化。</p><ul><li>对于LMCAS-SIFT和SL，我们在比较中包括了库</li><li>表达性的负值表示负面结果：简化二进制文件中的小工具集满足的表达性类别比原始文件更多。</li><li>对于小工具集的质量，则相反<ul><li>正值表示去膨胀后，每个小工具的平均副约束数量减少了。</li><li>但是，值在任何方向上小于0.5都不足以表示显著性，因为GSA的质量评分系统将次要的副约束值设为0.5，而将主要的副约束值设为3.0。</li><li>我们对GSA报告的度量标准进行了平均处理，显示在表9中。第一组列显示了每个工具在每个复杂性级别上成功去膨胀的基准数量<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(12)_9.png" alt></li></ul></li></ul></li><li><p>总体而言，根据这两个度量标准，我们评估的简化工具对安全性<strong>没有产生显著影响</strong></p><ul><li>多数情况下，我们的数据表明，某些工具和复杂性级别的表现性和链式能力都有所提高</li><li>只有TRIMMER在四个高复杂性基准测试上的表现显著不好，平均提高了3.5个表达性类别</li></ul></li></ul><h5 id="security-3-%E5%B0%8F%E5%B7%A5%E5%85%B7%E9%9B%86%E5%B1%80%E9%83%A8%E6%80%A7" tabindex="-1">Security-3 小工具集局部性</h5><h5 id="security-4-%E5%8F%AF%E4%BE%9B%E9%80%89%E6%8B%A9%E7%9A%84%E7%89%B9%E6%AE%8A%E7%94%A8%E9%80%94%E5%B0%8F%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B" tabindex="-1">Security-4 可供选择的特殊用途小工具类型</h5><p><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(12)_10.png" alt></p><h4 id="4.4-%E6%AD%A3%E7%A1%AE%E6%80%A7%E5%92%8C%E9%B2%81%E6%A3%92%E6%80%A7" tabindex="-1">4.4 正确性和鲁棒性</h4><h5 id="correctness%2Frobustness-1-executes-retained-functions" tabindex="-1">Correctness/Robustness-1 Executes Retained Functions</h5><h5 id="correctness%2Frobustness-2-errors-%2F-crashes-during-differential-testing" tabindex="-1">Correctness/Robustness-2 Errors / Crashes during Differential Testing</h5><ul><li><p>简化转换是复杂的，确保转换不损害程序健壮性是具有挑战性的，无论是在生产前（即，S2S）、生产过程中（即，CBS）还是生产后（即，B2B、SL）实施的。</p></li><li><p>有缺陷或不完整的转换会对程序产生负面影响，表现为辑错误、运行时错误、崩溃，有时还可能引入新的漏洞。</p><ul><li>我们在基准性能测试（第4.2节）中，我们发现了大量的证据，其中36.6%的在我们的评估中生成的去膨胀二进制文件未能执行其保留的功能。</li></ul></li><li><p>这突显了简化后验证的重要性，这是简化工作流程中经常被忽视或完全留给用户的一个阶段，尤其是针对Type II膨胀的工具。</p><ul><li>一定程度上是由于缺乏有效的测试工具，如回归测试和模糊测试，并不自然地支持测试去膨胀程序与其原始版本之间的差异</li><li>为此，我们创建了一个针对转换后程序的差异测试工具，名为DIFFER，该工具结合了差异、回归和模糊测试方法的元素。</li></ul></li><li><p>DIFFER 允许用户指定与保留和简化功能对应的种子输入。它使用这些输入运行原始程序及其一个或多个简化变体，并比较它们的输出。</p><ul><li>DIFFER 期望对于保留功能的输入，原始程序和去膨胀程序的输出应该相同。</li><li>相反，它期望对于去膨胀功能的输入，原始程序和去膨胀程序的输出应该不同。</li><li>如果 DIFFER 检测到意外的匹配、差异或崩溃，它会向用户报告，供其检查。DIFFER 的报告可以帮助用户识别去膨胀工具配置中的错误或去膨胀程序不健全的实例。与所有动态分析工具一样，DIFFER 的报告可能存在误报的可能性。为了将误报率降到最低，DIFFER 允许用户定义自定义输出比较器，以考虑输出中的预期差异（例如，程序会为其控制台输出添加时间戳）。</li><li>此外，DIFFER 支持基于模板的变异模糊测试种子输入，以确保对去膨胀和保留功能的输入空间进行最大覆盖。</li><li>DIFFER 不能为去膨胀工具或其生成的去膨胀程序提供正式的健壮性保证。且不能对复杂程序的输入空间进行详细测试，但在验证中非常有用，因为其对用户友好，只需要适中的用户专业知识</li></ul></li><li><p>使用我们在第3.3节中创建的通用简化规范作为起点，我们配置了 DIFFER 来测试每个基准程序的保留和简化掉的功能。我们对成功完成性能测试的每个简化基准程序（共90个变体）运行了 DIFFER，最长达12小时，以识别简化过程中引入的崩溃、不一致性或错误，以及未能去除应该去除的功能。我们的<strong>结果令人担忧</strong>：</p><ul><li>DIFFER 发现了27.8%（90个中的25个）的简化基准中存在错误或崩溃</li><li>简化工具在其余的简化基准中未能去除应该简化掉的的功能，占60%（65个中的39个）。</li><li>在 DIFFER 的测试中通过的最终26个去膨胀基准中，有13个是由 Binary Reduce（静态）产生的，七个是由 libfilter 产生的，四个是由 LMCAS-SIFT 产生的，而 OCCAM 和 CHISEL 各自产生了一个。</li></ul></li><li><p>我们的评估中，50%（40个中的20个）的去除 Type I 膨胀尝试最终成功，而只有3.3%的去除 Type II 膨胀尝试成功（180个中的6个）。我们的结果表明，文献中对简化后验证的普遍忽视导致了对成功简化的过度报告。</p></li></ul><h3 id="5-%E8%AE%A8%E8%AE%BA%E5%92%8C%E5%85%B3%E9%94%AE%E5%8F%91%E7%8E%B0" tabindex="-1">5 讨论和关键发现</h3><ul><li><strong>工具成熟度</strong><ul><li>简化工具缺乏在实际软件上所需的成熟度<ul><li>所有工具在所有基准简化后上只有42.5%的成功率通过性能测试</li><li>在中高复杂基准上只有21%的成功率</li></ul></li><li>这表明当前的简化工具可能过于适应较低复杂性的基准，之后新的方法应该重点关注更复杂的软件和编程语言特性/范式</li></ul></li><li><strong>Soundness Issues</strong><ul><li>使用DIFFER进行正确性和健壮性测试时，在我们评估的十个工具中，只有两个工具，即静态和动态的简化二进制，没有产生不健全的简化二进制文件（即，DIFFER没有检测到任何崩溃、失败或在保留功能中的错误）。然而，之所以是健全的，是因为该工具没有成功地去膨胀任何功能，这得到了这个二进制文件在去膨胀后增加了大小的事实的支持。</li><li>其余的工具每个都产生了比原始程序更多的错误（除了BinRec-ToB，它没有产生任何去膨胀的二进制文件）</li><li>虽然我们的性能测试和DIFFER检测到的大部分健全性问题都是与保留功能有关的问题，但我们的结果还揭示了与简化功能相关的严重程序健全性问题。新的方法必须发展起来，以缝合被切除代码留下的空洞。在我们的调查中，我们只观察到一个具有此能力的工具：CARVE[11]</li></ul></li><li><strong>边际效益和安全收益</strong><ul><li>我们评估的所有工具都没有在除了小工具局部性外的性能或安全性上实现改进</li><li>一些工具确实缩小了静态二进制大小，但这些改进是通过激进的简化和去除静态链接实现的，这限制了缩小的实用性</li><li>考虑到上述成熟度和Soundness问题，我们认为用户可能会发现简化的好处没有超过成本和潜在风险</li></ul></li></ul><h3 id="6-%E7%BB%93%E8%AE%BA" tabindex="-1">6 结论</h3><ul><li>本文中，我们对软件简化生态进行了调查，在调查中我们创建了<ul><li>一个简化工具分类方法</li><li>16个评估指标</li><li>包含20个不同复杂性的基准程序</li></ul></li><li>我们评估比较了4类中10个不同的工具，评估标明<ul><li>当前一代简化工具存在缺陷，使之不能再实际软件上应用，具体来说<ul><li>简化工具对于中高复杂度的程序支持有限</li><li>简化过程中难以维系健全性和健壮性</li><li>在提高程序的性能和安全上成果有限</li></ul></li></ul></li><li>我们已经公开了我们的基准集，数据和自定义工具，以推动简化工具的进一步发展</li></ul><h3 id="7-availability" tabindex="-1">7 availability</h3><p><a href="https://github.com/trailofbits/debloater-eval">评估</a><br><a href="https://github.com/trailofbits/differ">Differ工具</a></p><h3 id="8-%E4%BB%93%E5%BA%93%E5%AD%A6%E4%B9%A0" tabindex="-1">8 仓库学习</h3><p><a href="https://github.com/trailofbits/debloater-eval">仓库地址</a></p><h4 id="%E7%9B%AE%E5%BD%95%E5%88%86%E6%9E%90" tabindex="-1">目录分析</h4><h5 id="benchmarks" tabindex="-1">benchmarks</h5><p>benchmarks：包含基准程序和基准工具（包括人工改造版本）</p><ul><li>benchmarks-debloated:基准工具（因为每个基准程序能用到的基准工具不同，所以按照基准程序分的文件夹,具体在result的表格中可以看到针对特定基准软件哪些工具无法使用）<ul><li>high</li><li>low</li><li>medium</li></ul></li><li>benchmarks:基准程序<ul><li>high<ul><li>imagemagick-7.0.1-0</li><li>nginx-1.23.3</li><li>nmap-7.93</li><li>poppler-0.60</li></ul></li><li>low：就是chiselbench中的10个util-core程序，指举一个例子<ul><li>bzip2-1.0.5<ul><li>binaries:包含其各个形式的二进制文件</li><li>lmcas，occam_x64_bin,trimmer_x64_bin:针对各个工具的特殊二进制</li><li>source：源代码<ul><li>merged：将源代码项目合成一个文件</li><li>original：原始源代码项目</li></ul></li></ul></li></ul></li><li>medium<ul><li>bftpd-6.1</li><li>binutils-2.27</li><li>lighttpd-1.4</li><li>make-4.2</li><li>memcached-1.6.18</li><li>tcpdump-4.99.3</li><li>wget-1.20.3</li></ul></li></ul></li></ul><h5 id="metrics" tabindex="-1">metrics</h5><p>metrics: 包括评估脚本（基准程序需要跑得）和评估性能指标</p><ul><li>performance-test<ul><li>original：这个目录包含在原始基准测试上运行性能测试并收集指标的文件。指标将保存到 binary_metrics.csv 中。 有README<ul><li>Dockerfile:镜像构造</li><li>run_perf_tests.py 自动化测试脚本（TODO分析）</li></ul></li><li>performance-benchmarks：基准使用的脚本，包含不同场景。 有README<ul><li>inputs 文件夹：包含各个软件的测试用例输入</li><li>lib 文件夹：包含各个软件的功能各个场景脚本，每个脚本名字即<code>基准名字.sh</code>，一个场景即脚本中的一个函数</li><li>剩余脚本为测试脚本，名字为<code>benchmark_&lt;基准名字&gt;.sh</code>,大多数脚本需要一个参数，即二进制文件路径，少部分脚本需要其他参数，可以使用<code>-h</code>查看详情<ul><li>测试脚本还包括激进版本，即<code>benchmark_aggressive_&lt;基准名字&gt;.sh</code>，即只包含单个功能</li></ul></li></ul></li></ul></li></ul><h5 id="results" tabindex="-1">results</h5><p>results：包含原始和精简的评估结果以及创建它们的脚本。</p><ul><li><p>Debloater Eval Results.xlsx : 包括所有评测结果的表格</p></li><li><p>Debloater Evaluation Knowledge Base.xlsx : 包含作者科研的知识步骤</p></li><li><p>metrics-calcs：包含与简化评估相关的脚本和数据，包括 GSA，DIFFER，Dynamic libraries and File Size</p><ul><li>scripts:用于运行实验和评估结果的通用Python脚本。</li><li>results<ul><li>gsa：包含GSA评估的结果</li><li>differ：包含DIFFER评估的结果</li><li>file-stats:动态连接库和文件大小的结果</li></ul></li><li>batches：只能每个批次运行的配置文件</li><li>eval-scripts：包含特定实验运行的脚本</li><li>environment：包含配置实验环境的脚本和dockerfile</li></ul></li><li><p>differ实验结果</p></li></ul><h5 id="scripts" tabindex="-1">scripts</h5><p>scripts：包含用于自动化评估不同部分的各种脚本（未维护）。</p><ul><li>build-binaries：包含用于构建二进制文件的脚本，使用py脚本，在docker中进行构建</li><li>debloater_eval:收集评估结果的脚本，输出为csv</li><li>tests：TODO了解</li></ul><h5 id="tools" tabindex="-1">tools</h5><p>tools：包括可重复构建的环境，用于托管工具和评估中使用的简化规范。</p><ul><li><ol><li>GTIRB To Static：用于静态地剪裁掉不可达的库和代码，利用了&quot;Reachable Reduce&quot;。</li></ol></li><li><ol start="2"><li>LMCAS-METIS：使用一个规范（spec）以及对源代码的修改来对其进行简化。</li></ol></li><li><ol start="3"><li>OCCAM：根据其 GitHub 描述，这是一个针对 LLVM 位代码的“整体程序偏特化器（whole-program partial evaluator）”，旨在对在特定部署环境中运行的程序和共享/静态库进行简化。</li></ol></li><li><ol start="4"><li>Trimmer</li></ol></li><li><ol start="5"><li>chisel-2：需要token</li></ol></li><li><ol start="6"><li>chisel：源代码简化工具，它使用一个 oracle 来引导基于增量调试的减小过程。</li></ol></li><li><ol start="7"><li>GTIRB To Dynamic：使用 gtirb-block-trace。</li></ol></li><li><ol start="8"><li>Libfilter(Nibbler):采用静态分析来检测程序及其共享库中未使用的函数调用。随后，它删除这些未使用的函数，生成一个精简的二进制文件。</li></ol></li><li><ol start="9"><li>razor：用DynamoRIO对二进制文件进行插装，从而删除测试套件未执行的指令。</li></ol></li><li><p>tool-debloating-specs：包含已经写好的规范</p></li></ul><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;sok%3A-a-broad-comparative-evaluation-of-software-debloating-tools&quot; tabindex=&quot;-1&quot;&gt;SoK: A Broad Comparative Evaluation of Software De</summary>
      
    
    
    
    <category term="论文" scheme="http://example.com/categories/%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="SoftwareEngineering" scheme="http://example.com/tags/SoftwareEngineering/"/>
    
    <category term="SoftwareDebloating" scheme="http://example.com/tags/SoftwareDebloating/"/>
    
  </entry>
  
  <entry>
    <title>复杂软件简化分析实验</title>
    <link href="http://example.com/2024/02/04/%E6%9C%AC%E7%A7%91/%E6%9C%AC%E7%A7%91%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E5%A4%8D%E6%9D%82%E8%BD%AF%E4%BB%B6%E7%AE%80%E5%8C%96%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C/"/>
    <id>http://example.com/2024/02/04/%E6%9C%AC%E7%A7%91/%E6%9C%AC%E7%A7%91%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E5%A4%8D%E6%9D%82%E8%BD%AF%E4%BB%B6%E7%AE%80%E5%8C%96%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C/</id>
    <published>2024-02-04T08:13:57.502Z</published>
    <updated>2024-02-04T08:13:57.502Z</updated>
    
    <content type="html"><![CDATA[<p>实验按照对每个工具运行每个基准</p><h2 id="razor" tabindex="-1">RAZOR</h2><ol><li>获取镜像<code>sudo docker pull chenxiong/razor:0.01</code></li><li>运行镜像<code>sudo docker run --name container_name -d -it chenxiong/razor:0.01</code></li><li>更新razor仓库</li><li>替换debian源为阿里源<code>sudo vim /etc/apt/sources.list</code></li></ol><pre><code class="language-bash">deb http://mirrors.aliyun.com/debian/ buster main non-free contribdeb http://mirrors.aliyun.com/debian/ buster-updates main non-free contribdeb http://mirrors.aliyun.com/debian/ buster-backports main non-free contribdeb http://mirrors.aliyun.com/debian-security buster/updates maindeb-src http://mirrors.aliyun.com/debian/ buster main non-free contribdeb-src http://mirrors.aliyun.com/debian/ buster-updates main non-free contribdeb-src http://mirrors.aliyun.com/debian/ buster-backports main non-free contribdeb-src http://mirrors.aliyun.com/debian-security buster/updates main</code></pre><ol start="5"><li>下载Clang <code>apt install clang</code></li></ol><h3 id="nginx" tabindex="-1">nginx</h3><h3 id="lighttpd" tabindex="-1">lighttpd</h3><p><a href="https://redmine.lighttpd.net/projects/lighttpd/wiki/InstallFromSource">从源码编译步骤</a></p><ol><li>克隆并更新仓库</li></ol><pre><code class="language-bash"># initial checkoutgit clone https://git.lighttpd.net/lighttpd/lighttpd1.4.gitcd lighttpd1.4# subsequent updates (to obtain latest source)#cd lighttpd1.4git pull</code></pre><ol start="2"><li>更新依赖 <code>apt-get build-dep lighttpd</code></li><li>automake</li></ol><pre><code class="language-bash">#cd lighttpd1.4./autogen.shCC=clang ./configure -C --prefix=/usr/local  # ./configure --help for additional optionsmake -j 4make check</code></pre><ol start="4"><li>出现问题</li></ol><pre><code class="language-bash">configure: error: pcre2-config not found, install the pcre2-devel package or build with --without-pcre2</code></pre><p>解决方法：<code>apt install libpcre2-dev</code></p><ol start="5"><li>编译完成后，在<code>src</code>目录下生成<code>lighttpd</code>可执行文件</li><li>结合<code>razor</code>运行</li></ol><h3 id="nmap" tabindex="-1">nmap</h3><ol><li><a href="https://nmap.org/dist/">下载位置</a></li><li><a href="https://nmap.org/book/inst-source.html">按照指导编译</a></li><li>使用clang编译</li></ol><pre><code class="language-bash">CC=clang CXX=clang++ ./configuremake</code></pre><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;实验按照对每个工具运行每个基准&lt;/p&gt;
&lt;h2 id=&quot;razor&quot; tabindex=&quot;-1&quot;&gt;RAZOR&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;获取镜像&lt;code&gt;sudo docker pull chenxiong/razor:0.01&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;运行镜像</summary>
      
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="SoftwareEngineering" scheme="http://example.com/tags/SoftwareEngineering/"/>
    
    <category term="SoftwareDebloating" scheme="http://example.com/tags/SoftwareDebloating/"/>
    
  </entry>
  
</feed>

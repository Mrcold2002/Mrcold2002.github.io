<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-02-15T13:17:00.554Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>程序中不变量论文阅读</title>
    <link href="http://example.com/2024/02/04/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E7%A8%8B%E5%BA%8F%E4%B8%AD%E4%B8%8D%E5%8F%98%E9%87%8F%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>http://example.com/2024/02/04/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E7%A8%8B%E5%BA%8F%E4%B8%AD%E4%B8%8D%E5%8F%98%E9%87%8F%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</id>
    <published>2024-02-04T08:15:04.770Z</published>
    <updated>2024-02-15T13:17:00.554Z</updated>
    
    <content type="html"><![CDATA[<h2 id="invariant-based-program-repair" tabindex="-1">Invariant-based Program Repair</h2><p>Al-Bataineh O I. Invariant-based Program Repair[J]. arXiv preprint arXiv:2312.16652, 2023.</p><h3 id="0-%E6%91%98%E8%A6%81" tabindex="-1">0 摘要</h3><ul><li><p>本论文描述了一种 基于程序中ivariants概念的正式通用的自动化程序修复框架。</p></li><li><p>在上述框架中，动态分析缺陷程序的运行踪迹，推断出特征 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mrow><mi>c</mi><mi>o</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>c</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\varphi_{correct}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">correc</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 和 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mrow><mi>v</mi><mi>i</mi><mi>o</mi><mi>l</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\varphi_{violated}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>，其中 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mrow><mi>c</mi><mi>o</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>c</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\varphi_{correct}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">correc</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 表示可能不变量（良好模式）的集合，这些不变量是运行成功所需的，而 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mrow><mi>v</mi><mi>i</mi><mi>o</mi><mi>l</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\varphi_{violated}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 表示可能可疑不变量（错误模式），导致瑕疵程序中的错误。</p></li><li><p>随后，利用严格的程序分析技术来对这些规范进行精炼，这些技术还可以引导修复过程生成可用补丁，随后评估这些补丁的正确性</p></li><li><p>通过开发一种基于invariants的高校修复bug的修复系统，我们展示了使用invariants在APR中的实用性</p></li><li><p>初步分析证明，基于不变量的APR在处理bug的性能方面是有效的，能够生成 确保程序效率提升且不对其功能产生不利影响的补丁</p></li><li><p><strong>KeyWord</strong>：</p><ul><li>Automated program repair</li><li>Invariant learning and refinement</li><li>Patch overfitting</li><li>Program verifier</li><li>CPAChecker</li><li>Performance bug</li></ul></li></ul><h3 id="1-%E4%BB%8B%E7%BB%8D" tabindex="-1">1 介绍</h3><ul><li>Automated program repair (APR) 最近引起了很大的关注，其通过自动生成 瑕疵程序的补丁来显著减少手动调试工作。 现代化的修复工具已经被证明在修复许多实际程序中的错误方面是有效的.然而自动生成的补丁质量不佳[11]，仍然是软件从业者采用自动化程序修复的主要障碍</li></ul><h4 id="%E9%97%AE%E9%A2%98" tabindex="-1">问题</h4><p>当前APR工具自动生成的补丁质量较低的主要原因是缺乏预期行为的规范。大多数程序修复系统依赖于测试行为作为正确性标准，因为软件开发者没有明确提供正式规范。因此，当前的APR方法产生的补丁可能是合理的，但仍然在部署前进行手动检查。因此，目前无法保证生成的补丁通常是正确的，并且不会引入新的错误。</p><h4 id="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95" tabindex="-1">解决方法</h4><ul><li>程序验证技术使开发人员能够在部署之前证明程序的正确性。<ul><li>支持这项技术的关键之一是推断程序invarant,一个作为程序的抽象规范的逻辑表示。开发人员可以通过程序不变量显著受益，以确定修改代码必须要保留的程序属性。</li><li>不幸的是，这些invariants通常在代码中确实，导致了不严格的APR方法（如动态APR）占据主导地位；以及众所周知的补丁过拟合问题</li></ul></li><li>我们认为，通过使用测试用例和基于可达性的分析技术，可以获得准确的invarants集合，用于生成高质量的补丁，即 CPAChecker<br>[3] and PathFinder [15]之类的程序验证工具可用于优化生成invariants的过程<ul><li>首先，我们使用测试用例来分析程序的运行轨迹推断invariant集合，随后，使用程序验证器对这些候选就行优化以获得更准确的invariants。目标是推断出两个规范<ul><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mrow><mi>c</mi><mi>o</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>c</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\varphi_{correct}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">correc</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 表示成功运行需要的良好模式集合</li><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mrow><mi>v</mi><mi>i</mi><mi>o</mi><mi>l</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\varphi_{violated}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 表示导致目标错误的不良模式集合</li></ul></li></ul></li><li>基于invariant的APR提供了两个关键优点<ul><li><ol><li>将APR导向潜在可行的补丁</li></ol></li><li><ol start="2"><li>使得可以使用程序验证器对合理的补丁惊醒正式验证</li></ol></li></ul></li></ul><h4 id="viability-of-invariant-based-apr-%E5%8F%AF%E8%A1%8C%E6%80%A7%E5%88%86%E6%9E%90" tabindex="-1">Viability of Invariant-based APR 可行性分析</h4><ul><li>程序invariant在多个应用中展现了效率，如程序理解，错误定位和形式验证。</li><li>invariant之所以高效，是因为功能正确性与程序的最终结构相关，而不是特定的实现。 因此，他们可以帮助抽象出许多具体的执行步骤，从而极大的减少了理解补丁正确性所需的工作量。<ul><li>事实上，那些尝试修复一个没有形式规范的错误没有文档的程序（即未经过深思编写的程序）的开发人员可以发现，基于不变量的APR对他们的修复工作很有帮助。</li></ul></li><li>成熟的自动不变量检测工具如Daikon[4]和实用的软件验证工具如CPAChecker和PathFinder的可用性使基于不变量的程序修复技术成为可能。</li><li>乍一看，使用软件验证工具来优化不变量似乎成本太高，然而由于软件验证的巨大进步[2]，实际上，基于invariant的验证变得非常高效。<ul><li>特别是，软件分析框架CPAChecker，支持多种可达性分析，已经被有效地用于验证多达50k行的C程序的各种可达性查询。这使得可达性分析成为一种有前途的技术，可以用来显著减少补丁的过拟合问题并产生高质量补丁</li></ul></li></ul><h3 id="2-%E5%9F%BA%E4%BA%8Einvariant%E7%9A%84apr%E6%A1%86%E6%9E%B6" tabindex="-1">2 基于invariant的APR框架</h3><ul><li>本节将使用程序invariant的概念重新阐释APR问题。</li><li>然后，我们描述了如何分析无故障运行的执行跟踪，推断出程序预期行为的可能规范，以及分析有故障运行的执行跟踪，推断出可能导致故障行为的可疑不变量。再进一步进行前，然我们介绍一些定义</li></ul><h4 id="definition-1-%EF%BC%88fault-free-vs-fault-runs%EF%BC%89" tabindex="-1">Definition 1 （fault-free vs fault runs）</h4><ul><li>令 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></eq> 为一个bug程序，<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span></eq> 是 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></eq> 的运行集合，<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mrow><mi>b</mi><mi>e</mi><mi>h</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\varphi_{beh}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 是程序P的预期行为属性。 我们定义一个运行 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>∈</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">r\in R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span></eq> 是一个成功的运行（i.e. <strong>fault-free run</strong>）当 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>φ</mi><mrow><mi>b</mi><mi>e</mi><mi>h</mi></mrow></msub></mrow><annotation encoding="application/x-tex">P(r)=\varphi_{beh}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> ,否则，<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>∈</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">r \in R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span></eq> 是一个失败的运行（i.e. <strong>fault run</strong>）,当 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mo mathvariant="normal">≠</mo><msub><mi>φ</mi><mrow><mi>b</mi><mi>e</mi><mi>h</mi></mrow></msub></mrow><annotation encoding="application/x-tex">P(r)\neq \varphi_{beh}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq></li></ul><p>根据定义1我们可以注意到，通过分析从无故障运行中提取的信息，可以推断出程序预期行为的行为规范。 类似的，通过分析故障运行中的执行信息，可以推断出导致错误的错误invariant。 这是因为无故障运行表示保持程序invariant的运行，而有故障的运行表示违反某些程序invariant的运行。</p><h4 id="definition-2-%EF%BC%88invariant-based-apr-problem%EF%BC%89" tabindex="-1">Definition 2 （Invariant-based APR problem）</h4><ul><li><p>令 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></eq> 为一个包含bug <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span></eq> 的程序 并且 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>T</mi><mi>P</mi></msub><mo>∪</mo><msub><mi>T</mi><mi>F</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T=(T_P \cup T_F)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq> 为一个测试套件，<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>P</mi></msub></mrow><annotation encoding="application/x-tex">T_P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>表示通过的测试而 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>F</mi></msub></mrow><annotation encoding="application/x-tex">T_F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>表示失败的测试。 令 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span></eq> 表示动态invariant推断工具如Daikon，<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></eq> 表示程序验证工具如CPAChcker，基于invariant的APR过程包含以下步骤：</p><ul><li><ol><li><strong>Invariant 提取</strong>：使用 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span></eq> 生成程序 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></eq> 的初始invariant集合 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">I</mi></mrow><annotation encoding="application/x-tex">\mathcal{I}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.07382em;">I</span></span></span></span></eq></li></ol></li><li><ol start="2"><li><strong>Invariant 精炼</strong>:使用 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></eq> 精炼集合 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">I</mi></mrow><annotation encoding="application/x-tex">\mathcal{I}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.07382em;">I</span></span></span></span></eq> 产生规范 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mrow><mi>c</mi><mi>o</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>c</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\varphi_{correct}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">correc</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 和 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mrow><mi>v</mi><mi>i</mi><mi>o</mi><mi>l</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\varphi_{violated}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>。 这可以通过在程序感兴趣的位置断言不变量，并使用任何生成的反例来对其进行精炼来完成。</li></ol></li><li><ol start="3"><li><strong>错误定位</strong>：通过分析 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mrow><mi>c</mi><mi>o</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>c</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\varphi_{correct}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">correc</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 和 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mrow><mi>v</mi><mi>i</mi><mi>o</mi><mi>l</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\varphi_{violated}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>,计算可能产生有效补丁的可疑语句列表</li></ol></li><li><ol start="4"><li><strong>补丁生成</strong>：构造代码，纠正错误的不变量，同时保持程序其它的不变量，通过使用类似搜索或基于语义的补丁生成过程来执行</li></ol></li><li><ol start="5"><li><strong>补丁验证</strong>：使用 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></eq> 验证生成的补丁的正确性</li></ol></li></ul></li><li><p>根据正在修复的bug类型和分析程序的结构，不同的程序位置可能与属性 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mrow><mi>c</mi><mi>o</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>c</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\varphi_{correct}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">correc</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 和 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mrow><mi>v</mi><mi>i</mi><mi>o</mi><mi>l</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\varphi_{violated}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 相关联。 示例包括不同函数的前置条件和后置条件，或者某些程序的循环不变量。 需要注意，根据定义2描述的基于不变量的APR过程的前两个步骤对于增加生成的补丁精度是必要的，该过程的实际修复步骤，即3-5步，可以正式陈述如下：</p><ul><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>t</mi><mo>=</mo><mi>F</mi><mi>V</mi><mo stretchy="false">(</mo><mi>P</mi><mi>G</mi><mi>V</mi><mo stretchy="false">(</mo><mi>F</mi><mi>L</mi><mo stretchy="false">(</mo><msub><mi>φ</mi><mrow><mi>c</mi><mi>o</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>c</mi><mi>t</mi></mrow></msub><mo separator="true">,</mo><msub><mi>φ</mi><mrow><mi>v</mi><mi>i</mi><mi>o</mi><mi>l</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi></mrow></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>T</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mi>φ</mi><mrow><mi>c</mi><mi>o</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>c</mi><mi>t</mi></mrow></msub><mo separator="true">,</mo><msub><mi>φ</mi><mrow><mi>v</mi><mi>i</mi><mi>o</mi><mi>l</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">pt = FV(PGV(FL(\varphi_{correct},\varphi_{violated}),T),\varphi_{correct},\varphi_{violated})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">pt</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathnormal">PG</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">correc</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">correc</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq></li><li>上式中，<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>L</mi></mrow><annotation encoding="application/x-tex">FL</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">L</span></span></span></span></eq> 是基于不变量的错误定位，</li><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mi>G</mi><mi>V</mi></mrow><annotation encoding="application/x-tex">PGV</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">PG</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></eq> 是使用测试套件进行补丁生成和验证过程</li><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>V</mi></mrow><annotation encoding="application/x-tex">FV</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></eq> 表示使用验证工具V进行正式补丁验证的过程。<ul><li>如果未找到合理的补丁，或者找到的补丁是不正确的，则修复过程返回失败。</li><li>如果合理的补丁通过了工具V执行的验证步骤，该过程将返回一个补丁</li></ul></li></ul></li><li><p>接下来讨论如何通过分析使用通过和失败的测试运行程序P产生规范 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mrow><mi>c</mi><mi>o</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>c</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\varphi_{correct}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">correc</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 和 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mrow><mi>v</mi><mi>i</mi><mi>o</mi><mi>l</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\varphi_{violated}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>，对无故障和有故障运行的分析产生了以下模式</p><ul><li><ol><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mrow><mi>c</mi><mi>o</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>c</mi><mi>t</mi></mrow></msub><mo>=</mo><msub><mi mathvariant="script">I</mi><mrow><mi>g</mi><mi>o</mi><mi>o</mi><mi>d</mi></mrow></msub><mo>=</mo><mi>V</mi><mo stretchy="false">(</mo><mi>D</mi><mo stretchy="false">(</mo><mi>P</mi><mo separator="true">,</mo><msub><mi>T</mi><mi>P</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\varphi_{correct} = \mathcal{I}_{good}=V(D(P,T_P))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">correc</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="mord mathnormal mtight">oo</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">))</span></span></span></span></eq>,只是用成功运行推断不变量，这些不变量表示程序 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></eq> 的预期行为</li></ol></li><li><ol start="2"><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mrow><mi>f</mi><mi>a</mi><mi>u</mi><mi>l</mi><mi>t</mi><mi>y</mi></mrow></msub><mo>=</mo><msub><mi mathvariant="script">I</mi><mrow><mi>m</mi><mi>i</mi><mi>x</mi></mrow></msub><mo>=</mo><mi>V</mi><mo stretchy="false">(</mo><mi>D</mi><mo stretchy="false">(</mo><mi>P</mi><mo separator="true">,</mo><msub><mi>T</mi><mi>F</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\varphi_{faulty} = \mathcal{I}_{mix}=V(D(P,T_F))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">lt</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">mi</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">))</span></span></span></span></eq>,使用失败运行推断不变量，注意到 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">I</mi><mrow><mi>m</mi><mi>i</mi><mi>x</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\mathcal{I}_{mix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">mi</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 可能同时包含好的和坏的模式，这取决于目标错误如何影响 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></eq> 的不同功能。</li></ol></li><li><ol start="3"><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mrow><mi>v</mi><mi>i</mi><mi>o</mi><mi>l</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi></mrow></msub><mo>=</mo><msub><mi mathvariant="script">I</mi><mrow><mi>m</mi><mi>i</mi><mi>x</mi></mrow></msub><mi mathvariant="normal">/</mi><msub><mi mathvariant="script">I</mi><mrow><mi>g</mi><mi>o</mi><mi>o</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\varphi_{violated} = \mathcal{I}_{mix} / \mathcal{I}_{good}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">mi</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="mord mathnormal mtight">oo</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></eq>, 与错误相关的违反不变量的集合</li></ol></li></ul></li><li><p>将推断的不变量分类和区分为好的和坏的模式是很重要的，特别是在处理有多个功能要求的程序时。</p><ul><li>这将有助于在修改代码时确定要维持的期望不变量集合和要修复的冲突的不变量集合。</li><li>同时也将帮助识别与分析bug相关的不变量集合</li></ul></li><li><p>推断出的 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mrow><mi>c</mi><mi>o</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>c</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\varphi_{correct}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">correc</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 和 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mrow><mi>v</mi><mi>i</mi><mi>o</mi><mi>l</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\varphi_{violated}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 的准确性很大程度上取决于所使用不变量推断工具的准确性和不变量精炼过程的准确性，通过可达性分析增加程序行为的覆盖范围，可以增加 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mrow><mi>c</mi><mi>o</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>c</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\varphi_{correct}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">correc</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 和 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mrow><mi>v</mi><mi>i</mi><mi>o</mi><mi>l</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\varphi_{violated}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 为真的可能性</p></li></ul><h4 id="definition-3-%EF%BC%88patch-validation-in-invariant-based-apr%EF%BC%89" tabindex="-1">Definition 3 （Patch validation in invariant-based APR）</h4><ul><li><p>令 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></eq> 为一个包括 bug <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span></eq> 的程序，<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span></eq> 是一个包含至少一个失败测试和一个正确测试的测试套件。 假设 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">pt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">pt</span></span></span></span></eq> 是一个合理的补丁使得 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></eq> 通过了 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span></eq> 中的所有测试用例。 补丁 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">pt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">pt</span></span></span></span></eq> 的有效性可以按照以下形式进行检查 <section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi><mi>i</mi><mi>d</mi><mi>i</mi><mi>t</mi><mi>y</mi><mo>=</mo><mi>V</mi><mo stretchy="false">(</mo><mi>p</mi><mi>t</mi><mo separator="true">,</mo><msub><mi>φ</mi><mrow><mi>c</mi><mi>o</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>c</mi><mi>t</mi></mrow></msub><mo stretchy="false">)</mo><mo>∧</mo><mi mathvariant="normal">¬</mi><mi>V</mi><mo stretchy="false">(</mo><mi>p</mi><mi>t</mi><mo separator="true">,</mo><msub><mi>φ</mi><mrow><mi>v</mi><mi>i</mi><mi>o</mi><mi>l</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">validity = V(pt,\varphi_{correct}) \wedge \neg V(pt,\varphi_{violated})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathnormal">pt</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">correc</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">¬</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathnormal">pt</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></eqn></section> 其中 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo stretchy="false">(</mo><mi>p</mi><mi>t</mi><mo separator="true">,</mo><msub><mi>φ</mi><mrow><mi>c</mi><mi>o</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>c</mi><mi>t</mi></mrow></msub><mo stretchy="false">)</mo><mo>∈</mo><mo stretchy="false">{</mo><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi><mo separator="true">,</mo><mi>f</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">V(pt,\varphi_{correct}) \in \{true,false\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathnormal">pt</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">correc</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">se</span><span class="mclose">}</span></span></span></span></eq> , 工具的响应取决于正在检查的程序是否满足或违反了规范</p></li><li><p>为了提高对生成补丁有效性的信心，我们选择针对 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mrow><mi>c</mi><mi>o</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>c</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\varphi_{correct}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">correc</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 和 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mrow><mi>v</mi><mi>i</mi><mi>o</mi><mi>l</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\varphi_{violated}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 进行验证。 然而，为了降低调用验证器 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></eq> 的成本，我们打算实施一个三步的补丁验证方法，首先使用测试套件，然后在使用程序验证器，生成合理的补丁是通过使用测试用例在第一步完成的，第二步设计对合理补丁针对不良模式集合（属性 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mrow><mi>v</mi><mi>i</mi><mi>o</mi><mi>l</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\varphi_{violated}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> ）进行检查，通过前两步的补丁在第三步针对良好模式集合（属性 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mrow><mi>c</mi><mi>o</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>c</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\varphi_{correct}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">correc</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> ）进行检查</p></li></ul><h3 id="3-%E4%BD%BF%E7%94%A8invariant%E7%9A%84apr%E4%BF%AE%E5%A4%8D-performance-bugs" tabindex="-1">3 使用invariant的APR修复 Performance Bugs</h3><ul><li>性能bug是导致系统性能显著下降的编程错误。经验表明，许多广泛使用的商业软件都存在性能问题[13,6,10].</li><li>因此，这里需要开发一个严格的性能错误修复框架，确保在不影响功能的情况下提高效率。<ul><li>与功能错误相比，性能错误的一个独特特征是性能错误不会影响程序的功能性（即程序在语义上是正确的，但效率低下），因此可以使用不变量推断工具自动推断程序的与其行为</li></ul></li><li>本节描述了一个针对性能错误的基于不变量的APR系统，并演示了如何通过生成可以确保提高效率而不牺牲功能性的补丁来处理性能错误</li></ul><h4 id="3.1-%E9%92%88%E5%AF%B9%E6%80%A7%E8%83%BDbug%E7%9A%84%E5%9F%BA%E4%BA%8E%E4%B8%8D%E5%8F%98%E9%87%8F%E7%9A%84%E4%BF%AE%E5%A4%8D%E6%A1%86%E6%9E%B6" tabindex="-1">3.1 针对性能bug的基于不变量的修复框架</h4><ul><li><p>在本节，我们描述解决性能bug的基于不变量的修复框架，框架主要包含以下部分</p><ul><li><ol><li>通过测试集：包含使程序运行快速的测试用例。</li></ol></li><li><ol start="2"><li>失败测试集：包含导致程序运行缓慢的测试用例。</li></ol></li><li><ol start="3"><li>运行时监视器：用于跟踪程序的执行时间，并区分快速运行和缓慢运行。</li></ol></li><li><ol start="4"><li>自动不变量推断工具（例如Daikon或CPAChecker）和自动不变量验证工具（例如PVS、Z3求解器或CPAChecker）。</li></ol></li></ul></li><li><p>接下来讨论如何定义通过测试和失败测试的概念，以及针对性能错误，生成和验证补丁的过程</p></li></ul><h5 id="%E9%92%88%E5%AF%B9%E6%80%A7%E8%83%BD%E9%94%99%E8%AF%AF%E7%9A%84%E9%80%9A%E8%BF%87%E5%92%8C%E5%A4%B1%E8%B4%A5%E6%B5%8B%E8%AF%95" tabindex="-1">针对性能错误的通过和失败测试</h5><ul><li>性能错误在运行时不会产生debug信息：不会产生崩溃，异常或不正确的结果。 因此我们使用一个含有预定义定时器的运行时监视器来重新定义通过和失败测试的概念</li><li>我们将导致快速运行的测试用例视为通过测试，而导致缓慢运行的测试用例视为失败测试。</li><li>一个修复方案，可以将缓慢运行转换为快速运行，同时保持原程序的期望行为，有效的修复</li></ul><h5 id="%E9%92%88%E5%AF%B9%E6%80%A7%E8%83%BD%E9%94%99%E8%AF%AF%E7%9A%84%E8%A1%A5%E4%B8%81%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5" tabindex="-1">针对性能错误的补丁生成策略</h5><ul><li>因为我们处理的是语义上正确但效率底下的程序，因此通常可以通过重构原始程序的基本组件来创建程序的高效版本。</li><li>我们的初步分析表明，遗传修复工具（如GenProg）在处理性能错误方面是有效的。这表明，通过相对简单的更改，可以修复具有性能错误的程序。例如，可以使用遗传修复工具使用的移动，交换，删除和插入等变异操作符来修复各种性能错误</li><li>因此，我们的目标是将我们的修复框架和基于遗传的补丁生成工具结合起来</li></ul><h5 id="%E9%92%88%E5%AF%B9%E6%80%A7%E8%83%BD%E9%94%99%E8%AF%AF%E7%9A%84%E8%A1%A5%E4%B8%81%E9%AA%8C%E8%AF%81" tabindex="-1">针对性能错误的补丁验证</h5><ul><li>需要注意的是，不变量推断工具也可以用于推导与程序非功能属性相关的。这可以通过向被修复的程序添加额外的非功能变量来实现。</li><li>假设我们有一个程序 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></eq> 带有一组变量 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></eq> ，其中包含一个性能错误。 我们需要检查为程序 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></eq> 生成的补丁是否修理了性能错误，同时没有引入新的功能错误。为此，我们需要生成并验证与程序效率属性相关的断言，如下所述<ul><li><ol><li>添加一个新变量值 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>f</mi><mi>v</mi></mrow><annotation encoding="application/x-tex">nfv</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span></eq> , 其值不会影响 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></eq> 的行为。正在处理的性能错误的类型决定了如何使用 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>f</mi><mi>v</mi></mrow><annotation encoding="application/x-tex">nfv</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span></eq> 来模拟程序的效率。然而，对于我们考虑的循环程序，<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>f</mi><mi>v</mi></mrow><annotation encoding="application/x-tex">nfv</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span></eq> 的作用像一个计数器，每次迭代增加一次，换句话说，这是循环迭代次数作为效率的模型</li></ol></li><li><ol start="2"><li>使用不变量推断工具 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span></eq> 来推断原始版本和补丁版本的不变量上的数量，分别表示为 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">I</mi><mo stretchy="false">(</mo><mi>P</mi><mo separator="true">,</mo><mi>n</mi><mi>f</mi><mi>v</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi mathvariant="script">I</mi><mo stretchy="false">(</mo><mi>p</mi><mi>t</mi><mo separator="true">,</mo><mi>n</mi><mi>f</mi><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{I}(P,nfv),\mathcal{I}(pt,nfv)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="mopen">(</span><span class="mord mathnormal">pt</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span></eq>,前者表示 涉及变量 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>f</mi><mi>v</mi></mrow><annotation encoding="application/x-tex">nfv</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span></eq> 的程序 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></eq> 的不变量集合</li></ol></li><li><ol start="3"><li>比较 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">I</mi><mo stretchy="false">(</mo><mi>P</mi><mo separator="true">,</mo><mi>n</mi><mi>f</mi><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{I}(P,nfv)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span></eq> 和 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">I</mi><mo stretchy="false">(</mo><mi>p</mi><mi>t</mi><mo separator="true">,</mo><mi>n</mi><mi>f</mi><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{I}(pt,nfv)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="mopen">(</span><span class="mord mathnormal">pt</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span></eq> 中的 数值 断言，确定补丁版本是否比原始版本更有效率</li></ol></li></ul></li><li>为简单起见，我们假设我们处理的程序只有一个循环。然而，分析程序中的循环数量决定了需要多少个额外变量，因此，不变量推断工具 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span></eq> 用于推断关于 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo>∪</mo><mo stretchy="false">{</mo><mi>n</mi><mi>f</mi><mi>v</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">V\cup \{nfv\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">}</span></span></span></span></eq> 的不变量，然后我们区分以下类型的断言<ul><li><ol><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">I</mi><mo stretchy="false">(</mo><mi>P</mi><mo separator="true">,</mo><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{I}(P,V)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose">)</span></span></span></span></eq>： 与程序功能相关的断言</li></ol></li><li><ol start="2"><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">I</mi><mo stretchy="false">(</mo><mi>P</mi><mo separator="true">,</mo><mi>n</mi><mi>f</mi><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{I}(P,nfv)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span></eq>：与程序效率相关的断言</li></ol></li></ul></li><li>使用生成的断言，可以用以下方法检测补丁的有效性 <section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi><mi>i</mi><mi>d</mi><mi>i</mi><mi>t</mi><mi>y</mi><mo stretchy="false">(</mo><mi>p</mi><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>S</mi><mi>E</mi><mi>M</mi><mi>A</mi><mi>E</mi><mi>Q</mi><mo stretchy="false">(</mo><mi mathvariant="script">I</mi><mo stretchy="false">(</mo><mi>P</mi><mo separator="true">,</mo><mi>V</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mi mathvariant="script">I</mi><mo stretchy="false">(</mo><mi>p</mi><mi>t</mi><mo separator="true">,</mo><mi>V</mi><mo stretchy="false">)</mo><mo>∧</mo><mi>P</mi><mi>R</mi><mi>E</mi><mi>D</mi><mi>S</mi><mi>M</mi><mo stretchy="false">(</mo><mi mathvariant="script">I</mi><mo stretchy="false">(</mo><mi>p</mi><mi>t</mi><mo separator="true">,</mo><mi>n</mi><mi>f</mi><mi>v</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi mathvariant="script">I</mi><mo stretchy="false">(</mo><mi>P</mi><mo separator="true">,</mo><mi>n</mi><mi>f</mi><mi>v</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">validity(pt)=SEMAEQ(\mathcal{I}(P,V)),\mathcal{I}(pt,V) \wedge PREDSM(\mathcal{I}(pt,nfv),\mathcal{I}(P,nfv))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathnormal">pt</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">SEM</span><span class="mord mathnormal">A</span><span class="mord mathnormal">EQ</span><span class="mopen">(</span><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose">))</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="mopen">(</span><span class="mord mathnormal">pt</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">PRE</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.10903em;">SM</span><span class="mopen">(</span><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="mopen">(</span><span class="mord mathnormal">pt</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">))</span></span></span></span></span></eqn></section> 其中 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>E</mi><mi>M</mi><mi>A</mi><mi>E</mi><mi>Q</mi></mrow><annotation encoding="application/x-tex">SEMAEQ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">SEM</span><span class="mord mathnormal">A</span><span class="mord mathnormal">EQ</span></span></span></span></eq> 是一个bool操作来检查给定的不变量集合是否语义相同，<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mi>R</mi><mi>E</mi><mi>D</mi><mi>S</mi><mi>M</mi></mrow><annotation encoding="application/x-tex">PREDSM</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">PRE</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.10903em;">SM</span></span></span></span></eq> 是一个bool操作来检查与修补版本相关的谓词中的上界是否小于与原始程序相关的谓词中的上界。</li><li>我们现在描述两种正式的程序，使用可用的程序验证工具验证合理补丁的有效性<ul><li><ol><li>Daikon-PVS：在这个补丁验证过程中，Daikon用于生成和程序 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo separator="true">,</mo><mi>p</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">P,pt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">pt</span></span></span></span></eq> 功能和效率相关的断言。 如果 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">I</mi><mo stretchy="false">(</mo><mi>P</mi><mo separator="true">,</mo><mi>V</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi mathvariant="script">I</mi><mo stretchy="false">(</mo><mi>p</mi><mi>t</mi><mo separator="true">,</mo><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{I}(P,V),\mathcal{I}(pt,V)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="mopen">(</span><span class="mord mathnormal">pt</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose">)</span></span></span></span></eq> (即与功能属性相关的断言)不相同，则可能需要检查这些集合中的谓词之间的等价和蕴含关系，以确定 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></eq> 和 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">pt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">pt</span></span></span></span></eq> 是否在语义上等价。通过查询定理证明器 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mi>V</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">PVS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span></eq> ，可以完成这项任务。</li></ol></li><li><ol start="2"><li>CPAChecker-PVS:CPACheck的一个有趣特性是它以GraphML格式产生正确性证明，并且在这些证明中，可以分析程序的不变量。可以利用这个特性生成原始程序和相应的合理程序的不变量集合。如果两个程序的不变量集合不相同，则可能需要调用 PVS来检查这两个不变量集合之间的等价和蕴含关系。</li></ol></li></ul></li></ul><h4 id="3.2-%E4%BD%BF%E7%94%A8%E5%9F%BA%E4%BA%8E%E4%B8%8D%E5%8F%98%E9%87%8F%E7%9A%84apr%E4%BF%AE%E5%A4%8D%E7%8E%B0%E5%AE%9E%E4%B8%96%E7%95%8C%E7%9A%84%E6%80%A7%E8%83%BDbug" tabindex="-1">3.2 使用基于不变量的APR修复现实世界的性能bug</h4><ul><li>本节，我们将展示基于不变量的APR可以用于解决现实世界的性能bug。处于空间的原因，我们只考虑一个有趣的性能bug的实例，如下代码。这个bug是基于真实事件Apache的一个真实缺陷，也被其它研究人员研究过</li></ul><pre><code class="language-C">int found = -1;while ( found &lt; 0 ) &#123;// Check if string source [] contains target []  char first = target [0];  int max = sourceLen - targetLen ;  for (int i = 0; i &lt;= max; i++) &#123;    // Look for first character .    if ( source [i] != first) &#123;      while (++i &lt;= max &amp;&amp; source[i] != first );    &#125;   // Found first character    if (i &lt;= max) &#123;      int j = i + 1;      int end = j + targetLen - 1;      for (int k=1; j&lt;end &amp;&amp; source [j]== target[k]; j++, k ++);        if (j == end) &#123;        /* Found whole string target . */          found = i;          break;        &#125;      &#125;  &#125;  // append another character ; try again  source [ sourceLen ++] = getchar ();&#125;</code></pre><h5 id="%E5%AF%B9%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90" tabindex="-1">对程序分析</h5><ul><li>该程序旨在确定给定的（目标）字符串是否包含在另一个（源）字符串中。如果在源字符串中找到了目标字符串，程序设置变量<code>found</code>设置为目标字符串的第一个字符的索引。</li><li>但是，该程序存在一个很大的性能缺陷：<ul><li>当目标字符串位于源字符串的开头时，运行速度很快；</li><li>当字符串接近源字符串末尾时，运行速度缓慢，这是因为有大量冗余计算的增加，错误在于for循环控制的循环变量i的初始化语句在第6行应该放在主while循环外，就在变量<code>found</code>初始化之后</li></ul></li></ul><h4 id="3.3-%E7%BB%93%E6%9E%9C%E5%92%8C%E5%88%86%E6%9E%90" tabindex="-1">3.3 结果和分析</h4><ul><li>为了处理3.2中的性能bug，我们选择了两种APR工具，这两种工具都是修复C代码的通用修复工具，可以用于修复一系列程序错误，包括循环程序错误<ul><li>基于搜索的GenProg[7]</li><li>基于语义的FAnglix[16]</li></ul></li><li>GenProg成功生成了一个合理的补丁，但FAnglix没有。<ul><li>为了避免原始程序中的重复计算，GenProg将变量i的初始化语句移动到了第6行for循环之外，即修补版本的程序以变量i的初始化语句开始，此时生成的补丁同构了测试用例，因为i不再每次循环接收新字符时被设置为0</li></ul></li><li>为了检查GenProg生成的合理补丁的有效性，我们使用了工具Daikon，比较了原始程序和合理补丁版本的功能和效率断言。 Daikon生成了与功能变量相关的相同不变量集合（即，原始版本和修补版本都有与程序变量相关的相同不变量），这表明补丁保持了原始程序的功能行为</li></ul><h5 id="%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90" tabindex="-1">代码分析</h5><ul><li>代码中包含了4个的循环<ul><li>第2行的while循环</li><li>第6行的for循环</li><li>第9行的while循环</li><li>第15行的for循环</li></ul></li><li>为了评估原始程序和修补程序的效率，需要计算迭代次数的上界，因为补丁不会通过添加或删除操作修改任何循环的逻辑，即在两个程序中，四个循环的每次迭代都涉及相同数量的操作，因此，我为每个循环添加四个迭代计数器(cnt2,cnt6,cnt9,cnt15)来模拟每个循环的效率。 在分析缺陷和修补版本的效率断言中，我们得出以下观察结果<ul><li>对于有缺陷和修补版本中的cnt2，cnt15生成的不变量时相同的，这表明补丁不会影响第2，15行循环的迭代次数</li><li>cnt9只在缺陷版本中递增，并且cnt9&lt;=500499，修补版本不再使用第9行的while循环是一个重大的改进</li><li>Daikon为有缺陷版本生成了不变量cnt6&lt;=1001，而修补版本生成了不变量cnt6&lt;=501，这表明修补版本的第6行循环的迭代次数比原始代码中少了50%</li></ul></li><li>上述发现，以及原始版本和修补版本的衍生功能断言时相同的事实，增强了我们对GenProg工具生成补丁有效性的信心</li></ul><h3 id="4-%E7%9B%B8%E5%85%B3%E5%B7%A5%E4%BD%9C" tabindex="-1">4 相关工作</h3><h4 id="apr%E4%B8%AD%E8%BF%87%E6%8B%9F%E5%90%88%E9%97%AE%E9%A2%98" tabindex="-1">APR中过拟合问题</h4><ul><li>目前已有多种解决方法来缓解APR中的过度拟合问题<ul><li>例如符号规范推断[8]</li><li>基于机器学习的补丁优先级排序[1]</li><li>基于模糊测试的测试套件增强[5]和合成路径探索[12]</li><li>这些措施依赖于有限的不完整的测试用例，不能保证补丁的普遍正确性。</li></ul></li><li>与基于生成测试输入的方法相比面积与不变量的APR在修改代码时自动生成并精炼需要保持的不变量即需要修复的问题不变量，这使得该方法比现有修复方法更可靠。</li><li>现在通用的APR工具依赖于符号执行或合成执行来发现反例并生成修复补丁[9,12],然而这些修复方法需要手动检查生成的补丁是否正确或与开发者的补丁相同，这可能存在错误。 基于不变量的APR使得可以应用自动化验证技术来缓解过拟合问题，并通过与开发者补丁相比较来正式和系统地检查生成的补丁的准确性</li></ul><h4 id="%E8%A7%A3%E5%86%B3%E6%80%A7%E8%83%BD%E9%94%99%E8%AF%AF" tabindex="-1">解决性能错误</h4><ul><li>目前已经进行了许多尝试，使用动态，静态，混合分析方法来检测和修复程序中的性能错误[13,6,10]。<ul><li>[10]对性能错误进行了实证调查，并提出了一个用于识别它们的效率规则。</li><li>[13]中，使用动态-静态分析技术，开发了几种修复策略来识别和解决性能问题。</li></ul></li><li>然而我们的方法与先前的研究不同之处在于，它是一种更通用和精确的技术，利用程序不变量来解决循环程序的性能问题，并产生可靠的补丁。因为系统不变量，原始程序的效率可以系统的和修补版本进行比较</li></ul><h3 id="5-%E7%BB%93%E8%AE%BA-%E5%92%8C-%E6%9C%AA%E6%9D%A5%E5%B7%A5%E4%BD%9C" tabindex="-1">5 结论 和 未来工作</h3><h4 id="%E7%BB%93%E8%AE%BA" tabindex="-1">结论</h4><ul><li>我们描述了一个基于程序不变量概念的新型自动程序修复(APR)系统。<ul><li>基于不变量的APR有望处理比其它APR方法更广泛的错误，并生成更可靠的补丁，这是由于基于不变量的修复系统依赖于更强的正确性指标，而不是测试套件。</li><li>我们通过开发了一个针对性能缺陷的不变量修复系统来展示APR中利用不变量的实用性。 初步结果现实，基于不变量的APR可以帮助生成高质量的补丁，这些补丁可以确保程序效率提高而不会对其功能产生不利影响。</li></ul></li></ul><h4 id="%E6%9C%AA%E6%9D%A5%E5%B7%A5%E4%BD%9C" tabindex="-1">未来工作</h4><ul><li>为了完善此处开始的基于不变量的APR研究，我们确定了以下未来工作的关键方向<ul><li>首先，我们的主要目的是进行深入的实证分析，以确定基于不变量的APR在处理程序中功能性和非功能性缺陷方面的表现如何，这还涉及评估当前可访问的不变量推断和验证工具</li><li>准确的不变量生成是确保基于不变量的APR生成的补丁有效性的关键，我们推测可达性分析可以帮助解决这个复杂的计算任务，我们的目标是将基于不变量的APR与支持不变量生成和精炼的程序验证工具（如CPAChecker和PathFinder）相结合</li></ul></li></ul><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;invariant-based-program-repair&quot; tabindex=&quot;-1&quot;&gt;Invariant-based Program Repair&lt;/h2&gt;
&lt;p&gt;Al-Bataineh O I. Invariant-based Program Repair</summary>
      
    
    
    
    <category term="论文" scheme="http://example.com/categories/%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="SoftwareRepair" scheme="http://example.com/tags/SoftwareRepair/"/>
    
    <category term="InVariant" scheme="http://example.com/tags/InVariant/"/>
    
  </entry>
  
  <entry>
    <title>Software Debloating 论文阅读 （12）</title>
    <link href="http://example.com/2024/02/04/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/SoftwareDebloating/Software%20Debloating%20%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB(12)/"/>
    <id>http://example.com/2024/02/04/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/SoftwareDebloating/Software%20Debloating%20%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB(12)/</id>
    <published>2024-02-04T08:13:57.509Z</published>
    <updated>2024-02-04T08:13:57.509Z</updated>
    
    <content type="html"><![CDATA[<h2 id="sok%3A-a-broad-comparative-evaluation-of-software-debloating-tools" tabindex="-1">SoK: A Broad Comparative Evaluation of Software Debloating Tools</h2><p>SOK2.0</p><h3 id="0-%E6%91%98%E8%A6%81" tabindex="-1">0 摘要</h3><ul><li><p>软件简化工具旨在通过删除被称为“膨胀”（bloat）的不必要的代码来提高程序的安全性和性能。尽管已经提出了许多技术，但它们的应用还存在一些障碍。</p><ul><li>瘦身工具高度专业化，这使得采用者难以找到符合他们需求的合适工具</li><li>同时缺乏统一的评估标准，这使得采用者难以评估工具的优劣</li></ul></li><li><p>为了弥补则以差距，我们对近简化文献和集中目前正在商业开发的工具进行了广泛的调查</p></li><li><p>随后我们的10种简化工具进行了评估，确定其优势和劣势。我们的评估是在20个不同基准程序的多样化集合上进行的，涵盖了16个性能、安全性、正确性和可用性指标</p></li><li><p>我们的评估揭示了一些令人担忧的发现，这些发现与debloating文献中的主流叙述相矛盾</p><ul><li>首先，简化工具缺乏在实际软件中的使用，在中高复杂性基准的的成功率仅有21%</li><li>其次，简化工具的健壮还曾度存在问题，通过我们的差异模糊检测工具DIFFER，只有13%的简化生成了强壮的简化工具</li><li>最后，我们的结果表明，简化工具通常无法显著改善膨胀程序的性能或安全状况</li></ul></li><li><p>我们相信本文的贡献将会帮助潜在的使用者更好的理解工具，并激发未来对简化的研究和开发，为此我们开源了我们的基准集，数据和自定义工具</p></li></ul><h3 id="1-%E4%BB%8B%E7%BB%8D" tabindex="-1">1 介绍</h3><ul><li><p>软件简化是一个新兴的领域，关注于通过删除程序中不必要的代码（即膨胀）来增强程序的安全性和性能，这些不必要的代码通常以<strong>不必要的功能</strong>和<strong>多余的库代码</strong>的形式出现。</p></li><li><p>由于entrenched的软件实践（如 可重用性代码）和 一些趋势（范围蔓延），现代程序中普遍存在<strong>膨胀</strong>。为了面对这一问题，许多简化方法已经被提出，针对软件生命周期的各个阶段，然而由于一些原因，这些技术实际的实用没有跟上研究</p><ul><li><ol><li><strong>简化工具高度特化</strong>：每个工具面向不同类型的膨胀，软件类型（编译，解释，内核等），生命周期的阶段（源码，中间代码，二进制），并且有自己独特的分析方法。这使得使用者不能根据具体问题选择具体方法</li></ol></li><li><ol start="2"><li><strong>缺乏统一度量标准</strong>：这将导致关于不同方法如何提高性能和安全性的声明不清晰，不完整，且可能具有误导性，这是因为作者使用或创建的方法本身就是有问题的[12,48]，最终，使用者难以理解可以获得哪些期望的好处，因为看不出哪些度量标准是有用的或相关的。这一问题被相关简化文献中对健全性风险的肤浅讨论加剧，使得使用者更难以理解简化结果之间的权衡。</li></ol></li><li><ol start="3"><li><strong>缺少工具的比较评估</strong>：这使得使用者难以理解工具的优劣，尽管之前有研究在 膨胀的普遍性[14,50,51],简化权衡[73],安全度量标准研究[8,12,21]，但最近只有一项研究评估了软件简化工具本身，且只有4个工具[4]</li></ol></li></ul></li><li><p><strong>动机</strong>：迄今为止，在软件简化生态中没有工具，度量标注你，基准集，使用案例的全面回顾，分类，分析和评估。我们弥补通过进行一项调查和比较软件简化工具来弥补这一差距，并完成以下研究问题</p><ul><li><ol><li>软件简化工具如何分类？</li></ol></li><li><ol start="2"><li>哪些安全性，健全性，性能 指标是有用的？还需要什么新指标？</li></ol></li><li><ol start="3"><li>哪些基准测试和配置提供了对去膨胀工具的全面评估？</li></ol></li><li><ol start="4"><li>同一类别内的工具如何比较？</li></ol></li><li><ol start="5"><li>不同类别之间的去膨胀工具如何比较？</li></ol></li></ul></li><li><p><strong>贡献总结</strong>：</p><ul><li>第二节介绍我们对简化文献的调查结果</li><li>第三节描述我们评估简化工具及结果的实验方法</li><li>第四节展示评估结果</li><li>第五节讨论我们研究的主要发现</li></ul></li></ul><h3 id="2-%E8%BD%AF%E4%BB%B6%E7%AE%80%E5%8C%96%E5%B7%A5%E5%85%B7%E8%B0%83%E7%A0%94" tabindex="-1">2 软件简化工具调研</h3><ul><li><p>我们调查了从2013年至今超过60篇关于软件简化，特化和定制化的学术文章。此外，为了全面覆盖该领域的广度，我们还调查了各个开发阶段的各种商用技术和正在使用的技术。在我们调查的早期阶段，使用了一个广义的“软件简化”定义。因此，我们调查了许多许多传统上不视为软件的技术成果的简化方法，如容器[53],操作系统及其API[23,24,27,37]，测试用例[34,55,64]，硬件[16,76]，依赖构建[45]和其它[29,41,43,49,77]。</p></li><li><p>在接下来的部分中，我们建立了一个简化分类方法，该分类定义了膨胀的类型，简化工作流，简化技术，度量标准和基准测试。</p></li></ul><h4 id="2.1-%E8%86%A8%E8%83%80%E7%9A%84%E7%B1%BB%E5%9E%8B" tabindex="-1">2.1 膨胀的类型</h4><ul><li>总体上，简化工具尝试移除或终合两种类型的不必要代码，我们定义为I型膨胀和Ⅱ型膨胀<ul><li><strong>I型膨胀</strong>：是普遍不必要的，可以在不影响最终程序行为的情况下移除。最常见表现是在运行时动态加载到进程地址空间的库代码，但永远不会被调用。尽管比较罕见，但一些针对OS的简化工具中的I型膨胀，可以通过删除来防止恶意使用。四代码和不可达代码也属于I型膨胀，但是这些代码通常在编译时被删除，简化工具并不过多过关注</li><li><strong>Ⅱ型膨胀</strong>：该类型膨胀与最终用途相关，代码是否为Ⅱ型膨胀取决于用户如何使用程序。类型Ⅱ通常为不必要功能代码的形式，例如在图像处理软件中支持混淆或过时文件格式。处理操作系统和Web浏览器交互中的平台相关代码是Ⅱ型膨胀的一种形式，这种膨胀通常由构建系统和脚本引擎解决而不是简化工具</li></ul></li></ul><h4 id="2.2-%E7%AE%80%E5%8C%96%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%92%8C%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B" tabindex="-1">2.2 简化工作流和使用案例</h4><ul><li><p>尽管在技术上存在差异，但几乎所有简化工具都共享一个通用的高级六级段用户工作流</p><ul><li><ol><li>规范化（Specification）：用户创建一个特定于工具的规范，概述应该保留或消除的程序行为。</li></ol></li><li><ol start="2"><li>输入（Input）：用户提供规范和程序给去膨胀工具。</li></ol></li><li><ol start="3"><li>分析（Analysis）：工具使用规范中的信息来分析程序，并标记代码（例如，是否为不必要的，或作为某一功能的一部分）。</li></ol></li><li><ol start="4"><li>转换（Transformation）：工具修改程序，将膨胀代码与有用代码分开（例如，剪切、重构、附加标签）。</li></ol></li><li><ol start="5"><li>输出（Output）：工具产生一个修改后的程序，该程序要么不包含膨胀，要么包含必要的标签，以在运行时删除膨胀。</li></ol></li><li><ol start="6"><li>验证（Validation）：用户通过手动测试或他们选择的自动化工具（例如，模糊测试器）验证修改后的程序是否健全并按预期行为。如果输出无效，用户可能会重新开始工作流程。</li></ol></li></ul></li><li><p>尽管存在一个共同的高级工作流程，但许多工具为潜在的用户提供了不同的使用案例。</p><ul><li>针对I型膨胀：尽可能地消除膨胀</li><li>针对Ⅱ型膨胀，包含三个常用案例<ul><li><ol><li><strong>Arrressive</strong>：除所需要的单个功能外删除所有其它功能，例如，激进地简化一个文件压缩工具可能被定义为删除不必要的代码，只留下压缩文件并将结果写入磁盘的部分</li></ol></li><li><ol start="2"><li><strong>Miderate</strong>：保留几个核心和外围功能，简化其它部分。对于文件压缩工具该案例会保留压缩，解压缩和测试压缩文件完整性的代码</li></ol></li><li><ol start="3"><li><strong>Conservative</strong>：只删除少数外围功能</li></ol></li></ul></li></ul></li></ul><h4 id="2.3-%E7%AE%80%E5%8C%96%E6%8A%80%E6%9C%AF%E5%88%86%E7%B1%BB" tabindex="-1">2.3 简化技术分类</h4><p>我们将调查的软件简化工具分为5个类别，这些类别主要是通过在简化过程中各个阶段所做的设计进行分类的</p><h5 id="source-to-source-(s2s)" tabindex="-1">Source-to-Source (S2S)</h5><ul><li>S2S工具简化源代码，他们呢主要针对类型Ⅱ膨胀，尽管他们可以很容易的移除库中的I型膨胀。</li><li>简化 信息丰富 的源代码 与 其它级别表示（即IR和二进制）相比有<strong>两个优点</strong><ul><li><ol><li>开发者在分析阶段可以有很多选择：S2S简化器可以使用代码覆盖率[30,71–73]、模糊测试[9]、构建系统分析[28,69]和手动注释[11]技术来产生特性与代码的映射</li></ol></li><li><ol start="2"><li>源代码更容易进行转换，而不损坏程序完好性，因为编译器还未剥离高级信息并用及其语义代替它，在源代码转换后，编译器在这种情况下检查错误和优化也非常有用</li></ol></li></ul></li><li>尽管有以上优点，但由于其表达的灵活性（如syntactic sugar）编译器不支持直接转换源代码，转换源代码可能在技术上变得复杂。</li></ul><h5 id="compiler-based-specializers-(cbs)" tabindex="-1">Compiler-Based Specializers (CBS)</h5><ul><li>与S2S类似，接收源代码为输入，主要针对Ⅱ型膨胀。</li><li>但与之间简化源代码不同，CBS [2,3,38,39,42,58,61]在分析和转换阶段使用编译器（如LLVM）将源码降级为IR，根据用户的规范将关键输入参数或值替换为编译时常量，通过内置的编译器优化（如常量椽笔，循环展开和死代码去除）简化。</li><li>这种方法通过使用高可靠的编译通道而不是自定义转化程序来解决完整性。</li><li>作为一种权衡，CBS只支持arrgessive简化用例，不适合另外两种，或者在运行时触发功能的场景</li></ul><h5 id="binary-to-binary-(b2b)" tabindex="-1">Binary-to-Binary (B2B)</h5><ul><li>概念上与S2S相似，但B2B只针对二进制文件(ELF,Java字节码[13,32,33,65])</li><li>仅二进制的方法容易除左且充满挑战，但其具有简化旧的或闭源二进制文件的<strong>优势</strong>。</li><li>B2B方法简化器在分析阶段的选择有限，它们必须以来固有的不准确的二进制分析技术，例如执行测试用例的执行跟踪[5,15,22,26,40,48,57,67,74]和二进制提升[5,22,26,40,57,70,74]以及启发式[40,48]来生成特性到代码的映射。</li><li>由于二进制格式的独特性（例如，程序指令和数据的混合，简介分支等），转化阶段同样困难，因为在一般情况下回复一个二进制是不可判定的，B2B简化器必须小心地处理二进制输入，而不违反原始布局，通过空出没有操作或无效的代码[15,74]或将去膨胀版本的程序作为新的代码部分放在原始代码旁边[5,67]。</li><li>最终，B2B简化器的<strong>主要缺点</strong>也是二进制分析限制的后果：很难产生完整的简化二进制，并且需要高质量的二进制恢复才能有效（例如，Egalito [70]需要position-independent code以确保恢复）。</li></ul><h5 id="%E4%BB%A5%E4%B8%8A%E4%B8%89%E7%B1%BB%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93" tabindex="-1">以上三类工具总结</h5><ul><li>对于这三类工具，有<strong>两个常见的限制和挑战</strong><ul><li><ol><li><strong>验证简化程序是留给用户的任务</strong>：一些工具包含验证例程[67,75]，但只验证保留的功能，并未验证是否确实去除了多余的特性和/或尝试调用这些特性是否得到了妥善处理。 验证和重要，因为简化可能会引入额外的漏洞，这些漏洞的引入大于简化带来的潜在安全好处。</li></ol></li><li><ol start="2"><li><strong>在实际场景使用是困难的</strong>：需要额外的人工努力，通常是列举测试用例，对于复杂的程序，需要用例来确保保留所有所需的功能、错误处理和边缘情况。</li></ol></li></ul></li></ul><h5 id="static-library-(sl)" tabindex="-1">Static Library (SL)</h5><ul><li>SL工具针对I型膨胀</li><li>由于工具在静态的情况下可以直接分析计算目标程序的调用图并识别所需要库函数集合，这类工具不需要规范。</li><li>SL简化器使用各种转换方法，包括通过重写创建专用库以删除[7,31,35,54,62,66,75,78]或使用无操作或无效指令空出未使用的函数[1,59]，对库进行分片[51]，对可执行文件进行重写以静态链接库函数[26]，以及使用存根替换不必要的库函数[68]。</li><li><strong>优势</strong>：通过将其范围限制在Type I膨胀上，SL简化器避免了其他类工具所经历的许多挑战。<ul><li><ol><li>SL不会有创建不健全程序的风险，尽管有些工具可能无法处理如反射和间接引用等编程方法。</li></ol></li><li><ol start="2"><li>除目标程序外，SL简化器几乎不需要使用额外的人工，但这种设计导致这类工具不适用于Ⅱ型膨胀</li></ol></li></ul></li></ul><h5 id="runtime" tabindex="-1">Runtime</h5><ul><li>运行时简化器和SL相似，主要区别在它们的转换和输出阶段</li><li>为了避免对库进行永久性更改，运行时简化器记录所需的库函数作为程序元数据，并在执行期间干预动态链接过程，以从进程内存中去除不必要的库函数。</li><li>方法各不相同<ul><li>Piecewise Compilation and Loading (PCL) [52] 在二进制文件中嵌入调用图信息，并使用自定义加载器在运行时将不必要的函数重写为无效指令</li><li>BlankIt [47] 和Decker [46] 则采用相反的方法，根据当前执行点将仅必要的函数加载到程序的运行时内存中。</li><li>其他方法使用来自构建系统的信息，如配置选项 [36] 和包依赖性 [44] 来去除膨胀。</li></ul></li><li>除了SL去膨胀器的优点外，运行时去膨胀器还具有不干扰静态代码的优点，从而对结果的健全性有很高的信心。代价是管理进程内存需要的高运行时开销。</li></ul><h4 id="2.4-%E7%AE%80%E5%8C%96%E7%9A%84%E5%88%86%E6%9E%90%E6%8C%87%E6%A0%87" tabindex="-1">2.4 简化的分析指标</h4><ul><li><p>没有统一的指标，一般情况下这些指标都是从类似的程序转化技术中适应过来的（如代码优化），但在一些情况也引入了新的指标</p></li><li><p>总体上，我们注意到了30种不同的指标，我们将其分为三类在本节描述。这些指标包含了大多数典型的功能性和非功能性软件数据。</p></li><li><p>然而目前没有作品尝试衡量工具可用性，我们这位这个维度很重要，因为仅供专业人士使用的工具不会被主流采纳</p></li><li><p><strong>性能</strong>：</p><ul><li>衡量简化本身及产生的简化程序的资源消耗。</li><li>在衡量简化后的程序时，性能需要与源程序相比。</li><li>常用指标包括：CPU运行时间、内存开销、静态二进制大小、所需的外部资源数量，使用工具所需的人工努力。</li></ul></li><li><p><strong>正确性和鲁棒性</strong></p><ul><li>衡量简化后程序的稳定性和鲁棒性</li><li>通常，使用测试套件或模糊器来运行简化后程序，来识别错误的输出，崩溃及其它不良结果。 有趣的是我们看到的工作仅对简化后程序收集了它们，并未对原程序使用，然而正确性和鲁棒性的问题可能在原程序就存在，这里需要对比试验。</li><li>Crystal和Casinghino的[20]比较二进制分析工具使用基于SMT的最弱前置条件方法来证明两个程序二进制的等价性或突出它们行为上的差异，为简化场景提供了一个高保证度的正确性指标。</li></ul></li><li><p><strong>安全性</strong></p><ul><li>衡量简化后程序的安全性改进，在我们的调查中我们注意到了两个主要的安全类别：<strong>漏洞消除和代码重用预防code-reuse prevention</strong>。表面上，这些指标用于宣称结果的理想，如消除潜在的漏洞、减少程序的攻击面和减少代码重用攻击。然而，这些指标在实际应用中的实用性仍有待商榷。</li><li><strong>漏洞消除措施</strong><ul><li>可以为简化有已知漏洞的旧版本（如在MITRE的CVE数据库[17]中报告的漏洞）并显示该漏洞已删除。虽然这样展示了简化带来的好处，但没有预测能力，不具有普遍性，不能用于在实际场景中证明对未知漏洞的安全一处。</li><li>可以提出一个论点：已知漏洞对于难以修补的系统构成风险，但修补远比简化简单，侵入性小，风险小。</li><li>此外，使用这类指标可能会导致不准确或不完整，例如<ul><li>Qian等人[48]表明，之前声称在Type II膨胀[30]中消除漏洞的工作也重新引入了其他历史漏洞。</li><li>PCL [52]声称在Type I膨胀中消除已知的漏洞。但是，这些漏洞位于程序静态不可达的库函数中</li></ul></li><li>因此，它们只在极端或刻意的情况下是可利用的。</li></ul></li><li><strong>代码重用预防</strong><ul><li>工具面减少和代码重用预防度量单位：代码重用小工具（是存在于被攻击程序中的链式代码小片段，攻击者在被阻止直接使用shell时，可以利用小工具注入攻击）</li><li>常用的衡量安全改进的指标是减少攻击者可用的小工具总数，然而Brown和Pande [12]已经证明这不恰当，因为许多简化工具在大量减少小工具数量的同时，以很高的速率引入新的小工具，而大幅度减少小工具数量很可能对攻击者影响有限</li><li>反过来，Brown和Pande提出了用于衡量对攻击者实施利用施加的成本的定性小工具集度量标准（例如，小工具集表达能力、可组合性、特殊功能和局部性）以及一个用于计算它们的静态分析工具，即GSA（小工具集分析器）。</li></ul></li></ul></li></ul><h4 id="2.5-benchmark" tabindex="-1">2.5 Benchmark</h4><ul><li>大多数研究采用了在程序分析中常用的基准测试集，例如GNU Coreutils [25]、SPEC CPU 2006/2017 [18,19]和DaCapo[10]。此外，还有几项工作提供了自己的基准如CHISELBench [6]和OCCAM基准测试 [63]，这些基准可能互有交叉。</li><li>大多数基准复杂度不高，它们具有命令行用户界面，很少使用多线程，网络接口等，并且通常只使用一组输入运行到终止。这些基准程序amenable（经得起）简化所需的复杂跟踪和转换操作</li><li>许多工作还在bfptd、cUrl和httpd等中等复杂性基准上评估了他们的工具，但数量和频率较少。这样的基准测试的特点是使用复杂的输入、多线程、网络套接字等。尽管很少见，但一些工作 [48,49] 也在高复杂性软件上评估了他们的工具，如网络浏览器和文档阅读器。</li></ul><h3 id="3-%E8%AF%84%E4%BC%B0%E6%96%B9%E6%B3%95%E8%AE%BA" tabindex="-1">3 评估方法论</h3><p>详细说明方法，配置，指标，基准在评估中的选择</p><h4 id="3.1-%E5%B7%A5%E5%85%B7%E9%80%89%E6%8B%A9" tabindex="-1">3.1 工具选择</h4><ul><li>由于简化工具系统的多样性和规模，我们首先将我们的评估范围限定为支持用户空间C/C++程序和x86/x86-64机器的库的工具。这个基准配置是最广泛支持的，并且拥有最多的候选工具。</li><li>总共，我们在过滤掉继任者工具（例如，OCCAM-v2 [42] 相对于 OCCAM-v1 [39]）后确定了31个候选工具。<ul><li>我们通过公共仓库或向作者请求，成功地获得了24个工具的源代码，并能够成功地构建和运行其中的17个。我们为七个失败的工具付出了大量的努力来解决问题，但由于不可调和的技术问题 [9,44,52,72]或未响应的作者[15,61,74]，我们没有成功。</li><li>剩下17个中<ul><li>因需要IDA Pro [51]的商业许可证排除一个。</li><li>因一个工具将其基准硬编码 [69]而排除</li><li>四个工具需要耗时且需要手动预处理步骤来适应新的基准 [11,46,47,73]</li><li>以及一个工具有技术限制 [22]</li></ul></li></ul></li><li>最后下表中展示了我们选择的10个工具，其中3个工具是商业公司开发的学术工具的专门版本。为了避免混淆，我们在工具标题中使用商业公司的缩写并用连字符连接：CHISEL-GT (GrammaTech, Inc.)、BinRec-ToB (Trail of Bits) 和 LMCAS-SIFT (Smart Information Flow Technologies)。<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(12)_1.png" alt></li><li>对于每个工具，我们都准备了一个隔离的环境（即虚拟机或docker容器），配置有工具支持的最新操作系统和所有使用工具及操作我们基准程序所需的必要资源。</li></ul><h4 id="3.2-%E5%9F%BA%E5%87%86%E9%80%89%E6%8B%A9" tabindex="-1">3.2 基准选择</h4><ul><li>我们选择了20个基准程序程序（表2），在在大小、复杂性和功能上都有所不同<ul><li>为了代表低复杂性基准，我们使用了CHISELBench [6]，因为它在去膨胀文献中常常被使用，并为之前的工作提供了一个常见的比较点。</li><li>我们进一步添加了六个中等复杂性和四个高复杂性的基准，这些基准来自其他基准集 [56,63]。</li></ul></li><li>为了为这些基准构建64位ELF二进制文件，我们在Ubuntu Linux v20上使用了Clang/LLVM v10，并指定了两个构建选项：位置无关代码（-fPIC）和优化级别3（-O3）。</li><li>然而，由于各种工具和基准的特定限制，我们使用了不同的方法来构建一些参考二进制文件。我们在Debian Buster上为RAZOR和CHISEL构建了参考二进制文件。构建ImageMagick需要使用GCC v9.4 (Ubuntu)和GCC v8.3 (Debian Buster)而不是Clang/LLVM。最后，我们为BinRec-ToB构建了32位ELF二进制文件，因为它不支持64位程序。</li></ul><p><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(12)_2.png" alt></p><h4 id="3.3-%E7%AE%80%E5%8C%96%E9%85%8D%E7%BD%AE" tabindex="-1">3.3 简化配置</h4><ul><li>由于各工具对简化用例的支持各不相同，我们使用三种策略进行配置<ul><li><ol><li>对于SL工具，不需要规范</li></ol></li><li><ol start="2"><li>采用中等去膨胀案例，这在文献中最为普遍，用于S2S和B2B简化器</li></ol></li><li><ol start="3"><li>采用了arrgessive激进，因为这是CBS简化其唯一支持的</li></ol></li></ul></li><li>对于每个基准程序，我们创建一个通用的与工具无关的简化规范<ul><li>包括要保留的几个核心和外围功能（即moderate中等使用案例）</li><li>我们为每个功能定义了一个描述性名称和一个或多个样本指令（即测试用例），该基准程序可以执行该功能</li><li>随后我们可以进一步简化该规范，向激进版本靠近</li></ul></li><li>使用通用规范作为指南，我们然后为每个基准程序创建了工具特定的配置文件。</li><li>总的来说，我们为评估创建了160个不同的简化规范。</li></ul><h4 id="3.4-%E6%8C%87%E6%A0%87%E9%80%89%E6%8B%A9" tabindex="-1">3.4 指标选择</h4><ul><li>我们选择了16个指标（表3），来评估去简化器本身以及它们产生的去膨胀程序/库<ul><li>其中12个指标来自于第2.4节中概述的三个类别中常用的指标。通常我们选择从程序二进制文件的分析中计算的指标，因为这是所有去膨胀工具的共同程序表示<ul><li>值得注意的是，由于其较差的预测能力（不具有普遍性），我们选择不在我们的评估中使用CVE消除作为安全指标。</li></ul></li><li>我们进一步添加了四个工具可用性指标，以记录配置和使用去膨胀工具的主要差异。我们在第4节中提供了每个指标是如何计算以及我们的评估结果的详细信息。<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(12)_3.png" alt></li></ul></li></ul><h3 id="4-%E8%AF%84%E4%BC%B0%E7%BB%93%E6%9E%9C" tabindex="-1">4 评估结果</h3><ul><li>我们按照指标类别组织了我们的评估结果。<ul><li>首先，我们展示了工具本身的可用性和性能结果</li><li>然后是通过分析它们产生的去膨胀程序的性能、正确性和安全性指标。</li></ul></li><li>请注意，我们在本节中讨论了每个指标的重要发现和结果，但将整体和跨类别的分析留给第5节。</li></ul><h4 id="4.1-%E5%B7%A5%E5%85%B7%E5%8F%AF%E7%94%A8%E6%80%A7%E5%92%8C%E6%80%A7%E8%83%BD" tabindex="-1">4.1 工具可用性和性能</h4><ul><li>简化工具的一个主要目标是非专家用户可以使用来转换软件。<ul><li>每个工具的设计和用户界面影响其实现此目标的能力。我们提供的前六个指标，集中在简化工具的面向用户的方向：它们的可用性和性能。</li><li>我们假设用户已在适当的计算环境中为其安装了该工具，部署去膨胀的程序不再我们评估的范围</li><li>我们认为软件简化所需的所有工作都在面向用户的评估范围内<ul><li><ol><li>配置工具</li></ol></li><li><ol start="2"><li>使用基准集</li></ol></li><li><ol start="3"><li>运行工具</li></ol></li><li><ol start="4"><li>维护程序的简化版本以面对未来的变化</li></ol></li></ul></li></ul></li></ul><h5 id="usability-1%EF%BC%9A%E9%85%8D%E7%BD%AE%E5%B7%A5%E5%85%B7%E7%9A%84%E6%97%B6%E9%97%B4" tabindex="-1">Usability-1：配置工具的时间</h5><p>-为了比较用户配置简化的体验，我们记录了每个工具创建和验证具体简化规范所需的时间。在创建规范之前，我们通过它们的文档和示例熟悉了这些工具及其规范格式。这些测量只旨在为生成规范所需的努力提供大致的估计。</p><ul><li>表4显示了创建规范所需的平均时间，四舍五入到最近的分钟。我们根据第3.2节定义的三个基准复杂性级别计算平均值。<ul><li>在针对Type II膨胀的工具中，CBS工具生成规格所需的时间最短，因为其为激进的用例，规范仅包括一个测试用例。</li><li>B2B简化工具通常要15min到1h，其时间与测试用例数量成比例</li><li>S2S对于低复杂度基准配置简单，而中高复杂度需要几个小时。<ul><li>这主要由Chisel的设计引起，Chisel为了确定可删除代码，通过ML引导的Delta Debugging算法迭代地删除代码片段，然后编译运行修改后的代码看是否能通过测试用例。正确的Oracle是关键，因为会生成可以编译但运行错误的程序</li></ul></li><li>这些工具还需要额外的测试用例，来确保不删除必要的但不影响通过测试用例（例如安全控制和错误处理）的代码。其他工作已经提出了这样的问题，并显示当它们的补丁未被执行时，CHISEL会重新引入历史上的CVE[48]。<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(12)_4.png" alt></li></ul></li></ul><h5 id="usability-2%EF%BC%9A%E5%9F%BA%E5%87%86%E4%BD%BF%E7%94%A8%E6%97%B6%E9%97%B4" tabindex="-1">Usability-2：基准使用时间</h5><ul><li>三个简化工具需要用户的额外努力来使用基准程序，我们认为这与创建规范无关的，将其单独提出来。<ul><li>Chisel和Chisel-GT在中高复杂度基准集中无法在48h内结束运行，这是其代码设计的问题。为了评估这些工具超出ChiselBench（即低复杂度基准集）的表现，我们与工具的开发者何坐，实现了一个并行化框架以提高性能，使其满足我们对合理运行时的标准（48h）。最后需要26h完成</li><li>LMCAS-SIFT引入了一个“程序颈”的概念，定义为程序的配置逻辑（即 命令行 或/和 配置文件解析代码）和主逻辑（程序的其余部分）之间的边界。 LMCAS-SIFT要求在简化前识别一个合适的“颈”，并为此提供了一个叫neck miner的工具，然而这个工具不总是成功识别颈，导致简化失败，此时用户必须手动识别。<ul><li>在我们的评估中，neck miner未能自动为gzip、mkdir、sort、tar和uniq放置颈，并且平均需要8分钟手动放置它。8min发生在低复杂度基准测试上。在更复杂的基准测试上手动放置颈部可能需要更多时间</li></ul></li></ul></li></ul><h5 id="performance-1%EF%BC%8C2%EF%BC%9A%E5%B7%A5%E5%85%B7%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%E5%92%8C%E5%B3%B0%E5%80%BC%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8" tabindex="-1">Performance-1，2：工具运行时间和峰值内存使用</h5><ul><li>在完成工具配置和手动调整基准集后，接下来测量工具在基准上测试时的性能。</li><li>我们在表5中总结了这些工具在每个复杂度级别的所有基准测试上的平均CPU运行时间（以分钟为单位）和峰值内存使用情况。<ul><li>请注意，我们在这些计算中包括了失败的去膨胀操作。我们仅排除那些与该工具不兼容的基准测试，原因可能是该工具不支持C++代码、多线程程序等。</li><li>表5中的第一组列显示了每个复杂度级别上每个工具的兼容基准测试数量，总共有10个低复杂度、6个中等复杂度和4个高复杂度的基准测试。</li><li>除明显的异常值（objdump）外，所有简化工具在平均20min内完成简化。</li><li>CHISEL和CHISEL-GT分别需要CPU小时和CPU天来运行，因为其方法设计原因。</li><li>在内存小号方面，简化工具通常需要与目标程序相当的内存，除了使用RAZOR简化高复杂度程序需要使用31GB外，所有其他工具峰值为6GB甚至更少<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(12)_5.png" alt></li></ul></li></ul><h5 id="usability-3%EF%BC%9A%E6%93%8D%E4%BD%9C%E5%91%98%E6%89%80%E9%9C%80%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86" tabindex="-1">Usability-3：操作员所需专业知识</h5><ul><li>配置工具，运行工具，调试基准集都需要不同的专业知识，我们根据以下三个定义定义该指标<ul><li><strong>Low</strong>：操作员不需要了解工具或软件的内部工作原理就可以有效地进行去膨胀。</li><li><strong>Medium</strong>：操作员需要了解软件的内部工作原理，但不需要了解工具就可以有效地进行去膨胀。</li><li><strong>High</strong>：操作员需要了解工具和目标软件的内部工作原理才能有效地进行去膨胀</li></ul></li><li>我们在表6中展示了评估结果<ul><li>SL简化工具需要的专业只是最少，因为其不需要规范</li><li>CBS简化工具需要低级的专业知识，因为用户只需要熟悉软件的运行方式，但由于技术限制（即，OCCAM需要枚举链接库的构建选项，LMCAS-SIFT可能需要手动放置“neck”），实际上只有TRIMMER需要低级别的专业知识。</li><li>B2B简化工具需要枚举测试用例，以确保在分析阶段使用的动态跟踪具有足够的覆盖范围，从而产生合适的简化文件，所以需要中等级别的专业知识</li><li>Chisel和Chisel-GT由于需要专业的测试用例和验证脚本，需要最高级别的专业知识<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(12)_6.png" alt></li></ul></li></ul><h5 id="usability-4%EF%BC%9A%E7%BB%B4%E6%8A%A4%E9%9A%BE%E5%BA%A6" tabindex="-1">Usability-4：维护难度</h5><ul><li>评估简化后的程序长期维护的影响，主要考虑更新后修改简化规范并重新运行简化工具的难度，同时也考虑简化后的程序本身是否可以维护（例如，直接将补丁用于简化后的版本），我们定义这个指标如下<ul><li><strong>Low</strong>：工具可以在每次构建时运行，对用户来说成本微乎其微（即编译时间）。</li><li><strong>Medium</strong>：工具对程序表示进行了永久性更改，可以在去膨胀后进行维护。</li><li><strong>High</strong>：工具可能需要重新配置，并且每次原始程序更改时都必须完全重新运行。</li></ul></li><li>结果在表6中<ul><li>SL简化工具具有低维护难度，因为其对用户可以完全透明，并在程序更新时轻松重新运行</li><li>CBS去膨胀工具同样易于维护，因为它们对编译器施加了影响，但由于可能需要对原始程序的更改进行工具重新配置，我们评估它们的维护难度为中等。</li><li>CHISEL和CHISEL-GT评为中等维护难度，因为它们产生的是简化的源代码输出，这些代码可以在简化后直接修补或更新。</li><li>B2B简化工具标记为高难度，因为当原始程序进行上游更改时，它们必须重新配置和重新运行。值得注意的是，B2B去膨胀工具主要用于与旧版二进制文件一起使用，因此它们的维护难度可能不是它们使用的主要缺点。</li></ul></li></ul><h4 id="4.2-%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD" tabindex="-1">4.2 程序性能</h4><ul><li>软件简化旨在再进，或者至少移除代码后不会对程序的性能产生负面影响。<strong>主要期望</strong>是简化后的程序再磁盘上和运行时内存都占用更少空间。如果简化的程序结构得到，其中不必要的代码经常被执行，那么简化后执行的更快是不切实际的。相反，简化操作可能降低运行时性能。</li><li>本节提供了四个性能指标，这些指标基于使用这些工具产生的简化二进制文件和库</li></ul><h5 id="performance-5%EF%BC%9A%E9%9D%99%E6%80%81%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%A4%A7%E5%B0%8F" tabindex="-1">Performance-5：静态二进制大小</h5><ul><li>我们记录了每个成功简化的二进制文件在磁盘上的大小，并将其与原始程序的二进制文件大小进行比较。<ul><li>由于LMCAS-SIFT和SL简化工具在实现上的差异，我们对计算进行了修改。</li><li>Libfilter生成了基准程序的链接库的新的精简版本；因此，我们将简化后的库的总大小与原始库进行比较。</li><li>由LMCAS-SIFT和Binary Reduce (Static)创建的简化程序都是静态链接的二进制文件。对于这些文件，我们将静态链接二进制文件的大小与原始二进制文件及其动态链接库的总大小进行比较。</li></ul></li><li>我们用百分比表示大小变化，低于100%即大小减小。我们计算了3个复杂度基准下二进制文件大小变化，如图7示,第一组列为成功简化的程序数量。BinRec-ToB无法成功地去膨胀任何基准程序，因此我们在评估中从这个和所有后续表格中排除了它。<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(12)_7.png" alt></li><li>上表揭示了一些有趣的结果<ul><li>在所有复杂性级别上，RAZOR和Libfilter产生的去膨胀二进制文件平均较大。因为RAZOR将程序的去膨胀版本缝合到原始二进制文件的新代码部分，并标记原始代码部分为非可执行，而不是真正删除它。同样，Libfilter将不可达函数重写为HLT指令，而不是删除它们</li><li>总体上，其他工具对低复杂度基准实现了大幅减少，但在高复杂性基准上效果差异明显。这与在高复杂性基准程序上的低成功率（只有10个工具中的3个成功处理了所有四个）相结合，表明这些工具可能过度拟合于低和中复杂性基准程序。</li></ul></li></ul><h5 id="performance-6%EF%BC%9A%E9%93%BE%E6%8E%A5%E5%BA%93%E6%95%B0%E9%87%8F" tabindex="-1">Performance-6：链接库数量</h5><ul><li>记录简化前后基准程序链接的外部库数量。<ul><li>我们在这次评估中排除了LMCAS-SIFT和SL去膨胀工具，因为它们直接操作库。我们的结果仅供参考，因为通过去膨胀消除库在很大程度上取决于规范。</li><li>Binary Reduce (Dynamic)、CHISEL和CHISEL-GT在中等和高复杂性基准程序中通常成功地消除了一个或多个库，基于其设计，这是合理的</li><li>然而在TRIMMER和OCCAM在简化后的程序中引入了新的库。引入的库通常是libc++、libgcc和libm，这可能是由于工具使用其自定义的LLVM编译器转换通道对程序进行的更改所导致的。这些库相当大且计算复杂。根据用户简化的目标（例如，最小化代码大小或可重用性），引入这样的新依赖可能会适得其反。</li></ul></li></ul><h5 id="performance-3%EF%BC%8C4%EF%BC%9A%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%E5%92%8C%E5%B3%B0%E5%80%BC%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8" tabindex="-1">Performance-3，4：程序运行时间和峰值内存使用</h5><ul><li><p>为每个基准程序创建测试套件，根据我们的规范（中等和激进）对保留的功能进行测试。这些测试套件旨在尽可能地进行严格和长时间的运行。</p></li><li><p>我们对每个基准程序的参考二进制文件以及每个成功简化的二进制文件运行这些测试套件，记录总运行时间（以CPU秒为单位）和峰值内存消耗（以MB为单位）。</p></li><li><p>在许多情况下，简化的程序由于崩溃，无限执行或运行时错误无法完成测试，我们排除了这些失败</p></li><li><p>我们计算运行时间和峰值内存的变化百分比，其中值低于100%表示减少。然后我们计算了每个复杂度级别的平均值，如图8所示。第一列显示了每个工具在每个复杂性级别上成功完成性能测试的去膨胀基准程序数量。注意到我们排除了CHISEL的3个中等复杂性和2个高复杂性基准程序，因为CHISEL在没有修改源代码的情况下“成功”处理了这些基准程序（大概是没跑出结果）。<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(12)_8.png" alt></p></li><li><p>我们的评估揭示了一些重要的发现：</p><ul><li>对于中高复杂度的基准程序，所有的简化工具失败率都很高。总体上，简化的成功率只有22%，这对用于实际软件的简化技术提出了疑问</li><li>对于低复杂度的基准程序成功率也低于预期，尽管CHISELBench在文献中被广泛使用，但只有OCCAM和RAZOR成功地简化了所有的低复杂性基准程序。相反，BinRecToB和Binary Reduce (Dynamic)没有成功简化任何低复杂性基准程序。</li></ul></li><li><p>关于我们的性能指标，我们观察到只有少数简化的程序的性能明显差于其未修改的对应程序。</p><ul><li>除了CHISEL的一个异常值外，只有TRIMMER和OCCAM在多个复杂性级别上都显示出了一致且显著的（&gt;4%）对运行时间或内存消耗的负面影响。</li><li>其中最显著的是TRIMMER简化高复杂性基准程序运行时间增加了29.4%，以及OCCAM简化的低复杂性基准程序运行时间增加了18.3%。</li></ul></li></ul><h4 id="4.3-%E7%A8%8B%E5%BA%8F%E5%AE%89%E5%85%A8" tabindex="-1">4.3 程序安全</h4><ul><li>除性能改进外，简化文献经常提及程序安全的改进（如攻击面的减少）作为一个主要激励目标。然而攻击面减少的具体定义有很大的差异，并缺乏合理有效的标准来度量。鉴于其它常用度量标准的缺陷（如消除已知的漏洞），我们采用了四个度量指标，重点关注code re-usability prevention（代码重用预防）。</li><li>我们使用GSA[12]来分析我们简化二进制文件及未修改的对应部分，计算我们的度量指标，这些指标反映了在 W⊕X 和 ASLR 等常见安全控制存在的情况下，攻击者可以如何轻易地重复使用程序及其链接库中的代码来制造漏洞。</li><li>在没有事先知道程序中实际存在的漏洞的情况下，这些度量标准为简化的卫全好处提供了定性评估。</li></ul><h5 id="security-1%EF%BC%8C2-%E5%B0%8F%E5%B7%A5%E5%85%B7%E9%9B%86%E7%9A%84%E8%A1%A8%E8%BE%BE%E8%83%BD%E5%8A%9B%E5%92%8C%E8%B4%A8%E9%87%8F" tabindex="-1">Security-1，2 小工具集的表达能力和质量</h5><ul><li><p>前两个度量标准关注于程序二进制文件中可用的功能代码重用小工具的集合属性。攻击者会像在编程语言中的指令那样，将功能代码重用小工具链接在一起，以编写并启动一个攻击，而无需注入代码。</p></li><li><p><strong>小工具集表达能力</strong>：度量了二进制文件中功能小工具的集体表达能力，以确定它们是否足以启动实用的攻击。</p><ul><li>GSA 定义了 11 种不同的功能类别，小工具集中的小工具必须满足这些类别才能达到这一标准，并以满足类别的数量来报告表达能力</li></ul></li><li><p><strong>小工具集质量</strong>：度量了集合中小工具的平均链式能力，以确定它们可以多么容易地组合。</p><ul><li>对于攻击者有用的小工具，它们通常包含对其目的无关的机器指令，但可能对创建小工具链产生副约束（即，改变堆栈指针）。</li><li>GSA通过使用0.0的起始分数并为每个检测到的副约束增加这个分数来度量每个小工具的质量。整体集质量是计算为所有小工具的平均分数。</li></ul></li><li><p>对于这两个度量标准，GSA将简化的二进制文件与原始文件进行比较，并报告值变化。</p><ul><li>对于LMCAS-SIFT和SL，我们在比较中包括了库</li><li>表达性的负值表示负面结果：简化二进制文件中的小工具集满足的表达性类别比原始文件更多。</li><li>对于小工具集的质量，则相反<ul><li>正值表示去膨胀后，每个小工具的平均副约束数量减少了。</li><li>但是，值在任何方向上小于0.5都不足以表示显著性，因为GSA的质量评分系统将次要的副约束值设为0.5，而将主要的副约束值设为3.0。</li><li>我们对GSA报告的度量标准进行了平均处理，显示在表9中。第一组列显示了每个工具在每个复杂性级别上成功去膨胀的基准数量<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(12)_9.png" alt></li></ul></li></ul></li><li><p>总体而言，根据这两个度量标准，我们评估的简化工具对安全性<strong>没有产生显著影响</strong></p><ul><li>多数情况下，我们的数据表明，某些工具和复杂性级别的表现性和链式能力都有所提高</li><li>只有TRIMMER在四个高复杂性基准测试上的表现显著不好，平均提高了3.5个表达性类别</li></ul></li></ul><h5 id="security-3-%E5%B0%8F%E5%B7%A5%E5%85%B7%E9%9B%86%E5%B1%80%E9%83%A8%E6%80%A7" tabindex="-1">Security-3 小工具集局部性</h5><h5 id="security-4-%E5%8F%AF%E4%BE%9B%E9%80%89%E6%8B%A9%E7%9A%84%E7%89%B9%E6%AE%8A%E7%94%A8%E9%80%94%E5%B0%8F%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B" tabindex="-1">Security-4 可供选择的特殊用途小工具类型</h5><p><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(12)_10.png" alt></p><h4 id="4.4-%E6%AD%A3%E7%A1%AE%E6%80%A7%E5%92%8C%E9%B2%81%E6%A3%92%E6%80%A7" tabindex="-1">4.4 正确性和鲁棒性</h4><h5 id="correctness%2Frobustness-1-executes-retained-functions" tabindex="-1">Correctness/Robustness-1 Executes Retained Functions</h5><h5 id="correctness%2Frobustness-2-errors-%2F-crashes-during-differential-testing" tabindex="-1">Correctness/Robustness-2 Errors / Crashes during Differential Testing</h5><ul><li><p>简化转换是复杂的，确保转换不损害程序健壮性是具有挑战性的，无论是在生产前（即，S2S）、生产过程中（即，CBS）还是生产后（即，B2B、SL）实施的。</p></li><li><p>有缺陷或不完整的转换会对程序产生负面影响，表现为辑错误、运行时错误、崩溃，有时还可能引入新的漏洞。</p><ul><li>我们在基准性能测试（第4.2节）中，我们发现了大量的证据，其中36.6%的在我们的评估中生成的去膨胀二进制文件未能执行其保留的功能。</li></ul></li><li><p>这突显了简化后验证的重要性，这是简化工作流程中经常被忽视或完全留给用户的一个阶段，尤其是针对Type II膨胀的工具。</p><ul><li>一定程度上是由于缺乏有效的测试工具，如回归测试和模糊测试，并不自然地支持测试去膨胀程序与其原始版本之间的差异</li><li>为此，我们创建了一个针对转换后程序的差异测试工具，名为DIFFER，该工具结合了差异、回归和模糊测试方法的元素。</li></ul></li><li><p>DIFFER 允许用户指定与保留和简化功能对应的种子输入。它使用这些输入运行原始程序及其一个或多个简化变体，并比较它们的输出。</p><ul><li>DIFFER 期望对于保留功能的输入，原始程序和去膨胀程序的输出应该相同。</li><li>相反，它期望对于去膨胀功能的输入，原始程序和去膨胀程序的输出应该不同。</li><li>如果 DIFFER 检测到意外的匹配、差异或崩溃，它会向用户报告，供其检查。DIFFER 的报告可以帮助用户识别去膨胀工具配置中的错误或去膨胀程序不健全的实例。与所有动态分析工具一样，DIFFER 的报告可能存在误报的可能性。为了将误报率降到最低，DIFFER 允许用户定义自定义输出比较器，以考虑输出中的预期差异（例如，程序会为其控制台输出添加时间戳）。</li><li>此外，DIFFER 支持基于模板的变异模糊测试种子输入，以确保对去膨胀和保留功能的输入空间进行最大覆盖。</li><li>DIFFER 不能为去膨胀工具或其生成的去膨胀程序提供正式的健壮性保证。且不能对复杂程序的输入空间进行详细测试，但在验证中非常有用，因为其对用户友好，只需要适中的用户专业知识</li></ul></li><li><p>使用我们在第3.3节中创建的通用简化规范作为起点，我们配置了 DIFFER 来测试每个基准程序的保留和简化掉的功能。我们对成功完成性能测试的每个简化基准程序（共90个变体）运行了 DIFFER，最长达12小时，以识别简化过程中引入的崩溃、不一致性或错误，以及未能去除应该去除的功能。我们的<strong>结果令人担忧</strong>：</p><ul><li>DIFFER 发现了27.8%（90个中的25个）的简化基准中存在错误或崩溃</li><li>简化工具在其余的简化基准中未能去除应该简化掉的的功能，占60%（65个中的39个）。</li><li>在 DIFFER 的测试中通过的最终26个去膨胀基准中，有13个是由 Binary Reduce（静态）产生的，七个是由 libfilter 产生的，四个是由 LMCAS-SIFT 产生的，而 OCCAM 和 CHISEL 各自产生了一个。</li></ul></li><li><p>我们的评估中，50%（40个中的20个）的去除 Type I 膨胀尝试最终成功，而只有3.3%的去除 Type II 膨胀尝试成功（180个中的6个）。我们的结果表明，文献中对简化后验证的普遍忽视导致了对成功简化的过度报告。</p></li></ul><h3 id="5-%E8%AE%A8%E8%AE%BA%E5%92%8C%E5%85%B3%E9%94%AE%E5%8F%91%E7%8E%B0" tabindex="-1">5 讨论和关键发现</h3><ul><li><strong>工具成熟度</strong><ul><li>简化工具缺乏在实际软件上所需的成熟度<ul><li>所有工具在所有基准简化后上只有42.5%的成功率通过性能测试</li><li>在中高复杂基准上只有21%的成功率</li></ul></li><li>这表明当前的简化工具可能过于适应较低复杂性的基准，之后新的方法应该重点关注更复杂的软件和编程语言特性/范式</li></ul></li><li><strong>Soundness Issues</strong><ul><li>使用DIFFER进行正确性和健壮性测试时，在我们评估的十个工具中，只有两个工具，即静态和动态的简化二进制，没有产生不健全的简化二进制文件（即，DIFFER没有检测到任何崩溃、失败或在保留功能中的错误）。然而，之所以是健全的，是因为该工具没有成功地去膨胀任何功能，这得到了这个二进制文件在去膨胀后增加了大小的事实的支持。</li><li>其余的工具每个都产生了比原始程序更多的错误（除了BinRec-ToB，它没有产生任何去膨胀的二进制文件）</li><li>虽然我们的性能测试和DIFFER检测到的大部分健全性问题都是与保留功能有关的问题，但我们的结果还揭示了与简化功能相关的严重程序健全性问题。新的方法必须发展起来，以缝合被切除代码留下的空洞。在我们的调查中，我们只观察到一个具有此能力的工具：CARVE[11]</li></ul></li><li><strong>边际效益和安全收益</strong><ul><li>我们评估的所有工具都没有在除了小工具局部性外的性能或安全性上实现改进</li><li>一些工具确实缩小了静态二进制大小，但这些改进是通过激进的简化和去除静态链接实现的，这限制了缩小的实用性</li><li>考虑到上述成熟度和Soundness问题，我们认为用户可能会发现简化的好处没有超过成本和潜在风险</li></ul></li></ul><h3 id="6-%E7%BB%93%E8%AE%BA" tabindex="-1">6 结论</h3><ul><li>本文中，我们对软件简化生态进行了调查，在调查中我们创建了<ul><li>一个简化工具分类方法</li><li>16个评估指标</li><li>包含20个不同复杂性的基准程序</li></ul></li><li>我们评估比较了4类中10个不同的工具，评估标明<ul><li>当前一代简化工具存在缺陷，使之不能再实际软件上应用，具体来说<ul><li>简化工具对于中高复杂度的程序支持有限</li><li>简化过程中难以维系健全性和健壮性</li><li>在提高程序的性能和安全上成果有限</li></ul></li></ul></li><li>我们已经公开了我们的基准集，数据和自定义工具，以推动简化工具的进一步发展</li></ul><h3 id="7-availability" tabindex="-1">7 availability</h3><p><a href="https://github.com/trailofbits/debloater-eval">评估</a><br><a href="https://github.com/trailofbits/differ">Differ工具</a></p><h3 id="8-%E4%BB%93%E5%BA%93%E5%AD%A6%E4%B9%A0" tabindex="-1">8 仓库学习</h3><p><a href="https://github.com/trailofbits/debloater-eval">仓库地址</a></p><h4 id="%E7%9B%AE%E5%BD%95%E5%88%86%E6%9E%90" tabindex="-1">目录分析</h4><h5 id="benchmarks" tabindex="-1">benchmarks</h5><p>benchmarks：包含基准程序和基准工具（包括人工改造版本）</p><ul><li>benchmarks-debloated:基准工具（因为每个基准程序能用到的基准工具不同，所以按照基准程序分的文件夹,具体在result的表格中可以看到针对特定基准软件哪些工具无法使用）<ul><li>high</li><li>low</li><li>medium</li></ul></li><li>benchmarks:基准程序<ul><li>high<ul><li>imagemagick-7.0.1-0</li><li>nginx-1.23.3</li><li>nmap-7.93</li><li>poppler-0.60</li></ul></li><li>low：就是chiselbench中的10个util-core程序，指举一个例子<ul><li>bzip2-1.0.5<ul><li>binaries:包含其各个形式的二进制文件</li><li>lmcas，occam_x64_bin,trimmer_x64_bin:针对各个工具的特殊二进制</li><li>source：源代码<ul><li>merged：将源代码项目合成一个文件</li><li>original：原始源代码项目</li></ul></li></ul></li></ul></li><li>medium<ul><li>bftpd-6.1</li><li>binutils-2.27</li><li>lighttpd-1.4</li><li>make-4.2</li><li>memcached-1.6.18</li><li>tcpdump-4.99.3</li><li>wget-1.20.3</li></ul></li></ul></li></ul><h5 id="metrics" tabindex="-1">metrics</h5><p>metrics: 包括评估脚本（基准程序需要跑得）和评估性能指标</p><ul><li>performance-test<ul><li>original：这个目录包含在原始基准测试上运行性能测试并收集指标的文件。指标将保存到 binary_metrics.csv 中。 有README<ul><li>Dockerfile:镜像构造</li><li>run_perf_tests.py 自动化测试脚本（TODO分析）</li></ul></li><li>performance-benchmarks：基准使用的脚本，包含不同场景。 有README<ul><li>inputs 文件夹：包含各个软件的测试用例输入</li><li>lib 文件夹：包含各个软件的功能各个场景脚本，每个脚本名字即<code>基准名字.sh</code>，一个场景即脚本中的一个函数</li><li>剩余脚本为测试脚本，名字为<code>benchmark_&lt;基准名字&gt;.sh</code>,大多数脚本需要一个参数，即二进制文件路径，少部分脚本需要其他参数，可以使用<code>-h</code>查看详情<ul><li>测试脚本还包括激进版本，即<code>benchmark_aggressive_&lt;基准名字&gt;.sh</code>，即只包含单个功能</li></ul></li></ul></li></ul></li></ul><h5 id="results" tabindex="-1">results</h5><p>results：包含原始和精简的评估结果以及创建它们的脚本。</p><ul><li><p>Debloater Eval Results.xlsx : 包括所有评测结果的表格</p></li><li><p>Debloater Evaluation Knowledge Base.xlsx : 包含作者科研的知识步骤</p></li><li><p>metrics-calcs：包含与简化评估相关的脚本和数据，包括 GSA，DIFFER，Dynamic libraries and File Size</p><ul><li>scripts:用于运行实验和评估结果的通用Python脚本。</li><li>results<ul><li>gsa：包含GSA评估的结果</li><li>differ：包含DIFFER评估的结果</li><li>file-stats:动态连接库和文件大小的结果</li></ul></li><li>batches：只能每个批次运行的配置文件</li><li>eval-scripts：包含特定实验运行的脚本</li><li>environment：包含配置实验环境的脚本和dockerfile</li></ul></li><li><p>differ实验结果</p></li></ul><h5 id="scripts" tabindex="-1">scripts</h5><p>scripts：包含用于自动化评估不同部分的各种脚本（未维护）。</p><ul><li>build-binaries：包含用于构建二进制文件的脚本，使用py脚本，在docker中进行构建</li><li>debloater_eval:收集评估结果的脚本，输出为csv</li><li>tests：TODO了解</li></ul><h5 id="tools" tabindex="-1">tools</h5><p>tools：包括可重复构建的环境，用于托管工具和评估中使用的简化规范。</p><ul><li><ol><li>GTIRB To Static：用于静态地剪裁掉不可达的库和代码，利用了&quot;Reachable Reduce&quot;。</li></ol></li><li><ol start="2"><li>LMCAS-METIS：使用一个规范（spec）以及对源代码的修改来对其进行简化。</li></ol></li><li><ol start="3"><li>OCCAM：根据其 GitHub 描述，这是一个针对 LLVM 位代码的“整体程序偏特化器（whole-program partial evaluator）”，旨在对在特定部署环境中运行的程序和共享/静态库进行简化。</li></ol></li><li><ol start="4"><li>Trimmer</li></ol></li><li><ol start="5"><li>chisel-2：需要token</li></ol></li><li><ol start="6"><li>chisel：源代码简化工具，它使用一个 oracle 来引导基于增量调试的减小过程。</li></ol></li><li><ol start="7"><li>GTIRB To Dynamic：使用 gtirb-block-trace。</li></ol></li><li><ol start="8"><li>Libfilter(Nibbler):采用静态分析来检测程序及其共享库中未使用的函数调用。随后，它删除这些未使用的函数，生成一个精简的二进制文件。</li></ol></li><li><ol start="9"><li>razor：用DynamoRIO对二进制文件进行插装，从而删除测试套件未执行的指令。</li></ol></li><li><p>tool-debloating-specs：包含已经写好的规范</p></li></ul><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;sok%3A-a-broad-comparative-evaluation-of-software-debloating-tools&quot; tabindex=&quot;-1&quot;&gt;SoK: A Broad Comparative Evaluation of Software De</summary>
      
    
    
    
    <category term="论文" scheme="http://example.com/categories/%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="SoftwareEngineering" scheme="http://example.com/tags/SoftwareEngineering/"/>
    
    <category term="SoftwareDebloating" scheme="http://example.com/tags/SoftwareDebloating/"/>
    
  </entry>
  
  <entry>
    <title>复杂软件简化分析实验</title>
    <link href="http://example.com/2024/02/04/%E6%9C%AC%E7%A7%91/%E6%9C%AC%E7%A7%91%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E5%A4%8D%E6%9D%82%E8%BD%AF%E4%BB%B6%E7%AE%80%E5%8C%96%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C/"/>
    <id>http://example.com/2024/02/04/%E6%9C%AC%E7%A7%91/%E6%9C%AC%E7%A7%91%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/%E5%A4%8D%E6%9D%82%E8%BD%AF%E4%BB%B6%E7%AE%80%E5%8C%96%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C/</id>
    <published>2024-02-04T08:13:57.502Z</published>
    <updated>2024-02-04T08:13:57.502Z</updated>
    
    <content type="html"><![CDATA[<p>实验按照对每个工具运行每个基准</p><h2 id="razor" tabindex="-1">RAZOR</h2><ol><li>获取镜像<code>sudo docker pull chenxiong/razor:0.01</code></li><li>运行镜像<code>sudo docker run --name container_name -d -it chenxiong/razor:0.01</code></li><li>更新razor仓库</li><li>替换debian源为阿里源<code>sudo vim /etc/apt/sources.list</code></li></ol><pre><code class="language-bash">deb http://mirrors.aliyun.com/debian/ buster main non-free contribdeb http://mirrors.aliyun.com/debian/ buster-updates main non-free contribdeb http://mirrors.aliyun.com/debian/ buster-backports main non-free contribdeb http://mirrors.aliyun.com/debian-security buster/updates maindeb-src http://mirrors.aliyun.com/debian/ buster main non-free contribdeb-src http://mirrors.aliyun.com/debian/ buster-updates main non-free contribdeb-src http://mirrors.aliyun.com/debian/ buster-backports main non-free contribdeb-src http://mirrors.aliyun.com/debian-security buster/updates main</code></pre><ol start="5"><li>下载Clang <code>apt install clang</code></li></ol><h3 id="nginx" tabindex="-1">nginx</h3><h3 id="lighttpd" tabindex="-1">lighttpd</h3><p><a href="https://redmine.lighttpd.net/projects/lighttpd/wiki/InstallFromSource">从源码编译步骤</a></p><ol><li>克隆并更新仓库</li></ol><pre><code class="language-bash"># initial checkoutgit clone https://git.lighttpd.net/lighttpd/lighttpd1.4.gitcd lighttpd1.4# subsequent updates (to obtain latest source)#cd lighttpd1.4git pull</code></pre><ol start="2"><li>更新依赖 <code>apt-get build-dep lighttpd</code></li><li>automake</li></ol><pre><code class="language-bash">#cd lighttpd1.4./autogen.shCC=clang ./configure -C --prefix=/usr/local  # ./configure --help for additional optionsmake -j 4make check</code></pre><ol start="4"><li>出现问题</li></ol><pre><code class="language-bash">configure: error: pcre2-config not found, install the pcre2-devel package or build with --without-pcre2</code></pre><p>解决方法：<code>apt install libpcre2-dev</code></p><ol start="5"><li>编译完成后，在<code>src</code>目录下生成<code>lighttpd</code>可执行文件</li><li>结合<code>razor</code>运行</li></ol><h3 id="nmap" tabindex="-1">nmap</h3><ol><li><a href="https://nmap.org/dist/">下载位置</a></li><li><a href="https://nmap.org/book/inst-source.html">按照指导编译</a></li><li>使用clang编译</li></ol><pre><code class="language-bash">CC=clang CXX=clang++ ./configuremake</code></pre><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;实验按照对每个工具运行每个基准&lt;/p&gt;
&lt;h2 id=&quot;razor&quot; tabindex=&quot;-1&quot;&gt;RAZOR&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;获取镜像&lt;code&gt;sudo docker pull chenxiong/razor:0.01&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;运行镜像</summary>
      
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="SoftwareEngineering" scheme="http://example.com/tags/SoftwareEngineering/"/>
    
    <category term="SoftwareDebloating" scheme="http://example.com/tags/SoftwareDebloating/"/>
    
  </entry>
  
  <entry>
    <title>用户研究论文阅读</title>
    <link href="http://example.com/2024/01/22/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E7%94%A8%E6%88%B7%E7%A0%94%E7%A9%B6%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>http://example.com/2024/01/22/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E7%94%A8%E6%88%B7%E7%A0%94%E7%A9%B6%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</id>
    <published>2024-01-22T15:21:47.043Z</published>
    <updated>2024-01-22T15:21:47.043Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1.-trust-enhancement-issues-in-program-repair" tabindex="-1">1. Trust Enhancement Issues in Program Repair</h2><p>2022 IEEE/ACM 44th International Conference on Software Engineering (ICSE)</p><h3 id="00-%E6%91%98%E8%A6%81" tabindex="-1">00 摘要</h3><ul><li>自动化程序修复既是是一项新兴技术,通过学习、搜索和语义分析来自动修复程序中的错误和漏洞。</li><li>然而为了该技术更广泛的使用,对自动生成的补丁的信任是必要的,为此本文对100多位开发人员进行类调查,以了解他们对自动化程序修复的信任问题。</li><li>根据开发者偏好的调查反馈，我们对现有的基于测试套件的程序修复工具进行了定量评估。我们发现它们无法在一个小时的可接受时间范围内生成排名前10的高质量补丁。</li><li>我们的定性研究中开发者的反馈以及对现有修复工具的定量考察观察结果指出了推动程序修复研究的可行见解。具体而言，我们注意到在可接受的时间限制内生成修复补丁很大程度上取决于利用足够丰富的搜索空间的抽象表示</li><li>此外，尽管开发者的额外输入对于生成或排名补丁很有价值，但他们似乎对于大规模的人机交互并不感兴趣。</li></ul><h3 id="01-%E4%BB%8B%E7%BB%8D" tabindex="-1">01 介绍</h3><ul><li><p>令人惊讶的,无论学术界还是工业界,有关开发者对自动化程序修复信任的研究几乎没有(软件去膨胀也是一样)</p></li><li><p>我们希望研究开发者 不愿意使用程序修复的原因 是不是在于 不想依赖于自动生成的代码;这会有深远的影响,因为最近LLM的出现为自动生成代码完成工作带来了希望</p></li><li><p>本文中研究了如何增强开发者对自动生成的补丁的信任的问题,首先确定了与开发者对自动生成的补丁的信任相关的研究问题,分为两个类别</p><ul><li>a. 开发者对自动修复技术的期望,为此研究一下问题<ul><li>RQ1:开发者对应用自动化程序修复（以下简称APR）的兴趣程度有多大，以及他们如何设想使用它？</li><li>RQ2:软件开发人员可以提供额外的输入来增加对生成的补丁的信任度吗？</li><li>RQ3:自动程序修复（Automated Program Repair，APR）产生的补丁能增加开发者的信任的证据有哪些？</li></ul></li><li>b. 现有程序修复技术在满足开发者期望方面可能存在的不足,<ul><li>RQ4:现有自动修复技术能否在可接受的时间范围内(0.5/1/2 小时)确定高质量补丁的位置</li><li>RQ5:在APR的效率上,额外的输入(例如修复位置和额外的测试案例)会带来什么影响</li></ul></li></ul></li><li><p>对于a,我们在100多名专业软件开发人员中进行调查（共有35个问题）,多数为开发人员,少数为高级人员如架构师.结果显示</p><ul><li>开发人员对使用APR生成的少量(不超过10个)补丁持开放态度,但这些补丁要在可接受的时间范围内生成</li><li>此外开发人员愿意接受程序修复方法的标准(可以证明程序修复的正确性),同时也愿意提供额外的输入来推动APR的发展</li><li>开发人员最接受的额外输入是额外的测试用例</li></ul></li><li><p>对于b</p><ul><li>在我们的实验中会严格要求时间不超过1小时</li><li>同时对著名的修复工具进行比较和定量分析,得出结论:搜索空间的表示在在可接受的时间范围内产生合理/正确的补丁中很重要</li><li>最后,我们注意到APR可以视为微观层面的自动代码生成,通过研究APR的信任问题,我们也可以初步了解如何增强自动生成代码的信任</li></ul></li></ul><h3 id="02-%E7%A8%8B%E5%BA%8F%E4%BF%AE%E5%A4%8D%E4%B8%AD%E7%9A%84%E8%A7%84%E8%8C%83" tabindex="-1">02 程序修复中的规范</h3><ul><li><p>本段回顾这些规范讨论他们如何影响补丁的质量</p></li><li><p>测试套件即规范 Test Suites as Specification.</p><ul><li>修复目标:通过测试组件中所有测试用例来修复程序</li><li>问题:带来过拟合,因为测试套件可能不完整</li></ul></li><li><p>约束即规范 Constraints as Specification</p><ul><li>修复目标:修补程序使满足给定的约束</li><li>问题:实际中不能总是可以得到约束条件;同时满足约束后的程序不一定和源程序功能相同</li></ul></li><li><p>代码样式即规范 Code Patterns as Specification</p><ul><li>问题:不能满足功能的正确性</li></ul></li></ul><h3 id="03-%E8%B0%83%E6%9F%A5%E6%96%B9%E6%B3%95" tabindex="-1">03 调查方法</h3><ul><li><p>不可靠的过拟合补丁会导致开发人员对APR工具失去信任。这促使我们询问/调查开发人员如何增强APR以获得他们的信任。我们设计并进行了一项针对软件从业者的调查，旨在回答前三个研究问题（RQ1-3）。</p></li><li><p>调查询问35个问题,分为6类,问题包括 开放性和封闭性问题的组合,采用多项选择或5点李克特量表,问卷使用Microsoft Forms创建和部署</p><ul><li>C1 APR的使用情况（RQ1）：开发人员是否会使用APR，以及如何使用。</li><li>C2 输入/规范的可用性（RQ2）：开发人员可以为APR技术提供哪些类型的输入工件。</li><li>C3 对信任的影响（RQ2）：额外的输入将如何影响对自动生成的补丁的信任。</li><li>C4 解释（RQ3）：开发人员期望自动生成的补丁提供哪些证据/解释。</li><li>C5 APR副产品的使用情况（RQ3）：APR的哪些副产品对开发人员有用，例如用于手动修复错误。</li><li>C6 背景：参与者在软件开发过程中的角色和经验。</li></ul></li><li><p>通过两个渠道发放调查问卷 (1) Amazon Mturk,(2)向全球公司联系人放松私人链接. 随后对回复进行过滤,最终得到了103个有效的回复</p></li><li><p>分析措施:略</p></li></ul><h3 id="04-%E8%B0%83%E6%9F%A5%E7%BB%93%E6%9E%84" tabindex="-1">04 调查结构</h3><h4 id="4.1-developer-engagement-with-apr-(rq1)-%E5%BC%80%E5%8F%91%E8%80%85%E5%9C%A8apr%E7%9A%84%E5%8F%82%E4%B8%8E" tabindex="-1">4.1 Developer engagement with APR (RQ1) 开发者在APR的参与</h4><ul><li><p>本部分研究C1类</p></li><li><p>APR的接受度:</p><ul><li>额外的用户提供的文档，如测试用例，有助于增加对自动生成的补丁的信任。</li><li>但完全的开发者信任需要进行开发者手动的补丁审查,自动化动态和静态分析的测试报告，以及对补丁的解释，可以促进审查工作的进行。</li></ul></li><li><p>APR的交互</p><ul><li>开发者期望与APR的交互量较少，例如仅提供初始文档，测试用例。</li><li>APR应该能够在较短的时间内（30分钟至60分钟内）生成少量（5到10个）的补丁</li><li>APR应该要集成到现有的DevOps流程中，以支持开发工作流程。</li></ul></li></ul><h4 id="4.2-availability%2Fimpact-of-artifacts-(rq2)-%E6%96%87%E6%A1%A3%E7%9A%84%E5%8F%AF%E7%94%A8%E6%80%A7%2F%E5%BD%B1%E5%93%8D" tabindex="-1">4.2 Availability/Impact of Artifacts (RQ2) 文档的可用性/影响</h4><ul><li>本部分研究C2,C3类,调查开发者可以提供哪些额外的文档,以及这些文档对APR信任的影响:额外的测试用例,程序断言,逻辑约束</li><li>此外,参与者希望和工具交互较少,但如果工具提出了一些问题,开发者愿意提供额外的输入</li><li>大多数参与者认为出</li></ul><h4 id="4.3-%E8%A1%A5%E4%B8%81-%E7%9A%84%E8%A7%A3%E9%87%8A%2F%E8%AF%81%E6%8D%AE" tabindex="-1">4.3 补丁 的解释/证据</h4><h3 id="05-%E8%AF%84%E4%BC%B0%E6%96%B9%E6%B3%95" tabindex="-1">05 评估方法</h3><h3 id="06.-%E8%AF%84%E4%BC%B0%E7%BB%93%E6%9E%9C" tabindex="-1">06. 评估结果</h3><h4 id="6.1-apr-within-realistic-boundaries-apr-%E5%9C%A8%E7%8E%B0%E5%AE%9E%E8%8C%83%E5%9B%B4%E5%86%85(rq4)" tabindex="-1">6.1 APR within realistic boundaries APR 在现实范围内(RQ4)</h4><h4 id="6.2-impact-of-additional-inputs-%E9%A2%9D%E5%A4%96%E8%BE%93%E5%85%A5%E7%9A%84%E5%BD%B1%E5%93%8D(rq5)" tabindex="-1">6.2 Impact of additional inputs 额外输入的影响(RQ5)</h4><h3 id="07-threats-to-validity-%E5%AF%B9%E6%9C%89%E6%95%88%E6%80%A7%E7%9A%84%E5%A8%81%E8%83%81" tabindex="-1">07 THREATS TO VALIDITY 对有效性的威胁</h3><h3 id="08-%E7%9B%B8%E5%85%B3%E5%B7%A5%E4%BD%9C" tabindex="-1">08 相关工作</h3><h3 id="09-%E8%AE%A8%E8%AE%BA" tabindex="-1">09 讨论</h3><ul><li><p>在本文中，我们研究了提高开发人员对自动生成的补丁的信任度所涉及的问题。</p><ul><li>通过与100多名实践者的详细研究，我们探讨了开发人员对自动化程序修复工具的期望和容忍程度。</li><li>然后，我们对现有的修复工具进行定量评估，以模拟新手APR用户的经验。我们的定性和定量研究表明，需要探索的方向包括：减少与修复工具的交互、交换生成的测试用例等作为输入和修复工具输出的工件，以及关注抽象搜索空间表示而不是搜索算法框架。每个修复工具都有许多参数，我们只使用了默认参数设置，就像新手用户所期望的那样——我们没有探索各种参数设置。为了了解修复工具的全部功能，未来有必要系统地探索大量的参数设置，并尝试使用不同的超时时间来运行这些工具。</li></ul></li><li><p>自动化代码生成越来越火,但我们是否可以信任这种自动生成的代码,这将是一个吸引人的研究</p></li></ul><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1.-trust-enhancement-issues-in-program-repair&quot; tabindex=&quot;-1&quot;&gt;1. Trust Enhancement Issues in Program Repair&lt;/h2&gt;
&lt;p&gt;2022 IEEE/ACM 44t</summary>
      
    
    
    
    <category term="论文" scheme="http://example.com/categories/%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="SoftwareRepair" scheme="http://example.com/tags/SoftwareRepair/"/>
    
  </entry>
  
  <entry>
    <title>Software Debloating 论文阅读 （11）</title>
    <link href="http://example.com/2024/01/22/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/SoftwareDebloating/Software%20Debloating%20%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB(11)/"/>
    <id>http://example.com/2024/01/22/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/SoftwareDebloating/Software%20Debloating%20%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB(11)/</id>
    <published>2024-01-22T15:21:47.041Z</published>
    <updated>2024-01-26T09:37:20.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="occam-v2%EF%BC%9A" tabindex="-1">OCCAM-v2：</h2><p>Navas J A, Gehani A. OCCAM-v2: Combining Static and Dynamic Analysis for Effective and Efficient Whole-program Specialization: Leveraging scalable pointer analysis, value analysis, and dynamic analysis[J]. Queue, 2022, 20(5): 58-85.</p><h3 id="0-%E6%91%98%E8%A6%81" tabindex="-1">0 摘要</h3><ul><li>软件已发展到可以支持多样的功能集。灵活的软件工程实践，如为重用行设计而引入的冗余代码。在更常见的模式中，整个库被链接，然而实际上只需要其中的少数功能。这些额外代码的积累可能会对只需要访问功能子集的应用程序产生负面影响。</li><li>嵌入式系统通常只有有限的内存，不必要的代码占用的空间回增加成本并对性能产生不利影响。云计算平台可能会因为臃肿的代码增加内部攻击面，通过 return-oriented programming，jump-oriented programming，和call-oriented programming等机制</li><li>随着配置参数的增加，程序的轨迹空间呈指数增长。这使得全面测试成本的增加，这次进了全程序特化的需求，这可以将程序分析集中在将要部署的特定版本上</li><li>由于LLVM中间代码可以编译多种源语言，目前已经有一些工具来特化LLVM bit码，包括OCCAM[13]，LLPE[20]，Trimmer[19]. 然而，它们只能使用编译器转换来完成任务，相比之下，我们的工具OCCAM-v2，结合了更深入的静态分析，实用抽象解释框架，以及鼎泰分析。这种组合提供了更好的结果。</li><li>OCCAM-v2是我们之前工具OCCAM的扩展。将自动化构建复杂bit码的功能分解为一个单独的工具gllvm[8]。本文首先提供关于OCCAM的相关背景，然后描述其静态分析扩展，这些扩展提供了与OCCAM相同的健全性保证。接下来，将解释了使用了动态分析的可选的激进特化，最后报告了在一组应用程序上评估该工具的结果。</li></ul><h3 id="1-%E8%83%8C%E6%99%AF" tabindex="-1">1 背景</h3><ul><li>OCCAM-v1 使用部分估值法来简化大的应用和他们的依赖，如下图示（虚线框内的组件是 OCCAM-v2 中新增的。）</li><li>具体而言，OCCAM 允许将静态信息通过一个包含特定环境细节的专用清单传递给目标程序的入口。该工具工作在LLVM bit码上，这是一个中间表示，可以从多种源语言编译。</li></ul><p><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(11)_1.png" alt></p><ul><li>每个模块的函数和调用点被计算并保存在外部接口定义中，利用这个信息，OCCAM接着搜索具有具体参数的跨模块调用，如果找到这样一个调用，将根据策略确定是否需要特化该函数。 当这种情况发生时，会构建新函数的代码并将其添加到相关的LLVM位代码模块中，相应的接口将被更新以反映新函数的特征；具有相同签名的其他调用点将使用特化版本</li><li>OCCAM从程序入口出发，并使用应用程序清单所提供的任何静态信息。然后对包含在main中的调用点所识别的函数模块进行特化，该过程一直持续到找到所有可达模块。在每个步骤中，调用LLVM的内部优化。特别是，使用全局优化器进行进行常量折叠和传播，去除死代码，修建未使用的分支和不可达代码，这也是OCCAM的模块内特化。</li><li>由于这个过程可能会发现新的特化机会，所以整个过程将持续到能够达到全局稳态。通过这种方式，OCCAM能够完成整个程序的特化，在最后一步，OCCAM调用LLVM的编译器将位码转换为本机对象，并调用链接器生成特化的本机应用。</li></ul><h3 id="2-%E6%89%A9%E5%B1%95%E7%9A%84%E7%9A%84%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90" tabindex="-1">2 扩展的的静态分析</h3><ul><li>OCCAM-v2 的静态分析改进源于它引入了自定义指针分析和值分析。这两者都基于抽象解释。</li><li>LLVM 的 PoolAlloc DSA（数据结构分析）可以被OCCVM-v2使用来解析间接函数调用以及其他指针。</li><li>OCCAM-v2 使用了改进的 DSA 变种计算的调用图：开源的类型敏感指针分析工具 SeaDSA。</li></ul><h4 id="2.1-%E6%9B%B4%E7%B2%BE%E7%A1%AE%E7%9A%84%E8%B0%83%E7%94%A8%E5%9B%BE%E6%9E%84%E9%80%A0" tabindex="-1">2.1 更精确的调用图构造</h4><h5 id="%E8%B7%A8%E6%A8%A1%E5%9D%97%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%94%B9%E8%BF%9B" tabindex="-1">跨模块接口的改进</h5><ul><li>为了支持对大型软件的应用，OCCAM一次只对一个模块进行操作。<ul><li>然而为了促进整个程序的分析，对一个模块的更改必须意识到该模块与其它代码的交互。</li><li>通过对每个模块构建一个接口来实现这一点，该接口在更新其它模块的过程中使用。</li><li>特别地，接口提供了在模块内使用的外部符号和调用的描述。</li></ul></li><li>OCCAM-v1中，接口生成使用了LLVM计算的调用图，OCCAM-v2 使用了由 SeaDSA 计算的调用图。这个调用图比LLVM的更精确。<ul><li>这反过来提高了模块接口的特异性，从而优化了跨模块的特化</li><li>当一个模块的接口被计算出，它刚开始包括所有的非内部链接调用点（因此可以跨模块调用）。</li><li>此外，到达函数的来自其它模块调用的调用点也会被识别出来</li><li>这些调用是在间接的情况下，目标可以是任何函数，使用已经解析的调用图，OCCAM-v2减少了可能的集合</li></ul></li></ul><h5 id="%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%8F%82%E6%95%B0" tabindex="-1">处理函数指针参数</h5><ul><li>当对一个在模块外的函数进行调用时，其签名会出现在包含调用方的模块的接口中</li><li>当调用点包含一个常量参数时，可以对调用进行特化；如果参数是一个函数指针，OCCAM 仅限于使用 null 值的情况，这无法处理将函数作为参数按引用传递的情况</li><li>OCCAM-v2 支持对具有函数指针参数的外部调用进行特化。如果在调用方的上下文中函数接受一个或多个常量参数，那么该函数现在也可以被专门化。这是特别值得注意的，因为它涵盖了常见的编程模式，如回调函数的使用。</li></ul><h5 id="%E5%9F%BA%E4%BA%8E%E7%AD%BE%E5%90%8D%E7%9A%84%E5%80%99%E9%80%89%E8%B0%83%E7%94%A8%E6%B6%88%E9%99%A4" tabindex="-1">基于签名的候选调用消除</h5><ul><li>使用DSA会导致对实际程序的调用图的过度估计，因为DSA忽略了函数调用参数的类型，因此，具有与调用点签名不匹配的函数可能被错误地认为是有效候选函数</li><li>为解决这个问题，通过SeaDSA地的指针分析，将间接调用替换为一个switch语句，其中每个case对应一个候选地址，此后生成的调用图将不含间接调用<ul><li>在某些情况下，调用点和候选函数地址的签名可能不匹配，该分析可以根据参数类型正确地过滤出这种情况</li></ul></li></ul><h5 id="%E5%9F%BA%E4%BA%8E%E7%B1%BB%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E7%9A%84%E5%80%99%E9%80%89%E8%B0%83%E7%94%A8%E6%B6%88%E9%99%A4" tabindex="-1">基于类层次分析的候选调用消除</h5><ul><li>当间接调用解析为一组候选地址时，生成的调用图与原程序的调用图相比不够精确，通过减少候选集可以提高之后静态分析的精度。如果LLVM比特码的实例源于用C++编写的程序，则可以使用CHG（class hierarchy graph 类层次图）来提高分析的精度</li><li>OCCAM-v2构建了一个CHG，其节点是一个C<ins>类，两类之间的边表示父子类。CHG用于解析C</ins>虚拟函数的间接调用（指针分析支持C++虚拟调用，但是CHG通常可以通过分析从LLVM比特码中提取的虚拟表的信息来细化SeaDSA的推断）</li><li>对于来自C++程序的虚拟调用的调用点，执行以下步骤<ul><li><ol><li>确定包含调用方法的对象所关联的类C</li></ol></li><li><ol start="2"><li>计算所有直接或间接派生的C类的子类（CHG可用时该步骤可很快得到）</li></ol></li><li><ol start="3"><li>使用每个子类的虚拟表，手机所有具有与步骤1中提到的被调用方法匹配的类型签名的方法（通过检查比特码构造类的虚拟表）</li></ol></li></ul></li><li>此时，对于一个间接调用，所有来自虚拟调用的可能的调用被找到，这将允许使用该调用集合的间接调用被解析。</li></ul><h5 id="%E5%9F%BA%E4%BA%8E%E5%88%AB%E5%90%8D%E5%88%86%E6%9E%90%E7%9A%84%E4%BC%98%E5%8C%96" tabindex="-1">基于别名分析的优化</h5><ul><li>LLVM框架提供了AliasAnalysis基础结构。<ul><li>该客户端的API可以查询两个LLVM值是否为别名，这对于在优化目标代码时，两个值不能指向相同位置的变换非常有用。 实现必须对内存建模并支持回答这些查询</li></ul></li><li>SeaDSA实现了AliasAnalysis的API，这使得OCCAM-v2可以使用整个LLVM passes套件来增加指向信息的精度。</li><li>改进的别名分析也促进了其它优化，如死存储消除，可以帮助静态变量的识别</li></ul><h4 id="2.2-%E6%9D%83%E5%80%BC%E5%88%86%E6%9E%90%E7%9A%84%E4%BD%BF%E7%94%A8" tabindex="-1">2.2 权值分析的使用</h4><ul><li>OCCAM在简化软件时使用死代码消除，简化算法的核心依赖于构建从变量到常量的映射，这意味着该变量在所有可能的程序执行中都具有可以识别的常量值。<ul><li>为了创建更多的特化机会，OCCAM-v2构建了从变量到区间的映射，这将使得分支推理依赖于变量的值的范围</li></ul></li><li>抽象解释Abstract interpretation 是一种程序进行形式推理的常用技术，是静态分析设计的数学基础。<ul><li>该技术的一个经典用途是推断每个程序变量可以取地可能的值。这些可能的值使用不同的方式进行近似（称为抽象域）：区间最大最小值；两个变量间的差异；八角形约束；变量间地线性不等式</li></ul></li><li>尽管该分析很强大，但在LLVM中不可用。<ul><li>原因之一是大多数实现只考虑整数，而LLVM中的整数为机器算术。将这种分析调整为可以在机器算术中的工作是具有挑战性的，因为很难在精度和效率之间找到良好的平衡</li></ul></li></ul><h5 id="%E6%8E%A8%E6%96%AD%E4%B8%8D%E5%8F%98%E9%87%8F" tabindex="-1">推断不变量</h5><ul><li>C++库Crab7支持使用抽象解释对程序进行静态分析<ul><li>Crab在目标程序的CFG（控制流图）上进行操作，该形式语言无关</li><li>Clam4前端将LLVM IR转换为Crab的表示形式，随后使用Crab来推断目标程序中的不变量，通常接着进行常量传播和死代码消除（使用LLVM passes优化）。 已识别出的不变量可以让passes作出更强的假设，达到更好的优化</li></ul></li></ul><h5 id="%E5%AD%97%E6%AE%B5%E6%95%8F%E6%84%9F%E7%9A%84%E5%B8%B8%E9%87%8F%E4%BC%A0%E6%92%AD" tabindex="-1">字段敏感的常量传播</h5><ul><li>OCCAM的模块内特化依赖于LLVM的SCCP (sparse conditional constant propagation)。<ul><li>这个pass在分析时受到限制，因为其设计是 为了效率，在编译器的工作流程中使用</li><li>特别是，如果常量存储在C数组或结构体字段中,SCCP无法识别这个静态数据</li></ul></li><li>Clam 依赖于SeaDSA的字段敏感推理来维护内存的抽象表示。<ul><li>SeaDAS将内存划分为有限的区域，每个区域映射到一个逻辑数组，此时，区域由一个逻辑表达式建模，该表达式描述了受内存访问操作影响的位置。这使得能够有效地推理关于由SeaDSA处理的内存的情况，其中包括别名分析。</li></ul></li><li>当LLVM位码转化为crab的CFG时，内存存储被建模位弱更新（知道受影响区域但确切位置不知道）。clam为若更新定义了一个抽象与，crab在CFG推理时使用。<ul><li>虽然在域中推理是高效的，但不够精准，为了提高精准度，特别在结果体字段的情况下，开发了一种新的抽象域。其提供了混合抽象，这里在特殊情况下，内存被建模为强更新（将旧值替换为新值）</li></ul></li></ul><h5 id="%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E5%88%86%E6%9E%90%E7%9A%84%E4%BC%98%E5%8C%96" tabindex="-1">函数内部分析的优化</h5><ul><li>对不变量的了解有助于编译器优化，提高了OCCAM-v2的特化和消除目标应用程序及其依赖中代码片段的能力。</li><li>为此，我们开发了一种上下文敏感的构成分析，提供了比基础型更高的精准度。</li><li>为了提高性能，增加对函数内部分析备忘录。 尽管可能导致内存的额外消耗，但可以通过限制备忘录大小随后同构循环利用解决</li></ul><h3 id="3-%E9%9B%86%E6%88%90%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%86%E6%9E%90" tabindex="-1">3 集成的动态分析</h3><ul><li>作为在线部分求值器，OCCAM依赖于具体的已知的代码简化。<ul><li>这些信息的一个重要来源是用户指定的参数集，在实践中，这些参数由类似于getopt()的功能在程序入口附近处理。</li><li>这样的代码通常在循环中处理复杂字符串操作，此外，循环的界限可能不是静态的，这对静态分析技术构成了挑战</li></ul></li><li>OCCAM-v2的DCA（deployment context analysis）将特化分为两个阶段<ul><li>从概念上讲，目前程序的执行跟踪为第一阶段的前缀，使用动态分析计算，同时在第一阶段后缀也有，用于代表第一阶段未执行的程序</li><li>动态分析从程序入口开始，只要仍处在关键的混合状态，动态分析就要继续。具体来说，任何分支选择必须取决于已知的值</li><li>内存快照是前缀执行结束时的程序状态。它用于使用静态分析简化后缀。</li></ul></li><li>这个功能是通过修改LLVM的解释器lli来实现的。这个新的passes与lli有三个不同之处：<ul><li><ol><li>当遇到虚拟寄存器或在栈或堆上分配的内存位置的值，在执行期间可能是未知的。例如，程序可能使用第一个参数的值（在C中称为argv[1]），但在运行时用户可能在调用程序时没有提供任何参数。在这种情况LLVM解释器将中止执行。相反，新的pass将移动到下一个位代码指令并继续解释。</li></ol></li><li><ol start="2"><li>当遇到值未知的寄存器或内存位置时，新的传递将跟踪此事实。当后续指令依赖于未知值时，其结果也将被跟踪为未知。通过这种方式，新功能提供了一种轻量级的绑定时间分析，将动态值的污点向前传播。</li></ol></li><li><ol start="3"><li>在解释的位代码指令是依赖于未知值的条件时，执行将被停止。这使得程序可以在分支存在的情况下继续运行，只要可以评估它们。停止执行的条件是为了避免探索潜在的指数级状态空间，如果必须跟踪依赖于未知值的分支，将会导致这种情况发生。</li></ol></li></ul></li></ul><h4 id="%E9%80%89%E9%A1%B9%E5%A4%84%E7%90%86" tabindex="-1">选项处理</h4><h4 id="%E5%A4%9A%E6%A8%A1%E5%9D%97%E5%8A%A8%E6%80%81%E5%88%86%E6%9E%90" tabindex="-1">多模块动态分析</h4><h4 id="%E4%BF%9D%E5%AE%88%E6%8E%92%E9%99%A4" tabindex="-1">保守排除</h4><h4 id="%E5%8F%98%E9%87%8F%E5%87%BD%E6%95%B0" tabindex="-1">变量函数</h4><h4 id="%E5%A4%84%E7%90%86%E7%AE%97%E6%9C%AF%E5%86%85%E5%9C%A8%E5%87%BD%E6%95%B0" tabindex="-1">处理算术内在函数</h4><h4 id="%E6%9A%B4%E9%9C%B2%E5%B0%81%E8%A3%85%E7%9A%84-libc-%E8%B0%83%E7%94%A8" tabindex="-1">暴露封装的 libc 调用</h4><h3 id="4-%E8%AF%84%E4%BC%B0" tabindex="-1">4 评估</h3><ul><li>使用20个应用软件，是Trimmer中使用的，在Trimmer中有解释原因</li><li>Ubuntu 18.04 ，LLVM 10</li></ul><h4 id="effectiveness-%E6%95%88%E6%9E%9C" tabindex="-1">Effectiveness 效果</h4><ul><li>程序被编译成LLVM位码，随后位码中指令的数量。</li><li>分别计算 仅使用静态分析的OCCAM-v2，使用静态分析和动态分析的OCCAM-v2 删除指令的百分比<ul><li>每种情况下，特化上下文于Trimmer评估中的上下文相同。</li></ul></li><li>从数据中可以看出，OCCAM-v2动态分析和静态分析结合总是比单独使用静态分析可以删除更多的指令，平均而言，OCCAM-v2的混合分析可以删除原程序40.6%的LLVM IR指令<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(11)_2.png" alt></li></ul><h4 id="efficiency-%E6%95%88%E7%8E%87" tabindex="-1">Efficiency 效率</h4><ul><li>OCCAM-v2的静态分析被设计为 支持大规模且高效，必要时可以牺牲精度来换取效率。具体来说<ul><li>所使用的指针分析基于Bjarne Steensgard的算法</li><li>抽象解释框架配置为仅使用计算上高效的推理域，包括布尔值、区间和步幅</li><li>因此当使用静态分析模式时，平均特化时间为6.7s</li></ul></li><li>与Trimmer进行对比，其使用基于Lars Andersen的算法的指针分析（在SVF框架中实现）来选择精度而非可伸缩性。这一效果可以在配置注释通行证的成本中看到。<ul><li>对于Trimmer分析时间最长的三个程序，它们分别是objdump、yices和gprof，其分别使用了41.4、23.6和16.3分钟。</li><li>相比之下，OCCAM-v2对这三个程序进行的整个基于静态分析的专门化分别在34、34和27秒内完成。</li></ul></li><li>下图展示了每个程序的特化时间，其中包括静态分析和混合分析的时间。注意时间刻度为指数增长<ul><li>对于大多数程序，两种方法时间相似，bzip2例外，因为特化被配置为利用目标文件的内容，需要解释器遍历整个运行，尽管有此异常值，混合分析特化平均时间为22.4s<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(11)_3.png" alt></li></ul></li></ul><h3 id="5-%E9%99%90%E5%88%B6%E5%92%8C%E7%BC%93%E8%A7%A3%E6%8E%AA%E6%96%BD" tabindex="-1">5 限制和缓解措施</h3><h4 id="%E6%95%B4%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%81%87%E8%AE%BE" tabindex="-1">整个程序假设</h4><ul><li>OCCAM假设在特化时可以访问“整个程序”——即目标应用程序及其所有依赖的所有代码。这使得其能够把整个程序中调用的任何代码都可以作为待删除项，这种方法对许多程序有效，但并非对所有程序都适用。</li><li>存在多种原因导致这种担忧。<ul><li>一个重要的情况是，一个对象的源代码必须链接到程序中，但只能以汇编的形式提供。在这种情况下，OCCAM的分析将不会意识到在这样的对象中对外部全局变量的任何函数调用或访问，因为汇编不能构建成LLVM位代码。因此，OCCAM可能会删除所需的符号和函数。我们在musl libc和Linux内核中都遇到过这种情况。</li><li>在没有汇编的情况下，也可能发生类似的情况——例如，Apache根据其配置文件动态加载模块。这些模块可能会引入反向依赖性，即主程序包含特定函数的假设，这些函数可能已经基于对它们的调用缺失而被删除。为了解决这些情况，我们在OCCAM-v2中添加了对指定一组不应被内部化的函数和全局变量的支持。这样可以防止死代码消除删除这些元素</li></ul></li></ul><h4 id="%E9%93%BE%E6%8E%A5%E6%97%B6%E7%AC%A6%E5%8F%B7%E5%86%B2%E7%AA%81%E6%8E%AA%E6%96%BD" tabindex="-1">链接时符号冲突措施</h4><ul><li>OCCAM在模块内迭代执行常量传播和死代码消除，以及跨模块的函数特化。当达到一个固定点时，特化的模块被链接在一起。在这个阶段，模块中的符号可能会发生冲突。</li><li>符号冲突可能发生在应用程序中使用了相同的符号，以及它的一个库中使用了相同的符号，或者在多个库中定义了相同的符号。特化函数的命名方案最大程度地减少了新冲突可能性。OCCAM-v2通过一个中间步骤解决了这个问题。链接在内部进行分阶段，允许在参数中指定的位代码文件中的符号覆盖后续的重复符号。使用llvm-link构建中间链接的位代码文件，然后使用clang++将其与在清单中指定的本机库链接。</li></ul><h3 id="6-%E6%9C%AA%E6%9D%A5%E6%96%B9%E5%90%91" tabindex="-1">6 未来方向</h3><ul><li><strong>后缀简化</strong><ul><li>在完成第一阶段后，内存快照包含两种类型的状态。<ul><li>第一种类型包括寄存器中的值，可以安全地用于简化后缀。这种简化包括使用LLVM内部的优化，以及由于Crab在配置的域上的抽象解释而可能的优化。</li><li>第二种类型包括内存中的值。为了使用这些值，有两种选择。一种方法识别通常情况下安全的特殊情况。第二种方法涉及使用指针分析以确保后缀简化的合理性。由于这会产生显著的计算成本，因此尚未纳入。在未来，可以添加对此的支持，用户将需要在愿意在特化过程中承担开销的情况下显式激活它。</li></ul></li></ul></li><li><strong>减少过度特化</strong><ul><li>DCA依赖一个事实，即前缀是目标应用程序将根据特定输入始终执行的路径。这种方法的好处在于，它承诺提供一种捕获外部输入的通用机制。当前的实现探索了一种策略，该策略默认假定这些值与从后缀中获得的值独立。然后，根据需要添加约束来处理违反该假设的特定情况。</li><li>例如，考虑快照中的一个变量，它是指向内存位置的指针。假设在动态分析过程中为其分配了一个具体值。如果它在程序的一个后缀中出现，它将不会被替换为常量。这是因为在运行时，该指针可能具有不同的值。在没有这些排除的情况下，生成的二进制将包含过度特化的实例，即错误的正面具体化。另一种策略是实施互补的方法：默认情况下假定值除非来自指定的输入，否则不能被具体化。</li></ul></li></ul><h3 id="7-%E7%BB%93%E8%AE%BA" tabindex="-1">7 结论</h3><ul><li>OCCAM-v2使用可扩展的指针分析，权值分析和动态分析创造了一个高效的特化工具，服务于LLVM位码。</li><li>所实现的代码大小减少取决于具体的部署配置。</li><li>每个需要特化的应用程序需要伴有一个清单，该清单制定了在运行时提供的已知的具体参数，以及在运行时需要提供的其它参数的数量。<ul><li>部分求值的最佳情况是当所有参数完全指定时</li></ul></li><li>OCCAM-v2使用指针分析来去除虚拟化调用，从而能够消除任何直接调用都无法到达的函数的整体。</li><li>混合分析特征可以处理对于静态分析有挑战的情况，例如输入循环，字符串处理和外部数据（如文件中的数据）。</li><li>在评估的程序集合中，OCCAM-v2平均能够将指令数减少40.6%,运行时间中位数2.4s</li></ul><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;occam-v2%EF%BC%9A&quot; tabindex=&quot;-1&quot;&gt;OCCAM-v2：&lt;/h2&gt;
&lt;p&gt;Navas J A, Gehani A. OCCAM-v2: Combining Static and Dynamic Analysis for Effectiv</summary>
      
    
    
    
    <category term="论文" scheme="http://example.com/categories/%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="SoftwareEngineering" scheme="http://example.com/tags/SoftwareEngineering/"/>
    
    <category term="SoftwareDebloating" scheme="http://example.com/tags/SoftwareDebloating/"/>
    
  </entry>
  
  <entry>
    <title>Software Debloating 论文阅读 (9)(10)</title>
    <link href="http://example.com/2024/01/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/SoftwareDebloating/Software%20Debloating%20%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB(9)(10)/"/>
    <id>http://example.com/2024/01/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/SoftwareDebloating/Software%20Debloating%20%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB(9)(10)/</id>
    <published>2024-01-15T07:10:43.896Z</published>
    <updated>2024-01-15T07:10:43.896Z</updated>
    
    <content type="html"><![CDATA[<h2 id="(9)-software-bloat-analysis%3A-finding%2C-removing%2C-and-preventing-performance-problems-in-modern-large-scale-object-oriented-applications" tabindex="-1">(9) Software Bloat Analysis: Finding, Removing, and Preventing Performance Problems in Modern Large-Scale Object-Oriented Applications</h2><p>Xu G, Mitchell N, Arnold M, et al. Software bloat analysis: Finding, removing, and preventing performance problems in modern large-scale object-oriented applications[C], Proceedings of the FSE/SDP workshop on Future of software engineering research. 2010: 421-426.</p><h3 id="0-%E6%91%98%E8%A6%81" tabindex="-1">0 摘要</h3><p>我们将解释软件膨胀的原因,解析软件膨胀分析现状,为未来的工作提供帮助</p><h3 id="1-%E4%BB%8B%E7%BB%8D" tabindex="-1">1 介绍</h3><ul><li><p>Myhrvold 的定律:</p><ul><li>Software is a gas. Software always expands to fit whatever container it is stored in.</li><li>Software grows until it becomes limited by Moore’s law. The growth of software is initially rapid, like gas expanding, but is inevitably limited by the rate of increase in hardware speed.</li><li>Software growth makes Moore’s law possible. People buy new hardware because the software requires it.</li><li>Software is limited only by human ambition and expectation. We will always find new algorithms, new applications, and new users.</li></ul></li><li><p><strong>运行时膨胀</strong></p><ul><li>许多情况下是大型程序性能问题的根源,并不是硬件速度不够快,而是软件膨胀导致的</li><li>两种运行时膨胀<ul><li>内存膨胀:空间效率低下<ul><li>如Java程序中内存泄漏,因保留了不再使用的引用,尽管不影响程序的执行,但会消耗堆空间最后导致程序崩溃</li></ul></li><li>执行膨胀:执行了不必要的操作<ul><li>如在算法/设计上选择不恰当,在大型数据库中使用冒泡排序而不是快排等</li></ul></li></ul></li></ul></li><li><p><strong>多CPU带来的影响</strong></p><ul><li>随着核数增加,膨胀问题更痛苦</li><li>因为每个核心的平均内存带块下降,CPU性能的提升远高于内存带宽的提升</li></ul></li><li><p><strong>为什么是一个软件工程问题</strong></p><ul><li>解决膨胀问题的方法可以涵盖开发的所有阶段</li><li>程序员被教导使用抽象和模式,来重用代码和代码可读性,此时性能会交给编译器和运行时系统,如 即时编译器 JIT 和 垃圾回收期 GC. 但当抽象变得深层和嵌套,优化器将会吃力. 这里就需要对 效率和通用的权衡</li><li>膨胀的定义是相对的,如果存在更优的方法,那么目前的方法就是膨胀的. 发现膨胀可以被视为一个测试问题,来对实现进行效率评估</li><li>发现膨胀后,下一步是去除,程序分析可以发挥作用消除膨胀</li><li>在长期研究中,膨涨分析成为 资源约束 程序 的关键任务,因为这样的程序是移动计算的主流</li></ul></li></ul><h3 id="2-sota" tabindex="-1">2 SOTA</h3><p>介绍SOTA膨涨分析和面临的挑战</p><h4 id="2.1-%E5%8F%97%E7%AE%A1%E5%88%B6%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F" tabindex="-1">2.1 受管制语言中的内存泄漏</h4><ul><li>managed language: 管制语言,有运行时垃圾回收的语言</li><li>静态分析可以检测内存泄漏,但会受到 可伸缩和精确的 引用/对模型,反射,多线程等问题限制,因此实践中更多使用动态分析来识别内存泄漏</li><li>目前大多数工作采用&quot;从症状到原因&quot;的诊断方法,寻找可疑对象,随后从这些对象中找到泄漏的原因.<ul><li>可疑对象和原因的检测都是基于启发式的<ul><li>如[23,17]的工作使用某些类型实例数量的增加作为泄露对象的指示器</li><li>[16,4,25]的工作则识别一段时间没有使用的陈旧对象</li></ul></li><li>接下来从可疑对象后续遍历对象图来定位原因,然而启发式的限制在于 如果存在大量对象和极其复杂的引用关系时的不准确性</li><li>为了克服这个问题,来自[40]的工作采用了一种以容器为中心的视图,通过建模和分析容器行为来检测泄漏. 该方法基于一个重要观察结果,即Java中许多内存泄漏是由于对容器的误用,因此这项工作的局限在于,不是由容器引起的泄漏将被忽略.</li></ul></li><li>与Java内存泄漏相关研究还包括:开发能够将陈旧对象交换到磁盘[5,36] 或 仅回收极不可能再次使用的对象[6]. 这些技术可以保持性能和稳定性,从而在内存泄漏的情况下延长运行时间</li></ul><h4 id="2.2-%E5%AD%98%E5%82%A8%E8%86%A8%E8%83%80%E6%A3%80%E6%B5%8B" tabindex="-1">2.2 存储膨胀检测</h4><ul><li>[24]的工作引入健康签名来评估一个应用程序是否在必要的内存消耗和数据结构内存开销之间取得了良好的平衡。该工作的重点是Java集合对象。<ul><li>如,分析显示,一个包含2字符字符串的HashMap将其29%的空间用于指针开销，而HashSet对象的开销甚至可能更高</li><li>报告显示了一个实际应用程序，将其74%的内存用于集合的固定和每个元素的成本，这个百分比足以引起我们采取措施来避免膨胀。</li></ul></li></ul><h4 id="2.3-%E8%BF%90%E8%A1%8C%E8%86%A8%E8%83%80%E6%A3%80%E6%B5%8B" tabindex="-1">2.3 运行膨胀检测</h4><ul><li><p>大多数检测执行膨胀的工作都基于膨胀表现出的副作用（即可疑行为）。已经考虑的副作用类别包括大量的临时（短暂）对象、纯堆值拷贝和不适当的容器行为。</p></li><li><p><strong>临时对象</strong></p><ul><li>[9] 提出混合问题分析技术,对动态收集的调用结果区 进行静态分析以观察性能问题</li><li>[27]开发了一种基于JVM的工具Jolt,识别出使用大量临时对象的区域,该工具强制JVM中的JIT在这些区域执行激进的方法内联,仪表JIT可以找到更多的优化机会</li></ul></li><li><p><strong>纯拷贝</strong></p><ul><li>没有计算的序列纯堆拷贝 很可能出现多于操作</li><li>如 相同数据多个表示的存在,这些表示会不断的进行包装和解包</li><li>[38]的工作提出了一种拷贝分析方式,通过识别拷贝密集的区域来检测膨胀,已经证明这对于准确定位具有直接从其他数据结构复制数据的堆数据结构是有帮助的</li></ul></li><li><p><strong>容器膨胀</strong></p><ul><li>膨胀的一个重要来源是对容器的不当使用.</li><li>不同类型和实现的容器是为不同的使用场景设计的，因此在不了解其成本和收益的情况下选择容器可能导致显著的内存和执行膨胀。<ul><li>如HashSet适用于存储大量元素并提供快速成员测试，如果元素数量相对较小，则不应使用</li></ul></li><li>[26]提出了一种动态技术,该技术对程序进行分析以提出容器选择建议</li><li>[41]识别了两种特定类型的容器效率低下，即未充分利用的容器和过度填充的容器。该工作提出了第一种用于识别膨胀的静态分析：这种分析自动提取容器语义，不需要用户注释。</li><li>[39]的工作提出了一种动态成本和效益分析，通过捕获构造昂贵但对前向执行效益低的数据结构来检测膨胀</li></ul></li><li><p><strong>膨胀移除</strong></p><ul><li>在构建和初始化跨循环迭代保持不变的数据结构方面可能非常昂贵。</li><li>我们目前在进行一项静态分析,试图将这种数据结构提升出循环。该分析工作在两个方面展开：<ul><li>首先识别循环不变的逻辑数据结构，然后通过尝试提升访问它的语句来检查是否可以提升。</li><li>对于不能安全提升的数据结构，它计算提升可行性的度量，并呈现给用户进行进一步检查</li></ul></li></ul></li><li><p>尽管我们的工作取得了一些进展,但仍有以下三个挑战</p></li><li><p><strong>挑战1:动态分析的准确性</strong></p><ul><li>动态膨胀检测器生成的报告有大量误报,几乎所有的动态检测器都有这样的问题,因为很难定义 一个选择规则,来描述问题程序实体的唯一特征</li><li>可能的解决方案是将我们的期望从检测一般类别的问题降低到一个非常具体的类别，对于该类别可以定义更精确的症状,如[40]的工作,这一小类问题经常出现,以便可以忽略其它问题</li></ul></li><li><p><strong>挑战2:静态和动态分析的对比</strong></p><ul><li>[41]中的容器效率检测使用静态分析来检测动态分析的报错率,因为静态分析可以利用代表程序员意图或程序中固有错误的源代码属性.</li><li>传统中的测试和调试中,动态分析更精确,而在检测膨胀时,静态分析更精确.<ul><li>这种差异来自对分析的不同用途,即推断和用于检查</li><li>尚待研究的是是否有其它类型的膨胀检测或混合使用</li></ul></li></ul></li><li><p><strong>挑战3:基于规范的膨胀检测</strong></p><ul><li>现有工具不够精确的主要原因是缺乏定义膨胀的精确规范</li><li>如果在开发过程中使用一些规范,膨胀检测可以更容易</li><li>这种规范可以弥合非功能性性能分析与现有检查和测试程序功能属性的大量工作之间的差距，从而使完全自动化性能调整过程成为可能。</li></ul></li></ul><h3 id="3-%E6%9C%AA%E6%9D%A5%E6%96%B9%E5%90%91" tabindex="-1">3 未来方向</h3><h4 id="thin-patterns" tabindex="-1">Thin patterns</h4><ul><li>尽管设计模式[10] 在编写易于管理的代码方面很成功,但也是许多 运行时膨胀的根本原因<ul><li>如访问者模式,需要使用内部类表示不同的访问者,而这些访问者只有一个visit方法,会被实例化很多次,并且创建的对象都是相同的:它们没有数据,仅用于动态调度.</li></ul></li><li>未来关于模式的研究可能为现有模式创建一些专业化版本(如thin patterns),意在 达到效率和模块化之间的权衡</li><li>编译器方面,可以基于模式的特征进行进一步优化</li></ul><h4 id="%E6%B3%A8%E9%87%8D%E6%80%A7%E8%83%BD%E7%9A%84%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80%E5%92%8C%E5%B7%A5%E5%85%B7" tabindex="-1">注重性能的建模语言和工具</h4><ul><li>目前的许多性能设计集中在高层次的体系结构和流程而不是程序效率问题</li><li>因此,未来的工作可能会将性能建模语言和工具集成到现有的软件工程实践中,以便在设计阶段就可以考虑性能问题</li><li>粗心的设计会导致显著的运行时膨胀,特别是当使用建模工具后自动生成代码框架时<ul><li>如,当建模时粗心的关联会导致膨胀,考虑几个类之间的关系,这些关系包括方向性和多重性,尽管代码上有等效的实现,但却忽视了其性能影响. 更多的时候,程序员根本没有注意,只是建模工具选择默认的数据模型</li></ul></li></ul><h4 id="%E5%8D%95%E5%85%83%E6%A3%80%E6%B5%8B%2F%E8%86%A8%E8%83%80%E6%A3%80%E6%B5%8B" tabindex="-1">单元检测/膨胀检测</h4><ul><li>在早期的开发阶段就开始避免低效是很重要的,以防止低效的累积,这就需要新颖的程序分析和测试技术</li><li>目前如何使得单元测试验证非功能属性尚不清楚<ul><li>如,不容器为单元测试写断言,因单元级的冗余不明显</li></ul></li><li>但这其实本质困难是: 非功能性规范问题. 除了运行时间和空间,还能对性能做哪些断言?<ul><li>好的规范必须与某种膨胀问题密切相关，而不仅仅描述问题表现出的症状。</li><li>如果设计和评估了这样的规范，性能分析的研究可能会取得显著的进展。</li></ul></li></ul><h4 id="%E8%87%AA%E5%8A%A8%E5%8C%96%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%A8%8B%E5%BA%8F%E5%90%88%E6%88%90" tabindex="-1">自动化系统和程序合成</h4><ul><li>JVM中基于反馈的编译技术可能足够强大，可以在执行期间减少“大堆积” [20]<ul><li>例如,动态对象内联可能是减少指针开销的有效方法</li></ul></li><li>为了消除容器的低效性，运行时系统可以在观察到大部分空间未被使用时自动缩小为容器分配的空间</li><li>程序合成的最新进展为解决执行膨胀问题带来了新的希望。<ul><li>在给定用户定义的规范的情况下，程序合成工具可以自动从算法空间中选择最有效的算法。</li><li>这可以自然地应用于膨胀检测的研究中，以找到高效的实现，并且可能进一步用于生成满足性能要求的性能关键任务的实现。</li></ul></li></ul><h3 id="4-%E7%BB%93%E8%AE%BA" tabindex="-1">4 结论</h3><ul><li>论文中,我们描述了软件膨胀，这是一个逐渐对大规模面向对象应用产生负面影响的新兴问题.</li><li>我们认为这本质上是一个软件工程问题，是时候让软件工程社区为其提供新的解决方案了。</li><li>我们对一些现有的膨胀分析工作进行了调查，描述了其中的挑战，并勾勒了一些有前景的未来方向</li><li>我们相信，软件工程社区有比以往任何时候都更大的机会使软件更加高效，而这完全可以在应用程序级别实现，无需依赖不断增强的硬件能力。</li></ul><h2 id="(10)-occam%3Aautomated-software-winnowing%C2%B7" tabindex="-1">(10) OCCAM:Automated Software Winnowing·</h2><p>Malecha G, Gehani A, Shankar N. Automated software winnowing[C],Proceedings of the 30th Annual ACM Symposium on Applied Computing. 2015: 1504-1511.</p><p>SAC’15 April 13-17, 2015, Salamanca, Spain<br>Symposium on Applied Computing 2015</p><p><img src="https://github.com/SRI-CSL/OCCAM" alt="开源地址"></p><h3 id="0-%E6%91%98%E8%A6%81-1" tabindex="-1">0 摘要</h3><ul><li>为了解决代码膨胀问题,我们介绍一个OCCAM工具.<ul><li>OCCAM结合了部分求值和类型理论的技术，旨在减少部署应用中的代码。</li><li>OCCAM可以在不对程序源代码进行注释或以其他方式修改的情况下使用。</li><li>它利用配置时间信息生成一个根据将要部署的上下文进行专门定制的应用程序版本。</li></ul></li><li>我们介绍了我们的算法、实现和实验评估。</li></ul><h3 id="1-%E4%BB%8B%E7%BB%8D-1" tabindex="-1">1 介绍</h3><ul><li>模块化软件库 通过为图形,文件操作和网络提供 可复用功能,使得编写复杂应用更加容易,然而,为了实现通用性,库往往比应用程序所需要的功能更多<ul><li>如 libpng[10]提供了复杂的接口进行图像转换,但许多都用不到</li></ul></li><li>这个问题也涉及了软件栈的多个层次,由跨层依赖引入的开销<ul><li>如 miniblog[13]运行在PHP上,而PHP历来与libc,libc中许多函数仅被miniblog不使用的PHP代码使用. 这些函数包含在静态链接的二进制文件中,存储在磁盘中,执行期间需要内存,多余的代码甚至会被反向导向编程利用</li></ul></li><li>尽管大多数系统不是资源限制的,但 目前普遍的实现中,即使是 二进制文件中 不用的功能 和共享库也会影响性能,可靠性和安全.<ul><li>为此,我们提出了一种将代码特化到实际使用中并简化掉未使用功能的方法</li></ul></li><li>我们提出了 winnnowing(筛选),一种使用部分求值的静态分析和代码特化工具<ul><li>该过程保留了原始程序的正常语义,即原始程序在指定输入上的行为与精简程序的行为相同</li><li>无效的执行,如缓冲区溢出,会以不同方式执行</li></ul></li><li>在基本层次上,程序的功能对应于潜在的执行的适量,如C标准库中的socket函数</li></ul><pre><code class="language-C">int socket(int domain, int type, int protocol);</code></pre><ul><li>该函数接收3个int值,有大量潜在行为,但大多数组合不会被特定程序使用.<ul><li>如Web 服务器通常打开AF_INET和AF_INET6套接字，但不需要AF_APPLETALK或AF_ATMPVC套接字。</li><li>Winnowing的目标是从软件堆栈中删除未使用的行为,减少需要分析的代码,同时保留需要的功能</li></ul></li></ul><h4 id="%E5%8A%A8%E6%9C%BA" tabindex="-1">动机</h4><ul><li><p>筛选部署二进制文件的4个原因</p></li><li><p><strong>专用服务器</strong>:虚拟机的出现使得 高度专业化的服务器称为常态</p><ul><li>如Web服务器通常仅托管单个站点,而虚拟机中过于通用的库只会引入代码膨胀,即虚拟机之间的隔离破坏了共享代码的好处</li></ul></li><li><p><strong>自定义库</strong></p><ul><li>在嵌入式平台上,能够简化库,意味着开发人员可以通过删除不用的功能以使用更大更成熟的库.</li><li>许多应用程序在提供 编译时配置 来移除大块代码. 然而这种方法又开发者定义而不是使用者,因此对开发人员来说增加了维护不同构建配置的负担</li><li>上述方法也无法提供对应用程序获取内容的精确控制<ul><li>如,即使是间接地使用大型组件中的单个函数,也需要整个组件的存在</li><li>此外,为管理员增加了工作量,因为他们必须及时更新系统,这会涉及与应用程序无关的补丁,因为很难确定应用程序是否使用了有缺陷的函数,尤其在使用动态语言时</li></ul></li></ul></li><li><p><strong>简化分析</strong></p><ul><li>在安全重要的系统中,含有大型库是一种负担</li><li>更小的应用程序,较少的配置选项,更少更通用功能的库,更容易进行静态分析.</li><li>此外,部分估值的代码通常更简单,使得静态分析对上下文感知更有效</li></ul></li><li><p><strong>二进制多样性</strong></p><ul><li>专用库使得缓冲区溢出更难以利用</li><li>PHP等平台在可预测的地方包含相同的功能集</li><li>特化每个应用的部署实例,不仅可以移除不需要的功能,还可以移动和改变遗留的功能. 这对剩余功能的攻击更加困难</li></ul></li></ul><h4 id="%E8%B4%A1%E7%8C%AE" tabindex="-1">贡献</h4><ul><li><p>我们讨论了简化单个应用程序的思想和方法,我们的方法对所有同质的应用程序是相同的,即所有代码都可以编译成LLVM[7]位码格式的应用程序.</p></li><li><p>我们选择LLVM框架,因为该框架包括几种流行语言的前端,包括C,C++,Java,其有着明确的中间表示,支持静态和动态编译</p></li><li><p>我们的工作提供了以下内容</p><ul><li>一种用于大幅减少代码功能(包括库和应用程序)的工具. 可以用于实际的大型,工业程序中</li><li>一种将外部信息纳入简化过程的模块化方法. 这可以来用执行策略,如&quot;不应调用邮件&quot;或&quot;系统只能用字符串 ls 调用&quot;,类似面向切面的编程</li><li>关于 简化 对 二进制大小 和 执行性能 影响的 实质分析. 结果标明,简化的二进制文件在性能上没有额外的开销,根据不同的应用程序可以显著减少二进制文件的大小</li><li>一种工具 透明地增强大型软件项目的比那一过程,如Php,SQLite,以生成LLVM为嘛和本机目标文件</li></ul></li></ul><h3 id="2-winnowing" tabindex="-1">2 winnowing</h3><p>本节介绍了我们的方法的一个实例<br>2.1 描述筛选一个单独的编译片段,用LLVM调用模块<br>2.2 描述多模块筛选,使之可在更大的库和动态加载中使用</p><h4 id="2.1-%E6%A8%A1%E5%9D%97%E5%86%85%E7%B2%BE%E7%AE%80" tabindex="-1">2.1 模块内精简</h4><p><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(10)_1.png" alt></p><ul><li>LLVM的基本编译单元是模块,对于简单的程序,通常包含在一个单独的模块中,此时可以用上图的方法进行简化程序<ul><li>下面以简化C语言正则表达式库为例(仅使用C进行说明,所有的分析和转换都在LLVM位码上进行)</li></ul></li></ul><pre><code class="language-C">int regcomp ( regex_t ∗preg , const char ∗regex ,int cflags )&#123; /∗ . . . regcomp code . . . ∗/ &#125;void main ( int argc , char∗ argv[ ] ) &#123;  regex_t re;  regcomp (&amp;re,argv[1] , REG_EXTENDED|REG_ICASE ) ;  . . .&#125;</code></pre><ul><li><p>算法过程如下</p></li><li><p><strong>0. 编译</strong>:将源码编译为LLVM位码. 第三部分将讨论我们的工具,他能自动化的构建LLVM位码,通过指导构建Unix系统的脚本,如GNU的自动化工具</p></li><li><p><strong>1. 部分估值</strong>:winnower的核心是部分估值器,由两个阶段组成,winnower交错并迭代执行这两个阶段</p><ul><li><strong>1.1 优化</strong>:<ul><li>部分求值始于简化代码。其目标是暴露在编译时可确定的常量，消除死代码，并减少已知的控制流。将部分求值器应用于我们的代码片段将减少按位或运算，得到以下结果：<pre><code class="language-C">void main ( int argc , char∗ argv[ ] ) &#123;  regex_t re;  regcomp (&amp;re,argv[1] , REG_EXTENDED|REG_ICASE ) ;  . . .&#125;</code></pre></li><li>正如 Fujita [2] 和 Smowton [12] 所指出的那样，LLVM 优化器的激进性使其成为一个合理的程序内部部分求值器。</li><li>我们使用LLVM的 -O3 优化配置文件,包含了一些列简化,如 局数值编号、启发式循环展开、稀疏条件常数传播、常数折叠以及已知函数简化（简化对 libc 函数的调用，如 strlen 和 memcpy）。此优化传递还对局部函数执行一些保守的程序间优化，例如内联小函数和消除未使用的参数。</li></ul></li><li><strong>1.2 特化</strong><ul><li>优化阶段后,使用启发式方法 更 激进地在跨函数边界进行特化,在这个过程中寻找编译时已知参数的函数调用. 例如,regcomp的最后一个参数指定选项,如不区分大小写或是否支持扩展正则表达式. 该选项在编译时已知,因此可以进行特化,用已知的常量进行替代,删除不需要的参数<pre><code class="language-C">int regcomp ( regex_t ∗preg , const char ∗regex  )&#123; /∗ . . . regcomp with cflags=3 . . . ∗/ &#125;</code></pre></li><li>再将优化运用到这个特化后的函数上,可以通过简化对cflags的分支语句来删除四代码,还有可能将常量推送到其它参数的位置上,进行更进一步地特化</li><li>如果原始地使用,这两个阶段的迭代可能会增加代码的大小,但可以通过各种启发式方法来控制这一点.<ul><li>一种启发式方法是仅在未特化版本可以删除时特化函数,这个启发式方法完全对应减少功能的情况,是一种理想情况</li><li>实际上,我们发现 需要更激进地进行特化,以揭示有益的低级特化. 我们目前的启发式方法是贪婪的,只要看到一个支持的常量就进行特化,同时忽略可变参数函数.  除了整数之外，我们的专门化过程还支持浮点数、常量字符串、任何类型的空值以及全局变量和函数的地址。</li></ul></li><li><strong>递归</strong>:函数特化的主要困难是调用图中的循环,如果没有递归,我们可以限制特化的数量,因为我们指导LLVM优化器不会无限展开训话,然而,在有递归的情况下,我们必须检测特化何时会发散,考虑如下简单递归函数<pre><code class="language-C">int foo(int start,int end)&#123;  if(start&gt;end)&#123;return start-end;&#125;  return foo(start+1,end);&#125;int bar(ing x)&#123;  return foo(1,x);&#125;//特化后int foo_1(int end)&#123;  if(1&gt;end)&#123;return 1-end;&#125;  return foo_1(2,end);&#125;</code></pre><ul><li>此时foo_1(2,end)仍然可以特化,此时特化将无法停止,因为不知道end的值. 因此我们当前的实现选择不特化递归函数.</li><li>值得注意的是,部分评估器通过实践绑定分析[1,5]解决了这个问题,同时确实存在递归函数的部分评估技术[4]</li></ul></li></ul></li></ul></li><li><p><strong>2 消除</strong>:在部分评估稳定,或二进制文件变得过大而无法处理时,我们会删除不再需要的内部全局变量.</p><ul><li>在优化删除无法访问的代码时,全局变量可能变得没用.如果全局函数被特化,并且其所有被调用的位置都可以被特化的实例替代,则将删除这些全局函数.</li><li>我们使用LLVM的三个优化器实现了这个阶段: globaldce, globalopt, strip-dead-prototypes</li></ul></li><li><p><strong>3 链接</strong>:在迭代到固定点之后，我们使用 LLVM 工具将精简后的代码链接在一起构建二进制文件。这</p></li><li><p>模块内的简化算法构建了输入模块的语义等效版本，同时努力消除不必要的功能。</p></li><li><p>该算法可应用于任何单个编译单元，包括静态库和共享对象，因为它不通过删除导出的函数或更改其名称或类型来修改外部可见接口（在 LLVM 的抽象层面）。</p></li><li><p>然而，部分评估可能会极大地改变程序的内部结构，使得在代码中未表现的监控行为（如堆栈检查）失效。</p></li></ul><h4 id="2.2-%E6%A8%A1%E5%9D%97%E9%97%B4%E7%B2%BE%E7%AE%80" tabindex="-1">2.2 模块间精简</h4><ul><li>模块内精简效果好,因为大多数应用程序可以在精简之前通过静态链接库构建为单个模块。,但大型程序必须要与共享库进行交互,因此需要模块间精简</li><li>跨模块的精简的难点在于 代码的分离 和 维护兼容的二进制接口. 此外,我们希望特化是可重用的.<ul><li>如,我们会构建标准库的自定义版本,该版本通过仅包含这些应用程序所需的功能来支持多个应用程序。</li><li>然后，我们希望能够自动重写客户端应用程序以重用相同的精简库</li></ul></li><li>原理上,我们将模块间精简分为三个任务<ul><li>2.2.1 计算模块间依赖关系,使模块间的独立精简称为可能</li><li>2.2.2 对模块进行特化,</li><li>2.2.3 根据生成的规范进行重写</li><li>2.2.4 封存模块,隐藏其它模块未使用的符号,以便在链接时优化期间消除未使用的函数</li></ul></li><li>简化构成迭代 模块特化和封存 步骤,以产生完整的二进制文件</li><li>处于解释目的,我们考虑特化以下简单的代码片段，其中 bar 是在另一个模块中实现的。</li></ul><pre><code class="language-C">extern void bar(int,int);int main(int argc, char* argv[])&#123;  bar(argc,5);  bar(2,argc);  return 0;&#125;</code></pre><h5 id="2.2.1-%E4%BE%9D%E8%B5%96%E8%AE%A1%E7%AE%97" tabindex="-1">2.2.1 依赖计算</h5><ul><li>核心的组合机制是计算和使用模块的（函数和全局变量）依赖关系。<ul><li>在但模块内 简化时,有bar的代码可以立即特化</li><li>此时bar在另一个模块中定义,我们只能将foo记录未客户端模块的依赖</li></ul></li><li>为了对函数进行有意义的特化,我们需要知道关于参数值的信息。我们使用单例类型系统来表达这些信息 [8,16]。<ul><li>单例类型系统支持使用相等谓词对类型进行细化. 例如C 类型系统只能表达变量 x 是整数（int x）。使用单例类型，我们可以细化这个类型，不仅说明 x 是一个整数，而且其值为 5（int=5 x）。因此，我们简单程序的依赖关系如下：<pre><code class="language-C">bar(int=?, int=5)// 使用int=?表示未知的int值bar(int=2, int=?)</code></pre></li></ul></li><li>为了计算一个模块的依赖项,我们从模块的入口遍历调用图,并寻找外部符号引用.<ul><li>直接引用和调用点很简单；我们确定目标函数并记录信息</li><li>间接函数调用和函数指针则更为复杂。我们依赖于 LLVM 工具计算调用图，这些工具采用标准的程序分析技术，如别名分析和控制流和数据流分析。这些分析提高了 OCCAM 解析间接函数调用的能力。<ul><li>当我们无法静态确定调用的目标时，我们必须记录对每个可能的目标函数的最一般化（即未特化）调用。这是因为我们可能在不进行全局代码重写情况下,更改二进制接口。例如，如果代码将 bar 的地址存储在函数指针中，我们必须保守地记录最一般的依赖关系：</li></ul></li><li>在某些情况下，模块内部剔除期间进行的部分评估将简化这个结构，使我们能够静态解析函数。虽然这阻止了进一步的特化，但在一般情况下是不可避免的，例如，当被特化的程序在表中查找函数指针时。</li></ul></li><li>要计算整个应用程序的依赖项，我们从包含程序入口点的模块开始，并遍历代码链接的库，如下图所示。为了处理循环模块依赖的一般情况，我们迭代这个过程，直到后续的依赖计算不产生额外的依赖项<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(10)_2.png" alt="image"></li></ul><h5 id="2.2.2-%E7%89%B9%E5%8C%96" tabindex="-1">2.2.2 特化</h5><p><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(10)_3.png" alt="image"></p><ul><li>特化,使用每个客户模块的依赖性来决定要特化的函数</li><li>如上图示,遍历依赖文件中的调用列表，确定是否以及如何特化每个函数。函数特化的工作方式与模块内情况相同</li><li>即，复制函数体，删除常量参数，并将它们替换为函数体中。</li><li>区别在,与模块内简化不同,我们无法访问函数调用点以重写它们来调用专门的函数. 因此,我们生成了一份重写规范,详细说明客户端如何修改以使用更具体地接口.</li><li>以之前bar的特化举例,生成以下重写,此时只需调用一个参数</li></ul><pre><code class="language-C">&quot;bar&quot;(int=?1, int=5) -&gt; &quot;bar_x_5&quot;(int=?1)&quot;bar&quot;(int=2, int=?2) -&gt; &quot;bar_2_x&quot;(int=?2)</code></pre><h5 id="2.2.3-%E9%87%8D%E5%86%99" tabindex="-1">2.2.3 重写</h5><ul><li>特化后,使用重写规范更新客户端模块. 我们遍历所有外部定义函数的调用点,并查找与调用点匹配的最精确的重写,更新调用点以使用新的函数名和参数</li><li>例如之前的例子变为</li></ul><pre><code class="language-C">int main(int argc, char* argv[])&#123;  bar_x_5(argc);  bar_2_x(argc);  return 0;&#125;</code></pre><ul><li>特化步骤不会删除任何未特化的函数,因为不匹配任何规则的调用点将继续调用未专门化的函数</li><li>重写本质上与模块内特化修改调用者相同,但需要向模块内添加新的函数原型,并从重写规范中重新读取.</li><li>因为我们没有修改通用函数的数显,因此我们可以安全地忽略间接调用和将外部符号存储在变量中</li></ul><h5 id="2.2.4-%E5%B0%81%E5%AD%98" tabindex="-1">2.2.4 封存</h5><ul><li><p>重写完成后，模块内和跨模块的消除即可等效。在此步骤中，我们将对外部世界没有直接引用的符号变为内部，有效地覆盖了其他模块可以与我们的模块进行交互的漏洞。这允许模块内精简删除不可达代码并更激进地优化函数，因为它可以静态分析所有潜在的调用点。</p></li><li><p>使用我们的接口，封装模块非常简单，如下图所示。我们只需迭代所有外部符号，并将任何未在接口中引用的符号变为内部。值得注意的是，拥有准确的接口对于此步骤的正确性至关重要，因为如果我们尝试在另一个模块中引用内部符号，链接将失败。</p></li></ul><p><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(10)_4.png" alt="image"></p><h4 id="2.3-%E5%8A%A8%E6%80%81%E6%A3%80%E6%9F%A5" tabindex="-1">2.3 动态检查</h4><ul><li>当我们能够在组件中静态确定接口的时候，简化效率最高。</li><li>然而在某些情况下，比如通过函数指针进行调用时，确定函数如何调用将会变得困难。例如，在面向对象语言中进行动态分派或在动态语言的解释器中查找函数表时，以下说明一个实例</li></ul><pre><code class="language-C">extern int (*foo)(int);extern int (*bar)(int);void go(bool foobar) &#123;    int (*f)(int) = foobar ? foo : bar;    f(2);     f(3);&#125;</code></pre><ul><li>此代码中，我们只知道 foo 和 bar 会以参数2，3调用，但重写代码并不简单，因为我们在对f的调用中要实用不同的函数。 在这里，我们必须要构建一个包装函数来检查参数并根据需要调度到特化版本，或者在违反接口时发出错误信号，以保持相同的二进制级别的接口。</li><li>这里有两个潜在位置执行动态检查，在调用点或者函数定义处，各有不同的好处</li></ul><h5 id="2.3.1-%E9%87%8D%E5%86%99%E5%AE%A2%E6%88%B7%E7%AB%AF" tabindex="-1">2.3.1 重写客户端</h5><p>第一种选择是重写客户端，即在调用点执行检查。<br>此时，库只导出特化函数（foo_2 和 foo_3 ），但客户端同时需要非特化的。为此，我们必须通过测试其参数并将其分配到合适的特化函数中来实现通用函数。如在客户端模块实现foo如下</p><pre><code class="language-C">extern int foo_2();extern int foo_3();inline int foo(int x) &#123;    if (x == 2) return foo_2(); // foo(2)    if (x == 3) return foo_3(); // foo(3)    exit(1);&#125;</code></pre><ul><li>对客户端进行部分估值将导致该调用被内联，并且在x是静态已知的情况下删除条件。对于调用不符合接口的代码，将执行fall-through并发出错误信号</li></ul><h5 id="2.3.2-%E9%87%8D%E5%86%99%E5%BA%93" tabindex="-1">2.3.2 重写库</h5><ul><li>另一种选择是重写库中的目标函数，这对于强制执行，无法静态验证的 库的接口很有用<br>。它还可以在单独模块中进行使用，以解决间接调用的困难那，为此，OCCAM复制了旧的foo实现并进行重写</li><li>我们将导出的函数foo替换为一个检查参数的函数（以强制执行foo只能用2，3调用），并相应的进行委托或终止客户端。 由于oldfoo在库中是内部的，有static修饰，模块内的简化将对其进行特化并最终从执行文件中删除通用版本</li></ul><pre><code class="language-C">int foo(int x) &#123;    if (x == 2) return oldfoo(2);    if (x == 3) return oldfoo(3);    exit(1);&#125;static int oldfoo(int x) &#123; /* foo code */ &#125;</code></pre><h3 id="3-%E5%AE%9E%E7%8E%B0" tabindex="-1">3 实现</h3><ul><li><p>我们实现了我们描述的所有技术，并应用于多个实例，以了解在实际应用中实用简化技术的实用性</p></li><li><p>我们的代码作为一组LLVM编译器传递实现的。我们通过一组Python包装器实用LLVM opt程序运行它。这意味着简化的每个简短都会产生一个新的程序文件（或接口文件）。虽然这种方法不如纯C但不实体化中间结果的效率高，但它能够灵活地尝试其它转化和特化的启发式方法，我们的代码发布提供了一个教程，演示了我们如何使用我们的工具对应用程序进行简化</p></li><li><p>为了创建程序的bit码，我们开发了一组脚本来包装现有的构建工具，这是因为大型应用程序的构建过程通常使用各种工具，如autoconf，libtool，cmake，make。 虽然这些工具支持各种平台和配置，但不支持将LLVM bit码作为目标架构</p></li><li><p>为了与检查依赖项的现有构建脚本集成，我们的工具将每个命令翻译成两个命令（如调用gcc或ld）。</p><ul><li>第一个编译产生一个修改的版本来获取LLVMbit码</li><li>第二个生成ELF标准版本，生成ELF对象确认构建成功，并确保所有的依赖选项都存在。</li></ul></li><li><p>虽然在构建速度方面不太理想，但我们的脚本相当健壮，能够编译大型程序和库，如PHP，SQLite，uClibc</p></li></ul><h3 id="4-%E4%BE%8B%E5%AD%90%E7%A0%94%E7%A9%B6" tabindex="-1">4 例子研究</h3><ul><li><p>首先回顾我们的目标</p></li><li><p>首先，我们希望减少代码的功能，但这不一定意味着代码的减少；相反，它可能意味着减少可能的执行次数，复制一个函数会增加代码大小，但不会增加复杂性。同样地。在一个参数上特化一个函数，可以通过限制传递的值来减少其可能的行为。为了衡量这一点，我们可以查看应用程序在简化前后的调用图。</p></li><li><p>次要目标是代码大小的减少和配置复杂性。</p><ul><li>大型库支持在粗粒度上启用功能，例如PHP中支持MySQL。</li><li>简化为库用户提供了一种自动化方式，来精确地选择它们想要地功能。为衡量这一点，我们可以将简化与现有技术进行比较，例如使用库地静态链接（仅使用存档中的必要对像）</li></ul></li><li><p>我们的例子研究包括两个web服务器，nweb[3],thttpd[9],及两个web应用程序使用的PHP解释器</p></li></ul><h4 id="nweb" tabindex="-1">nweb</h4><ul><li><strong>nweb</strong>是一个静态内容Web服务器，只有200多行C代码，它的大小和架构并不是简化的理想对象（小且配置少），但其可以展示简化的实际效果。 因为nweb仅依赖于libc，且非常简单，uClibc足以满足它的需求 （libc和uClibc都是C标准库，但uClibc是面向嵌入式系统的轻量级库）</li><li>由于nweb通过命令行进行配置，我们根据我们希望提供的参数对main函数进行特化。为此我们使用命令<code>nweb 8080 /root</code> 告诉nweb监听端口并从root提供文件<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(10)_5.png" alt="image"></li><li>上图展示了简化对nweb调用图的影响，图中的粗灰色框表示特化的函数。 简化前有27个函数，简化后只有17个，其余10个被特化或内联到11个不同的函数中，每个特化都减少了至少一个参数。这些特化包括<ul><li><ol><li>log函数被复制了三次，每次都因不同的状态可以打印日志。通用函数已被删除，特化实例的部分求值去除了怪异的控制流，变成straight-line code程序（只有顺序结构），使其可以直接调用sprint，open，write</li></ol></li><li><ol start="2"><li>libc中设置socket的函数（bind，listen和socket）每个被特化为处理TCP请求。其中socket函数最有趣，被特化为 面向 Internet（AF_NET） 和 面向流的socket（SOCK_STREAM）</li></ol></li><li><ol start="3"><li>libc中处理软件中断的函数（signal）被特化两次以处理SIGCHLD和SIGHUP，这些特化可以使得其他工具可以轻松地确认程序仅以有限的方式响应中断</li></ol></li></ul></li></ul><h4 id="thttpd" tabindex="-1">thttpd</h4><ul><li><strong>thttpd</strong>是另一个考虑的Web服务器。其有许多功能，约8500行C代码，支持CGI，在启动时使用chroot，在内存中缓存，使用htpasswd身份验证。除了核心的libc功能外，thttpd还连接到libcrypt以保护其.htpasswd文件，httpd可以在运行时通过命令行参数配置，也可以在编译时使用一个头文件进行配置，该头文件同构一组49个宏控制代码生成。这些宏包括我们希望在简化中公开的，如.htpasswd的路径存储在AUTH_FIL宏中</li><li>对thttpd进行简化会产生125个特化函数，主要分为三类<ul><li>定时器创建（tmr_create）的特化：所有这些调用都会被特化，包括在计时器到期时运行的函数指针。 这可以防止数据攻击。</li><li>缓冲区分配（httpd_realloc_str）:一个调用扩展了用于存储标头的缓冲区大小，该调用对前领个参数进行了特化，因为二者都是全局变量的地址 。<code>httpd_realloc_str(&amp;header, &amp;maxheader, sizeof(headerstr) + strlen(realm) + 3);</code></li><li>错误代码的特化。 因为我们的特化框架不支持可变参数函数，因此我们无法特化错误函数中对 snprintf的调用。 然而，常量的传播可以进行，因此，可以通过额外的特化来注入这些常量所需的特化</li></ul></li></ul><h4 id="php" tabindex="-1">PHP</h4><ul><li>PHP [14] 是一个用于网站的流行编程语言。它附带了一个庞大的标准库，涵盖了从简单的字符串和日期操作到像chroot这样的POSIX系统调用的各种功能。这种“一揽子式”方法对于快速启动新应用程序非常有用。同时，这也为攻击提供了广泛的攻击面，特别是对于使用eval的应用程序。为了解决这个问题，我们可以对托管应用程序不需要的 PHP 运行时功能进行剪裁。</li><li>为了演示这一点，我们构建了一个minblog[13]专用的PHP解释器，这是一个用PHP编写的小型博客框架。我们用我们的工具链自动地构建PHP解释器的LLVM二进制位码。在编译后，我们需要确定miniblog需要的接口，这里有两个复杂问题<ul><li><ol><li>首先PHP以文本形式提供给PHP解释器，这意味着我们无法使用LLVM通道来确定运行应用程序所需要的接口。PHP的静态评估超出了本文的范围。因此我们使用正则表达式来捕捉与PHP函数调用语法相对应的文本模式。之后，我们人工地检查结果，这个过程可以由语义的静态分析和在程序运行时记录跟踪的工具来替代。即便使用这些工具，我们认为由手动审核此列表仍然是有用的，以查看底层系统所依赖的内容。</li></ol><ul><li>从静态分析我们可以确定miniblog依赖于PHP标准库中地52个函数，包括包括字符串和文件操作以及 MySQL 函数。为了比较，我们编译了可以使用 PHP 的编译选项配置的最小解释器（包括 PHP 标准库和 MySQL 扩展）的解释器。这包含 1029 个函数，包括可能危险的函数，如 system 和 mail。一些被消除的函数包含过去 PHP 版本中的漏洞（CVE-2011-1148 和 CVE-2010-2191）。这些漏洞在已经进行了精简的 PHP 部署中将不再存在。</li></ul></li><li><ol start="2"><li>第二个问题是PHP解释器的架构。PHP解释器讲库函数实现存储在一个可以动态调度的表中。因此，通过此表中的函数进行的所有调用都太过保守，所有函数都有可能是目标。即使我们可以使用类似 Smowton [12] 开发的技术将 PHP 代码拉入部分评估期间，使用 LLVM 优化器很难实现解决通过此表调用所需的部分评估。取而代之的是，我们注意此表的结构并使用第 2.3 节中描述的技术修改函数。在标准的 PHP 解释器中，每个库例程 Xxx 都在函数 zif_Xxx 中实现。因此，我们可以轻松编写钩子，将未使用的函数重写为错误。</li></ol></li></ul></li><li>对简化miniblog，生成了997个形如<code>zif_system(?) =&gt; fail</code>的重写，处于审计和调试的目的，我们实现fail函数时记录了违规的函数调用</li></ul><h3 id="5-%E8%AF%84%E4%BC%B0" tabindex="-1">5 评估</h3><h4 id="%E6%80%A7%E8%83%BD" tabindex="-1">性能</h4><ul><li><p>我们比较了使用专门化和不使用专门化构建的每个服务器在请求率上的表现，以了解运行时的影响。</p></li><li><p>性能以每秒请求数来衡量，用于提供单个小型静态页面。</p></li><li><p>为了控制网络带宽，我们在 localhost:8080 上执行了测试。</p></li><li><p>我们使用 Apache 基准测试工具 ab 来生成请求。</p></li><li><p>我们运行了 40 次试验，每次对服务器进行 5000 次请求。</p></li><li><p>测试在一台轻度负载的 Intel Core 2 四核桌面上运行，时钟频率为 2.4 GHz，配备 4 GB 的 RAM 和 Linux 2.6.38，并使用 TuxOnIce 补丁集</p></li><li><p>为了进行公平比较，基线在链接之前使用LLVM-O3进行优化，两个版本都静态链接到uClibc-0.9.32，使用OCCAM构建并使用uClibc构建的标准配置选项进行优化（使用-O2）。</p></li><li><p>下图显示了nweb和thttpd的比较结果<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(10)_6.png" alt="image"></p></li><li><p>nweb中差异在样本中变化较大，不具有统计意义</p></li><li><p>thttpd中，简化版本在95%的置信度上高于基线版本。这种性能改善可能有两个原因造成</p><ul><li>简化使用-O3作为其部分求值器，而标准配置使用-O2。这种差异可能会导致简化版本的代码更快。</li><li>函数的复制暴露了常量，创造了更多的编译时优化机会</li></ul></li></ul><h4 id="%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%B0%8F" tabindex="-1">代码大小</h4><ul><li>我们在简化中使用的激进特化策略导致httpd模块大小增加了45%，如下图示，这是部分评估技术已知的问题，其中大部分由于报错函数特化参数的复制引起的。这个问题可以使用更保守地启发式搜索解决，如果产生了显著的差异，其只会保留一个特化，</li></ul><p><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(10)_7.png" alt="image"></p><ul><li>libcrypt和libc模块的二进制大小在简化后几乎没有增加，这是因为大多数函数都是叶子例程（例如字符串操作）或它们立即调用操作系统。因此，在这些单独的模块中，很少有机会内联或特化函数。额外的大小是由于对库的特化调用减去了静态链接器引入，但thttpd模块未使用的额外函数和常量。在高度优化的低级别库中，这些都不是显著的，因为档案中的每个对象通常只定义了最小数量的函数。</li></ul><p><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(10)_8.png" alt="image"></p><ul><li>许多常见的库，如libc，通常被编译为共享对象（或系统等效物），而不是静态链接。正常的共享对象包含整个库，与这样的库动态链接的任何应用程序都会引入大量不相关的功能。通过在构建共享对象之前应用精简，我们可以大大减少这种情况。</li></ul><p><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(10)_9.png" alt="image"></p><ul><li>图9展示了应用第4节技术于PHP的结果。<ul><li>min表示使用PHP编译配置选项可以构建的最小PHP模块。它的大小为5.5 MB，其中4.0 MB（用虚线标记）是解释器（没有导出的PHP函数）。剩下的1.5 MB是标准库。</li><li>+mysql表示添加了MySQL支持的二进制文件。它需要额外的4%存储（不包括MySQL库）。</li><li>+mysql-sys是添加了一个策略以阻止对11个危险的PHP函数的调用后的二进制文件。</li><li>miniblog表示在对miniblog的接口进行精简之后得到的解释器版本。在模块内精简之后，LLVM比特码的大小从5.8 MB缩小到4.2 MB，减少了27%；这只比核心解释器大5.5%。从精简中减小PHP解释器二进制大小的效果类似于我们在thttpd案例中看到的libc共享对象的最小化（如图8所示）。</li></ul></li></ul><h3 id="6-%E7%BB%93%E8%AE%BA" tabindex="-1">6 结论</h3><ul><li>我们开发了OCCAM工具,用于将应用程序特化到其部署环境</li><li>我们解释了为什么我们的工具可以精确地从应用程序中移除功能</li><li>我们还认为,少量的手动工作可以用于解决优于信息的不完整引起的困难(如,不知道解释器正在运行的程序或不精确的别名分析)</li></ul><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;(9)-software-bloat-analysis%3A-finding%2C-removing%2C-and-preventing-performance-problems-in-modern-large-scale-object-oriented-appl</summary>
      
    
    
    
    <category term="论文" scheme="http://example.com/categories/%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="SoftwareEngineering" scheme="http://example.com/tags/SoftwareEngineering/"/>
    
    <category term="SoftwareDebloating" scheme="http://example.com/tags/SoftwareDebloating/"/>
    
  </entry>
  
  <entry>
    <title>Software Debloating 论文阅读 (7)(8)</title>
    <link href="http://example.com/2024/01/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/SoftwareDebloating/Software%20Debloating%20%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB(7)(8)/"/>
    <id>http://example.com/2024/01/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/SoftwareDebloating/Software%20Debloating%20%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB(7)(8)/</id>
    <published>2024-01-15T07:10:43.893Z</published>
    <updated>2024-01-15T07:10:43.893Z</updated>
    
    <content type="html"><![CDATA[<h2 id="blade%3A-scalable-source-code-debloating-framework" tabindex="-1">BLADE: Scalable Source Code Debloating Framework</h2><p>2023 IEEE Secure Development Conference</p><p>Ali M, Habib R, Gehani A, et al. BLADE: Scalable Source Code Debloating Framework[J]. 2023 IEEE Secure Development Conference (SecDev),2023</p><h3 id="0-%E6%91%98%E8%A6%81" tabindex="-1">0 摘要</h3><ul><li>现有的源代码精简工具在动态云环境中应用时存在可扩展性低和运行时开销高的问题，其中实例会即时启动 （指明场景）</li><li>为了解决这一挑战，我们提出了BLADE，它利用常见的编码习惯和语言限制构建简单而有效的启发式方法，以实现更快的源代码精简<ul><li>例如：通常在使用之前定义变量，因此删除节点时，其在语法树的位置越深，破坏代码的概率越低；</li><li>例如：在精简某些功能时，基本块中的语句可能会被一起删除</li></ul></li><li>为此，Blade使用分层源代码简化，通过反向谦虚遍历选择简化候选，以便在定义之前删除使用</li><li>低运行开销使得BLADE能够实际应用于大型工作负载的代码精简</li><li>我们的评估表明，与现有的源代码精简工具相比，BLADE运行更快。<ul><li>与 Chisel 相比，BLADE平均快2.3倍，并在代码大小和攻击面的减小方面提供可比较的效果。</li><li>与另一款源代码精简工具 Debop 相比，BLADE平均快2.75倍。</li><li>（然而这两款都很慢）</li></ul></li></ul><h3 id="1-%E4%BB%8B%E7%BB%8D" tabindex="-1">1 介绍</h3><ul><li><p>简化工具需要的性质</p><ul><li><ol><li>快速且可拓展,同时不损害通用性</li></ol><ul><li>动态云环境中,实例会即时启动,因此需要快速的精简工具</li><li>CI/CD中,需要即时提供更新的构建</li></ul></li><li><ol start="2"><li>可审计性:</li></ol><ul><li>允许在精简后检查生成的代码是否存在任何意外的副作用。不在源代码级别操作的精简工具[2]，[4]–[6] 对于这种用例不太理想。</li></ul></li></ul></li><li><p>基于源代码简化方案的工作原理</p><ul><li><ol><li>创建测试规范描述所需的功能</li></ol></li><li><ol start="2"><li>迭代地选择要从代码库中删除的一组代码语句的候选集</li></ol></li><li><ol start="3"><li>将剩余的代码与规范进行测试。</li></ol><ul><li>如果通过，就永久性地删除所选的语句。然后继续对剩余的代码进行搜索。</li><li>如果测试失败，将那些选定的语句放回代码库，并考虑一个新的候选语句集，直到所有集合都用尽。</li></ul></li></ul></li><li><p>当今的简化方法很慢,甚至超时[1]，[7]–[9],它们常规地使用Delta-Debugging进行搜索,复杂度为 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq> ;而Debop[7]使用随机优化进行搜索,然而其精简效率较低</p></li><li><p>为此我们提出BLADE,支持快速且可扩展的代码精简</p><ul><li>BLADE采用了一个结构感知的代码精简过程，其运行时间为 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq>,这使得将 BLADE 用于精简大型代码库（例如 nginx、sqlite3）变得实际可行。</li><li>BLADE在源代码级别上操作，以实现可审计性。</li></ul></li><li><p>评估表明,BLADE比 Chisel 快 2.3 倍，比 Debop 快 2.75 倍.</p></li><li><p>总的来说, 高度的代码精简、安全强化和低运行时开销的通用潜力使得 BLADE 在现代动态精简使用案例中更具有优势。</p></li><li><p>本文贡献如下</p><ul><li><ol><li><strong>新颖方法</strong>：BLADE利用其快速算法，有效地扩展到大型工作负载（例如，nginx、sqlite3）。这使得BLADE成为现实工作负载的实际解决方案。</li></ol></li><li><ol start="2"><li><strong>全面评估</strong>：与现有的精简框架进行的比较评估显示，BLADE在精简时间上相比其他方案有显著改进，而不会牺牲代码精简。</li></ol></li><li><ol start="3"><li><strong>开源</strong>:<a href="https://github.com/pawnsac/BLADE-deb">仓库地址</a></li></ol></li></ul></li></ul><h3 id="2-%E5%8A%A8%E6%9C%BA%E5%92%8C%E8%A7%81%E8%A7%A3" tabindex="-1">2 动机和见解</h3><ul><li><p>DD算法低效的两个原因</p><ul><li><ol><li>可以被简化的语句可能分散而不是成片出现.因此,搜索可移除代码的最大片段所需的时间潜在地可能超过实际删除大块代码所带来的可能时间优势</li></ol></li><li><ol start="2"><li>没有考虑编程语言的语法规则</li></ol><ul><li>例如:在候选删除集中包含一个定义语句,在未删除的代码中有其应用,此时不能够删除该定义语句. 这样会产生语法错误,且编译这样的代码也是不必要的,编译这样代码浪费的时间可以通过在删除语句的定义之前优先删除其应用来避免</li></ul></li></ul></li><li><p>见解1:利用先定义后使用的结构</p><ul><li>通常,变量先定义后使用,因此在语法树中,被删除的语句未知越深,出现错误概率越低</li><li>因此BLADE利用这一见解优化迭代次数,因为DD是优删除前部分的定义语句,而BLADE优先删除后部分的定义语句</li></ul></li><li><p>见解2:利用语法树层次结构</p><ul><li>给定一个包含多个语句的代码块,可以在考虑其中单个语句之前先把整个语句删除</li><li>而DD采用二分搜索移除大块,BLADE利用这一见解可以加快速度</li></ul></li></ul><h3 id="3-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1" tabindex="-1">3 系统设计</h3><ul><li>形式化定义:类似Chisel等</li><li>简化流程如下</li></ul><ol><li>识别并从程序中删除一组候选语句。</li><li>编译剩余的程序。</li><li>测试 Oracle 执行程序所需的功能。</li><li>测试 Oracle 比较程序输出与预期输出。</li><li>根据测试 Oracle 的结果，候选语句要么被永久性地删除（精简），要么重新引入到程序中。这个过程重复进行，直到精简算法无法进一步精简程序。</li></ol><ul><li>系统总体设计如下,下面进行详细介绍<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(7)_1.png" alt></li></ul><h4 id="a-%E8%AF%AD%E5%8F%A5%E6%A0%91" tabindex="-1">A 语句树</h4><ul><li>对于给定的程序简历语句树,不同于AST,其叶子节点是完整的语句,中心节点是代码块(如函数,循环,if-else语句或结构体).</li><li>BLADE将语句块保留为内部节点以进行分层简化:删除内部节点及其子树等效删除整个代码块,删除后如未通过测试,则将该块重新放回1,并在该块中反向遍历进行DD</li><li>下图为一个语句树例子<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(7)_2.png" alt="语句树"></li><li>构建语句树使用LLVM的前端Clang [12]提取原始代码的token,随后使用这些token构建语句数,并分类为块或语句</li></ul><h4 id="b-%E7%AE%80%E5%8C%96%E7%AE%97%E6%B3%95" tabindex="-1">B 简化算法</h4><ul><li>简化算法以语句树为输入,递归地进行简化. 其以后序遍历语句树,没有并行优化的基本算法如下</li><li><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(7)_3.png" alt="基本算法"><ul><li>首先尝试删除整个树来简化(第2行),否则回复树(第5行)</li><li>该算法对于每个节点只遍历一遍,因此复杂度是 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq></li></ul></li></ul><h4 id="c-%E5%B9%B6%E8%A1%8C%E6%93%8D%E4%BD%9C" tabindex="-1">C 并行操作</h4><ol><li><strong>同时多节点简化</strong>:在一次迭代中同时处理给定节点下的多个子节点</li></ol><ul><li>具体来说在多个进程中运行算法1,并行移除不同组合的子节点,通过测试集的删除最多的是最佳状态,此外永久删除节点更新全局状态</li><li>算法如下图所示 <img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(7)_4.png" alt="并行算法"><ul><li>第5,6行为进程分配节点</li><li>第7行进程并行删除分配的节点,并测试</li><li>最佳简化在15行确定</li><li>n是节点的子节点数,有 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></eq> 种组合,我们依据 <strong>见解1</strong> 进行排序.在原型实现种,我们只考虑前n种组合</li><li>在给定节点，BLADE选择第一个即将到来的节点作为第一个进程的候选集；第二个进程获得前两个即将到来的节点，依此类推，第n个进程获取前n个即将到来的节点作为运行算法1的候选集。</li></ul></li><li>多节点并行主要有两个好处<ul><li><ol><li>速度:可以在一次迭代种删除更大的代码块,例如并行5个进程可一次删除5个节点.下图标明,在67.6%的情况下,一次迭代删除的语句多余一个 <img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(7)_5.png" alt="并行删除"></li></ol></li><li><ol start="2"><li>简化:允许多节点组合简化,这在移除具有中和作用代码时有帮助</li></ol></li></ul></li></ul><ol start="2"><li><strong>次级减小</strong>:</li></ol><ul><li>BLADE仅使用一组优先级高的组合,因此始终存在次级迭代能产生更多的简化.</li><li>为此,我们运行另外一组进程执行次级同时遍历,有以下目的<ul><li><ol><li>在第一轮简化后制作 新一轮的简化组合</li></ol></li><li><ol start="2"><li>死代码清除(包括删除标签定义,不遵循先定义后使用原则)</li></ol></li></ul></li><li>这些次级迭代使用不同程度的语句树执行算法2,然而保持至少一个函数的并行迭代器之间的距离是重要的,原因有两个<ul><li><ol><li>使得多个迭代器的简化路径不重叠</li></ol></li><li><ol start="2"><li>允许迭代器为下一个迭代器创建新的简化组合之前能够全面搜索函数.</li></ol></li></ul></li><li>BLADE提供了调整并行迭代器及其调整进程数量的功能.使用多个迭代器减少了对程序执行多次完整遍历的需求,显著提高了代码简化水平</li></ul><h4 id="d-%E6%B5%8B%E8%AF%95oracle" tabindex="-1">D 测试Oracle</h4><ul><li><strong>功能检查器</strong>:<ul><li>使用一组测试脚本(bash脚本),测试脚本需要完全覆盖核心功能</li><li>程序相对于给定功能的通用性被定义为程序处理指定功能的一般范围输入的适应性. 为了增加通用性会增加输入,导致时间增加,通过优化迭代次数,BLADE使得更好的通用性称为可能</li></ul></li><li><strong>适应检查器</strong>:<ul><li>维系简化程序的质量,如安全性评估等</li><li>目前实现种,使用Clang静态分析来保证简化适应度如[1]中所实现。<ul><li>控制流完整性（Control Flow Integrity）Sanitizer</li><li>地址（Address）Sanitizer</li><li>内存（Memory）Sanitizer</li><li>未定义行为（Undefined Behavior）Sanitizer</li><li>泄漏（Leak）Sanitizer，</li></ul></li></ul></li></ul><h3 id="4-%E8%AF%84%E4%BC%B0" tabindex="-1">4 评估</h3><ul><li>与Chisel,Razor,Debop比较</li></ul><h4 id="a-%E6%A0%87%E5%87%86" tabindex="-1">A 标准</h4><ul><li><strong>分析效率</strong>:运行时间表现对比</li><li><strong>简化</strong>:</li><li><strong>安全</strong>:</li><li><strong>通用性</strong></li></ul><h4 id="b-%E8%AF%84%E4%BC%B0%E9%A1%BA%E5%BA%8F" tabindex="-1">B 评估顺序</h4><ul><li><ol><li>在小程序上对比</li></ol></li><li><ol start="2"><li>在大的应用程序上对比,着重体现了BLADE的优势:在实际工作负载上的可扩展性</li></ol></li></ul><h4 id="c-%E8%AF%84%E4%BC%B0%E7%8E%AF%E5%A2%83" tabindex="-1">C 评估环境</h4><ul><li>Linux Server</li><li>2个 Xeon Silver 4210 CPU@2.20GHz处理器</li><li>512GB DDR4</li><li>操作系统为Ubuntu 20.04.4 LTS</li></ul><h4 id="d-%E8%AF%84%E4%BC%B0%E9%85%8D%E7%BD%AE" tabindex="-1">D 评估配置</h4><ol><li><strong>目标程序和功能选择</strong>:</li></ol><ul><li>使用 nginx、sqlite3、make 和 tar 作为大型程序样本，以衡量可扩展性。</li><li>使用ChiselBench作为小程序样本</li><li>选择每个程序的核心参数,需要保证功能检查其全面覆盖了程序的各种输入范围.<ul><li>例如:对于sort,uniq,输入包括文本,二进制,图像和压缩文件</li></ul></li></ul><ol start="2"><li><strong>设置BLADE,Chisel,Debop和Razor</strong></li></ol><ul><li>使用相同测试Oracle对于所有工具,并针对各自修改<ul><li>Razor需要Oracle为python</li><li>Debop要求每次结束时输出一组测量值,还要两个参数</li></ul></li></ul><h4 id="e-%E5%88%86%E6%9E%90%E6%95%88%E7%8E%87%E8%AF%84%E4%BC%B0" tabindex="-1">E 分析效率评估</h4><ul><li>ChiselBench种,BLADE平均比Chisel快2.3倍,比Debop快2.75倍;</li><li>这使得它能够扩展到大型代码库，并鼓励添加更复杂的测试用例到测试 Oracle 中。</li></ul><h4 id="f-%E7%AE%80%E5%8C%96%E8%AF%84%E4%BC%B0" tabindex="-1">F 简化评估</h4><ul><li>从4个维度出发<ul><li>二进制大小:<ul><li>BLADE平均减少 67%</li><li>Chisel 67%</li><li>Debop 7%</li><li>Razor -19%:因为razor会将之前的设为只读而添入新的代码块<br><img src="../../../images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(7)_6.png" alt="二进制大小"></li></ul></li><li>运行代码大小:<ul><li>BLADE减少 83%</li><li>Chisel 86%</li><li>Razor 50%</li><li>Debop 10%<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(7)_7.png" alt="运行代码大小"></li></ul></li><li>静态块<ul><li>BLADE减少 86%</li><li>Chisel 88%</li><li>Razor 45%</li><li>Debop 7%<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(7)_8.png" alt="静态块"></li></ul></li><li>代码行<ul><li>BLADE减少 83%</li><li>Chisel 76%</li><li>Debop 1%</li><li>注意到从Chisel到BLADE代码行数有显著的减少,主要有以下BLADE考虑了但Chisel没有的两个原因<ul><li><ol><li>未使用声明的减少</li></ol></li><li><ol start="2"><li>结构体的减少<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(7)_9.png" alt="代码行数"></li></ol></li></ul></li></ul></li></ul></li></ul><h4 id="g-%E5%AE%89%E5%85%A8%E8%AF%84%E4%BC%B0" tabindex="-1">G 安全评估</h4><ul><li>从三个方面考虑<ul><li><ol><li>ROP Gadgets:使用Salwan的ROP Gadget工具[13]计算总共的唯一ROP gadgets.</li></ol><ul><li>BLADE减少 83%</li><li>Chisel 84%</li><li>Razor 52%</li><li>Debop 4%<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(7)_10.png" alt="ROP Gadgets"></li></ul></li><li><ol start="2"><li>内存泄漏:使用名为Saber [14]的静态分析工具评估给定程序的内存泄漏</li></ol><ul><li>BLADE和Chisel处理内存泄漏能力是相当的,某些情况下BLADE引入了新的泄漏,这是因为BLADE的适应性检查其使用Clang的静态分析其,存在漏检情况<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(7)_11.png" alt="内存泄漏"></li></ul></li><li><ol start="3"><li>CVEs:Common Vulnerabilities and Exposures:是特定程序已知的漏洞,这些漏洞被识别然后与公众分享</li></ol><ul><li>BLADE在9个中删了5个,与Chisel相同</li><li>Razor从9个中删了4个</li></ul></li></ul></li></ul><h4 id="h-%E9%80%9A%E7%94%A8%E6%80%A7%E8%AF%84%E4%BC%B0" tabindex="-1">H 通用性评估</h4><ul><li><p>程序相对于给定功能的通用性定义为程序处理指定功能/在精简后保留的参数的一般输入范围的能力。</p><ul><li>例如:bzip2对于-fc参数,为了测试通用性，我们为每个目标程序设计了一组新的测试用例，这些测试用例不属于功能检查器的预定义测试用例. 结果如下<img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(7)_12.png" alt="通用性"></li></ul></li><li><p><strong>通用性和训练用例的数量</strong>:下图展示了训练用例数量和验证集数量之间的关系<img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(7)_13.png" alt="通用性和训练用例的数量"></p><ul><li>其粗略表明:随着训练用例数量的增加,通用性也会增加</li><li>对于多样化输入的程序,需要更多的训练用例以保证通用性</li></ul></li><li><p>总结:BLADE的通用性与SOTA相当,并且可以增加训练集进一步增强通用性</p></li></ul><h4 id="%E6%9B%B4%E8%BF%9B%E4%B8%80%E6%AD%A5%3A%E5%AF%B9%E5%A4%A7%E5%9E%8B%E5%BA%94%E7%94%A8%E8%BF%9B%E8%A1%8C%E7%B2%BE%E7%AE%80" tabindex="-1">更进一步:对大型应用进行精简</h4><ul><li><p>两个大的:nginx:76k 行,sqlite3-manager 75k 行</p></li><li><p>两个中的:tar 31k,make 27k</p></li><li><p>效果如下<img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(7)_14.png" alt></p></li><li><p><strong>现有方法在大型应用上</strong>:</p><ul><li>DEBOP表现不好,在大程序上不用</li><li>Chisel在24h内无法完成简化,且在简化中出现错误</li><li>Razor不是基于源代码的,我们没有再次耗费太多精力</li></ul></li><li><p><strong>nginx</strong>:</p><ul><li>选择原因:(1)大程序(2)CVE中的漏洞</li><li>BLADE移除了6个CVE,因为简化删除了易受攻击的功能</li><li>对简化后的二进制文件进行通用性测试,托管了20个不同的html界面,18个运行成功</li></ul></li><li><p><strong>sqlite3-manager</strong>:因其大程序,可解释如何通过移除功能增加安全性(移除update和delete可去除SQL注入)</p></li></ul><h3 id="5-%E8%AE%A8%E8%AE%BA" tabindex="-1">5 讨论</h3><ul><li><strong>通用性和训练样例</strong><ul><li>BLADE的通用性与训练样例的全面性有关</li><li>然而蚕蛹少量训练数据达到更好通用性仍是一个开放问题</li></ul></li><li><strong>编程语言</strong><ul><li>目前BLADE面向C/C++程序,但理论上可以面向任何 先定义后使用 的结构,然而原始的DD确实可以应用于所有程序</li><li>为了应对更广泛的语言,BLADE可以以LLVM IR为输入,这是一种中间代码,任何语言编写的程序都可以首先编译为LLVM IR的形式,然后使用BLADE简化啊</li></ul></li></ul><h3 id="6-%E7%9B%B8%E5%85%B3%E5%B7%A5%E4%BD%9C" tabindex="-1">6 相关工作</h3><ul><li><strong>基于源代码的简化器</strong>:<ul><li>有很多 :C-reduce [8], Perses [9],Chisel [1], Debop [7], DomGad [25], and Cov-A/F [26]</li><li>大部分使用了Delta Debugging (DD) algorithm [10]:该算法最初是为了确定在程序中起作用的“昨天”（工作模板程序）但在“今天”（错误程序）不起作用的最小故障诱导代码. DD就是发现有问题的代码,然后去掉这些代码将是程序正确;这与代码简化有着相似的原理<ul><li>基于DD,C-reduce[8] 对源代码应用一系列变换（更改标识符、变量范围、合并定义和用函数体替换函数调用）以减小源代码. 这不仅费时间,也不可行,且代码难以审计. 而BLADE很快,同时保持源代码的可审计行和可读性</li><li>基于DD,语法指导的方法Perse[9],利用语言的语法减少了无效输出,但仍然会超时,而BLADE为线性算法</li><li>Chisel(被认为是SOTA),基于强化学习优化DD,而BLADE平均比其块2.3倍</li></ul></li><li>上述方法都基于DD,而BLADE不基于DD,而是用新的算法选择候选集,进行简化;</li><li>DomGad和Debop使用随即优化消除对DD的依赖,实现简化和通用性之间的权衡</li><li>而BLADE侧重速度,这反过来促进更多的训练数据来实现高通用性,这种高速可以应用于实际工作负载</li><li>[26]也提出了使用模糊测试和静态分析方法来阻止输入过拟合,相同的方法也可以应用于BLADE来强化训练数据</li></ul></li><li><strong>基于 IR和 binary 的简化器</strong><ul><li>JShrink[27] 对Java字节码 构造静态和动态的扩展调用图 来及逆行转化</li><li>J-Reduce[28] 使用DD有效减少Java字节码</li><li>Trimmer[5]和OCCAM[4]基于IR,使用如输入特化、循环展开和常量传播等技术，在程序的LLVM IR [24]上执行减小</li><li>RAZOR[2]在二进制可执行文件上进行简化</li><li>上述方法的主要缺点就是不支持可审计性</li></ul></li><li><strong>基于库的简化</strong><ul><li>Nibber[6] 通过删除共享库中未使用的函数来简化的放啊</li><li>PieceWise[29] 针对 共享库和静态库的代码,识别模块间的依赖关系并删除它们之间未使用的代码</li><li>这类技术是见解的,可以和BLADE和其它基于源码码的简化技术结合使用</li></ul></li><li><strong>杂项</strong><ul><li>一系列工作在不同的起点进行简化[30]-[40] (如JS,浏览器,app,配置文件)</li><li>有一项工作对简化进行了比较[41]</li></ul></li></ul><h3 id="7-%E7%BB%93%E8%AE%BA" tabindex="-1">7 结论</h3><ul><li>我们提出了BLADE简化框架,利用程序语言的结构实现更高效的简化,使其可以应用于大的程序上</li><li>它满足了一个有效的减小工具所设定的所有目标（减小代码大小和攻击面，快速减小，维护正确性以及可审计性）</li><li>与先前方法相比,我们BLADE在大的程序负载上有了很大的提升</li></ul><h2 id="carve%3A-practical-security-focused-software-debloating-using-simple-feature-set-mappings" tabindex="-1">CARVE: Practical Security-Focused Software Debloating Using Simple Feature Set Mappings</h2><p>FEAST’19: Proceedings of the 3rd ACM Workshop on Forming an Ecosystem Around Software</p><p>Brown M D, Pande S. Carve: Practical security-focused software debloating using simple feature set mappings[C],Proceedings of the 3rd ACM Workshop on Forming an Ecosystem Around Software Transformation. 2019: 1-7.</p><h3 id="0-%E6%91%98%E8%A6%81-1" tabindex="-1">0 摘要</h3><ul><li>现有技术对普通用户不实用存在创造不稳定程序和引入漏洞的风险，而且不适用于debloating网络协议实现等复杂软件</li><li>本文我们提出了CARVE，这是一种简单而有效的以安全为重点的debloating技术<ul><li>采用静态源代码注释来映射软件特性源代码,在debloating过程中消除了对高级软件分析的需求，降低了用户所需的整体技术水平</li><li>CARVE通过引入替代debloating技术超越了现有技术，该技术能够保留软件的互操作性并减轻创建不稳定程序或引入漏洞的风险</li><li>我们在12个debloating场景中评估了CARVE，并展示了满足或超过现有技术的安全性和性能改进。</li></ul></li></ul><h3 id="1-%E4%BB%8B%E7%BB%8D-1" tabindex="-1">1 介绍</h3><ul><li>软件膨胀对几乎所有软件都产生负面影响，在安全性和性能方面产生各种问题[1,6,7]</li><li>膨胀的主要来源是功能蔓延，即软件包随着时间的推移积累新功能的趋势[8]</li><li>膨胀的另一个来源是软件工程实践，这些实践倾向于重用模块化的软件库。程序通常仅使用每个外部库提供的功能的一个小子集[1]，然而，在运行时，整个库都加载到程序的内存空间中。</li><li>现有技术[2-5,9-10,18]存在限制</li></ul><h4 id="1.1-%E5%8A%A8%E6%9C%BA" tabindex="-1">1.1 动机</h4><ul><li>基于功能的简化方法基于复杂的规范和先进的分析技术,有很高的技术门槛,一般用户难以使用<ul><li>Chisel[3]需要用户提供测试脚本,脚本需要编译源代码并包含对生成程序的测试,且消耗时间长</li><li>TOSS[2]和TRIMMER[4]要求用户和LLVM,angr,TEMU等复杂工具进行交互以简化</li></ul></li><li>以上技术只能删除代码,无法保留良好的软件属性,如优雅的错误处理、用户体验、规范合规性和互操作性<ul><li>如ChiselBench中Chisel的简化结果会产生无意义的输出</li><li>TOSS简化的服务器软件对请求无法以规范协议响应</li></ul></li><li>现有方法在安全性上也存在限制<ul><li>使用动态分析引导去膨胀的技术，如 CHISEL 和 TOSS，由于对与功能相关的代码识别的不精确方式，可能导致产生不稳定的程序并引入新的漏洞 [18]</li><li>在源代码级别操作且只能进行代码删除的去膨胀工具（例如 CHISEL）也可能由于功能特定代码与与功能无关的代码之间的交互而引入新的漏洞</li><li>正如 Brown 和 Pande [22] 所示,改变程序的表示会以不可预测的方式引入新的Gadget,产生安全影响,多次简化和分析迭代可以减缓这种影响,而简化慢的工具不适合这项任务(如Chisel)</li></ul></li></ul><h4 id="1.2-%E8%B4%A1%E7%8C%AE" tabindex="-1">1.2 贡献</h4><ul><li><p>提出CARVE:一种简单有效以安全为中的的简化方法 <img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(8)_1.png" alt></p><ul><li>CARVE 不使用动态分析来识别与功能相关的代码,相反,用户使用简单灵活的基于注释的映射,将功能静态的映射到实现它们的源代码</li><li>这些功能映射允许用户进行稳健的、细粒度的去膨胀，可以选择用保留高级程序属性的替代代码替换去膨胀的代码，例如协议兼容性，并防止引入漏洞</li><li>CARVE 在预处理步骤中去膨胀软件，将具有特定功能映射源代码 和 识别不需要的功能的配置文件 作为输入</li><li>CARVE扫描源代码并智能地删除与不需要的功能相关联的代码，并根据映射插入替代代码。</li><li>其简化高效,因为与特征映射解耦,最终产品是一个仅包含所需功能的源代码的精简版本，可以在不更改构建链的情况下进行处理。</li></ul></li><li><p>我们通过使用CARVE从四个不同程度的侵略性的网络协议实现中去膨胀功能来评估CARVE</p><ul><li>这类软件具有输入/输出复杂性、规范合规性、跨平台互操作性和状态性质，去膨胀这类软件是具有挑战性的。</li><li>我们分析了我们的方法产生的去膨胀变体，并观察到安全性和性能方面的好处，包括消除漏洞、减少代码重用小工具集效用、减小代码大小和消除外部依赖</li></ul></li><li><p>下面第2节讨论Carve实现细节,第3节提供评估结果,第4节确定未来工作</p></li></ul><h3 id="2-%E8%AE%BE%E8%AE%A1" tabindex="-1">2 设计</h3><ul><li><p>基于特征的简化将软件特征映射到相应源代码并随后删除不需要的代码</p><ul><li>现有方法通过动态方法 处理映射,即使用具体输入执行程序,即Cov;</li><li>这些方法存在显著局限性<ul><li>它们要求用户提供复杂的规范或依赖于先进的软件分析工具生成映射。</li><li>它们难以识别非确定性特征、由外部条件触发的特征（例如拥塞控制）或没有可观察输出的特征（例如性能特征）。</li><li>简化软件的规模:因为确保生成的映射的正确性可能需要大量执行，这些方法的成本随着输入空间和执行时间的增加而上升，可能在处理大型、功能丰富的程序时变得不切实际。</li></ul></li></ul></li><li><p>CARVE通过静态特征映射克服了这些限制,其中用户直接将映射放置在目标程序的源代码中</p><ul><li>基于注释的特征映射是程序员熟悉的技术,这种方法在 自动化软件文档工具Doxygen,Sphinx[24,25] 中使用<ul><li>类似于C/C++预处理器指令(如 #ifdef)</li><li>且不仅限于输入触发的特征,也可以在指令级别防止</li></ul></li><li>缺点:<ul><li>需要手动进行注释进行特征映射,工作量可能大;</li><li>然而现代软件大部分重视代码质量,因此大多数软件特征可以直接映射到其关联的源代码</li></ul></li><li>针对缺点<ul><li>CARVE 通过整合几个设计元素来减少用户生成映射的工作量,由此减轻了缺点</li><li>由于特征映射为静态且在源代码中持久存在,因此生成映射的工作量仅需一次</li><li>此外,软件特征可以嵌套在特征结构中,简化了将 某个代码段 映射到多个相关特征的任务</li><li>CARVE还支持隐式特征映射,对常见代码结构进行语法感知进行简化,自动处理因为代码移除造成的控制流影响. 隐式映射提供了比预处理指令方案更丰富的简化支持</li></ul></li></ul></li></ul><h4 id="2.1-%E7%89%B9%E5%BE%81%E6%98%A0%E5%B0%84%E5%89%96%E6%9E%90" tabindex="-1">2.1 特征映射剖析</h4><ul><li>下图展示内嵌映射,由三部分组成<ul><li><ol><li>用户配置标记(///),将注释和特征映射分开</li></ol></li><li><ol start="2"><li>紧随标记,用户标明一个或多个特证明,用[] 包裹</li></ol></li><li><ol start="3"><li>可选操作符,用来区分 显式文件映射,显式段映射,隐式段映射<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(8)_2.png" alt></li></ol></li></ul></li></ul><h4 id="2.2-%E6%98%BE%E5%BC%8F%E7%89%B9%E5%BE%81%E6%98%A0%E5%B0%84" tabindex="-1">2.2 显式特征映射</h4><ul><li>支持两种显式映射(图中蓝色标记)<ul><li><ol><li>文件映射使用 <code>!</code> 操作符,指导简化器移除文件所有代码如果特征不需要</li></ol></li><li><ol start="2"><li>段显式映射,使用 <code>~</code>操作符,指导简化器移除到下一个<code>///~</code>之间的代码段,如果该功能不需要</li></ol><ul><li>对于段显式映射,还可以在两个替换标记之间<code>///^</code>指定替换代码段 ,例如，第13行的带替换映射指示debloater移除第17-19行的代码，并用第15行的代码替换它。</li></ul></li></ul></li></ul><h4 id="2.3-%E9%9A%90%E5%BC%8F%E7%89%B9%E5%BE%81%E6%98%A0%E5%B0%84" tabindex="-1">2.3 隐式特征映射</h4><ul><li>图中绿色标出,其通过将两个关键任务从简化器中去除,减少了生成特征映射所需的工作量<ul><li>首先,隐式特征映射不需要 终止标签来标记代码段的结束: 隐式映射指示简化器分析映射后的代码,从而确定其机构,进而确定因嘎嘎i删除的代码</li><li>隐式映射 消除了使用 替代代码的显式映射, 来处理与控制流影响<ul><li>例如:switch语句或条件分支 的隐式映射指示简化器分析删除映射代码的控制流影响,以产生 不产生意外控制流的简化代码<ul><li>图二中,第9行映射时,简化器将知道简化代码仅为一条语句,仅删除第10行</li><li>第22行和第25行的映射函数定义,此时,简化器将扫描和函数定义相关联的右括号,以确认要删除哪些行,对于这些映射,简化器将删除第23行和26-32行</li></ul></li></ul></li><li>下图展示了具有控制流的简化结构实例,右侧代码时左侧代码移除Feature_B后的结果 <img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(8)_3.png" alt="隐式映射"><ul><li>在对第4行switch语句进行语法感知分析时,简化器将确定由于缺少break语句,6,7行的映射代码是可到达的,此时,简化器无法删除这些行,只能删除case标签</li><li>对第12,13行条件分支语句进行分析,确定分支构造中的else块的存在 组织删除12行,为了保持else块的正确分支,只能删除else if块部分</li></ul></li><li>在简化器中处理隐形映射需要对不同PL进行特定的语法感知分析,因此,CARVE的设计支持使用自定义语言的简化模块. 针对C/C++的简化器支持单个语句,函数和结构定义,switch case以及条件分支的隐式映射</li></ul></li></ul><h4 id="2.4-%E8%A1%A8%E8%BE%BE%E8%83%BD%E5%8A%9B" tabindex="-1">2.4 表达能力</h4><ul><li>我们发现隐式特征映射在大多数情况下足够表达,能够正确识别某个功能的代码.</li><li>但由于高级PL的灵活性,有时候隐式映射无法表达,此时如果有必要需要使用显式映射并使用替代代码. 此时通过删除和替代代码,任何简化操作都足够表达</li><li>在我们4个基准测试中, 不得不使用显式映射+替换的比例为 5/668</li></ul><h4 id="2.5-%E7%AE%80%E5%8C%96%E5%99%A8%E6%93%8D%E4%BD%9C" tabindex="-1">2.5 简化器操作</h4><ul><li>CARVE使用的静态特征映射方案将 特征映射到代码 与 代码简化 解耦. 因此简化变得简易</li><li>CARVE流程<ul><li><ol><li>CARVE 以一个单独的配置文件作为输入</li></ol><ul><li>文件指定了特征映射源代码的未知</li><li>代码所使用语言(指示语法感知模块)</li><li>简化特征的层次结构</li><li>用户希望简化的特征列表</li></ul></li><li><ol start="2"><li>执行时,简化器复制指定的源代码目录,并扫描特征映射的源代码,当发现特征映射时,简化器将于指定的简化特征进行比较,如果是需要简化特征的子集,简化器将处理该映射,否则继续扫描,直到所有文件都被扫描完毕</li></ol></li></ul></li></ul><h4 id="2.6-%E5%8F%AF%E9%9D%A0%E6%80%A7" tabindex="-1">2.6 可靠性</h4><ul><li>当用户提供的特征映射(包括替代代码)是正确的,Carve会是一种可靠的简化技术<ul><li>简化器执行的所有转换在语法和控制流上将会都是正确的</li><li>静态特征映射是 细粒度的,将特征对应到源代码,因此映射可以精准对应到特征; 而对于动态方法,由于其不可预测性,可能会产生不正确的映射<ul><li>如Chisel被证明简化的程序引入了新的漏洞并产生了额外的意外行为[18]</li><li>TOSS使用的特征识别机制不能保证识别所有特征代码, 需要对期望的功能和不期望的功能进行 去噪模糊测试以检测不可靠的变体 [2]</li></ul></li></ul></li><li>高级程序语言表达是高度抽象的,所以在简化时具有挑战性,删除代码时有时不得不产生漏洞<ul><li>下面代码中,从switch语句中删除任一case都不影响语义,但会在会授权的情况执行受保护的函数</li><li>CARVE通过支持 替代 代码来缓解这一问题,本例子中可以替代异常处理代码</li></ul></li></ul><pre><code class="language-C">switch(auth_type)&#123;  case 1:perform_auth_1(creds);break;  case 2:perform_auth_2(creds);break;&#125;protected_function();</code></pre><ul><li>于编写源代码类似,编写特征映射也可能出错<ul><li>在实践中,创建特征映射发生的错误可以使用 确保源代码正确的工具 来检测</li><li>导致违反语言语义映射的错误会被编译器捕获</li><li>成功编译的代码中存在的映射错误可以通过常见的测试技术,如单元测试和集成测试来识别</li><li>使用Coverity [26] 这样的常见静态分析工具可以识别安全问题，比如无意中删除边界检查</li></ul></li></ul><h3 id="3-%E8%AF%84%E4%BC%B0" tabindex="-1">3 评估</h3><ul><li>选择4个网络协议软件包,这些软件包在大小,特征密度和复杂性方面都各不相同,简化这些软件时调整性的,因为其涉及复杂的交互和严格的规范,软件包括<ul><li>libmodbus v3.1.4，一个工业协议库。</li><li>Bftpd v4.9，一个FTP服务器实用程序。</li><li>libcurl v7.61.0，一个数据传输实用程序库。</li><li>mongoose v.6.8，一个嵌入式Web服务器库。</li></ul></li><li>对每个软件包,我们手动创建了各种粒度的特征信息,以及三种不同的简化配置,以适应不同的场景<ul><li>保守（C）：对软件包中的一些外围特征进行简化</li><li>中等（M）：对软件包中的一些外围特征和一些核心特征进行简化</li><li>激进（A）：对软件包中除了一小部分核心特征之外的所有可简化特征进行简化</li></ul></li><li>每种情景中<ul><li>我们使用CARVE对软件包进行简化,使用默认的软件包构建配置 和 GCC v7.3.0 构建了结果变体,所有软件在同一平台上构建,每个构建保持不变</li><li>我们使用开发者提供的测试脚本和自定义测试脚本来测试所有变体,以确保其保留特征的正确性,并且调用简化掉的特征时不会导致变体崩溃</li></ul></li></ul><h4 id="3.1-%E5%AE%89%E5%85%A8%E6%8F%90%E5%8D%87" tabindex="-1">3.1 安全提升</h4><ul><li>简化可以消除漏洞<ul><li><ol><li>在CVE库中搜索了选择软件包的已知漏洞</li></ol><ul><li>对libmodbus和Bftpd,没有CVE,libcurl有6个,mongoose有17个</li><li>随后分析简化后漏洞的消除情况,结果如图</li></ul></li><li><ol start="2"><li>软件抵抗代码重用攻击</li></ol><ul><li>该攻击将执行重定向到内存中现有的指令，以引发恶意效果</li><li>在基于小工具的代码重用攻击方法（如ROP、JOP和COP）中，执行被重定向到程序中存在的有序短指令序列（小工具），以构造恶意有效载荷而无需注入代码。</li><li>评估基于 Gadget的安全 是复杂的,因为再简化后可能引入新的. 我们使用Brown和Pande [22]提出的度量来衡量CARVE对基于小工具的攻击的有效性，即特殊用途小工具的可用性和小工具集表达性。我们的结果显示在表1的分组列中。</li></ul></li></ul></li><li>总体而言,CARVE在减少小工具集表达性方面是有效的，针对三个不同表达性水平 [20, 21]<ul><li>在十二个情景中的七个中，简化减少了整体小工具集的表达性</li><li>在三个情景中简化没有效果</li><li>在两个情景中产生了负面影响<ul><li>我们结果中观察到的负面副作用与CHISEL [22]和TRIMMER [4]中观察到的负面副作用一致。由于CARVE易于重新配置且去噪速度快，因此它非常适合使用迭代去噪来缓解这些负面副作用 [22]。</li></ul></li></ul></li></ul><p><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(8)_4.png" alt></p><h4 id="3.2-%E5%A4%A7%E5%B0%8F%E5%87%8F%E5%B0%8F" tabindex="-1">3.2 大小减小</h4><ul><li>减小效果如下图<ul><li>二进制减小高于预期,因为对简化代码编译器效果优化的提升</li><li>简化还消除了部分外部库的依赖,降低了运行时内存消耗<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(8)_5.png" alt="减小效果"></li></ul></li></ul><h4 id="3.3-%E6%80%A7%E8%83%BD%E5%BC%80%E9%94%80" tabindex="-1">3.3 性能开销</h4><ul><li>CARVE的解耦涉及将简化开支最小化,每个情景的简化均不超过5s,同时也方便扩展<ul><li>技术的主要开销在功能映射上,创建和维护映射有很多工作量,包括对软件的输入程度,特征密度及目标软件的复杂性</li><li>在实践中,我们发现在用户对源代码的了解有限的情况下，创建初始特征映射并会因成本而放弃</li><li>软件工程实践倾向于模块化和分离软件包,这将帮助减少生成合理映射所需要的工作量</li></ul></li><li>对于我们的基准软件,生成密度如下(mappings/KLOC)<ul><li>ibmodbus为61.5 m/KLOC</li><li>Bftpd为24.2 m/KLOC</li><li>mongoose为13.4 m/KLOC</li><li>libcurl为4.9 m/KLOC</li><li>且很少使用替代映射,libmodbus需要17个，libcurl需要20个,另外两个不需要</li></ul></li><li>这标明创建特征映射的一次性成本是合理的。</li></ul><h3 id="4-%E8%AE%A8%E8%AE%BA" tabindex="-1">4 讨论</h3><ul><li><strong>与现有技术比较</strong><ul><li>Chisel[2]和TOSS[3] 平均减少代码大小 86%,43.8%在ChiselBench中,Carve与其相当</li><li>Trimmer[4]平均减少代码大小 21% 在复杂的基于网络的软件中; 此时Carve性能优于Trimmer</li><li>消除CVE方面,CARVE与CHISEL相当</li><li>CARVE在减少和引入新 gadgets方面与Chisel和Trimmer相当</li></ul></li><li><strong>限制</strong>:<ul><li>仅对源代码操作,不适用于闭源软件</li><li>可以用于任何基于文本且支持注释的软件,但目前只支持 C/C++ 语言</li></ul></li><li><strong>未来工作</strong><ul><li>基于创建其它语言的简化模块</li><li>开发静态分析工具,帮助用户快速生成可靠的特征映射; 这些工具将实时分析用户创建的映射,提供建议的新映射,并识别个别简化时潜在的可靠性问题</li></ul></li></ul><h3 id="5-%E7%BB%93%E8%AE%BA" tabindex="-1">5 结论</h3><ul><li>本文介绍Carve,一种简单而强大的软件瘦身技术，它克服了现有方法的缺点<ul><li>在不需要先进软件分析的情况下实现有效简化</li><li>同时保留了如 交互性和规范性 等理想软件特性</li></ul></li><li>评估显式<ul><li>CARVE适合于解决网络协议的简化问题,在4个协议简化中,安全性和性能都很出色</li><li>在12个场景中,CARVE消除了漏洞,减少了代码工具重用</li><li>并使用了 易于用户使用的简单技术,缩减了代码大小,与现有方法相当</li></ul></li></ul><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;blade%3A-scalable-source-code-debloating-framework&quot; tabindex=&quot;-1&quot;&gt;BLADE: Scalable Source Code Debloating Framework&lt;/h2&gt;
&lt;p&gt;2023 IEEE</summary>
      
    
    
    
    <category term="论文" scheme="http://example.com/categories/%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="SoftwareEngineering" scheme="http://example.com/tags/SoftwareEngineering/"/>
    
    <category term="SoftwareDebloating" scheme="http://example.com/tags/SoftwareDebloating/"/>
    
  </entry>
  
  <entry>
    <title>Software Debloating 论文阅读 (5) (6)</title>
    <link href="http://example.com/2024/01/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/SoftwareDebloating/Software%20Debloating%20%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB(5)(6)/"/>
    <id>http://example.com/2024/01/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/SoftwareDebloating/Software%20Debloating%20%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB(5)(6)/</id>
    <published>2024-01-15T07:10:43.890Z</published>
    <updated>2024-01-15T07:10:43.890Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(5)_x.png" alt></p><h2 id="debop%3Aprogram-debloating-via-stochastic-optimization" tabindex="-1">DEBOP:Program Debloating via Stochastic Optimization</h2><p>ICSE-NIER’20, May 23–29, 2020, Seoul, Republic of Korea<br>CCF A会</p><p>Q. Xin, M. Kim, Q. Zhang, and A. Orso, “Program debloating via stochastic optimization,” in Proceedings of the ACM/IEEE 42nd International Conference on Software Engineering: New Ideas and Emerging Results, ICSE-NIER ’20, (New York, NY, USA), p. 65–68, Association</p><h3 id="0-%E6%91%98%E8%A6%81" tabindex="-1">0 摘要</h3><ul><li><p>Debloating的定义</p></li><li><p>我们确信程序debloating是一个多方面的问题,必须用更通用的方法解决. 基于此,我们提出了一种通用的方法,可以将程序去膨胀问题形式化为一个多目标优化问题(multi-objective optimization problem, MOP),并使用随机优化算法来解决它.</p></li><li><p>给定一个需要简化的程序,我们需要用户指定</p><ul><li><ol><li>程序的使用情况(例如:一组带有相关使用概率的输入)</li></ol></li><li><ol start="2"><li>去膨胀关注的因素</li></ol></li><li><ol start="3"><li>这些因素的相对重要性</li></ol></li></ul></li><li><p>基于以上信息,该方法定义了一个合适的目标函数,用于将分数非陪给每个可能的简化程序,并生成最大化目标函数的解决方案</p></li><li><p>我们同时提出和评估了DEBOP:我们方法的一个具体实例,考虑了 大小减小,攻击面减小和通用性三个方面</p></li><li><p>结果现实,尽管仍然是初步的(albeit still preliminary),表明我们的方法可以有效地生成实现不同去膨胀目标之间良好权衡的去膨胀程序</p></li></ul><h3 id="1-%E4%BB%8B%E7%BB%8D" tabindex="-1">1 介绍</h3><ul><li><p>去膨胀有很多目标,且目标间可能冲突,例如</p><ul><li>失败10%的输入,但减少了80%的漏洞,这是可以接受的</li><li>当通用性更重要时,程序大小的减小程度可以牺牲</li></ul></li><li><p>因此我们提出了一种新的,通用的程序去膨胀方法,将其视为多目标优化问题</p></li><li><p>我们方法根据以下元素指定简化任务</p><ul><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span></eq> 需要简化的程序</li><li>一组带有使用概率的输入(即使用情况)</li><li>去膨胀任务关注的因素</li><li>这些因素的相对重要性,用权重表示</li></ul></li><li><p>基于以上信息,该方法生成一个目标函数 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span></span></span></span></eq> ,方法使用 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span></span></span></span></eq> 来聘雇搜索出的简化程序的分数,最终需要最大化 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span></span></span></span></eq></p></li><li><p>我们同时介绍了DEBOP,为我们方法的一个具体实例,考虑了三个去膨胀目标</p><ul><li><ol><li>程序大小减小</li></ol></li><li><ol start="2"><li>程序攻击面减小</li></ol></li><li><ol start="3"><li>程序通用性</li></ol></li></ul></li><li><p>除此外,DEBOP也接受三个目标的权重,以此重定义 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span></span></span></span></eq></p></li><li><p>我们使用MCMC(Markov Chain Monte Carlo 马尔可夫蒙特卡洛)技术来 有效地探索解空间,MCMC在函数 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span></span></span></span></eq> 的指导下,对 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span></eq> 的简化版本进行采样,并报告具有最佳值得版本,这个过程我们称为 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mrow><mi>d</mi><mi>e</mi><mi>b</mi></mrow></msub></mrow><annotation encoding="application/x-tex">p_{deb}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> , 其是实际解得近似值</p></li><li><p>评估,在ChiselBenchmark</p><ul><li>在多目标权衡上表现不错,同时与另一个方法进行比较</li><li>DEBOP可能通用性不佳,但会产生更好得整体效果</li></ul></li><li><p>本文贡献如下</p><ul><li><ol><li>一个新的通用的简化程序形式化方法,将其视为多目标优化问题</li></ol></li><li><ol start="2"><li>一个具体的实例DEBOP,用于简化程序,并在多个目标之间进行权衡</li></ol></li><li><ol start="3"><li>一个概念验证聘雇,展示我们方法的潜在用途,并提供了对程序简化中权衡的新见解</li></ol></li><li><ol start="4"><li><a href="https://sites.google.com/view/debop19">DEBOP开源</a></li></ol></li></ul></li></ul><h3 id="2-%E8%83%8C%E6%99%AF" tabindex="-1">2 背景</h3><ul><li>Debloating定义</li><li>程序表示</li></ul><h3 id="3-%E6%96%B9%E6%B3%95debop" tabindex="-1">3 方法DEBOP</h3><ul><li><p>DEBOP</p><ul><li>支持三个目标:程序大小减小,程序攻击面减小,程序通用性</li><li>通过MCMC取样技术,在优化问题上取得近似解</li></ul></li><li><p>形式化描述</p><ul><li>一个简化程序的版本 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>p</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>∈</mo><mi>S</mi><mi>u</mi><mi>b</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p&#x27;\in Sub(p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">u</span><span class="mord mathnormal">b</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span></eq></li><li>size reduction: <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>r</mi><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msup><mi>p</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>s</mi><mi>z</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>−</mo><mi>s</mi><mi>z</mi><mo stretchy="false">(</mo><msup><mi>p</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><mrow><mi>s</mi><mi>z</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">sr(p,p&#x27;)=\frac{sz(p)-sz(p&#x27;)}{sz(p)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0019em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">sr</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.5845em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0645em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.04398em;">sz</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">p</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.04398em;">sz</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">p</span><span class="mclose mtight">)</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.04398em;">sz</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></eq>, <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>z</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">sz(p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">sz</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span></eq>是程序 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span></eq> 的大小,如代码行数</li><li>attack surface reduction: <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>r</mi><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msup><mi>p</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>a</mi><mi>s</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>−</mo><mi>a</mi><mi>s</mi><mo stretchy="false">(</mo><msup><mi>p</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><mrow><mi>a</mi><mi>s</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">ar(p,p&#x27;)=\frac{as(p)-as(p&#x27;)}{as(p)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0019em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.5845em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0645em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">s</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">p</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">s</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">p</span><span class="mclose mtight">)</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">s</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></eq>, <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>s</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">as(p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span></eq>是程序 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span></eq> 的攻击面数量,如 gadget数量</li><li>generality: <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msup><mi>p</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo>=</mo><msub><mo>∑</mo><mrow><msub><mi>i</mi><mi>k</mi></msub><mo>∈</mo><mi>I</mi></mrow></msub><mi>p</mi><msub><mi>r</mi><mi>k</mi></msub><mi>T</mi><mo stretchy="false">(</mo><msub><mi>i</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g(p,p&#x27;)=\sum_{i_k\in I} pr_kT(i_k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0019em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1556em;vertical-align:-0.4056em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1786em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3488em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1512em;"><span></span></span></span></span></span></span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4056em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq>, <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span></eq> 是一组输入, <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><msub><mi>r</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">pr_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 是输入 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>i</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">i_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 的使用概率, <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><msub><mi>i</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(i_k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq> 是 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>p</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">p&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></eq> 在输入 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>i</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">i_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 上的测试结果, <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><msub><mi>i</mi><mi>k</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">T(i_k)=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></eq> 表示通过, <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><msub><mi>i</mi><mi>k</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">T(i_k)=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></eq> 表示失败</li></ul></li><li><p>DEBOP的目标是生成一个简化程序,最大化 sr,ar,g 的加权和</p><ul><li>首先计算简化程序的分数, <eq><span class="katex-error" title="ParseError: KaTeX parse error: Can&#x27;t use function &#x27;$1#x27; in math mode at position 9: r(p,p&#x27;) $̲ , 与sr,ar组合 $" style="color:#cc0000">r(p,p&#x27;) $ , 与sr,ar组合 $</span></eq>r(p,p’)=(1-\alpha) * sr(p,p’) + \alpha * ar(p,p’)<eq><span class="katex-error" title="ParseError: KaTeX parse error: Can&#x27;t use function &#x27;$1#x27; in math mode at position 1: $̲ , 其中 $\alpha" style="color:#cc0000">$ , 其中 $\alpha</span></eq> 表示sr和ar的相关重要性</li><li>随后计算目标函数 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msup><mi>p</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(p,p&#x27;)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0019em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq> , 与r,g组合 <section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msup><mi>p</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>β</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>r</mi><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msup><mi>p</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo>+</mo><mi>β</mi><mo>∗</mo><mi>g</mi><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msup><mi>p</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(p,p&#x27;)=(1-\beta) * r(p,p&#x27;) + \beta * g(p,p&#x27;)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0519em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0519em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0519em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></eqn></section> , 其中 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span></eq> 表示r和g的相关重要性</li><li>我们将这个值称为 <em>O-score</em> , 现在可以将DEBOP的简化任务形式化为一个优化问题 <section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>P</mi><mrow><mi>d</mi><mi>e</mi><mi>b</mi></mrow></msub><mo>=</mo><mi>a</mi><mi>r</mi><mi>g</mi><mi>m</mi><mi>a</mi><msub><mi>x</mi><mrow><msup><mi>p</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>∈</mo><mi>S</mi><mi>u</mi><mi>b</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow></msub><mi>O</mi><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msup><mi>p</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P_{deb} = argmax_{p&#x27;\in Sub(p)} O(p,p&#x27;)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1571em;vertical-align:-0.3552em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">ma</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">b</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">p</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></eqn></section> 通过使用不同的权重 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span></eq> 和 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span></eq> , 可以调整DEBOP的行为,以便在sr,ar,g之间进行权衡</li></ul></li><li><p>由于 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>u</mi><mi>b</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Sub(p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">u</span><span class="mord mathnormal">b</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span></eq> 的指数规模，通过枚举每个 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>p</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>∈</mo><mi>S</mi><mi>u</mi><mi>b</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p&#x27;∈Sub(p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">u</span><span class="mord mathnormal">b</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span></eq> 并找到具有最高<em>O-score</em>的 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>p</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">p&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></eq> 来解决这个问题是不可行的。因此，Debop利用随机搜索，特别是马尔可夫链蒙特卡洛（MCMC）采样方法，生成一个近似的 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mrow><mi>d</mi><mi>e</mi><mi>b</mi></mrow></msub></mrow><annotation encoding="application/x-tex">p_{deb}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>。</p></li></ul><h4 id="mcmc-%26-metropolis-hastings-algorithm" tabindex="-1">MCMC &amp; Metropolis-Hastings Algorithm</h4><ul><li><p>MCMC采样用来估计一个分布 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span></eq> 的期望值. 为了使用MCMC,我们需要使用 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msup><mi>p</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(p,p&#x27;)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0019em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq> 为 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span></eq> 定义一个密度函数 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msup><mi>p</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(p,p&#x27;)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0019em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq> , <section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msup><mi>p</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mi>Z</mi></mfrac><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><mi>k</mi><mo>∗</mo><mi>O</mi><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msup><mi>p</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(p,p&#x27;)=\frac{1}{Z}exp(k*O(p,p&#x27;))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0519em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0074em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0519em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">))</span></span></span></span></span></eqn></section> 其中k,Z是常数</p></li><li><p>我们的目标是根据密度值 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span></eq> 的比例来抽取足够数量的样本 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span></eq> ，并基于 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span></eq> 推断 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span></eq> 的性质。直观地说，这意味着应该从具有较高密度值（因此具有较高O-score）的 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span></eq> 中抽取更多样本，而不是从具有较低密度值的 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span></eq> 中抽取样本。在我们的情况下，样本是一个简化的程序 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>p</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>∈</mo><mi>S</mi><mi>u</mi><mi>b</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p&#x27;∈Sub(p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">u</span><span class="mord mathnormal">b</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span></eq> 。为了抽取这样的样本，我们使用 *Metropolis-Hastings（MH）*算法[7]，给定当前样本 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>p</mi><mi>i</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup></mrow><annotation encoding="application/x-tex">p&#x27;_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0106em;vertical-align:-0.2587em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-2.4413em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2587em;"><span></span></span></span></span></span></span></span></span></span></eq> ，定义新样本<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>p</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup></mrow><annotation encoding="application/x-tex">p&#x27;_{i+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0689em;vertical-align:-0.317em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-2.4413em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.317em;"><span></span></span></span></span></span></span></span></span></span></eq>被接受的概率为：<section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>A</mi><mo stretchy="false">(</mo><msubsup><mi>p</mi><mi>i</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo>→</mo><msubsup><mi>p</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mfrac><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msubsup><mi>p</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo stretchy="false">)</mo><mo>∗</mo><mi>q</mi><mo stretchy="false">(</mo><msubsup><mi>p</mi><mi>i</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo separator="true">,</mo><msubsup><mi>p</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo stretchy="false">)</mo></mrow><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msubsup><mi>p</mi><mi>i</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo stretchy="false">)</mo><mo>∗</mo><mi>q</mi><mo stretchy="false">(</mo><msubsup><mi>p</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo separator="true">,</mo><msubsup><mi>p</mi><mi>i</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo stretchy="false">)</mo></mrow></mfrac><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mfrac><mrow><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><mi>k</mi><mo>∗</mo><mi>O</mi><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msubsup><mi>p</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>∗</mo><mi>q</mi><mo stretchy="false">(</mo><msubsup><mi>p</mi><mi>i</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo separator="true">,</mo><msubsup><mi>p</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo stretchy="false">)</mo></mrow><mrow><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><mi>k</mi><mo>∗</mo><mi>O</mi><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msubsup><mi>p</mi><mi>i</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>∗</mo><mi>q</mi><mo stretchy="false">(</mo><msubsup><mi>p</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo separator="true">,</mo><msubsup><mi>p</mi><mi>i</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo stretchy="false">)</mo></mrow></mfrac><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex"> \begin{aligned} A(p&#x27;_i \rightarrow p&#x27;_{i+1}) &amp;= min(1,\frac{f(p,p&#x27;_{i+1}) * q(p&#x27;_i,p&#x27;_{i+1})}{f(p,p&#x27;_i)*q(p&#x27;_{i+1},p&#x27;_i)}) \\ &amp;=min(1,\frac{exp(k*O(p,p&#x27;_{i+1})) *q(p&#x27;_i,p&#x27;_{i+1})}{exp(k*O(p,p&#x27;_i)) *q(p&#x27;_{i+1},p&#x27;_i)}) \end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:5.5602em;vertical-align:-2.5301em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.0301em;"><span style="top:-5.0301em;"><span class="pstrut" style="height:3.4589em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3053em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.4589em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.5301em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.0301em;"><span style="top:-5.0301em;"><span class="pstrut" style="height:3.4589em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">min</span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4589em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7337em;"><span style="top:-2.4231em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.0448em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2769em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7337em;"><span style="top:-2.4231em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0448em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3352em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7337em;"><span style="top:-2.4231em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.0448em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2769em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.707em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-2.4413em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.317em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-2.4413em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2587em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-2.4413em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.317em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.0212em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.4589em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">min</span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4589em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7337em;"><span style="top:-2.4231em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.0448em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2769em;"><span></span></span></span></span></span></span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7337em;"><span style="top:-2.4231em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0448em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3352em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7337em;"><span style="top:-2.4231em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.0448em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2769em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.707em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-2.4413em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.317em;"><span></span></span></span></span></span></span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-2.4413em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2587em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-2.4413em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.317em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.0212em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.5301em;"><span></span></span></span></span></span></span></span></span></span></span></span></eqn></section> 其中 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo stretchy="false">(</mo><msubsup><mi>p</mi><mi>i</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo separator="true">,</mo><msubsup><mi>p</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">q(p&#x27;_i,p&#x27;_{i+1})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0689em;vertical-align:-0.317em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-2.4413em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2587em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-2.4413em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.317em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq> 是从 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>p</mi><mi>i</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup></mrow><annotation encoding="application/x-tex">p&#x27;_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0106em;vertical-align:-0.2587em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-2.4413em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2587em;"><span></span></span></span></span></span></span></span></span></span></eq> 到 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>p</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup></mrow><annotation encoding="application/x-tex">p&#x27;_{i+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0689em;vertical-align:-0.317em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-2.4413em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.317em;"><span></span></span></span></span></span></span></span></span></span></eq> 的转移概率. 当转移是对称时(例如 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo stretchy="false">(</mo><msubsup><mi>p</mi><mi>i</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo separator="true">,</mo><msubsup><mi>p</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo stretchy="false">)</mo><mo>=</mo><mi>q</mi><mo stretchy="false">(</mo><msubsup><mi>p</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo separator="true">,</mo><msubsup><mi>p</mi><mi>i</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">q(p&#x27;_i,p&#x27;_{i+1})=q(p&#x27;_{i+1},p&#x27;_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0689em;vertical-align:-0.317em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-2.4413em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2587em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-2.4413em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.317em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0689em;vertical-align:-0.317em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-2.4413em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.317em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-2.4413em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2587em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq> ),被接受的概率称为 <section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mo stretchy="false">(</mo><msubsup><mi>p</mi><mi>i</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo>→</mo><msubsup><mi>p</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mfrac><mrow><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><mi>k</mi><mo>∗</mo><mi>O</mi><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msubsup><mi>p</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><mrow><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><mi>k</mi><mo>∗</mo><mi>O</mi><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msubsup><mi>p</mi><mi>i</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A(p&#x27;_i \rightarrow p&#x27;_{i+1})=min(1,\frac{exp(k*O(p,p&#x27;_{i+1})) }{exp(k*O(p,p&#x27;_i)) })</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0519em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1072em;vertical-align:-0.3053em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3053em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.4218em;vertical-align:-0.9629em;"></span><span class="mord mathnormal">min</span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4589em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7337em;"><span style="top:-2.4231em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.0448em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2769em;"><span></span></span></span></span></span></span><span class="mclose">))</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.707em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-2.4413em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.317em;"><span></span></span></span></span></span></span><span class="mclose">))</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9629em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span></span></eqn></section></p></li><li><p>总的MH算法从样本 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>p</mi><mn>0</mn><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup></mrow><annotation encoding="application/x-tex">p_0&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.2481em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-2.4519em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span></span></span></span></eq> 开始,随后迭代执行以下步骤</p><ul><li><ol><li>从 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>p</mi><mi>i</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup></mrow><annotation encoding="application/x-tex">p&#x27;_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0106em;vertical-align:-0.2587em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-2.4413em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2587em;"><span></span></span></span></span></span></span></span></span></span></eq> 中随机生成一个新的样本 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>p</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup></mrow><annotation encoding="application/x-tex">p&#x27;_{i+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0689em;vertical-align:-0.317em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-2.4413em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.317em;"><span></span></span></span></span></span></span></span></span></span></eq></li></ol></li><li><ol start="2"><li>计算 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">(</mo><msubsup><mi>p</mi><mi>i</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo>→</mo><msubsup><mi>p</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A(p&#x27;_i \rightarrow p&#x27;_{i+1})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0106em;vertical-align:-0.2587em;"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-2.4413em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2587em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0689em;vertical-align:-0.317em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-2.4413em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.317em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq></li></ol></li><li><ol start="3"><li>以概率 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">(</mo><msubsup><mi>p</mi><mi>i</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo>→</mo><msubsup><mi>p</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A(p&#x27;_i \rightarrow p&#x27;_{i+1})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0106em;vertical-align:-0.2587em;"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-2.4413em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2587em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0689em;vertical-align:-0.317em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-2.4413em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.317em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq> 接受 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>p</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup></mrow><annotation encoding="application/x-tex">p&#x27;_{i+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0689em;vertical-align:-0.317em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-2.4413em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.317em;"><span></span></span></span></span></span></span></span></span></span></eq> ,否则拒绝 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>p</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup></mrow><annotation encoding="application/x-tex">p&#x27;_{i+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0689em;vertical-align:-0.317em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-2.4413em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.317em;"><span></span></span></span></span></span></span></span></span></span></eq> ,并保持 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>p</mi><mi>i</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup></mrow><annotation encoding="application/x-tex">p&#x27;_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0106em;vertical-align:-0.2587em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-2.4413em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2587em;"><span></span></span></span></span></span></span></span></span></span></eq> 作为下一个样本</li></ol></li></ul></li><li><p>下图明确了DEBOP使用的MH算法</p><ul><li>1到5行初始化,6到21行是迭代</li><li>在每次迭代中,从当前样本 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">ps</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">s</span></span></span></span></eq> 突变到一个新样本 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><msup><mi>s</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">ps&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></eq> ,有两种方式<ul><li><ol><li>从程序中随机选择一个语句</li></ol></li><li><ol start="2"><li>从 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">ps</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">s</span></span></span></span></eq> 中加入或删除这一语句(7-11行)</li></ol></li></ul></li><li>随后算法根据公式 计算接收概率,直到产生样本数为n个</li></ul></li></ul><p><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(5)_1.png" alt></p><h3 id="4-%E6%A6%82%E5%BF%B5%E9%AA%8C%E8%AF%81%E8%AF%84%E4%BC%B0" tabindex="-1">4 概念验证评估</h3><ul><li>探究两个问题<ul><li>RQ1:当提供不同的 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo separator="true">,</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha,\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span></eq> 参数时,DEBOP的产生的简化程序在sr,ar,g之间如何权衡?</li><li>RQ2:DEBOP的简化与具体单目标的简化方法相比如何</li></ul></li></ul><h4 id="%E5%AE%9E%E7%8E%B0" tabindex="-1">实现</h4><ul><li>用C++实现DEBOP原型</li><li>使用Clang构建p的AST来识别其语句</li><li>用(GCC v7.4.0 -O3) 编译简化程序后的运行大小来衡量程序大小</li><li>使用ROPgadget来识别程序的gadget数量,衡量程序攻击面</li></ul><h4 id="%E5%AE%9E%E9%AA%8C%E8%AE%BE%E7%BD%AE" tabindex="-1">实验设置</h4><ul><li>ChiselBench</li><li>设置1s超时限制,防止未终止</li><li>设置1000个样本,k=50来计算期望概率</li></ul><h4 id="4.1-rq1%E7%BB%93%E6%9E%9C" tabindex="-1">4.1 RQ1结果</h4><p><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(5)_2.png" alt="RQ1"></p><ul><li>当 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span></eq> 增加时,sr更接近ar,因为生成的程序更倾向攻击面减少</li><li>当 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span></eq> 增加时,即更重视通用性,g增加而sr,ar减少</li><li>以上结果证实了DEBOP可以在简化过程中进行不同的权衡</li></ul><h4 id="4.2-rq2%E7%BB%93%E6%9E%9C" tabindex="-1">4.2 RQ2结果</h4><p><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(5)_3.png" alt="RQ2"></p><ul><li><p>由于空间限制,只展示每个 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span></eq> 下Debop的分数和Chisel分数的比率,这些比率是在考虑的九个β值上计算得出的平均值和标准差。</p></li><li><p>上表的扩展版本可以在网上找到。</p></li><li><p>与Chisel进行对比</p><ul><li>DEBOP在sr,ar,g之间权衡,而Chisel只考虑sr</li><li>在sr上,Chisel比Debop好</li><li>ar,g上,Debop比Chisel好</li></ul></li><li><p>且Debop后续可以再改进</p></li></ul><h3 id="5-%E7%9B%B8%E5%85%B3%E5%B7%A5%E4%BD%9C" tabindex="-1">5 相关工作</h3><ul><li>很少有简化的工作考虑多个目标,我们的方法基于MCMC技术用多目标思想来考虑这一问题</li><li>我们的工作也与用MCMC解决其它问题有关,如超优化[20],以及更广泛的使用遗传算法来改进软件的技术[16]</li></ul><h3 id="6-%E7%BB%93%E8%AE%BA%E5%92%8C%E6%9C%AA%E6%9D%A5%E5%B7%A5%E4%BD%9C" tabindex="-1">6 结论和未来工作</h3><ul><li><p>我们提出了一种新的通用的程序去膨胀方法,将其视为多目标优化问题</p></li><li><p>并且我们提出了DEBOP,为我们方法的一个具体实例,考虑了三个去膨胀目标,并使用MCMC技术来解决它.</p></li><li><p>最后，我们通过概念验证评估展示了我们方法的可行性和潜在用途</p></li><li><p>未来工作,除更广泛的评估外</p><ul><li>我们将研究如何通过使用(1) 除语句之外的其它变异元素(2)基于程序结构的变异,来改进算法</li><li>同样计划研究其它采样算法(Gibbs sampling[10]),其它随机搜索算法 (genetic programming[15]) 来进行优化</li><li>在更长期和更广泛的未来研究方向上，我们提出的方法具有通用性，可以应用于去臃肿之外的领域。特别是，我们计划在我们的方法的背景下研究资源适应[8]、能源减少[21]和程序修复方面的应用。</li></ul></li></ul><h2 id="subdomain-based-generality-aware-debloating" tabindex="-1">Subdomain-Based Generality-Aware Debloating</h2><p>ASE 20 ,CCF A会<br>Xin Q, Kim M, Zhang Q, et al. Subdomain-based generality-aware debloating[C],Proceedings of the 35th IEEE/ACM International Conference on Automated Software Engineering. 2020: 224-236.</p><h3 id="0-%E6%91%98%E8%A6%81-1" tabindex="-1">0 摘要</h3><ul><li><p>程序膨胀降低性能和安全</p></li><li><p>为了突破基于输入的方法过拟合输入集的限制,我们提出了 <strong>DOMGAD</strong> ,有两个主要优点超过现有方法</p><ul><li><ol><li>其生成的简化程序保证在子域上工作,而不是输入</li></ol></li><li><ol start="2"><li>使用随机优化简化程序,以在简化和通用性(即简化程序能够正确处理整个域中输入的程度)上实现权衡</li></ol></li></ul></li><li><p>在ChiselBench上评估,50%的代码减少和95%的通用性,高于目前两种SOTA</p></li></ul><h3 id="1-%E4%BB%8B%E7%BB%8D-1" tabindex="-1">1 介绍</h3><ul><li><p><strong>DOMGAD</strong>两个优点</p><ul><li><ol><li>生成的简化程序保证在子域上工作,而不是输入;</li></ol><ul><li>即DomGad生成的程序对属于这些子域的每一个输入都能正确运行;</li><li>对不属于当前子域的输入都会禁止运行防止异常行为; 与此相对基于输入的方法仅能保证在特定输入下正确运行,因此阻止异常行为的唯一方法是阻止未知输入的执行</li></ul></li><li><ol start="2"><li>DOMGAD不仅考虑了简化,也考虑了在通用性上的权衡</li></ol></li></ul></li><li><p>我们的方法中,使用路径 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span></eq> 来符号化 程序 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></eq> 的子域,使用符号 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">D</mi><mo stretchy="false">(</mo><mi>π</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{D}(\pi)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mclose">)</span></span></span></span></eq> 来指示所有属于该子域的输入.</p></li><li><p>为了正确运行子域内所有输入,DOMGAD保守地保留 运行运行路径上的代码</p></li><li><p>DOMGAD的目标是生成一个可以处理子域的简化程序,并实现简化和通用之间的权衡. 即,假设输入在程序中均匀分布,我们的方法生成尽可能小的程序同时处理子域内尽可能多的输入</p></li><li><p>为了实现这一目标,我们将简化为顶定义为一个优化为题,定义一个目标函数,量化 reduction 和 generality,并使用随机优化算法来解决它</p></li><li><p>量化通用性很难,我们提出了一种基于关键洞察的实际技术，即可以对程序域的底层输入分布进行建模并利用基于采样的方法</p><ul><li>具体来说,DOMGAD<ul><li><ol><li>从输入分布中抽取样本,来识别出一组有限的路径集合 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∏</mo></mrow><annotation encoding="application/x-tex">\prod</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∏</span></span></span></span></eq> ,这些路径集合覆盖了程序域的大部分输入</li></ol></li><li><ol start="2"><li>基于导致该路径的采样输入数量,估计每个路径 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo>∈</mo><mo>∏</mo></mrow><annotation encoding="application/x-tex">\pi \in \prod</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∏</span></span></span></span></eq> 相对应的子域大小. 尽管我们的采样方法只能计算通用性的近似值,但可以通过计算,界定解的误差. 因此通过足够的样本,我们的方法误差将会非常小</li></ol></li></ul></li></ul></li><li><p>我们总的简化过程如下</p><ul><li>输入程序 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></eq> , 一个输入采样器 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">IS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span></eq> , 该采样器模拟 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></eq> 域中的输入分布 并生成输入样本,给定这些输入,DOMGAD进行三个主要步骤: (1) 路径识别 (2)路径量化 (3) 随机优化</li><li><ol><li>路径识别:DOMGAD调用 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">IS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span></eq> 生成输入样本,并识别出一组路径 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∏</mo></mrow><annotation encoding="application/x-tex">\prod</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∏</span></span></span></span></eq> ,这些路径覆盖了程序域的大部分输入</li></ol></li><li><ol start="2"><li>路径量化:DOMGAD再次调用 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">IS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span></eq> 生成额外的样本用于估计每个路径 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo>∈</mo><mo>∏</mo></mrow><annotation encoding="application/x-tex">\pi \in \prod</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∏</span></span></span></span></eq> 相对应的子域大小. 基于这些估计,DOMGAD计算每个生成的简化程序的通用性. 在这一步中,同时也比较 reduction 和工具面</li></ol></li><li><ol start="3"><li>随机优化:DOMGAD使用MCMC随机优化算法,来实现生成 通用性和简化之间的权衡</li></ol></li></ul></li><li><p>使用ChiselBench评估DOMGAD,与Chisel和DEBOP进行比较.</p></li><li><p>本文主要贡献如下</p><ul><li><ol><li>一个新的,基于子域的,注重通用性的简化技术DOMGAD, 使用随机优化算法来生成简化程序来达到简化和通用性之间的权衡</li></ol></li><li><ol start="2"><li>通过实验评估展示我们技术的效果,并证实了进行注重泛化的简化是可行的</li></ol></li><li><ol start="3"><li>提供了DOMGAD的原型实现,并<a href="https://sites.google.com/view/domgad/">开源</a></li></ol></li></ul></li></ul><h3 id="2-%E7%A4%BA%E4%BE%8B" tabindex="-1">2 示例</h3><h3 id="3-%E5%88%9D%E6%AD%A5%E5%AE%9A%E4%B9%89" tabindex="-1">3 初步定义</h3><h3 id="4-%E6%88%91%E4%BB%AC%E7%9A%84%E6%96%B9%E6%B3%95%3Adomgad" tabindex="-1">4 我们的方法:DOMGAD</h3><h3 id="5-%E8%AF%84%E4%BC%B0" tabindex="-1">5 评估</h3><h3 id="6-%E7%9B%B8%E5%85%B3%E5%B7%A5%E4%BD%9C" tabindex="-1">6 相关工作</h3><h4 id="%E7%A8%8B%E5%BA%8F%E7%AE%80%E5%8C%96" tabindex="-1">程序简化</h4><ul><li><p>DOMGAD与一系列[22,41,45,55,57] 依赖 使用配置文件的简化技术相关</p><ul><li>TRIMMER [55] 通过激进的编译器优化实现简化</li><li>OOCAM [38] 通过部分估值实现简化</li><li>C-Reduce[45],Perses[57],CHISEL[22] 是基于delta-debugging的简化技术</li><li>J-Reduce[20] 使用依赖信息来改进delta-debugging</li><li>RAZOR [41] 采用基于代码覆盖,推理,和二进制重写的简化方法</li></ul></li><li><p>与上述技术不同</p><ul><li>DOMGAD是基于子域的,而不是具体的输入</li><li>DOMGAD不是单纯的简化导向,而是在简化和通用性之间进行权衡</li></ul></li><li><p>DEBOP[61] 是我们之前提出的方法,但其是基于输入的,并且在语句级别操作,而不是路径级别.如我们结果显示,这对其简化和效率产生了影响</p></li><li><p>DomGad也和一些基于静态分析来删除死代码或未使用代码的技术相关[1, 24, 26, 27, 29, 42],以及对应特别程序(例如 容器[44] 或 web应用[3]),或特殊目的(例如安全检测[15]) 而执行简化的技术有关</p></li><li><p>更广泛地硕,DOMGAD和膨胀检测[4,62,63],识别不必要代码[21],以及通过程序切片识别感兴趣代码的技术有关[60]</p></li></ul><h4 id="%E6%A8%A1%E5%9E%8B%E8%AE%A1%E6%95%B0%E5%92%8C%E6%A6%82%E7%8E%87%E5%88%86%E6%9E%90" tabindex="-1">模型计数和概率分析</h4><ul><li>因为DOMGAD使用静态采样方法,因此其与 模型技术有关[2,7,32],这些技术旨在量化满足给定公式的模型数量</li><li>处于类似原因,其也与概率软件分析[5,16,51] 有关,这些技术旨在量化程序的概率行为</li><li>与统计模型检验技术[35]有关,该技术通过验证统计方法验证概率事件的属性</li></ul><h4 id="mcmc%E5%92%8C%E4%BC%98%E5%8C%96" tabindex="-1">MCMC和优化</h4><ul><li>DOMGAD使用基于MCMC的,以此其和使用MCMC解决其它问题的技术间接有关,如优化[52]、漏洞查找[8,33]基于模型的GUI测试[56]和程序混淆[36]。最后，DomGad与资源适应[12]、能量减少[53]、程序修复[34]以及更广泛的软件改进[40]的优化技术有松散的关联。</li></ul><h3 id="7-%E7%BB%93%E8%AE%BA%E5%92%8C%E6%9C%AA%E6%9D%A5%E5%B7%A5%E4%BD%9C" tabindex="-1">7 结论和未来工作</h3><ul><li>结论<ul><li>现有基于输入的方法容易过拟合输入,且只考虑简化</li><li>我们提出了一种新的,基于子域的,注重通用性的简化技术DOMGAD, 使用随机优化算法,来生成简化程序来达到简化和通用性之间的权衡,通过一个综合这两个相互冲突度量的目标函数执行随机优化</li><li>结果显示我们的技术可以生成显著的代码减少（平均50%），同时保持高泛化性（平均95%）</li><li>与SOTA比较,DOMGAD表现良好</li></ul></li><li>未来工作<ul><li><ol><li>扩展我们的评估</li></ol><ul><li>(1) 使用 DOMGAD 应用于更广泛的程序集,来评估我们现在的结果是否具有普遍性</li><li>(2) 进行用户研究,评估现实环境中通用性的价值</li></ul></li><li><ol start="2"><li>探究提升路径识别和量化 效率的新方法</li></ol><ul><li>具体而言,将考虑 分层抽样[47],顺序抽样[58] 等方法</li><li>以及研究基于共享输入样本 ,同时执行路径识别和量化的可能性</li></ul></li><li><ol start="3"><li>考虑其它随机方法</li></ol><ul><li>例如 Gibbs Sampling[17],来改进优化结果</li></ul></li><li><ol start="4"><li>研究推断程序输入分布的方法</li></ol><ul><li>可能基于使用配置文件,自动构建输入样本生成器.为此,可以考虑基于 概率程序合成[39],概率密度估计[59],分布估计[30]和深度生成模型[43, 46]的方法。</li></ul></li></ul></li></ul><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(5)_x.png&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;debop%3Aprogram-debloating-vi</summary>
      
    
    
    
    <category term="论文" scheme="http://example.com/categories/%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="SoftwareEngineering" scheme="http://example.com/tags/SoftwareEngineering/"/>
    
    <category term="SoftwareDebloating" scheme="http://example.com/tags/SoftwareDebloating/"/>
    
  </entry>
  
  <entry>
    <title>Software Debloating 论文阅读 (4)</title>
    <link href="http://example.com/2024/01/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/SoftwareDebloating/Software%20Debloating%20%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB(4)/"/>
    <id>http://example.com/2024/01/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/SoftwareDebloating/Software%20Debloating%20%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB(4)/</id>
    <published>2024-01-15T07:10:43.886Z</published>
    <updated>2024-01-15T07:10:43.886Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(4)_x.png" alt></p><h1 id="razor%3A-a-framework-for-post-deployment" tabindex="-1">Razor: A Framework for Post-deployment</h1><p>Software Debloating</p><p>28th USENIX Security Symposium　CCFA会</p><p>Qian C, Hu H, Alharthi M, et al. RAZOR: A framework for post-deployment software debloating[C],28th USENIX security symposium (USENIX Security 19). 2019: 1733-1750.</p><h2 id="0-%E6%91%98%E8%A6%81" tabindex="-1">0 摘要</h2><ul><li>最近得debloating技术需要源码,限制了其实际中的应用</li><li>本文提出了一个实际的debloating框架:RAZOR,在部署的二进制代码上进行代码简化<ul><li>基于用户的期望,生成一个最小的满足功能的程序</li><li>同时不只是根据给定的测试用例,RAZOR使用了几种控制流的启发式算法来推断出必要的代码,以支持用户期望的功能</li></ul></li><li>我们再常见的基准上进行测试,同时也在真实的应用上进行测试,包括 火狐浏览器,闭源PDF阅读器FoxitReader,结果显式RAZOR可以在二进制上减少超过70%的代码</li><li>RAZOR简化了代码,并且没有引入新的安全隐患,因此RAZOR是一个实际的框架,可以在对实际的程序使用</li></ul><h2 id="1-%E4%BB%8B%E7%BB%8D" tabindex="-1">1 介绍</h2><ul><li><p>要使这种部署后使用的方法(即面向部署二进制文件的方法)对用户有用,有两个挑战</p><ul><li><ol><li>如何使得对软件了解较少的用户,表达他们对软件特点的需求,即哪个功能需要保留和移除</li></ol></li><li><ol start="2"><li>如何修改软件二进制文件来移除不需要的功能和保留需要的</li></ol></li></ul></li><li><p>为了解决第一个挑战,可以让用户提供一组样例输入集合来解释他们将如何使用这个软件,这样其实输入到输出构成一个映射即可,然而实际中,即使处理相同的输入,也会有不同的执行路径,因此这种方法不可行</p></li><li><p>为了基于用户提供的输入能够实际地简化程序,我们必须找到支持完整功能但处理样例输入时为执行的代码,称为<strong>相关代码</strong></p><ul><li>然而,相关代码地识别很困难,特别地,让用户(甚至开发者)提供一个能够执行某一功能的所有必要代码的输入语料库是一项具有挑战的任务</li><li>此外,即使用户提供了所有可能输入的一些描述(例如样式),仍然很难确定这些输入所有可达的代码</li><li>因此,我们坚信,所有在部署后情况下的去膨胀机制,都应该基于 尽力而为 的启发式机制.<ul><li>启发式方法会尽可能地标识相关代码,同时保留最少的不相关代码</li><li>而死代码消除,增量调试法不适用于本问题,因为它们只关注移除静态死代码 或 保留程序在几个特定输入上的行为</li></ul></li></ul></li><li><p>我们设计了一种启发式方法,基于这样的假设:代码路径差异越大,相关功能越少. 具体地,对于给定的与运行路径 $ p $ ,我们要找到一条不同的路径 $ q $ ,满足</p><ul><li><ol><li>$ q $ 没有不同的指令</li></ol></li><li><ol start="2"><li>$ q $ 没有调用新的函数</li></ol></li><li><ol start="3"><li>$ q $ 不需要额外地库函数</li></ol></li><li><ol start="4"><li>$ q $ 不依赖于具有不同功能地库函数</li></ol></li></ul></li><li><p>然后,我们相信 $ q $ 是与 $ p $ 相关的,将 $ q $ 中的代码视为相关代码</p></li><li><p>从(1)到(4),启发式方法在包括地代码越来愈多,对于给定程序,我们会逐渐提升启发式等级直到生成的程序稳定.然而实际上,在我们的评估中,即使是最激进的启发式方法,也只会使得引入的最终代码少量增加</p></li><li><p>当所有相关代码被确定,我们开发了一个二进制重写平台来删除不必要的代码生成一个简化的程序.</p><ul><li>由于简化程序的特性,我们的平台不会面临一般二进制重写工具的符号化问题[51,52,53,5] <code>TODO</code><ul><li>具体来说,通用二进制重写工具必须保留所有程序功能,但在没有可靠反汇编技术和完成的控制流图(control-flow graph,CFG)下很困难</li><li>对于去膨胀,我们只保留样本输入的功能,其中反汇编和CFG可以通过观察程序运行获得</li></ul></li></ul></li><li><p>我们设计了RAZOR框架来实现部署后的去膨胀,框架由三个部分组成</p><ul><li><strong>Tracer</strong>:监视程序在样例输入上的执行,记录执行代码</li><li><strong>PathFinder</strong>:使用启发式方法从已经执行的代码中推断出更多的相关代码</li><li><strong>Generator</strong>:基于Tracer和PathFinder的输出产生新的二进制文件</li></ul></li><li><p>在RAZOR框架中,我们实现了三个追踪器(两个基于动态二进制插装,一个基于硬件追踪功能),四个启发式路径查找算法,一个二进制生成器</p></li><li><p>为了理解RAZOR的效果,我们再三个基准集进行了测试(1)SPEC CPU2006 基准 (2)ChiselBenchmark 10个程序 (3) 两个真实程序,火狐浏览器和闭源PDF阅读器FoxitReader</p></li><li><p>在我们的评估中,我们基于一组训练输入执行跟踪和去膨胀,并用一组和输入相似但不同的输入进行测试,结果显示</p><ul><li>RAZOR可以减少70-80%的程序大小,同时只引入了1.7%的新二进制文件开销</li><li>我们将RAZOR和CHISEL进行比较,在ChiselBenchmark上,我们发现Chisel简化程度更好,但在测试用例中失败了几个,同时Chisel引入了新的漏洞在简化程序中,例如 由于删除边界检查而导致的缓冲区溢出.而RAZOR不会引入新的问题</li><li>我们还分析了我们的路径查找器识别出的相关代码,并发现不同的启发式方法可以很好的提升程序的鲁棒性</li></ul></li><li><p>综上所述,我们的论文创新如下</p><ul><li><strong>新方法</strong>:RAZOR,在二进制文件上进行使用,需要给定输入</li><li><strong>开源</strong>:<a href="https://github.com/cxreet/razor.">Razor仓库地址</a></li><li><strong>贴合实际,即开即用</strong>:在现实程序中进行了测试,结果显示简化后的程序有显著的减少,更好的安全性</li></ul></li></ul><h2 id="2-%E9%97%AE%E9%A2%98" tabindex="-1">2 问题</h2><h3 id="2.1-motivating-example" tabindex="-1">2.1 Motivating Example</h3><p><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(4)_1.png" alt></p><ul><li>上图展示了一个膨胀的程序,用于解析不同种类的图片<ul><li>基于用户的选择调用不同的函数</li><li>在<code>parsePNG</code>中<ul><li>代码首先分配内存来保存图像</li><li>然后将内存地址保存在<code>img</code>中</li><li>然后通过使用宏<code>ALIGN(v,a)</code>,确保<code>img</code>按照16字节对齐.</li><li>最后调用函数<code>readToMem</code>将图像内容从文件加载到内存中进一步处理</li></ul></li><li><code>parseJPEG</code>和<code>parseGIF</code>代码类似</li></ul></li><li>然而当用户只需要解析PNG格式的图片,该程序是膨胀的,例如 iPhone设备总是PNG格式的图片,因此不需要解析JPEG的代码,这些代码中可能还存在一些安全问题.</li><li>在现实中,我们可以轻易找到支持过时格式(如PCX,Sun Raster,TGA)的文档阅读器(如MacOS 上的 Preview),我们可以对这些程序进行去膨胀来减小他们的大小和攻击面</li></ul><h3 id="2.2-program-debloating" tabindex="-1">2.2 Program Debloating</h3><ul><li><p>问题定义:给定一个程序 $ P $ , 其有一组功能 $ \mathcal{F} = {F_0,F_1,F_2,…} $ ,用户指定的功能 $ \mathcal{F_u} = {F_i,F_j,F_k,…} $ , 我们的目标是生成一个程序 $ P’ $ 保留在 $ \mathcal{F_u} $ 中的函数,并且拒接对 $ \mathcal{F}-\mathcal{F_u} $中函数的请求</p></li><li><p>本文关注于在软件二进制代码中简化功能:我们从运行中构建一个控制流图CFG来指导基于二进制的简化.</p></li><li><p>下图展示了之前例子在二进制下的状态<img src="../../../images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(4)_2.png" alt></p><ul><li><ol><li>黑色箭头表示过程内跳转</li></ol></li><li><ol start="2"><li>虚线箭头表示过程间跳转</li></ol></li></ul></li><li><p>在CFG中去除不可达的节点,我们可以得到简化后的CFG</p></li></ul><h3 id="2.3-%E6%8C%91%E6%88%98%E5%92%8C%E6%8E%AA%E6%96%BD" tabindex="-1">2.3 挑战和措施</h3><ul><li>功能-&gt;函数-&gt;二进制代码的转换是有挑战的,为此引出两个问题<ul><li><strong>C1</strong>: 如何表达不必要的功能</li><li><strong>C2</strong>: 如何将功能对应到代码</li></ul></li><li>以上问题的可能解决方法是根据用户提供的一组测试用例来观测程序的运行以此识别出相关代码.<ul><li>我们的问题可以描述为:给定二进制程序 $ P_b $ 和一组测试集 $ T={t_i,t_j,t_k…} $ ,每个测试用例 $ t_i $ 触发 $ P_b $ 的一些函数,我们会创建一个最小的程序 $ P_b’ $ 仅支持 $ T $ 中的测试用例触发的函数</li></ul></li><li>测试用例可以帮我们解决<strong>C1,C2</strong>,但测试用例不能完全覆盖所需功能的全部相关代码,即有一些相关代码不会被触发.如果我们仅删除未运行的代码,程序功能将会被破坏<ul><li>例如:在上面解析图片的代码中,第11行的判断可能在测试用例中一直未实现,导致第12行被认为是未执行代码,这将引发问题.</li><li>在本文后续 $5.2 的评估中,展示了如果只是简单的移除未运行的代码,会导致很多问题,甚至程序的崩溃.<strong>并且所有基于测试用例的方法都会有这个问题</strong></li></ul></li><li><strong>C3</strong>: 如何从有限的测试用例中找到相关代码<ul><li>针对此问题,我们提出了基于CFG的启发式方法来推理出更多的相关代码,来支持我们需要的功能</li><li>问题定义:<ul><li>假设 $ T $ 中的测试用例触发了 $  \mathcal{I} = {i_0,i_1,i_2,…}　$ 中的二进制指令,我们的启发式方法会自动地指明更多被测试用例集合 $ T $ 所覆盖功能的相关代码.</li><li>具体地,我们定义一个超集 $ \mathcal{I’} = \mathcal{I} \cup {i_x,i_y,i_z …}$ 并保留在 $ \mathcal{I’} $ 中的所有指令,同时删除其它指令使得代码最小化.</li></ul></li><li>在上面解析照片的例子中,如果测试用例中没有经过12行,我们的启发式搜索将会包括这一相关代码</li><li>在 $5.3 中 我们将会展示我们的启发式方法在查找相关代码上是有效的,并且只会引发少量的代码增加</li></ul></li></ul><h2 id="3-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1" tabindex="-1">3 系统设计</h2><p><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(4)_3.png" alt></p><ul><li>上图展示了RAZOR的架构:给定一个膨胀的二进制程序和一组可以触发所需程序功能的测试集,RAZOR移除不需要的代码生成 支持所需功能的最小二进制代码</li><li>为了实现上述目标<ul><li>RAZOR首先使用<code>Tracer</code>收集测试用例上的运行路径</li><li>随后编码路径构造程序的CFG,其中包含所有的运行指令</li><li>接着,RAZOR使用<code>PathFinder</code>来识别出相关代码,即使用启发式方法扩展CFG</li><li>最后基于扩展的CFG<code>Generator</code>重新生成二进制代码来生成满足功能的最小二进制程序</li></ul></li></ul><h3 id="3.1-%E8%BF%90%E8%A1%8C%E8%B7%AF%E5%BE%84%E6%94%B6%E9%9B%86" tabindex="-1">3.1 运行路径收集</h3><p><code>Tracer</code>收集三种信息记录控制流信息</p><ol><li>已执行指令,包括内存地址和原始字节</li><li>条件分支的跳转或不跳转,如 je指令</li><li>间接跳转或调用 的目标地址,如 jmpq *%rax</li></ol><ul><li><p>Tracer记录已执行指令的原始字节以处理动态生成/修改的代码,然而，指令级别的记录效率低下，同时大多数实际程序只包含静态代码</p></li><li><p>因此Tracer从基本块级别的记录开始，仅记录每个已执行基本块的地址;</p><ul><li>在执行过程中，它检测所有动态代码行为，如可写和可执行的内存区域（例如即时编译[13]），或重叠的基本块（例如合法的代码重用[26]），并切换到指令级别的记录以避免遗漏指令。</li><li>一个条件分支可能会被多次执行，最终覆盖一个或两个目标（即fall-through目标和跳转目标）。对于间接跳转/调用指令，我们记录所有已执行的目标并计算它们的频率</li></ul></li><li><p>下图为一个收集的运行路径的例子![]</p><ul><li>记录了分支跳转的情况</li><li>间接跳转的次数<br>(/images/论文/software%20debloating%20论文/(4)_4.png)</li></ul></li><li><p>我们发现使用多种工具收集执行跟踪是值得的</p><ul><li>首先，没有一种机制可以完全高效地记录跟踪信息<ul><li>基于软件的插桩工具:可以忠实地记录所有信息，但引入了显著的开销[7, 25, 6]</li><li>基于硬件的日志:可以有效的记录信息,但需要特殊的硬件,并且不能保证完备性(例如,Intel PT中的数据丢失)</li></ul></li><li>其次,程序在不同跟踪环境下执行的程序将显示不同的路径<ul><li><code>Dynamorio</code>总是将文件名扩展为绝对路径,导致一些程序中不同的执行路径(如 vim)</li></ul></li></ul></li><li><p>因此,我们提供了三种不同的软件和硬件实现,用户可以根据自己的需求选择最好的,甚至可以将多个工具的跟踪信息合并来获得更好的代码覆盖率</p></li><li><p><strong>CFG的构造</strong></p><ul><li>RAZOR使用收集到的执行路径来反汇编二进制文件,并以此可靠地构造CFG. 与先前使用启发式方法确定函数边界的工作[52, 51, 3, 4, 45]不同，RAZOR从执行跟踪中获取准确的指令地址和函数边界信息</li><li>从这种可靠地信息开始,我们可以识别更多地代码指令,随后我们的启发式方法可以将他们是否是相关代码进行考量<ul><li>对于条件分支指令,两个目标都是已知的,都可以有效地进行反汇编</li><li>对于间接跳转/调用指令,我们可以识别出潜在地跳转表</li></ul></li></ul></li></ul><h3 id="3.2-%E5%9F%BA%E4%BA%8E%E5%90%AF%E5%8F%91%E5%BC%8F%E7%9A%84%E8%B7%AF%E5%BE%84%E6%8E%A8%E6%96%AD-heuristic-based-path-inference" tabindex="-1">3.2 基于启发式的路径推断 Heuristic-based Path Inference</h3><p>我们使用最佳尝试的启发式方法以包括更多的相关代码.以下我们将按照保留代码的程度依次介绍</p><ul><li>下图为使用不同启发式方法产生的不同效果<ul><li>左侧为原始CFG,右侧为扩展后的CFG</li><li>代码设计为计算 <code>log(sqrt(max(rax,rbx,rcx)))</code></li><li>虚线表示追踪过程中未执行的分支和块,原始的执行路径是 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>1</mn></msub><mo>→</mo><msub><mi>L</mi><mn>2</mn></msub><mo>→</mo><msub><mi>L</mi><mn>3</mn></msub><mo>→</mo><msub><mi>L</mi><mn>5</mn></msub><mo>→</mo><msub><mi>L</mi><mn>7</mn></msub><mo>→</mo><msub><mi>L</mi><mn>9</mn></msub></mrow><annotation encoding="application/x-tex">L_1 \rightarrow L_2 \rightarrow L_3 \rightarrow L_5 \rightarrow L_7 \rightarrow L_9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq><br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(4)_5.png" alt></li></ul></li></ul><h4 id="(1)-%E9%9B%B6%E4%BB%A3%E7%A0%81%E5%90%AF%E5%8F%91%E5%BC%8F-zero-code-heuristic-(zcode)" tabindex="-1">(1) 零代码启发式 Zero-code heuristic (zCode)</h4><ul><li>该启发式方法引入新边(例如基本块之间的跳转)在CFG中</li><li>对于只有一个目标的条件跳转指令,<code>PathFinder</code>会检查非选择目标是否已经在CFG中,如果在,<code>PathFinder</code>也允许从该分支指令跳到非选择目标.<ul><li>这里需要注意到,这是将未运行的代码向与运行的代码中调价,即相关代码,所以总的程序仍然是简化的</li></ul></li><li>在上图中,<code>zCode</code>启发式方法将会引入边 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mn>1</mn><mo>→</mo><mi>L</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">L1\rightarrow L3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord">3</span></span></span></span></eq> ,因为 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">L3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord">3</span></span></span></span></eq> 是 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">L1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord">1</span></span></span></span></eq> 的非选择目标,但之后依然存在在CFG中</li></ul><h4 id="(2)-%E9%9B%B6%E8%B0%83%E7%94%A8%E5%90%AF%E5%8F%91%E5%BC%8F-zero-call-heuristic-(zcall)" tabindex="-1">(2) 零调用启发式 Zero-call heuristic (zCall)</h4><ul><li>该启发式包括不执行任何函数调用的替代执行路径</li><li>使用该启发式方法,<code>PathFinder</code>从条件语句中未被采取的目标出发,并跟着控制流找到最终和 已执行路径合并的新路径. 如果新路径中没有<code>call</code>指令,则将其添加到CFG中</li><li>当<code>PathFinder</code>走到未运行指令时,我们没有准确的信息来反汇编或构建CFG,相反,我们依赖现有的方法[53,3]进行二进制分析</li><li>应用该启发式方法zcall,在上图中,<code>PathFinder</code>将会引入块 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">L_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 和边 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mn>3</mn><mo>→</mo><mi>L</mi><mn>4</mn><mo>→</mo><mi>L</mi><mn>5</mn></mrow><annotation encoding="application/x-tex">L3\rightarrow L4 \rightarrow L5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord">5</span></span></span></span></eq>,因为该路径在 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>5</mn></msub></mrow><annotation encoding="application/x-tex">L_5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 出进行了合并,且不包含调用指令</li></ul><h4 id="(3)-%E9%9B%B6%E5%BA%93%E8%B0%83%E7%94%A8%E5%90%AF%E5%8F%91%E5%BC%8F-zero-libcall-heuristic-(zlib)" tabindex="-1">(3) 零库调用启发式 Zero-libcall heuristic (zLib)</h4><ul><li>与zCall先死,但<code>PathFinder</code>在包括可选路径时更加激进<ul><li>新路径可以包含同二进制文件中的函数或已执行的外部函数的调用指令</li><li>但zlib不运行调用未执行的外部函数</li></ul></li><li>在上图中,使用该启发式,<code>PathFinder</code>将会引入块 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>6</mn></msub></mrow><annotation encoding="application/x-tex">L_6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 和边 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>5</mn></msub><mo>→</mo><mi>L</mi><mn>6</mn><mo>→</mo><mi>L</mi><mn>7</mn></mrow><annotation encoding="application/x-tex">L_5\rightarrow L6 \rightarrow L7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord">7</span></span></span></span></eq>,因为该路径没有对未执行的外部函数的调用</li></ul><h4 id="(4)-zero-functionality-heuristic-(zfunc)" tabindex="-1">(4) Zero-functionality heuristic (zFunc)</h4><ul><li>该启发式方法运行包括为执行的外部函数调用只要其不触发新的高级功能</li><li>为了将库函数和功能相关联,我们检查它们的描述并将其手工分组.<ul><li>例如,log和sqrt术语指数和算数字部份,因此认为其基于相似的功能</li></ul></li><li>使用该启发式方法,<code>PathFinder</code>将会引入块 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>8</mn></msub></mrow><annotation encoding="application/x-tex">L_8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq> 和边 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>7</mn></msub><mo>→</mo><mi>L</mi><mn>8</mn><mo>→</mo><mi>L</mi><mn>9</mn></mrow><annotation encoding="application/x-tex">L_7\rightarrow L8 \rightarrow L9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord">9</span></span></span></span></eq>,因为该路径没有对未执行的外部函数的调用,且不触发新的高级功能</li></ul><h4 id="(5)-%E7%AE%97%E6%B3%95" tabindex="-1">(5) 算法</h4><ul><li>下图展示了<code>PathFinder</code>寻找相关代码的步骤<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(4)_6.png" alt></li></ul><ol><li>对于CFG中的每一个条件语句</li><li>使用<code>get_non_taken_branch</code>得到未执行的分支</li><li>如果两个分支都执行了,继续遍历;否则按照启发式等级进行判断</li><li>如果为执行的分支属于当前CFG且当前启发式等级大于等于 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mi>C</mi><mi>o</mi><mi>d</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">zCode</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span></span></span></span></eq>,</li><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mi>C</mi><mi>o</mi><mi>d</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">zCode</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span></span></span></span></eq> 将未执行的分支加入到CFG中</li><li>如果启发式等级比 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mi>C</mi><mi>o</mi><mi>d</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">zCode</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span></span></span></span></eq> 高, <code>PathFinder</code> 将会首先得到从未选择分支出发的可选路径并且最终合并到已执行路径中.</li><li>随后迭代所有的可选路径,在迭代中根据启发式等级调用相应的验证函数</li><li>最后在13和14行,确定该路径是否需要被包括到CFG中</li></ol><h3 id="3.3-%E5%8E%BB%E8%86%A8%E8%83%80%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%90%88%E6%88%90-debloated-binary-synthesization" tabindex="-1">3.3 去膨胀二进制合成 Debloated Binary Synthesization</h3><ul><li><p>通过原始的膨胀二进制代码和扩展的CFG,<code>Generator</code>生成一个简化的二进制文件并包括所有的功能</p><ul><li><ol><li>其将根据CFG反汇编原本的二进制代码,并生成包含所有必要指令的伪汇编文件</li></ol></li><li><ol start="2"><li><code>Generator</code>修改伪汇编代码来创建合法的汇编代码. 这些修改包括 基本块的表示,具体化简介跳转,插入故障处理代码</li></ol></li><li><ol start="3"><li>将汇编代码编译成目标文件,其中包括所需指令的机器码</li></ol></li><li><ol start="4"><li><code>Generator</code>将机器码从目标文件中复制到原始二进制文件的新代码中</li></ol></li><li><ol start="5"><li><code>Generator</code>修改新代码段来修复原始代码和数据的引用</li></ol></li><li><ol start="6"><li>最后,<code>Generator</code>将原始代码段设置为不可执行以减小代码大小.(我们将原始代码段留在去膨胀程序中来支持可能的读取,如switch语句的跳转表[11],该设计将于后续讨论)</li></ol></li></ul></li><li><p>该部分需要底层知识,很费时间,如之后需要再细看</p></li></ul><h4 id="3.3.1-%E5%9F%BA%E6%9C%AC%E5%9D%97%E7%9A%84%E8%A1%A8%E7%A4%BA" tabindex="-1">3.3.1 基本块的表示</h4><h4 id="3.3.2-%E8%B7%B3%E8%BD%AC%E7%9A%84%E5%85%B7%E4%BD%93%E5%8C%96" tabindex="-1">3.3.2 跳转的具体化</h4><h4 id="3.3.3-%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E4%BB%A3%E7%A0%81" tabindex="-1">3.3.3 故障处理代码</h4><h2 id="4-%E5%AE%9E%E7%8E%B0" tabindex="-1">4 实现</h2><ul><li>我们使用1085行C代码、514行C++代码和4034行Python代码实现了RAZOR的原型,如下图所示<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(4)_13.png" alt></li><li>该原型只支持x86-64 ELF二进制文件</li></ul><h3 id="4.1-tracer-implementations" tabindex="-1">4.1 Tracer Implementations</h3><ul><li>我们为用户提供了三种不同的跟踪器,用户可以根据自己的需求选择最好的,甚至可以将多个工具的跟踪信息合并来获得更好的代码覆盖率.</li><li>在我们的评估中，我们使用基于软件的插桩技术来收集简单程序的完整跟踪信息，并使用基于硬件的方法来高效地获取大型程序的跟踪信息。</li></ul><h4 id="(1)-%E9%87%87%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%8F%92%E8%A3%85%E8%BF%9B%E8%A1%8C%E8%B7%9F%E8%B8%AA" tabindex="-1">(1) 采用软件插装进行跟踪</h4><ul><li>使用动态插装工具Dynamorio [7]和Pin [25]来监测程序. 这两个工具都提供了在函数级别、基本块级别和指令级别的插装接口</li><li>我们通过三个插装步骤来收集控制流信息<ul><li><ol><li>在每个基本块的开始处记录起始地址</li></ol></li><li><ol start="2"><li>在每个条件分支指令,在指令和其两个目标之间插入两段代码来监听跳转的信息</li></ol></li><li><ol start="3"><li>在每个间接调用和跳转指令前,记录每次调用的具体目标</li></ol></li></ul></li><li>当基本块和条件分支指令运行后即可移除插装,保留间接跳转和调用指令的插装,以此减少不必要的开销</li></ul><h4 id="(2)-%E4%BD%BF%E7%94%A8%E7%A1%AC%E4%BB%B6%E7%89%B9%E6%80%A7%E8%BF%9B%E8%A1%8C%E8%BF%BD%E8%B8%AA" tabindex="-1">(2) 使用硬件特性进行追踪</h4><ul><li>考虑到软件插装的开销,我们提供了一个基于Intel处理器跟踪（Intel PT）的高效Tracer。</li><li>Intel PT以高度压缩的方式记录流信息的变化：TNT数据包描述了一个条件分支是否被执行；TIP数据包记录了间接分支的目标，例如间接调用和返回。</li><li>由于Intel PT直接将跟踪信息写入物理内存，而无需触及页表或内存缓存，因此它实现了最高效的跟踪。</li><li>可以使用不同平台上其它硬件功能实现更高效的Tracer,如Intel CPU上的分支跟踪存储（BTS）或在ARM CPU上的程序流跟踪（PTM）。</li></ul><h3 id="4.2-%E6%9B%B4%E6%96%B0elf%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86-update-elf-exception-handler" tabindex="-1">4.2 更新ELF异常处理 Update ELF Exception Handler</h3><p>emmm… 看得不是很懂呢,且跟汇编有关,略</p><h2 id="5-%E8%AF%84%E4%BC%B0" tabindex="-1">5 评估</h2><ul><li><p>从以下方面进行评估</p><ul><li>Code reduction:代码简化程度5.1</li><li>Functionality:<ul><li>功能有效性 5.2</li><li>路径寻找的效率 5.3</li></ul></li><li>安全性 5.4</li><li>性能开销 5.5</li><li>现实中的去膨胀 5.6</li></ul></li><li><p><strong>实验设置</strong></p><ul><li>在以下基准下进行评估<ul><li>29 SPEC CPU2006 基准:包括12个C,10个C++,10个Fortran程序</li><li>ChiselBench</li><li>两个现实程序:火狐浏览器和闭源PDF阅读器FoxitReader</li></ul></li><li>使用基于软件的追踪器<code>Dynamorio</code>和<code>Pin</code>来收集执行跟踪</li><li>对于FoxitReader和FireFox,我们使用基于硬件的追踪器<code>Intel PT</code>来收集执行跟踪,以此保证执行速度并避免异常行为</li><li>实验在64位ubuntu 16.04 系统上进行,使用Intel Core i7-6700K CPU, 32GB内存</li></ul></li></ul><h3 id="5.1-%E4%BB%A3%E7%A0%81%E7%AE%80%E5%8C%96%E7%A8%8B%E5%BA%A6" tabindex="-1">5.1 代码简化程度</h3><ul><li>因为RAZOR基于二进制,所以我们比较运行时的内存</li><li>下面对RAZOR和CHISEL进行对比:图a为在SPEC上,图b为在ChiselBench上<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(4)_7.png" alt><ul><li><ol><li>在SPEC中,RAZOR可以平均减少68.19%代码,CHISEL78.8%</li></ol></li><li><ol start="2"><li>在ChiselBench中,Chisel减少83.4%.</li></ol><ul><li>对于7个程序,chisel减少成都优于razor,但是在3个程序中,razor减少更多</li></ul></li></ul></li><li>需要注意的是Chisel更倾向于移除代码,只要满足输入即可</li></ul><h3 id="5.2-%E5%8A%9F%E8%83%BD%E6%9C%89%E6%95%88%E6%80%A7" tabindex="-1">5.2 功能有效性</h3><ul><li><p>使用chiselBenchmark,运行原始二进制文件,使用chisel后的二进制文件,使用razor后的二进制文件进行测试,以确定所需功能是否保留,结果如下图示<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(4)_8.png" alt="5.2"></p></li><li><p>RAZOR在使用保留更多代码的启发式时,最终都会通过功能验证. 而哈人的,Chisel自己只通过了3个,其主要有以下四个问题</p><ul><li><ol><li>错误的操作:因过拟合输入导致,如bzip2</li></ol></li><li><ol start="2"><li>无限循环:因为删除了循环的边界检查,如gzip</li></ol></li><li><ol start="3"><li>崩溃:删除了参数为空检查,如bzip2,date</li></ol></li><li><ol start="4"><li>遗漏输出:CHISEL删除了用于在stdout和stderr上打印输出的代码，导致结果丢失。如grep</li></ol></li></ul></li></ul><h3 id="5.3-%E8%B7%AF%E5%BE%84%E5%AF%BB%E6%89%BE%E7%9A%84%E6%95%88%E7%8E%87" tabindex="-1">5.3 路径寻找的效率</h3><ul><li><p>使用两组实验评估 <code>PathFinder</code>在寻找所需功能的相关代码时的有效性</p><ul><li><ol><li>使用从低到多不同启发式等级的RAZOR来去膨胀程序,找到对每个程序最小的启发式等级</li></ol></li><li><ol start="2"><li>使用N折交叉验证启发式方法的鲁棒性(在5.6中)</li></ol></li></ul></li><li><p>按照以下方法在ChiselBench上测试RAZOR</p><ul><li><ol><li>设计覆盖相同功能集的训练输入和测试输入</li></ol></li><li><ol start="2"><li>使用训练输入跟踪程序,并用不同等级的启发式进行去膨胀 none, zCode, zCall, zLib, zFunc</li></ol></li><li><ol start="3"><li>在测试输入上使用去膨胀后的程序,记录失败情况</li></ol></li></ul></li><li><p><code>PathFinder</code>配置见附录Table7,我们使用相同的选项构造训练集和测试集,但二者间具体的参数不同</p></li></ul><p><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(4)_9.png" alt></p><ul><li><p>上图展示了结果,可以明显看出,随着启发式等级的增加,失败的测试用例显著下降,而简化率的下降却不明显.</p></li><li><p>请注意，zCode启发式方法稍微增加了代码的减小幅度，因为它使得条件跳转的分支更多，从而减少了失败分支的插装。</p></li><li><p>四种启发式作用的例子:略,见论文</p></li><li><p>结论:<code>PathFinder</code>可以有效识别与训练输入线管的代码,并完备由训练输入出发的功能. 它强化了去膨胀二进制文件的同时保持了简化的效率</p></li></ul><h3 id="5.4-%E5%9C%A8%E5%AE%89%E5%85%A8%E6%96%B9%E9%9D%A2%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%A5%BD%E5%A4%84" tabindex="-1">5.4 在安全方面带来的好处</h3><ul><li><p>通过统计减少的bug数来评估去膨胀带来的安全性</p></li><li><p>在ChiselBenchmark中统计其历史bug和如今bug</p><ul><li>对于历史bug,我们探究其补丁是否在去膨胀程序中</li><li>对于如今bug,我们探究其问题代码是否仍存在</li></ul></li><li><p>下图展示了评估结果,当前版本有13个bug,有10个在Chisel中被评估,3个bug存在在老版本<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(4)_10.png" alt></p><ul><li>图中bzip, date, gzip,mkdir, rm, and tar 的六个漏洞仍然存在，因为测试用例执行了相关的有漏洞代码</li><li>另外六个漏洞并非由二进制文件本身引起。例如，CVE-2011-4089是由bash脚本bzexe的竞态条件引起的，而不是由bzip2二进制文件引起的。因此，RAZOR不会禁用此类漏洞。</li></ul></li><li><p>Chisel与RAZOR相比</p><ul><li>Chisel比较激进,在移除了更多漏洞的同时也引入了旧的.</li><li>Razor比较保守,阻碍移除漏洞,但有助于避免新的漏洞</li></ul></li><li><p>同时测量了ROP（Return-Oriented Programming）gadgets的减少情况. 一旦攻击者能够改变控制流,可重用的ROP gadgets的数量将使得程序更易受控制流劫持的攻击</p><ul><li>RAZOR平均减少了 61.9%的ROP gadgets,而Chisel减少了 85.1%</li><li>结果在预期内,我们潜在的有意防止 forward-edge control-flow attacks,即攻击者通过破坏函数指针而不是返回地址来改变控制流</li><li>同时使用新技术可以进一步实现完整的控制流完整性</li></ul></li></ul><h3 id="5.5-%E6%80%A7%E8%83%BD%E5%BC%80%E9%94%80" tabindex="-1">5.5 性能开销</h3><ul><li><strong>时间</strong><ul><li>RAZOR<ul><li>ChiselBenchmark上平均1.78s</li><li>Firefox 8.51s</li><li>FoxitReader 50.42</li></ul></li><li>Chisel:在ChiselBenchmark上要11hours+</li></ul></li><li><strong>运行时开销</strong><ul><li>与SPEC基准测试进行比较,平均而言,RAZOR为去膨胀程序引入1.7%的运行时开销,表明其在现实世界不是是高效的.</li><li>间接调用是开销的主要来源,这里可以进一步优化</li></ul></li></ul><h3 id="5.6-%E5%9C%A8%E7%8E%B0%E5%AE%9E%E7%A8%8B%E5%BA%8F%E4%B8%8A%E7%9A%84%E5%8E%BB%E8%86%A8%E8%83%80" tabindex="-1">5.6 在现实程序上的去膨胀</h3><ul><li><p>对于Firefox浏览器，我们使用RAZOR加载了排名前50的Alexa网站[28]。我们随机选择了25个网站作为训练输入，并将另外25个网站作为测试输入。</p></li><li><p>对于Foxit Reader，我们使用RAZOR打开并滚动了包含表格、图形和JavaScript代码的55个不同的PDF文件。我们随机选择了其中的15个文件作为训练输入，并将另外40个文件作为测试输入</p></li></ul><h4 id="%E4%BB%A3%E7%A0%81%E7%BC%A9%E5%87%8F%E5%92%8C%E5%8A%9F%E8%83%BD%E6%80%A7" tabindex="-1">代码缩减和功能性</h4><p><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(4)_11.png" alt></p><p>如上图示,当启发式等级达到zLib时,可以通过所有的测试用例</p><h4 id="%E6%80%A7%E8%83%BD%E6%B6%88%E8%80%97" tabindex="-1">性能消耗</h4><ul><li>在几个基准测试上与运行了去膨胀的Firefox浏览器(启发式等级zLib)并发现RAZOR对Octane [33]、SunSpider [34]、Dromaeo-JS [30]和Dromaeo-DOM [29]基准测试引入了-2.1%、1.6%、0%和2.1%的开销</li><li>对于Foxit Reader未找到基准测试,但打开和滚动pdf未发现明显减速</li></ul><h4 id="%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%3A%E6%AF%8F%E4%B8%AA%E7%BD%91%E7%AB%99%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E9%9A%94%E7%A6%BB" tabindex="-1">应用场景:每个网站的浏览器隔离</h4><ul><li>在传统的浏览器环境中，所有打开的标签页和窗口都在同一个进程和内存空间中运行。这意味着一个恶意网站可以通过注入脚本或其他攻击手段来访问和修改同一进程中的其他站点的内容。这可能导致用户数据泄露、会话劫持和其他安全问题。</li><li>每个网站的浏览器隔离,作为浏览器去除臃肿的一个应用，我们可以创建仅支持特定网站的最小化版本<ul><li>例如，银行可以为其客户提供一个只支持其网站所需功能的最小化浏览器，同时暴露最少的攻击面。</li></ul></li><li>们在三个受欢迎且安全敏感的网站集合上应用了RAZOR：银行网站、电子商务网站和社交媒体网站。可以看出可以带来一定的收益<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(4)_12.png" alt></li></ul><h4 id="%E5%90%AF%E5%8F%91%E5%BC%8F%E6%96%B9%E6%B3%95%E7%9A%84n%E6%8A%98%E4%BA%A4%E5%8F%89%E6%A3%80%E9%AA%8C" tabindex="-1">启发式方法的N折交叉检验</h4><ul><li>首先，我们将Alexa的前50个网站随机分成五组，每组10个网站。我们从中挑选了两组（共20个网站）进行训练，剩下的30个网站用于测试。我们进行了10次这样的评估. 结果略</li><li>其次，我们将Alexa的前50个网站随机分成10组，每组五个网站。我们从中随机挑选了五组（共25个网站）进行训练，剩下的25个网站用于测试。我们进行了10次这样的评估。结果略</li><li>结果表明，我们的启发式方法对于推断具有类似训练输入功能的未执行代码是有效的</li></ul><h2 id="6-%E8%AE%A8%E8%AE%BA" tabindex="-1">6 讨论</h2><h4 id="%E5%B0%BD%E6%9C%80%E5%A4%A7%E5%8F%AF%E8%83%BD%E7%9A%84%E8%B7%AF%E5%BE%84%E6%8E%A8%E6%96%AD-best-effort-path-inference" tabindex="-1">尽最大可能的路径推断 Best-effort path inference</h4><ul><li>将高等级的功能对应到低等级的代码是具有挑战性的,尤其是在代码未开源时</li><li>RAZOR采用基于控制流的启发式方法来推断更多的相关代码,但是这些方法并不完美,都是尽最大你眼里</li><li>目前,启发式的方法在二进制分析和重写中被广泛使用[53,52].通过执行跟踪,RAZOR能够减轻这些工作的局限性,例如找到间接调用目标.</li><li>评估显式,我们的基于控制流的启发式方法在实践中是有效的</li></ul><h4 id="cfi-and-deblaoting" tabindex="-1">CFI and deblaoting</h4><ul><li>控制流完整性Control-flow integrity (CFI)强制每个间接控制流转移（即间接调用/跳转和返回）都前往合法目标[1], 它防止了开发人员无法预料的恶意行为</li><li>而软件去膨胀需要根据用户的需求删除良性但不必要的代码<ul><li>例如,如果函数A被设计为间接调用i的合法目标，CFI将允许从i到A的转移。但是，如果用户不需要A中的功能，软件去膨胀将禁用转移并完全删除函数代码</li></ul></li><li>一方面,去膨胀实现了一种粗粒度的CFI，攻击者只能将控制流转移到剩余的代码。同时简化了一些CFI工作所需的分析，因为代码基础更小</li><li>另一方面,现有的CFI为实施去膨胀提供了基本平台。<ul><li>例如，RAZOR利用了在binCFI [53]中开发的几种二进制分析技术进行优化。</li></ul></li></ul><h4 id="%E5%9F%BA%E4%BA%8E%E5%BA%93%E7%9A%84%E5%8E%BB%E8%86%A8%E8%83%80" tabindex="-1">基于库的去膨胀</h4><ul><li>我们尝试使用RAZOR对每个程序的库进行去膨胀,又成功的也有失败的<ul><li>例如,在去膨胀libc.so库时,使用zFunc启发式方法最激进的保留代码,还是会触发不同的执行路径. 检查原因时发现其执行路径对环境变化非常敏感<ul><li><ol><li>其包含大量针对内存或字符串的高度优化代码,这戏代码会根据参数值选择最有效的实现方式,如strncmp有16种实现方式</li></ol></li><li><ol start="2"><li>其会根据进程状态进行不同的擦欧总,如每次内存分配,malloc会选择第一个可用块,输入的不同可能会导致malloc遍历完全不同的路径</li></ol></li></ul></li><li>为此我们计划开发针对库的启发式方法来应对环境敏感的运行<ul><li>例如,我们可以在函数级别而不是块级别上进行去膨胀</li></ul></li></ul></li><li>目前我们还将探索基于源码的方法,并尝试将其移植到二进制上</li></ul><h4 id="%E5%88%A0%E9%99%A4%E5%8E%9F%E5%A7%8B%E4%BB%A3%E7%A0%81" tabindex="-1">删除原始代码</h4><ul><li><p>RAZOR当前的设计是将原始代码 保留在去膨胀程序中,并将其权限更改为已读,以减少攻击面.</p></li><li><p>这种设计简化了对代码中潜在数据的处理,程序可能因为一些特殊目的来读取这些数据</p></li><li><p>为了进一步减小程序的大小,我们完全可以删除原始代码部分,具体操作如下</p><ul><li>在执行跟踪期间，我们将原始代码部分设置为仅执行[11]，以便任何从代码部分读取的操作都会触发异常并被追踪器记录；</li><li>我们执行向后的数据流分析，以确定每个记录的内存访问所使用的数据指针的来源；</li><li>在二进制合成过程中，我们将数据从原始代码部分重定位到新的数据部分，并更新新代码以访问新位置。</li></ul></li><li><p>通过这种方法,我们可以解决二进制重写过程中输入的重定位这一挑战性问题.</p><ul><li>实际上,我们进行了研究来了解这个问题的普遍性,我们发现在我们文章中测试用的程序,给定我们的测试用例,没有一个程序会从代码部分读取数据,此时只需要简单的删除原始代码即可,以减小文件大小和内存占用</li></ul></li></ul><h4 id="%E6%9C%AA%E6%9D%A5%E5%B7%A5%E4%BD%9C" tabindex="-1">未来工作</h4><ul><li>我们将开源RAZOR</li><li>我们计划扩展该平台以支持更多格式和架构的二进制文件，包括共享库、32位二进制文件、Windows PE程序、MacOS March-O程序和ARM二进制文件。</li><li>同时，我们将设计更多与安全性相关的启发式方法，使RAZOR能够支持各种真实世界的情况。</li></ul><h2 id="7-%E7%9B%B8%E5%85%B3%E5%B7%A5%E4%BD%9C" tabindex="-1">7 相关工作</h2><h3 id="library-debloating%3A%E5%9F%BA%E4%BA%8E%E5%BA%93%E7%9A%84%E5%8E%BB%E8%86%A8%E8%83%80" tabindex="-1">Library debloating:基于库的去膨胀</h3><ul><li><p>库旨在未不同的用户提供大量的功能支持,对库去膨胀可以对每个程序定制不同的代码基础,并显著减少代码</p></li><li><p>Mulliner :<em>CodeFreeze</em>:用于从Windows共享库中删除不必要的代码 [36]</p></li><li><p>Quach  :<em>piece-wise</em>:使用分块编译和加载进行去膨胀 [40]</p></li><li><p>Jiang  : 提出从Android应用程序,Java运行时环境和SDK中删除死代码的方法 [23,22]</p></li><li><p>我们的系统与上述方法有两个不同</p></li></ul><ol><li>之前的方法在每次过程开始都要进行二进制重写,而RAZOR通过静态二进制重写生成简化的二进制程序,一次重写永久使用</li><li>库去膨胀使用静态分析找到不用的代码,并且保守地保留了所有可能有用的代码;而我们地系统通过动态执行来跟踪和定位 执行的代码 或通过启发式找到代码,并移除其它地代码</li></ol><h3 id="delta-debugging-%E5%A2%9E%E9%87%8F%E8%B0%83%E8%AF%95%E6%B3%95" tabindex="-1">Delta debugging 增量调试法</h3><ul><li>DD被提出来 最小化触发错误的输出,例如<ul><li>Regehr,<em>C-Reduce</em>[42]:高效生成更小的测试用例</li><li>Sun,<em>Perses</em>[49]:使用形式化语法 很快地 生成更小却功能相同的程序</li><li>Heo,<em>Chisel</em>[15]:使用强化学习来加速DD过程</li></ul></li><li>然而,由DD产生的程序仅支持测试用例,尽管现实中对确定的功能有近乎无限的测试用例.</li><li>相反,RAZOR使用基于控制流的启发式方法,可以推断出更多的必要的相关代码来完备所需的功能</li></ul><h3 id="%E5%9F%BA%E4%BA%8E%E6%BA%90%E4%BB%A3%E7%A0%81%E7%9A%84%E5%8E%BB%E8%86%A8%E8%83%80" tabindex="-1">基于源代码的去膨胀</h3><ul><li>最近很多方法使用程序分析来简化代码<ul><li>Bu [8] : 提出了一种 <em>bloat-ware</em> 设计范式,该范式分析Java源代码来优化对象分配,避免运行时内存使用膨胀</li><li>Sharif [44] : 提出 <em>Trimmer</em>,将用户提供的被指传播到程序代码中,然后使用编译器优化来减小代码大小</li></ul></li><li>这些系统,以及[42,49,15] 依赖于对源代码的复杂分析,而这些分析不总是能用于部署的系统. 相反,RAZOR仅需要二进制程序,使其更适合实际部署</li></ul><h3 id="%E5%9F%BA%E4%BA%8E%E5%AE%B9%E5%99%A8%E7%9A%84%E5%8E%BB%E8%86%A8%E8%83%80" tabindex="-1">基于容器的去膨胀</h3><ul><li>容器变得越来越受欢迎,但其代码基础越来越膨胀</li><li>Guo[14] 提出了一个监视程序运行的方法,以识别必要的资源为被追踪的程序创建一个最小的容器</li><li>Rastogi[41] 开发了 <em>Cimplifier</em> , 使用动态分析来收集不同程序的资源使用,然后根据用户定义的策略将原始容器划分为一组较小的容器</li><li>RAZOR也适用于容器或其它系统的去膨胀,例如 Inter PT 支持操作系统的追踪,而这时RAZOR中使用的</li></ul><h3 id="%E5%9F%BA%E4%BA%8E%E7%A1%AC%E4%BB%B6%E7%9A%84%E5%8E%BB%E8%86%A8%E8%83%80" tabindex="-1">基于硬件的去膨胀</h3><ul><li>近来,硬件设备也是膨胀的,例如通用处理器被过度设计于应用于特定应用,如 嵌入式设备,可穿戴设备和互联网设备</li><li>Cherupalli[10] 提出了一个方法可以自动的从 通用处理器中 移除未使用的门,以生成为特定应用的定制处理器</li><li>目前,软件的膨胀和硬件的膨胀是分开进行的,一个有趣的方向是同时考虑硬件和软件来找到更多的去膨胀空间</li></ul><h2 id="8-%E7%BB%93%E8%AE%BA" tabindex="-1">8 结论</h2><ul><li>本文提出RAZOR,一个用于实际程序去膨胀的框架,它利用一组测试用例和基于控制流的启发式方法,来收集支持用户所需功能的必要代码</li><li>去膨胀的二进制程序有较小的攻击面,改进的安全性保证,鲁棒性的功能和高效的执行</li><li>我们的评估证明,RAZOR是一个实用的,可用于对现实程序简化的去膨胀方法</li></ul><h2 id="9-%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93" tabindex="-1">9 阅读总结</h2><ol><li>本文<strong>问题驱动</strong>很好,对于老旧的程序,肯定会有一些过时的功能,这些功能的代码可能会带来安全性的问题,为此需要程序去膨胀</li><li><strong>相关代码</strong>的定义很好,但这应该是出现在基于输入测试用例的方法上,因为测试用例可能不能包括所有情况,所以有的相关代码没有被运行,如果轻易删除会引发问题.<ul><li>但是如果是非基于输入的方法呢</li></ul></li><li>需要坚实的底层基础,如了解汇编和反汇编等,这样才能更好理解本文方法</li><li>去膨胀需要在不同级别进行</li></ol><ul><li><p>本文因是在二进制上,所有可以从块级别出发构造CFG,然后进行去膨胀</p></li><li><p>对于基于源代码的,可以基于函数级别,基于库级别,而对于面向对象的语言,可以对于包级别等</p></li><li><p>问题</p><ul><li><ol><li>第四种启发式方法,即保留最大程度,怎么还要手工标注库的功能区分</li></ol></li><li><ol start="2"><li>方法基于二进制,可以无视软件是否开源直接使用,但相应的需要对应的底层代码知识,不方便开发人员进行二次改造(大概),并且这涉及用户的信任度,真敢用吗</li></ol></li></ul></li></ul><h2 id="10-%E5%A4%8D%E7%8E%B0" tabindex="-1">10 复现</h2><ul><li>使用docker进行复现</li></ul><h3 id="%E5%A4%8D%E7%8E%B0chiselbenchmark" tabindex="-1">复现ChiselBenchmark</h3><p>按照 <a href="https://github.com/cxreet/razor/wiki/Exercises">github网站指示</a> 即可</p><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(4)_x.png&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;razor%3A-a-framework-for-post</summary>
      
    
    
    
    <category term="论文" scheme="http://example.com/categories/%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="SoftwareEngineering" scheme="http://example.com/tags/SoftwareEngineering/"/>
    
    <category term="SoftwareDebloating" scheme="http://example.com/tags/SoftwareDebloating/"/>
    
  </entry>
  
  <entry>
    <title>Software Debloating 论文阅读 (3)</title>
    <link href="http://example.com/2024/01/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/SoftwareDebloating/Software%20Debloating%20%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB(3)/"/>
    <id>http://example.com/2024/01/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/SoftwareDebloating/Software%20Debloating%20%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB(3)/</id>
    <published>2024-01-15T07:10:43.883Z</published>
    <updated>2024-01-15T07:10:43.883Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(3)_x.png" alt></p><h1 id="effective-program-debloating-via-reinforcement-learning-(chisel)" tabindex="-1">Effective Program Debloating via Reinforcement Learning (Chisel)</h1><p>2018 ACM SIGSAC Conference on Computer and Communications Security (CCS ’18)　CCFA会</p><p>Heo K, Lee W, Pashakhanloo P, et al. Effective program debloating via reinforcement learning[C],Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security. 2018: 380-394</p><h2 id="0-%E6%91%98%E8%A6%81" tabindex="-1">0 摘要</h2><ul><li>在软件工程中，代码重用和“一刀切”的方法是导致软件规模和复杂性显著增加的主要因素。由此产生的软件膨胀导致了性能下降和安全漏洞的增加。</li><li>我们提出了一个名为Chisel的系统，旨在帮助程序员有效地定制和去膨胀程序。<ul><li>Chisel接受一个待去膨胀的程序和一个对其所需功能的高级别规范作为输入</li><li>输出是一个根据规范正确减少的版本的程序</li><li>与其它方法相比,Chisel通过使用一种基于强化学习的新颖方法来加速搜索减少的程序并扩展到大型程序，从而显著提高了效果。</li></ul></li><li>我们对一组包含10个广泛使用的UNIX实用程序的13-90 KLOC(Kilo lines of code) C源代码套件进行了评估，结果表明Chisel能够成功去除所有不需要的功能并减少攻击面。</li></ul><h2 id="1-%E4%BB%8B%E7%BB%8D" tabindex="-1">1 介绍</h2><ul><li><p>软件膨胀导致性能下降并增加安全漏洞,此外常见库中的各种gadget使得攻击者可以在不向应用程序注入任何代码的情况下执行任意算法</p></li><li><p>此外软件经常包含一些被用户几乎没用过的功能,但没有给用户任何实际和有效的方法去除它们</p><ul><li>目前流行的做法是对现有程序重新进行一个轻量级的实现.例如针对嵌入式平台的轻量级实现:WebServer(Lighttpd),DataBase(SQLite),C/C++ libaries(EGLIBC,yClibc-bg),命令行实用程序(BusyBox,ToyBox). 但这种方法需要源代码开源且需要大量手动工作</li><li>在移动应用程序中,IOS APP引入乐系统瘦身,可以自动检测用户设备型号,仅下载特定设备所需的内容,但这需要开发者标记其软件来对应关系,这导致在IOS上该方法也不常用</li></ul></li><li><p>我们开发了一个实用的系统,使得程序员能够定制和简化程序</p><ul><li>该系统将一个程序,及其需要保留功能的相关高级规范作为输入</li><li>输出一个根据规范正确简化的程序</li></ul></li><li><p>我们认为简化后的程序有效需要以下五个关键点</p><ul><li><strong>Minimality</strong> 最小:系统是否尽可能地 根据期望地特点 修建了程序</li><li><strong>Efficiency</strong> 效率:系统是否高效地 找到了最小化地程序并且可以扩展到大规模的程序</li><li><strong>Robustness</strong> 鲁棒:系统是否避免了 引入新的异常和漏洞 在生成的程序中</li><li><strong>Naturalness</strong> 自然:系统是否生成了 可维护和可扩展 的代码</li><li><strong>Generality</strong> 通用:系统是否可以应用于 大量不同的 程序和特点吗</li></ul></li><li><p>如下图示,Chisel系统需要一个程序P和一个质量测试函数S,来检查获选程序是否满足或与需要的属性冲突,最后输出一个最简化的程序P’同时满足S<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(3)_1.png" alt></p></li><li><p>Chisel提供了一个 在生成程序最小性上的 正是保证,叫做 1-minimality,已经被证实在程序简化中有效</p><ul><li>调用质量测试函数可能很昂贵,例如其可能会参与候选程序的编译和 在程序套件运行</li><li>而1-minimality 保证 缩小算法在最坏情况下,调用质量测试函数的次数 为 程序大小的二次方</li><li>尽管 此保证 不能保证找到最优解,但也有次优性质,也很难扩展到大程序</li><li>而Chisel通过避免生成大量的 语义或语法上 无效的候选程序 来避免这个问题</li></ul></li><li><p>Chisel保证简化后的程序满足给定的属性期望,所以其具有鲁棒性.</p><ul><li>其避免会随换程序或破环其自然性的转换</li><li>最后,其将 程序和属性 都视为黑盒,使其适用于各种不同类型的程序和规范</li></ul></li><li><p>C-REDUCE 和 PERSES不满足上述特点,这两个工具同Chisel一样,接受一个需要简化的程序和一个质量测试函数作为输入,并输出一个简化的程序</p><ul><li>C-REDUCE满足了与Chisel相同的最小性和正确性标准,但其牺牲了效率,自然度和通用性.C-Reduce针对手写的程序转换规则是定制且紧密耦合的,由于这些规则是短时的,所以C-reduce在寻找简化程序时会产生大量的语义和语法无效的候选程序,此外,该工具经常生成不自然的代码</li><li>Perses同样牺牲了效率和通用性,其简化过程是基于语法引导的,这可以避免在搜索过程中产生语法无意义的候选程序.然而依然无法避免语义无效的候选程序,因为其无法感知程序元素间的语义依赖关系(例如def-use关系). 同时,基于语法感知的简化在每一步都太过保守,因此比C-Reduce效率更低.</li></ul></li><li><p>我们客服现有方法限制的 主要技术见解 是 使用 强化学习 来 加速程序的简化</p><ul><li>通过反复的试错,chisel构建并完善了一个静态模型,来决定每个候选程序通过测试的可能性,该模型可以有效的捕捉程序元素间的语义依赖同时引导搜索至最小程序</li><li>Chisel的学习方法是跨语言的,因为模型是从 尝试的候选程序和他们的属性测试结果 的简单向量中 学习的</li></ul></li><li><p>在10个UNIX上广泛使用的实用程序套件上对Chisel进行评估,Chisel高效地收敛到最小程序,由于其它所有方法.</p><ul><li>并成功修复了10个程序中的6个漏洞(CVE),平均消除了66.2%的gadgets,简化的程序通过SOTA的fuzz:AFL的持续三天的进一步验证</li><li>此外,我们还手动分析了简化后的源码,确认删除功能符合预期,同时保留了诸如 模块化和局部性的理想软件工程实践</li></ul></li><li><p><strong>论文贡献总结</strong></p><ul><li><ol><li>提出Chisel系统来减少程序的大小和复杂度,其目标是从现有软件中移除不需要的功能并减少他们的攻击面</li></ol></li><li><ol start="2"><li>提出了一个通用的强化学习框架,为了更高效和更大的程序简化. 该框架可以在不同目标语言和规范上使用</li></ol></li><li><ol start="3"><li>使用一组UNIX的通用程序对Chisel进行评估,结果显示其可以减少软件的缺陷和攻击面且不引入新的bug</li></ol></li></ul></li></ul><h2 id="2-motivating-example" tabindex="-1">2 MOTIVATING EXAMPLE</h2><ul><li>我们通过一个例子(Unix通用工具 tar)来解释Chisel如何帮助程序员定制和简化程序.<ul><li>假设针对嵌入式 我们需要一个简易的tar,目前针对嵌入式的tar有一个BusyBox.原始的tar提供97个命令行选项,BusyBox仅提供8个</li><li>我们将演示如何通过向Chisel提供简单而高级的规范来自动获取与BusyBox有相同功能的程序</li><li>同时我们还将展示这种简化如何导致 简化的代码 和 安全性的增强. 最后我们解释了如何保证结果程序的鲁棒性</li></ul></li></ul><h3 id="2.1-%E6%98%8E%E7%A1%AEchisel%E7%9A%84%E8%BE%93%E5%85%A5" tabindex="-1">2.1 明确Chisel的输入</h3><ul><li>首先,我们需要用户编写一个高等级的特征规范,该规范描述了程序的期望功能.<ul><li>规范可以是一个脚本程序,其接收一个源程序并编译,并检查编译后的程序恮输出行为是否符合期望,如果不符合返回false,否则返回true</li></ul></li></ul><pre><code class="language-bash">1 #!/bin/bash23 function compile &#123;4 clang −o tar.debloat tar−1.14.c5 return $?6 &#125;78 function core &#123;9 # test 1: archiving multiple files10 touch foo bar11 ./tar.debloat cf foo.tar foo bar12 rm foo bar13 ./tar.debloat xf foo.tar14 test −f foo −a −f bar || exit 11516 # test 2: extracting from stdin17 touch foo18 ./tar.debloat cf foo.tar foo19 rm foo20 cat foo.tar | ./tar.debloat x21 test −f foo || exit 122 ... #12 more tests that exercise the 8 target options23 return 024 &#125;2526 function non_core &#123;27 for test_script in ‘ls other_tests/∗.sh‘; do # for all optional test cases28 &#123; sh −x −e $test_script; &#125; &gt;&amp; log29 grep 'Segmentation fault' log &amp;&amp; exit 130 done31 return 032 &#125;3334 compile || exit 135 core || exit 136 non_core || exit 1</code></pre><ul><li>上述代码是一个可用作规范的脚本程序,该脚本包括三个步骤<ul><li><ol><li>第一步中调用complie函数(第三行),检查源程序是否可以编译</li></ol></li><li><ol start="2"><li>第二步调用core函数来检查程序是否表现出期望的属性,这一步包括14个测试用例,用于测试8个命令行选项,仅在通过全部测试用例时进入下一步</li></ol><ul><li>例如:第14行,第一个测试用例,检测是否可以压缩和解压缩文件</li></ul></li><li><ol start="3"><li>第三步调用non_core避免简化带来新的错误,其指定了一种要求,即调用了简化去掉的功能时,程序至少不能崩溃(第29行),如果没有这个要求,简化器可能会随意地删除非核心功能地代码,这将导致移除删除功能被调用后很容易崩溃和受到攻击</li></ol></li></ul></li><li>为了完成这样的脚本,我们需要广泛覆盖目标功能地测试程序,这些测试用例可以通过开发人员使用自动测试生成技术活回归测试套件来获得.本文中,使用开发人员为原始程序写的测试套件</li></ul><h3 id="2.2-chisel%E4%B8%8E%E5%85%B6%E5%AE%83%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%93%E6%9E%9C%E6%AF%94%E8%BE%83" tabindex="-1">2.2 Chisel与其它方法的结果比较</h3><ul><li>给定tar的原始程序(45778行,13227个语句),12小时内,Chisel生成了简化版本(1687行,538个语句),而C-Reduce和Perses都无法在12小时内生成简化版本,简化例子如下</li></ul><pre><code class="language-C">1 /∗ Chisel: global variable declarations removed ∗/2 34 char ∗safer_name_suffix (char ∗file_name, int link_target) &#123;5     /∗ Chisel: code containing CVE removed ∗/6     return file_name;7 &#125;89 void extract_archive() &#123;10    char ∗file_name = safer_name_suffix(stat_info.file_name, 0);11    /∗ Chisel: overwriting functionalities removed ∗/12 &#125;1314 void list_archive() &#123; ... /∗ same as original ∗/ &#125;1516 void read_and(void ∗(do_something)(void)) &#123;17  enum read_header status;18  while (...) &#123;19    status = read_header();20      switch (status) &#123;21        case HEADER_SUCCESS: (∗do_something)(); continue;22        /∗ Chisel: unnecessary functionalities removed ∗/23        default: break;24      &#125;25    &#125;26 &#125;2728 /∗ Supports only 8 options: −c, −f, −x, −v, −t, −O, −o, −k ∗/29 int main(int argc, char ∗∗argv) &#123;30    int optchar;31    while (optchar = getopt_long(argc, argv) != −1) &#123;32        switch (optchar) &#123;33          case 'x': read_and(&amp;extract_archive); break;34          case 't': read_and(&amp;list_archive); break;35          /∗ Chisel: unsupported options removed ∗/36        &#125; 37      &#125;38 ... /∗ same as original ∗/39 &#125;/*  Code snippet of the original version of tar*/1 int absolute_names;2 int ignore_zeros_option;3 struct tar_stat_info stat_info;45 char ∗safer_name_suffix (char ∗file_name, int link_target) &#123;6     char ∗p;7     if (absolute_names) &#123;8       p = file_name;9     &#125; else &#123;10      /∗ CVE−2016−6321 ∗/11      /∗ Incorrect sanitization when &quot;file_name&quot; contains &quot;..&quot; ∗/12      /∗ &quot;p&quot; points to the longest suffix of &quot;file_name&quot; without &quot;../&quot; ∗/13      ...14    &#125;15    ...16    return p;17 &#125;1819 void extract_archive() &#123;20    char ∗file_name = safer_name_suffix(stat_info.file_name, 0);21    /∗ Overwrite &quot;file_name&quot; if exists ∗/22    ...23 &#125;2425 void list_archive() &#123; ... &#125;26 void read_and(void ∗(do_something)(void)) &#123;27    while (...) &#123;28       enum read_header status = read_header();29      switch (status) &#123;30        case HEADER_SUCCESS: (∗do_something)(); continue;31        case HEADER_ZERO_BLOCK:32          if (ignore_zeros_option) continue;33          else break;34        ...35        default: break;36      &#125;37    &#125;38  ...39 &#125;4041 /∗ Support all options: −x, −t, −P, −i, ... ∗/42 int main(int argc, char ∗∗argv) &#123;43    int optchar;44    while (optchar = getopt_long(argc, argv) != −1) &#123;45      switch (optchar) &#123;46        case 'x': read_and(&amp;extract_archive); break;47        case 't': read_and(&amp;list_archive); break;48        case 'P': absolute_names = 1; break;49        case 'i': ignore_zeros_option = 1; break;50        ...51      &#125;52    &#125;53  ...54 &#125;</code></pre><ol><li><code>main</code>函数中reduced版本,与原始版本比较,减少了不需要得选项</li><li><code>read_and</code>函数检查输入文件的头部,并在头部无效时进行异常处理,如果头部有效,根据命令调用响应函数.在简化版本中,异常处理部分被移除,头部无效即终止程序</li><li><code>safer_name_suffix</code>函数通过和三处冗余分支得到显著简化</li></ol><ul><li>实现上述简化,不能只是用典型的静态分析和动态分析<ul><li>静态分析保守地保留了所有代码部分,因为在编译时命令行选项和输入文件都是未知的,因此静态方法无法删除函数<code>read_and</code>中的任何代码,因为原本代码中29行status无法确定</li><li>动态可达性不能删除函数<code>safer_name_suffix</code>中的任何代码,因为测试用例中没有执行选项’-P’,所以变量absolute_name总为0,结果动态方法总是覆盖第9行地分支,因此无法删除从原始代码第9行开始的讨论安全漏洞的方法</li></ul></li></ul><h3 id="2.3-%E5%88%86%E6%9E%90chisel%E7%9A%84%E8%BE%93%E5%87%BA" tabindex="-1">2.3 分析Chisel的输出</h3><ul><li>从两方面进行 输出安全漏洞和进一步验证</li></ul><h4 id="%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E7%A7%BB%E9%99%A4" tabindex="-1">安全漏洞移除</h4><ul><li><p>tar工具在解压缩文件时的安全漏洞和修复措施。原始版本的tar存在一个漏洞，允许攻击者通过恶意构造的路径名覆盖现有文件。开发人员通过忽略包含’…/'的路径名来修复了这个问题。在Chisel版本中，由于删除了相关功能，这个漏洞无法再被利用。</p></li><li><p>详细情况请看论文描述</p></li></ul><h4 id="%E8%BF%9B%E4%B8%80%E6%AD%A5%E9%AA%8C%E8%AF%81" tabindex="-1">进一步验证</h4><ul><li>化简后的程序很小,并且很大程度上保留了语法结构,用户可以很轻松的与源代码进行比较.复杂的代码也可以通过比较工具清晰的展示缩减程度</li><li>此外,化简后的大小和复杂度可以使用准确的自动化技术.<ul><li>为了检查简化版本是否引入了新bug,我们使用现有的技术进行推理(例如 静态/动态分析,模糊测试,运行时监控或验证),来提高正确率</li><li>我们对简化后的tar进行了静态分析和随机模糊测试</li></ul></li><li>去膨胀化使得人工检查静态分析称为可能<ul><li>例如,Sparrow[13]是一种用于发现安全漏洞的静态分析器，它在一秒钟内只为简化后的tar程序生成了19个警报，而原始程序则生成了1,290个警报。经过手动检查，我们得出结论认为所有19个警报都是假的。</li></ul></li><li>去臃肿化后的程序还可以通过随机测试工具（如模糊器）进行高效测试<ul><li>我们在简化后的tar程序上运行了AFL工具[1]，即使在三天内也没有找到任何导致失败的输入。这提高了对去臃肿化后的程序正确性的信心。</li></ul></li></ul><h2 id="3-%E8%83%8C%E6%99%AF" tabindex="-1">3 背景</h2><p>本节正式定义了我们的程序去臃肿化设置,并介绍了基于我们的程序去臃肿化方法的 增量调试和强化学习的概念。</p><h3 id="3.1-%E7%A8%8B%E5%BA%8F%E5%8E%BB%E8%86%A8%E8%83%80" tabindex="-1">3.1 程序去膨胀</h3><ul><li>定义<ul><li>令<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>∈</mo><mi mathvariant="double-struck">P</mi><mo separator="true">,</mo><mi mathvariant="double-struck">P</mi></mrow><annotation encoding="application/x-tex">P \in \mathbb{P},\mathbb{P}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8833em;vertical-align:-0.1944em;"></span><span class="mord mathbb">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathbb">P</span></span></span></span></eq>是所有程序的集合</li><li>一个<code>property 属性</code> 定义各位一个属性测试函数<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo>:</mo><mi mathvariant="double-struck">P</mi><mo>→</mo><mi mathvariant="double-struck">B</mi></mrow><annotation encoding="application/x-tex">O:\mathbb{P} \rightarrow \mathbb{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">P</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">B</span></span></span></span></eq>,<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">B</mi><mo>=</mo><mo stretchy="false">{</mo><mi>T</mi><mo separator="true">,</mo><mi>F</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\mathbb{B} = \{T,F\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mclose">}</span></span></span></span></eq>,当<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo><mo>=</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">O(P)=T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span></eq>时,当且仅当<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></eq>有该属性,否则<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo><mo>=</mo><mi>F</mi></mrow><annotation encoding="application/x-tex">O(P)=F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span></eq></li><li>令<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>P</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|P|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord">∣</span></span></span></span></eq>为P的大小,根据一个合适的度量标准,例如语句或符号的数量</li></ul></li><li>给定一个程序<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></eq>,一个属性测试函数<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span></span></span></span></eq>满足<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo><mo>=</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">O(P)=T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span></eq>,程序去膨胀的目标是找到最小的程序<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>P</mi><mo lspace="0em" rspace="0em">∗</mo></msup><mo>∈</mo><mi mathvariant="double-struck">P</mi></mrow><annotation encoding="application/x-tex">P^{*} \in \mathbb{P}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">P</span></span></span></span></eq>满足 <section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>P</mi><mo>∗</mo></msup><mo>=</mo><msub><mrow><mi>a</mi><mi>r</mi><mi>g</mi><mtext> </mtext><mi>m</mi><mi>i</mi><mi>n</mi></mrow><mrow><msup><mi>P</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>∈</mo><mi mathvariant="double-struck">P</mi></mrow></msub><mi mathvariant="normal">∣</mi><msup><mi>P</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mi mathvariant="normal">∣</mi><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mi>s</mi><mi mathvariant="normal">.</mi><mi>t</mi><mi mathvariant="normal">.</mi><mtext> </mtext><mtext> </mtext><mtext> </mtext><mi>O</mi><mo stretchy="false">(</mo><msup><mi>P</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo>=</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">P^* = {arg\,min}_{P&#x27; \in \mathbb{P}} |P&#x27;| \,\,\,\,\,s.t.\,\,\,O(P&#x27;)=T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7387em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7387em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0734em;vertical-align:-0.2715em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">min</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2381em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mrel mtight">∈</span><span class="mord mathbb mtight">P</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2715em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">s</span><span class="mord">.</span><span class="mord mathnormal">t</span><span class="mord">.</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span></span></eqn></section><ul><li>如果实现这个目标则成为全局最小性,但这是NPC问题</li><li>因此实践中去膨胀的追求为一个更可行的目标称为 <code>1-minimality</code>[45]. 一个程序<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>P</mi><mo>∗</mo></msup><mo>∈</mo><mi mathvariant="double-struck">P</mi></mrow><annotation encoding="application/x-tex">P^* \in \mathbb{P}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">P</span></span></span></span></eq>被称为 <code>1-minimality</code>当且仅当对于任意的从<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>∗</mo></mrow><annotation encoding="application/x-tex">P*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord">∗</span></span></span></span></eq>删除单个元素获得的变体<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>P</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">P&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></eq>不能通过属性测试</li></ul></li></ul><h3 id="3.2-delta-debugging(dd-for-short)" tabindex="-1">3.2 Delta Debugging(DD for short)</h3><h4 id="%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0" tabindex="-1">算法描述</h4><p><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(3)_2.png" alt></p><ul><li>给定程序<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></eq>和属性<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span></span></span></span></eq>,DD首先将输入程序转换为列表<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span></eq>,其中包含任意粒度(tokens,lines,函数)</li></ul><ol><li>初始化时,将解决方案设为L,分区数设为n(第1,2行)</li><li>当前解决方案候选L划分为n个分区(第4行)</li><li>对于每个分区<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">u_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>算法测试 该分区(或其补集) 是否可以保留属性(第5,7行)</li><li>如果能保留,删除其补集,否则删除分区(第6,8行)</li><li><ol><li>如果一个分区通过属性测试,DD将n设置为2重复该过程;</li><li>如果一个补集通过测试,DD将n设置为n-1,维持当前粒度等级;</li><li>当没有分区和补集通过属性测试时,DD将每个分区分为两半</li></ol></li><li>如果每个分区都不能分割(12行),则返回对应剩余元素列表L的程序<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>P</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">P&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></eq>(13行);</li><li>否则,通过将每个剩余分区分成两半继续主循环(10行)</li><li>此算法最坏复杂度为<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>P</mi><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(|P|^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq></li></ol><h4 id="%E7%AE%97%E6%B3%95%E4%BE%8B%E5%AD%90" tabindex="-1">算法例子</h4><pre><code class="language-C">1 int f1 () &#123; return 0; &#125;2 int f2 () &#123; return 1; &#125;3 int f3 () &#123; return 1; &#125;4 int f4 () &#123; return 1; &#125;5 int f5 () &#123; return 1; &#125;6 int f6 () &#123; return 1; &#125;7 int f7 () &#123; return 1; &#125;8 int main () &#123; return f1(); &#125;</code></pre><ul><li>考虑上述简单的C代码,我们的目标属性时终止并返回0,同时定义在函数粒度上进行简化,因此,最小的程序应该仅包含函数 f1和main.</li><li>下图展示了算法的迭代过程<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(3)_3.png" alt></li></ul><ol><li>最初两次迭代中,算法尝试两个分区(n=2),每个分区包含前四行和最后四行。</li><li>由于这两个分区都无法保留属性，算法通过将n设置为4来增加粒度，并尝试了四个分区，但都失败了（迭代3-6）。</li><li>然后算法尝试了这四个分区的补集。在第8次迭代中，算法找到了一个保留属性的补集。通过将n减1，算法保持当前的粒度并尝试当前候选的n = 3个子集。</li><li>由于所有三个子集（⟨f1, f2⟩，⟨f5, f6⟩，⟨f7, main⟩）都已经尝试过，所以它们被跳过。然后它尝试它们的补集，并在第9次迭代中找到另一个较小的程序。</li><li>再次将n减1，算法保持当前的粒度并尝试当前候选的n = 2个子集。同样，所有两个子集（及其补集）都已经尝试过并且失败了。</li><li>现在算法将粒度翻倍（n &lt;- 2 × 2），并尝试四个子集（迭代10-13），但都失败了。</li><li>继续尝试它们的补集，在第15次迭代中找到了另一个正确的补集。n = 4 - 1 = 3</li><li>现在它尝试程序的n = 3个子集及其补集，并在最后一次迭代中找到最小解决方案。</li></ol><h3 id="3.3-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-reinforcement-learning" tabindex="-1">3.3 强化学习 Reinforcement Learning</h3><h4 id="%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E5%86%B3%E7%AD%96%E8%BF%87%E7%A8%8B-markov-decision-process" tabindex="-1">马尔可夫决策过程 Markov Decision Process</h4><ul><li>Markov Decision Process(MDP) 是一个用于解决顺序决策问题的框架.在这个框架中,一个代理(agent)作为学习者和决策者,与所谓的环境进行交互,代理根据每个状态下的行为从环境中获得奖励. 形式上,MDP有以下几个部分<ul><li>一组状态<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span></eq>,初始状态<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>0</mn></msub><mo>∈</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">s_0 \in S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span></eq></li><li>一组动作<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">A</mi></mrow><annotation encoding="application/x-tex">\mathcal{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal">A</span></span></span></span></eq>和函数<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>:</mo><mi>S</mi><mo>→</mo><msup><mn>2</mn><mi mathvariant="script">A</mi></msup></mrow><annotation encoding="application/x-tex">A:S\rightarrow 2^{\mathcal{A}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathcal mtight">A</span></span></span></span></span></span></span></span></span></span></span></span></eq>,指定每个状态下可用的函数</li><li>过渡模型<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>:</mo><mi>S</mi><mo>×</mo><mi mathvariant="script">A</mi><mo>→</mo><mi>P</mi><mi>r</mi><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T:S\times \mathcal{A} \rightarrow Pr(S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span></eq>,其中<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><msup><mi>s</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mi mathvariant="normal">∣</mi><mi>s</mi><mo separator="true">,</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(s&#x27;|s,a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0019em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mclose">)</span></span></span></span></eq>表示从状态<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span></eq>执行动作<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span></eq>转移到状态<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>s</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">s&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></eq>的概率</li><li>奖励函数<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>:</mo><mi>S</mi><mo>→</mo><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">R:S\rightarrow \mathbb{R}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">R</span></span></span></span></eq>,其中<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R(s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span></eq>表示状态<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span></eq>的预期奖励</li></ul></li><li>求解MDP的目标是找到一个策略 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo>:</mo><mi>S</mi><mo>→</mo><mi mathvariant="script">A</mi></mrow><annotation encoding="application/x-tex">\pi: S \rightarrow \mathcal{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal">A</span></span></span></span></eq> ,该策略指定了在给定状态下的代理采取的理想的行为.通常我们感兴趣的是找到一个最优的策略 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>π</mi><mo lspace="0em" rspace="0em">∗</mo></msup></mrow><annotation encoding="application/x-tex">\pi^{*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span></eq> ,使得对于每个状态 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>∈</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">s\in S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span></eq>,其被定义为 <section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>π</mi><mo>∗</mo></msup><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><mi><munder><mo><mi>a</mi><mi>r</mi><mi>g</mi><mtext> </mtext><mi>m</mi><mi>a</mi><mi>x</mi></mo><mrow><mi>a</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></munder></mi><mi><munder><mo><mo>∑</mo></mo><msup><mi>s</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></munder></mi><mi>T</mi><mo stretchy="false">(</mo><msup><mi>s</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mi mathvariant="normal">∣</mi><mi>s</mi><mo separator="true">,</mo><mi>a</mi><mo stretchy="false">)</mo><msup><mi>V</mi><mo>∗</mo></msup><mo stretchy="false">(</mo><msup><mi>s</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi^* (s) = \underset{a\in A(s)}{arg \,max} \underset{s&#x27;}{\sum } T(s&#x27;|s,a)V^*(s&#x27;)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7387em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.344em;vertical-align:-1.294em;"></span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.4306em;"><span style="top:-2.1146em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight">A</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">s</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop"><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.1604em;"><span></span></span></span></span></span></span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.856em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op" style="position:relative;top:0em;">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.294em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7387em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></eqn></section> 其中 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>V</mi><mo>∗</mo></msup><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V^*(s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span></eq> 表示在代理在状态s下施行最优策略是奖励的期望和,其是如下递归定义 <section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>V</mi><mo>∗</mo></msup><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><mi>R</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>+</mo><mi>γ</mi><mi><munder><mo><mo>∑</mo></mo><msup><mi>S</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></munder></mi><mi>T</mi><mo stretchy="false">(</mo><msup><mi>s</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mi mathvariant="normal">∣</mi><mi>s</mi><mo separator="true">,</mo><msup><mi>π</mi><mo>∗</mo></msup><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><msup><mi>V</mi><mo>∗</mo></msup><mo stretchy="false">(</mo><msup><mi>s</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> V^*(s) = R(s) + \gamma \underset{S&#x27;}{\sum} T(s&#x27;|s,\pi^*(S)) V^*(s&#x27;)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7387em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.3443em;vertical-align:-1.2943em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8557em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op" style="position:relative;top:0em;">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2943em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7387em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">))</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7387em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></eqn></section> 其中 <eq><span class="katex-error" title="ParseError: KaTeX parse error: Can&#x27;t use function &#x27;$1#x27; in math mode at position 8: \gamma $̲ 是一个折扣因子,用于平衡当前…" style="color:#cc0000">\gamma $ 是一个折扣因子,用于平衡当前奖励和未来奖励的重要性. 通常情况下,我们假设 $0 \leq \gamma \leq 1</span></eq> ,并且 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span></eq> 越大,未来奖励的重要性越高</li></ul><h4 id="%E5%9F%BA%E4%BA%8E%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0" tabindex="-1">基于模型的强化学习</h4><ul><li>基于模型的强化学习（Model-based Reinforcement Learning，MBRL）是一种在马尔可夫决策过程（Markov Decision Process，MDP）中使用模型来指导代理与环境交互的技术。</li><li>MBRL通过预测环境对代理在每个状态下采取的动作的响应来学习转移概率和奖励模型。</li><li>在解决MDP的过程中，MBRL跟踪状态转换和动作，根据获取的信息更新模型。</li><li>对于每个状态，代理根据模型估计未来奖励的期望总和，并选择使未来奖励期望总和最大化的动作。</li></ul><h2 id="4-%E6%88%91%E4%BB%AC%E7%9A%84%E6%96%B9%E6%B3%95" tabindex="-1">4 我们的方法</h2><h3 id="4.1-%E9%9D%9E%E6%AD%A3%E5%BC%8F%E6%8F%8F%E8%BF%B0" tabindex="-1">4.1 非正式描述</h3><ul><li><p>我们方法的关键是优先考虑能通过属性测试候选者,以此来快速收敛出一个解决方案,相当于在DD中减少属性测试的失败率,减少遍历失败的候选者的时间</p></li><li><p>为此,我们使用MBRL,维护一个模型来预测每个候选者通过属性测试的几率.</p></li><li><p>与原生DD相比,基于上面的例子,我们的算法只需要调用10次即可,下面详细展示使用标准树决策模型时算法的每次迭代<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(3)_4.png" alt></p><ol><li>第一次迭代中,程序P通过属性测试,将此结果添加到模型数据集中,此时模型预测全部程序都能通过测试</li><li>使用模型考虑优先候选者,此时二者优先级相同,故第一次迭代随机选择子集⟨f5, f6, f7, main⟩,没有通过测试,此结果添加至数据集中,形成图中(b)中第一个<strong>决策树,内部节点表示特定函数的存在条件,叶子节点表示给定程序通过属性测试的概率</strong>.第一棵树预测包含f4的程序通过属性测试,没有则不通过</li><li>第二次迭代选择第一次的补集⟨f1, f2, f3, f4⟩并失败,此结果加入数据集,模型决策树发生变化. 现在分区大小缩小一半,目前模型认为需要同时又f4和main才能通过属性测试</li><li>第三次迭代中,&lt; f1,f2 &gt;的补集被预测通过测试,但没有,将数据加入数据集得到新的预测树,预测同时需要&lt; f2, main&gt; 才能通过测试</li><li>在经过6次迭代后,获得理想决策树,认为包含main和f1是能通过属性测试的,此后再分区大小再缩小,均不能通过属性测试,因此迭代终止,返回程序&lt; main, f1&gt; 为最小程序</li></ol></li></ul><h3 id="4.2-%E7%94%A8%E4%BA%8Edd%E7%9A%84mdp" tabindex="-1">4.2 用于DD的MDP</h3><ul><li><p>接下来对用于DD的MDP作正式定义</p></li><li><p>给定原始程序P和属性测试函数O,MDP的目标是找到一个好的策略来引导DD找到满足O的最小程序</p></li><li><p>MDP的每个组件定义如下</p><ul><li>State:为候选程序列表和粒度等级的二元组<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><mo stretchy="false">⟨</mo><mi>L</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">S = \langle L, n \rangle</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⟨</span><span class="mord mathnormal">L</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">⟩</span></span></span></span></eq>,其中<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span></eq>是候选程序列表,<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></eq>是粒度等级</li><li>Action:状态<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>=</mo><mo stretchy="false">⟨</mo><mi>L</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">s=\langle L,n \rangle</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⟨</span><span class="mord mathnormal">L</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">⟩</span></span></span></span></eq>的可能的行为<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A(s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span></eq>定义为<section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mo stretchy="false">⟨</mo><mo stretchy="false">⟨</mo><msub><mi>u</mi><mn>1</mn></msub><mo stretchy="false">⟩</mo><mo separator="true">,</mo><mn>2</mn><mo stretchy="false">⟩</mo><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mo stretchy="false">⟨</mo><mo stretchy="false">⟨</mo><msub><mi>u</mi><mi>n</mi></msub><mo stretchy="false">⟩</mo><mo separator="true">,</mo><mn>2</mn><mo stretchy="false">⟩</mo><mo stretchy="false">}</mo><mspace width="1em"><mo stretchy="false">(</mo><mi>s</mi><mi>u</mi><mi>b</mi><mi>s</mi><mi>e</mi><mi>t</mi><mi>s</mi><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><mo>∪</mo><mtext> </mtext><mo stretchy="false">{</mo><mo stretchy="false">⟨</mo><mo stretchy="false">⟨</mo><mi>L</mi><mi mathvariant="normal">/</mi><msub><mi>u</mi><mn>1</mn></msub><mo stretchy="false">⟩</mo><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">⟩</mo><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mo stretchy="false">⟨</mo><mo stretchy="false">⟨</mo><mi>L</mi><mi mathvariant="normal">/</mi><msub><mi>u</mi><mi>n</mi></msub><mo stretchy="false">⟩</mo><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">⟩</mo><mo stretchy="false">}</mo><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mo stretchy="false">(</mo><mi>c</mi><mi>o</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>s</mi><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><mo>∪</mo><mo stretchy="false">{</mo><mo stretchy="false">⟨</mo><mi>L</mi><mo separator="true">,</mo><mn>2</mn><mi>n</mi><mo stretchy="false">⟩</mo><mo stretchy="false">}</mo><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>r</mi><mi>e</mi><mtext> </mtext><mtext> </mtext><mi>g</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>u</mi><mi>l</mi><mi>a</mi><mi>r</mi><mi>i</mi><mi>t</mi><mi>y</mi><mo stretchy="false">)</mo></mspace></mrow><annotation encoding="application/x-tex">A(s)=\{ \langle \langle u_1 \rangle ,2 \rangle,..., \langle \langle u_n \rangle ,2 \rangle \} \quad (subsets) \\ \cup\, \{ \langle \langle L/u_1 \rangle ,n-1 \rangle,..., \langle \langle L/u_n \rangle ,n-1 \rangle \} \,\,\,\, (complements) \\ \cup \{ \langle  L  ,2n \rangle \} (more\,\, granularity)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{⟨⟨</span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">⟩</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mclose">⟩</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">⟨⟨</span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">⟩</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mclose">⟩}</span><span class="mspace" style="margin-right:1em;"></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">b</span><span class="mord mathnormal">se</span><span class="mord mathnormal">t</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∪</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">{⟨⟨</span><span class="mord mathnormal">L</span><span class="mord">/</span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">⟩</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">⟩</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">⟨⟨</span><span class="mord mathnormal">L</span><span class="mord">/</span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">⟩</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">⟩}</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord mathnormal">co</span><span class="mord mathnormal">m</span><span class="mord mathnormal" style="margin-right:0.01968em;">pl</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∪</span><span class="mopen">{⟨</span><span class="mord mathnormal">L</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mord mathnormal">n</span><span class="mclose">⟩}</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">ore</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">an</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span></span></eqn></section> 即<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A(s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span></eq>由当前状态中下一个候选程序和所有粒度对组成</li><li>Transition function:转移函数定义如下,(<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>=</mo><mo stretchy="false">⟨</mo><mi>L</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">⟩</mo><mo separator="true">,</mo><mi>a</mi><mo>=</mo><msup><mi>s</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">s=\langle L,n \rangle,a=s&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⟨</span><span class="mord mathnormal">L</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">⟩</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></eq>) <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><msup><mi>s</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mi mathvariant="normal">∣</mi><mi>s</mi><mo separator="true">,</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(s&#x27;|s,a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0019em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mclose">)</span></span></span></span></eq>定义为<section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><msup><mi>s</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mi mathvariant="normal">∣</mi><mi>s</mi><mo separator="true">,</mo><mi>a</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>i</mi><mi>f</mi><mtext> </mtext><mtext> </mtext><msup><mi>s</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><mo stretchy="false">⟨</mo><msub><mi>u</mi><mi>i</mi></msub><mo separator="true">,</mo><mn>2</mn><mo stretchy="false">⟩</mo><mtext> </mtext><mtext> </mtext><mo separator="true">,</mo><mtext> </mtext><mtext> </mtext><mi>O</mi><mo stretchy="false">(</mo><msub><mi>u</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mi>T</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>i</mi><mi>f</mi><mtext> </mtext><mtext> </mtext><msup><mi>s</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><mo stretchy="false">⟨</mo><mi>L</mi><mi mathvariant="normal">/</mi><msub><mi>u</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">⟩</mo><mtext> </mtext><mtext> </mtext><mo separator="true">,</mo><mtext> </mtext><mtext> </mtext><mi>O</mi><mo stretchy="false">(</mo><mi>L</mi><mi mathvariant="normal">/</mi><msub><mi>u</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mi>T</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>i</mi><mi>f</mi><mtext> </mtext><mtext> </mtext><msup><mi>s</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><mo stretchy="false">⟨</mo><mi>L</mi><mo separator="true">,</mo><mn>2</mn><mi>n</mi><mo stretchy="false">⟩</mo><mtext> </mtext><mtext> </mtext><mo separator="true">,</mo><mtext> </mtext><mtext> </mtext><mi mathvariant="normal">∄</mi><mi>i</mi><mi mathvariant="normal">.</mi><mi>O</mi><mo stretchy="false">(</mo><msub><mi>u</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mi>T</mi><mo>∨</mo><mi>O</mi><mo stretchy="false">(</mo><mi>L</mi><mi mathvariant="normal">/</mi><msub><mi>u</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mi>T</mi><mtext> </mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>o</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi>r</mi><mi>w</mi><mi>i</mi><mi>s</mi><mi>e</mi></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">T(s&#x27;|s,a)=\begin{cases} 1 &amp; if\,\,s&#x27;=\langle u_i,2 \rangle \,\,,\,\,O(u_i)=T \\ 1 &amp; if\,\,s&#x27;=\langle L/u_i,n-1 \rangle \,\,,\,\,O(L/u_i)=T\\ 1 &amp; if\,\,s&#x27;=\langle L,2n \rangle \,\,,\,\, \nexists i. O(u_i)=T \lor O(L/u_i)=T\ \\0 &amp; otherwise \end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0519em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:5.76em;vertical-align:-2.63em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-1.6em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-1.592em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.916em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.8889em" height="0.916em" style="width:0.8889em" viewbox="0 0 888.89 916" preserveaspectratio="xMinYMin"><path d="M384 0 H504 V916 H384z M384 0 H504 V916 H384z"/></svg></span></span><span style="top:-3.15em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.292em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.916em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.8889em" height="0.916em" style="width:0.8889em" viewbox="0 0 888.89 916" preserveaspectratio="xMinYMin"><path d="M384 0 H504 V916 H384z M384 0 H504 V916 H384z"/></svg></span></span><span style="top:-5.2em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.13em;"><span style="top:-5.13em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-0.81em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.63em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.13em;"><span style="top:-5.13em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">⟨</span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mclose">⟩</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">⟨</span><span class="mord mathnormal">L</span><span class="mord">/</span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">⟩</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">L</span><span class="mord">/</span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">⟨</span><span class="mord mathnormal">L</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mord mathnormal">n</span><span class="mclose">⟩</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord amsrm">∄</span><span class="mord mathnormal">i</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">L</span><span class="mord">/</span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace"> </span></span></span><span style="top:-0.81em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">i</span><span class="mord mathnormal">se</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.63em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></eqn></section> 即状态转移仅放生在 下一个候选程序通过属性测试 或 需要更小的粒度时</li><li>Reward function:奖励函数定义如下 <section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mo stretchy="false">⟨</mo><mi>L</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">⟩</mo><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>1</mn><mspace width="1em"><mo stretchy="false">(</mo><mi>L</mi><mtext> </mtext><mtext> </mtext><mi>i</mi><mi>s</mi><mtext> </mtext><mtext> </mtext><mn>1</mn><mo>−</mo><mi>m</mi><mi>i</mi><mi>n</mi><mi>i</mi><mi>m</mi><mi>a</mi><mi>l</mi><mo stretchy="false">)</mo></mspace></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>0</mn><mspace width="1em"><mo stretchy="false">(</mo><mi>o</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi>r</mi><mi>w</mi><mi>i</mi><mi>s</mi><mi>e</mi><mo stretchy="false">)</mo></mspace></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">R( \langle L,n \rangle ) = \begin{cases} 1\quad (L\,\,is\,\,1-minimal) \\ 0\quad (otherwise)\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(⟨</span><span class="mord mathnormal">L</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">⟩)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:1em;"></span><span class="mopen">(</span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">minima</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mclose">)</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">0</span><span class="mspace" style="margin-right:1em;"></span><span class="mopen">(</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">i</span><span class="mord mathnormal">se</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></eqn></section> 即当<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span></eq>是1-minimal时,奖励为1,否则为0</li></ul></li><li><p>解决MDP是不切实际的,为此使用MBRL</p></li><li><p>我们学习了一个概率模型 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">M</mi><mo>:</mo><mi mathvariant="double-struck">P</mi><mo>→</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\mathcal{M}: \mathbb{P} \rightarrow [0,1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">P</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></eq> ,返回候选程序通过属性测试函数的概率 并 从中获得策略</p></li><li><p>我们用 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>T</mi><mo>^</mo></mover><mo separator="true">,</mo><mover accent="true"><mi>R</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{T},\hat{R}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1412em;vertical-align:-0.1944em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9468em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1667em;"><span class="mord">^</span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9468em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1667em;"><span class="mord">^</span></span></span></span></span></span></span></span></span></span></eq>表示<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo separator="true">,</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">T,R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span></eq>的估计,他们的定义和<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">M</mi></mrow><annotation encoding="application/x-tex">\mathcal{M}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal">M</span></span></span></span></eq>而不是<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span></span></span></span></eq>,</p><ul><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>T</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{T}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9468em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9468em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1667em;"><span class="mord">^</span></span></span></span></span></span></span></span></span></span></eq>定义如下 <section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mover accent="true"><mi>T</mi><mo>^</mo></mover><mo stretchy="false">(</mo><msup><mi>s</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mi mathvariant="normal">∣</mi><mi>s</mi><mo separator="true">,</mo><mi>a</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="script">M</mi><mo stretchy="false">(</mo><msub><mi>u</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><msub><mi>K</mi><mrow><mi>s</mi><mo separator="true">,</mo><mi>a</mi></mrow></msub><mspace width="1em"><mo stretchy="false">(</mo><msup><mi>s</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><mo stretchy="false">⟨</mo><msub><mi>u</mi><mi>i</mi></msub><mo separator="true">,</mo><mn>2</mn><mo stretchy="false">⟩</mo><mo stretchy="false">)</mo></mspace></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="script">M</mi><mo stretchy="false">(</mo><mi>L</mi><mi mathvariant="normal">/</mi><msub><mi>u</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><msub><mi>K</mi><mrow><mi>s</mi><mo separator="true">,</mo><mi>a</mi></mrow></msub><mspace width="1em"><mo stretchy="false">(</mo><msup><mi>s</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><mo stretchy="false">⟨</mo><mi>L</mi><mi mathvariant="normal">/</mi><msub><mi>u</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">⟩</mo><mo stretchy="false">)</mo></mspace></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo stretchy="false">(</mo><msub><mo>∏</mo><mrow><mo stretchy="false">⟨</mo><msup><mi>L</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo><msup><mi>n</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">⟩</mo><mo>∈</mo><mi>A</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><msup><mi>s</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow></msub><mn>1</mn><mo>−</mo><mi mathvariant="script">M</mi><mo stretchy="false">(</mo><msup><mi>L</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><msub><mi>K</mi><mrow><mi>s</mi><mo separator="true">,</mo><mi>a</mi></mrow></msub><mspace width="1em"><mo stretchy="false">(</mo><msup><mi>s</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><mo stretchy="false">⟨</mo><mi>L</mi><mo separator="true">,</mo><mn>2</mn><mi>n</mi><mo stretchy="false">⟩</mo><mo separator="true">,</mo><mn>2</mn><mi>n</mi><mo>≤</mo><mi mathvariant="normal">∣</mi><mi>L</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mspace></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>0</mn><mspace width="1em"><mo stretchy="false">(</mo><msup><mi>s</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><mo stretchy="false">⟨</mo><mi>L</mi><mo separator="true">,</mo><mn>2</mn><mi>n</mi><mo stretchy="false">⟩</mo><mo separator="true">,</mo><mn>2</mn><mi>n</mi><mo>≥</mo><mi mathvariant="normal">∣</mi><mi>L</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mspace></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\hat{T}(s&#x27;|s,a) = \begin{cases} \mathcal{M}(u_i)/K_{s,a} \quad (s&#x27; = \langle u_i,2 \rangle) \\ \mathcal{M}(L /u_i)/K_{s,a} \quad (s&#x27; = \langle L/u_i,n-1 \rangle) \\ (\prod_{\langle L&#x27;,n&#x27;\rangle \in A(s)/s&#x27;}1-\mathcal{M}(L&#x27;))/K_{s,a} \quad (s&#x27; = \langle L,2n \rangle,2n\leq|L|) \\ 0 \quad (s&#x27; = \langle L,2n \rangle,2n\geq|L|)\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1968em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9468em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1667em;"><span class="mord">^</span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:5.8027em;vertical-align:-2.6514em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-1.6em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-1.592em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.916em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.8889em" height="0.916em" style="width:0.8889em" viewbox="0 0 888.89 916" preserveaspectratio="xMinYMin"><path d="M384 0 H504 V916 H384z M384 0 H504 V916 H384z"/></svg></span></span><span style="top:-3.15em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.292em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.916em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.8889em" height="0.916em" style="width:0.8889em" viewbox="0 0 888.89 916" preserveaspectratio="xMinYMin"><path d="M384 0 H504 V916 H384z M384 0 H504 V916 H384z"/></svg></span></span><span style="top:-5.2em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.1514em;"><span style="top:-5.1514em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathcal">M</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">/</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">⟨</span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mclose">⟩)</span></span></span><span style="top:-3.7114em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathcal">M</span><span class="mopen">(</span><span class="mord mathnormal">L</span><span class="mord">/</span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">/</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">⟨</span><span class="mord mathnormal">L</span><span class="mord">/</span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">⟩)</span></span></span><span style="top:-2.2714em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mopen">(</span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2253em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">⟨</span><span class="mord mtight"><span class="mord mathnormal mtight">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose mtight">⟩</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight">A</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">s</span><span class="mclose mtight">)</span><span class="mord mtight">/</span><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4747em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathcal">M</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">))</span><span class="mord">/</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">⟨</span><span class="mord mathnormal">L</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mord mathnormal">n</span><span class="mclose">⟩</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">∣</span><span class="mord mathnormal">L</span><span class="mord">∣</span><span class="mclose">)</span></span></span><span style="top:-0.7886em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">0</span><span class="mspace" style="margin-right:1em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">⟨</span><span class="mord mathnormal">L</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mord mathnormal">n</span><span class="mclose">⟩</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">∣</span><span class="mord mathnormal">L</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.6514em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></eqn></section> 其中<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mrow><mi>s</mi><mo separator="true">,</mo><mi>a</mi></mrow></msub></mrow><annotation encoding="application/x-tex">K_{s,a}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></eq>是一个归一化因子,使得<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>T</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{T}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9468em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9468em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1667em;"><span class="mord">^</span></span></span></span></span></span></span></span></span></span></eq>成为一个概率分布<ul><li>前两个例子中,转移概率被定义为子集和他的补集通过质量测试函数的概率</li><li>另外两个例子针对更小的粒度,其概率为,1减去所有子集通过属性测试的概率. 最后如果粒度已经达到最小,则转移概率为0</li></ul></li><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>R</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{R}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9468em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9468em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1667em;"><span class="mord">^</span></span></span></span></span></span></span></span></span></span></eq>定义如下 <section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mover accent="true"><mi>R</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mo stretchy="false">⟨</mo><mi>L</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">⟩</mo><mo stretchy="false">)</mo><mo>=</mo><munder><mo>∏</mo><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi mathvariant="normal">∣</mi><mi>L</mi><mi mathvariant="normal">∣</mi></mrow></munder><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi mathvariant="script">M</mi><mo stretchy="false">(</mo><mi>L</mi><mi mathvariant="normal">/</mi><msub><mi>u</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\hat{R}(\langle L,n\rangle) = \prod_{1\leq i\leq |L|}(1 - \mathcal{M}(L/u_i))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1968em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9468em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1667em;"><span class="mord">^</span></span></span></span></span></span></span><span class="mopen">(⟨</span><span class="mord mathnormal">L</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">⟩)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.566em;vertical-align:-1.516em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.809em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mrel mtight">≤</span><span class="mord mathnormal mtight">i</span><span class="mrel mtight">≤</span><span class="mord mtight">∣</span><span class="mord mathnormal mtight">L</span><span class="mord mtight">∣</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∏</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.516em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal">M</span><span class="mopen">(</span><span class="mord mathnormal">L</span><span class="mord">/</span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">))</span></span></span></span></span></eqn></section> 其中<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">u_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>是<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span></eq>的部分,即<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>R</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mo stretchy="false">⟨</mo><mi>L</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">⟩</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\hat{R}(\langle L,n\rangle)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1968em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9468em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1667em;"><span class="mord">^</span></span></span></span></span></span></span><span class="mopen">(⟨</span><span class="mord mathnormal">L</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">⟩)</span></span></span></span></eq> 表示<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span></eq>在模型<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">M</mi></mrow><annotation encoding="application/x-tex">\mathcal{M}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal">M</span></span></span></span></eq>下为1-minimal的概率</li></ul></li><li><p>最后给定估计的转移和奖励函数 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>T</mi><mo>^</mo></mover><mo separator="true">,</mo><mover accent="true"><mi>R</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{T},\hat{R}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1412em;vertical-align:-0.1944em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9468em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1667em;"><span class="mord">^</span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9468em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1667em;"><span class="mord">^</span></span></span></span></span></span></span></span></span></span></eq>,我们的目标是找到最优策略 <section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mover accent="true"><mi>π</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><mi><munder><mo><mi>a</mi><mi>r</mi><mi>g</mi><mtext> </mtext><mtext> </mtext><mi>m</mi><mi>a</mi><mi>x</mi></mo><mrow><mi>a</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></munder></mi><mi><munder><mo><mo>∑</mo></mo><msup><mi>s</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></munder></mi><mover accent="true"><mi>T</mi><mo>^</mo></mover><mo stretchy="false">(</mo><msup><mi>s</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mi mathvariant="normal">∣</mi><mi>s</mi><mo separator="true">,</mo><mi>a</mi><mo stretchy="false">)</mo><mover accent="true"><mi>V</mi><mo>^</mo></mover><mo stretchy="false">(</mo><msup><mi>s</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mspace width="1em"><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mspace></mrow><annotation encoding="application/x-tex">\hat{\pi}(s) = \underset{a\in A(s)}{arg\,\, max}\underset{s&#x27;}{\sum} \hat{T}(s&#x27;|s,a) \hat{V}(s&#x27;) \quad (1) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.344em;vertical-align:-1.294em;"></span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.4306em;"><span style="top:-2.1146em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight">A</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">s</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop"><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.1604em;"><span></span></span></span></span></span></span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.856em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op" style="position:relative;top:0em;">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.294em;"><span></span></span></span></span></span></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9468em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1667em;"><span class="mord">^</span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mclose">)</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9468em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:1em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></eqn></section> 其中 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>V</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{V}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9468em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9468em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span></span></span></span></span></span></span></eq> 是在策略 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>π</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{\pi}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span></span></span></span></span></span></span></eq>下的期望价值和,其定义如下 <section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mover accent="true"><mi>V</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><mover accent="true"><mi>R</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>+</mo><mi>γ</mi><mi><munder><mo><mo>∑</mo></mo><msup><mi>s</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></munder></mi><mover accent="true"><mi>T</mi><mo>^</mo></mover><mo stretchy="false">(</mo><msup><mi>s</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mi mathvariant="normal">∣</mi><mi>s</mi><mo separator="true">,</mo><mover accent="true"><mi>π</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mover accent="true"><mi>V</mi><mo>^</mo></mover><mo stretchy="false">(</mo><msup><mi>s</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mspace width="1em"><mo stretchy="false">(</mo><mn>0</mn><mo>≤</mo><mi>γ</mi><mo>≤</mo><mn>1</mn><mo stretchy="false">)</mo><mspace width="1em"><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mspace></mspace></mrow><annotation encoding="application/x-tex"> \hat{V}(s) = \hat{R}(s) + \gamma \underset{s&#x27;}{\sum} \hat{T}(s&#x27;|s,\hat{\pi}(s)) \hat{V}(s&#x27;) \quad (0\leq \gamma \leq 1) \quad (2) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1968em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9468em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1968em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9468em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1667em;"><span class="mord">^</span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.344em;vertical-align:-1.294em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.856em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op" style="position:relative;top:0em;">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.294em;"><span></span></span></span></span></span></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9468em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1667em;"><span class="mord">^</span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">))</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9468em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:1em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:1em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span></eqn></section> 其中 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>V</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{V}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9468em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9468em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span></span></span></span></span></span></span></eq> 可以通过动态规划获得.</p><ul><li>根据该策略,由行为导致的状态转移和奖励 为被用于 改进估计值,这将继续优化政策.</li><li>在我们的评估中,我们发现当 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\gamma = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></eq> 时 效果最好(即仅考虑即时奖励)</li></ul></li></ul><h3 id="4.3-%E9%9D%99%E6%80%81%E6%A8%A1%E5%9E%8B" tabindex="-1">4.3 静态模型</h3><p>我们描述了如何学习上述模型。我们的目标是使用该模型来预测给定程序 $ P $ 的 $ O§ $ 的概率。我们从程序去膨胀过程中收集的数据中学习模型。</p><ul><li><p><strong>特征表示</strong>:假设一个程序由 $ n $ 个元素组成 $ \langle u_1,…u_n \rangle $ , 每个 $ P $ 的子程序 $ P’ $ 被特点编码函数 $ F $ 编码成一个长度为 $ n $ 的二进制向量 <section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><msup><mi>P</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">⟨</mo><msub><mi>b</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>b</mi><mi>n</mi></msub><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex"> F(P&#x27;) = \langle b_1,...,b_n \rangle </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0519em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⟨</span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">⟩</span></span></span></span></span></eqn></section> 其中 $ b_i = 1 $ 当且仅当 $ u_i \in P’ $,否则 $ b_i = 0 $.</p></li><li><p><strong>数据标记</strong>:每个特征向量被一个布尔值标记 $ \mathcal{O}§ $ ,表示该程序是否通过属性测试. 每个标记数据在DD过程中每次实验中进行收集</p></li><li><p><strong>模型学习</strong>:使用现成的监督学习模型如决策树,该算法在DD过程中说及特征向量和标记. 该模型可以预测 对于一个给定的特征向量 $ P $ 预测其标记 $ \mathcal{O}§ $ . 通过将 $ \mathcal{O} $ 替换为 $ \mathcal{M} $ , 我们可以定义近似版本的 $ \hat{T} , \hat{R}$</p></li></ul><h3 id="4.4-%E5%9F%BA%E4%BA%8E%E5%AD%A6%E4%B9%A0%E7%9A%84%E7%A8%8B%E5%BA%8Fdebloating" tabindex="-1">4.4 基于学习的程序Debloating</h3><ul><li>现在正式说明我们的方法<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(3)_5.png" alt></li><li>入参:<ul><li><ol><li>原始程序 $ P $ 和属性测试函数 $ O $</li></ol></li><li><ol start="2"><li>一个现成的监督学习方法 $ \mathcal{L} $ ,用于学习模型</li></ol></li><li><ol start="3"><li>一个特征编码函数 $ F $ ,用于将程序编码为特征向量</li></ol></li></ul></li><li>算法解析<ul><li>第2行,状态 $ s $ 初始化为原始程序</li><li>第3行,数据集 $ D $ 初始化为 原始程序的特征向量和其标签(T) 的二元组</li><li>第4-13行为主循环,直至程序不能再分割<ul><li>第5行更新数据集</li><li>第6行计算当前模型得到的策略</li><li>第7行根据策略选择下一个状态</li><li>第8行检查属性测试是否通过</li><li>第9行:当前状态通过属性测试 或 需要更细粒度划分程序的时候,改变当前状态,</li><li>第12行:属性测试结果添加到数据集中</li></ul></li></ul></li></ul><h2 id="5-%E8%AF%84%E4%BC%B0" tabindex="-1">5 评估</h2><ul><li><strong>Q1. Effectiveness</strong>:debloating的质量和时间</li><li><strong>Q2. Security</strong>:是否移除的缺陷和攻击面的减少</li><li><strong>Q3. Robustness</strong>:对未见过输入的鲁棒性</li></ul><h3 id="5.1-%E5%AE%9E%E9%AA%8C%E8%AE%BE%E7%BD%AE" tabindex="-1">5.1 实验设置</h3><ul><li><strong>实施</strong>:<ul><li>我们将Chisel作为C程序的简化器,采用了基于语法引导的分层增量调试法(Delta-Debugging)<ul><li>Chisel首先使用标准的增量调试法简化全局级组件(全局变量声明,类型定义,函数定义等)</li><li>随后递归的再局部级组件(赋值,循环体,条件语句等)</li><li>局部级简化完成或,Chisel重新调用全局级简化，并继续整个过程直到找到一个最小版本</li><li>同时,Chisel通过简单的依赖分析,拒接无用的程序(如缺失主函数等)</li></ul></li><li>Chisel由2361行OCaml代码组成。我们使用FastDT3的现成决策树算法来学习模型。我们使用精确的决策树（即不使用提升/袋装法，也不限制树的最大深度）。所有实验在3.0 GHz和128 GB内存的Linux机器上进行</li></ul></li><li><strong>基准 Benchmarks</strong><ul><li>使用GNU软件包中的10个基准程序来评估Chisel,</li><li>下表展示了这些程序的特征</li><li>且这些程序均为开源且广泛应用</li><li>每个都有一个或多个已知的安全漏洞CVE</li><li>并且有人工缩减的版本,可以在BusyBox中找到</li></ul></li><li><strong>规范</strong><ul><li>期望保留的功能参考了BusyBox的实现,我们假设BusyBox默认配置支持的选项是每个程序的核心功能</li><li>处于安全考虑,我们强制简化的程序在执行非核心功能程序时不产生任何未定义的行为(不仅是崩溃),例如缓冲区溢出或使用未初始化的变量</li><li>为此,我们使用Clang的sanitizer选项[4]编译程序在运行时监视未定义的行为</li><li>为了广泛的测试所有功能,我们从源代码仓库收集了测试用例</li><li>总的来说,Chisel生成的简化版本的程序满足以下限制<ul><li><ol><li>可以编译</li></ol></li><li><ol start="2"><li>与原始程序相比在核心功能上有着相同的输出</li></ol></li><li><ol start="3"><li>在执行非核心功能时不会产生未定义的行为</li></ol></li></ul></li><li>此外,为每次运行设置时间限制,防止由Chisel引入的无限循环的程序</li></ul></li><li><strong>基线化简器</strong>:C-REDUCE 和 PERSES</li></ul><h3 id="5.2-%E7%AE%80%E5%8C%96%E7%9A%84%E6%95%88%E7%8E%87" tabindex="-1">5.2 简化的效率</h3><ul><li><ol><li>简化大小</li></ol><ul><li>使用以下三种情况进行比较<ul><li>原始程序</li><li>基于静态分析 Sparrow [13] 删除未使用的代码: statements 从 172,304 到 55,848 (32.4%) (因为Unix实用程序有公共库)</li><li>Chisel:减少89.1%,只剩6111</li></ul></li></ul></li><li><ol start="2"><li>与现有方法比较运行时间</li></ol><ul><li>Chisel在12h内完成简化,因其不仅避免了语法错误,也学习去避免了语义错误</li><li>C-REDUCE超时6个,因其是基于行的简化器</li><li>PERSES超时2个,因其是一个纯粹的基于语法的简化器</li></ul></li><li><ol start="3"><li>与BusyBox中的人工简化版本比较</li></ol><ul><li>BusyBox为一个单一的可执行程序,通过子命令调用所有工具</li><li>BusyBox有7个程序比Chisel生成的程序更小,但这主要因为人工可以使用更优化的代码和数据结构,总的来说,Chisel生成的代码大小合理</li></ul></li><li><ol start="4"><li>Chisel比现有方法产生的程序更自然,使得人可以维护和扩展,同时保留了原始结构 和 软件工程实践(如模块化和局部化)</li></ol></li><li><ol start="5"><li>与Cov进行比较,证明Chisel的必要,覆盖率使用llvm-cov [11]计算,结果如下图示,结果显示Chisel可以比朴素的Cov方法显著的减少更多的代码<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(3)_7.png" alt></li></ol></li></ul><h3 id="5.3-%E5%AE%89%E5%85%A8%E5%A2%9E%E5%BC%BA" tabindex="-1">5.3 安全增强</h3><ol><li>首先检查简化后程序,查看Chisel是否已经去除已知的露铜</li><li>计算原始程序和简化程序的gadgets数量衡量攻击面的减少,这里使用ROP-gadget[12]工具</li><li>使用SOTA静态缓冲区溢出分析器Sparrow [13],检查所有报告的警报</li></ol><p><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(3)_8.png" alt></p><ul><li>结果展示如上图<ul><li><ol><li>Chisel 去除了10个程序中6个的CVEs</li></ol></li><li><ol start="2"><li>去除了潜在的攻击面,具体而言平均减少了 66.2%的ROP gadgets</li></ol></li><li><ol start="3"><li>减少了95.4%的缓冲区溢出警报,剩下的警报较少进行手动检查后确认是假警报</li></ol></li></ul></li></ul><h3 id="5.4-%E9%B2%81%E6%A3%92%E6%80%A7" tabindex="-1">5.4 鲁棒性</h3><ul><li>通过SOTA 模糊器 AFL,生成随机的命令行输入 和 必要的输入文件进行测试,实验进行了三天</li></ul><ol><li>大多数情况下,Chisel生成的程序在测试中表现良好,模型测试没有检测到崩溃.此外,由于有sanitizer的保护,Chisel生成程序时有效的过滤掉了错误的程序</li><li>然而在未见过的输入可能会出现错误.<ul><li>根据我们的经验,随机模糊测试可以丰富测试脚本生成更健壮的程序:将使得简化后程序崩溃的模糊测试生成样例加入到测试脚本中,并重新运行Chisel和模糊测试,程序健壮性进一步提升,接下来3天内模糊器没有发生崩溃</li></ul></li></ol><h2 id="6-%E5%AF%B9%E6%9C%89%E6%95%88%E6%80%A7%E7%9A%84%E5%A8%81%E8%83%81" tabindex="-1">6 对有效性的威胁</h2><ol><li>Chisel可能会因为<strong>测试脚本返回不确定</strong>的结果而出错.<ul><li>主要有未定义的行为引起,我们可以使用sanitizer来过滤这些有问题的程序,但如果目标程序使用了未受相同保护方案编译外部库,则无法过滤. 如果外部库是开源的话可以通过再编译进行解决</li><li>另一个原因是我们避免了 不能终止的程序 产生,因为简化可能导致不能终止(如去除了循环语句的终止条件),为此我们设置了时间限制. 然而如果限制不够大,测试脚本可能返回不能确定的结果.这个问题可以通过动态监测和躲避无限循环解决</li></ul></li><li><strong>测试用例不够完备</strong><ul><li>我们使用AFL模糊测试工具对生成的程序进行了鲁棒性测试。然而，如果输入需要符合特定的格式，我们的测试可能不够全面，因为我们无法向AFL提供特定的语法，使其能够通过过滤不合法的测试输入来剪枝搜索空间。</li><li>为了解决这个问题，我们可以使用基于语法的模糊测试工具[25, 44]。</li></ul></li><li><strong>静态分析的不确定性</strong><ul><li>我们使用Sparrow静态分析器与AFL一起测试鲁棒性。尽管该分析器对于大多数C程序功能是准确的，但如果目标程序具有复杂的指针算术操作或由未知语义的API函数引起的复杂控制流程，则可能会存在不确定性。</li><li>在实践中，由于设计一个完全准确的静态分析器极其具有挑战性，因此会使用对于不同语言功能而言是准确的各种静态分析工具[31]。在此方面，我们可以通过结合多个具有不同功能的静态分析器的结果来缓解这个问题。</li></ul></li></ol><h2 id="7-%E7%9B%B8%E5%85%B3%E5%B7%A5%E4%BD%9C" tabindex="-1">7 相关工作</h2><ul><li><strong>程序Debloating</strong>:现在有很多在不同粒度缓解软件膨胀的技术<ul><li>coarse-grained(大粒度级,如应用级)<ul><li>例子:Rastogi et al. [35] 容器级别 Docker. 可以根据用户的限制将一个复杂容器分成多个简单的小容器,其方法基于动态分析获取应用的信息</li></ul></li><li>finer-grained(小粒度级)<ul><li>JRed [28] 和 RedDroid [27] 去除了Java和Android应用中的未使用的类和方法</li><li>Quach et al. [34] 提出了一个简化系统 ,在编译和加载中去除不必要的代码,其系统通过静态分析和基于训练的技术计算函数依赖来简化应用和库</li></ul></li><li>与之前方法比较,Chisel可以再更细的粒度进行简化,如语句级别. 现有的小粒度的方法基于静态分析只能去除不用的代码,而Chisel很激进甚至可以出去在运行路径上的代码</li><li><strong>程序膨胀检查</strong><ul><li>Bhattacharya等人[19]介绍了一种分析技术，用于检测Java应用程序中可能的膨胀源;我们的方法自动删除相对于属性测试程序的冗余代码</li></ul></li><li><strong>监测和减少运行时内存膨胀</strong><ul><li>这与程序debloating正交但互补,因为程序debloating可能潜在缓解这一问题通过移除运行路径上的代码</li></ul></li></ul></li><li><strong>测试输入最小化</strong><ul><li>目前很多简化程序的方法都是 最小化使得编译器或解释器不会崩溃的程序,由于其不关注简化后的代码是否可以运行或维护,最后产生的代码安全性和可读性都很差. 例如C-REDUCE不能维护程序的软件工程时间,而我们的目标是开发人员可以后续使用的精简程序</li><li>现有的方法仅通过简单的指导来搜寻最小的程序.最近出现了能够识别程序<em>语法结构</em>的方法,这种先验知识可以避免很多语法错误的程序的尝试,但不能从<em>语义</em>上避免错误.我们的系统通过构建静态模型避免了语义上错误的尝试. 同时,我们的方法可以加速现有的所有方法,包括又非结构化输入的增量调试法</li></ul></li><li><strong>程序切片和可达性分析</strong><ul><li>切片是从程序中提取的与某个感兴趣点的值相关的子部分,通常由静态分析和动态分析得出. 我们的方法旨在更一般的属性并且不需要特定的语义和依赖分析,且我们的方法可以获得比程序切片更小的程序</li><li>在我们的实验中，我们与可达性分析相比较，而不是使用切片技术，原因如下。<ul><li>动态切片包含了在程序的特定执行下影响目标变量值的所有语句。然而，从高级规范中确定感兴趣的变量和程序点可能是具有挑战性的。即使用户手动注释这些目标，动态切片对于程序精简可能仍然效果不佳。例如，“safer_name_suffix” 的输出实际上取决于函数中的大部分语句。因此，与 Chisel（相比，动态切片无法消除漏洞。</li></ul></li><li>静态可达性计算通常会因为静态分析的不可判定性而产生对实际可达代码的不精确近似。<ul><li>通常无法有效处理复杂的控制流，例如间接过程调用（如 setjmp / longjmp，函数指针或反射）、复杂的条件语句和指针算术。</li><li>而我们的方法不受这些问题的限制。动态可达性计算在代码大小方面可能比静态方法更有效。然而，我们的研究表明，我们的方法产生的程序比基于动态可达性的程序具有更小的攻击面</li></ul></li></ul></li></ul><h2 id="8-%E7%BB%93%E8%AE%BA" tabindex="-1">8 结论</h2><ul><li><p>我们提出了Chisel, 一种基于 增量调试法的学习系统,用于程序debloating</p><ul><li>我们的方法通过给定的测试脚本高效地简化程序</li><li>学习到的概率模型加速找到最小程序的速度</li><li>此外这种精简方法除去了一些漏洞,并显著减少了潜在的攻击面</li><li>此外,简化获得的 程序大小和复杂度 运行更进一步应用精确的推理方法和人工检查</li></ul></li><li><p>在未来,计划在以下方向扩展Chisel</p><ul><li><ol><li>探索更好的概率模型和高效的增量学习方法</li></ol></li><li><ol start="2"><li>设计除 IO 之外的其它规范</li></ol></li><li><ol start="3"><li>应用于简化二进制等其它语言的方法</li></ol></li></ul></li></ul><h2 id="9-%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93" tabindex="-1">9 阅读总结</h2><ul><li>Chisel:使用强化学习框架辅助增量调试法来进行程序去膨胀</li><li>问题:<ul><li><ol><li>需要用户提供属性测试函数,很麻烦的</li></ol></li><li><ol start="2"><li>增量调试法很慢的,套上强化学习更慢了</li></ol></li><li><ol start="3"><li>删除的代码取决于输入,并且只会删除代码,因为使用的是增量调试法</li></ol></li></ul></li></ul><h2 id="10-%E5%A4%8D%E7%8E%B0" tabindex="-1">10 复现</h2><ul><li><p>在win11上使用ubuntu20.04虚拟机</p><ul><li>直接下载源码,编译运行,运行失败,应该是新版被不兼容旧版本的问题</li><li>于是在虚拟机上使用docker,在docker上跑chisel,最小的gzip跑了14h(</li></ul></li><li><p>结论:很慢的,之后也不用跑了,感受下效果练练手就行了</p></li></ul><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(3)_x.png&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;effective-program-debloating-</summary>
      
    
    
    
    <category term="论文" scheme="http://example.com/categories/%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="SoftwareEngineering" scheme="http://example.com/tags/SoftwareEngineering/"/>
    
    <category term="SoftwareDebloating" scheme="http://example.com/tags/SoftwareDebloating/"/>
    
  </entry>
  
  <entry>
    <title>Software Debloating 论文阅读 (2)</title>
    <link href="http://example.com/2024/01/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/SoftwareDebloating/Software%20Debloating%20%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB(2)/"/>
    <id>http://example.com/2024/01/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/SoftwareDebloating/Software%20Debloating%20%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB(2)/</id>
    <published>2024-01-15T07:10:43.880Z</published>
    <updated>2024-01-15T07:10:43.880Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2.-sok%3A-a-tale-of-reduction%2C-security%2C-and-correctness---evaluating-program-debloating-paradigms-and-their-compositions" tabindex="-1">2. SoK: A Tale of Reduction, Security, and Correctness - Evaluating Program Debloating Paradigms and Their Compositions</h2><p>ESORICS 2023 - 28th European Symposium on Research in Computer Security, Lecture Notes in Computer Science, Springer, 2023.(CCF B)</p><p>Ali M, Muzammil M, Karim F, et al. SoK: A Tale of Reduction, Security, and Correctness-Evaluating Program Debloating Paradigms and Their Compositions[J]. Computer Security–ESORICS 2023, 2023.</p><h3 id="0-%E6%91%98%E8%A6%81" tabindex="-1">0 摘要</h3><ul><li>本文提出 DebloatBencha,一个可以 扩展的,可持续的 基准平台,可以比较方法间的不同</li><li>然后,对现阶段的技术进行了一个全面的比较</li><li>我们整合了4种不同的方法进行比较,揭漏了其中的一些隐秘<ul><li>基于源程序的</li><li>基于编译器的中间表示</li><li>基于运行时的二进制代码</li><li>基于外部库的</li></ul></li><li>同时我们也将一些方法进行了结合,发现了一些方法组合起来的效果((e.g., Chisel-Occam, Chisel-Occam-Razor)优于单独实用的效果</li></ul><h3 id="1-%E4%BB%8B%E7%BB%8D" tabindex="-1">1 介绍</h3><ul><li><p>当前去膨胀方法遇到的挑战:不能合适地去评估正确性和表现,首要的原因是缺乏一个基准平台,由此简历多样化的分析工具的路径变得不清晰且代价高昂</p></li><li><p><strong>评估平台</strong>:设计DEBLOATBENCHA基准框架,来评估目标程序是C/C++ 的去膨胀方法,因为C/C++ 使用范围广且攻击面多</p><ul><li>当前平台集成了一组软件去膨胀研究,代表了四种类别:Chisel(源代码),Occam（编译器中间表示）,Razor（可执行二进制文件）和Piece-wise（外部库）</li><li>当前目标程序套件包括10个来自ChiselBencha的实用程序,3个基于GUI(graphical user interface)的程序和2个面向网络的程序</li><li>该平台提供易于使用的命令行接口来运行不同的去膨胀工具</li><li>同时平台设计有可定制性和可扩展性</li></ul></li><li><p><strong>评估去膨胀方法</strong>:对 继承在评估平台的4种方法进行了全面的研究,具体而言,检查了由去膨胀方法生成的二进制文件的正确性,内存使用量,磁盘大小,安全相关的代码片段,运行时间的变化,我们发现</p><ul><li>基于静态分析的方法(Occam,PECEC-WISE)通过了所有测试</li><li>使用动态分析的方法(Chisel,Razor)的二进制文件随着去膨胀程度的增加失败的测试越多</li><li>CHisel对非核心工具程序无法产生二进制文件,RAZOR也在3个非核心工具程序无法产生二进制文件,这表明测试驱动的去膨胀器在处理GUI和网络编程的程序中存在限制</li><li>此外,四个工具中有三个运行很快,可以集成到软件阶段工作流中,我们创建了首种将多个工具组合来应用到单个二进制文件的方法,根据我们实验证明,这种组合可在某些方面达到很好的效果</li></ul></li><li><p>在平台的开发和方法评估中,我们同时也修复报告了一些bug,并提出了一些改进方法</p></li><li><p>我们的贡献总结</p><ul><li><ol><li>开发了一种易于扩展的框架 DebloatBenchA ,来评估去膨胀算法.为 目标程序套件(10个来自ChiselBencha的实用程序,3个基于GUI(graphical user interface)的程序和2个面向网络的程序) 创建了82个变体来进行鲁棒性测试. 在该框架中集成了4种不同类型的方法,目前正在开源中</li></ol></li><li><ol start="2"><li>对4种方法进行了全面的评估,发现了一些隐秘,并提出了一些改进方法</li></ol></li><li><ol start="3"><li>利用多个去膨胀方法的优势,提出了一种组合分析方法,经过评估显示优于单个方法</li></ol></li></ul></li></ul><h3 id="2-%E5%8E%BB%E8%86%A8%E8%83%80%E7%AE%97%E6%B3%95" tabindex="-1">2 去膨胀算法</h3><ul><li>DebloatBencha支持应用级和库级别的去膨胀,因为评估内核级的去膨胀需要与  应用级和库级别 不同的机制,故暂不考虑.下表总结了各种应用程序和库级别的程序去膨胀方法<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(1)_2_1.png" alt></li></ul><h4 id="2.1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%BA%A7%E5%88%AB%E7%9A%84%E5%8E%BB%E8%86%A8%E8%83%80" tabindex="-1">2.1 应用程序级别的去膨胀</h4><ul><li>应用程序级的去膨胀器可以分为三类<ul><li>源代码级:包括Chisel,C-Reduce,Perses,大部分源代码级的方法使用delta调试算法的变体进行去膨胀.delta调试算法(Delta-debugging)使用一个测试集来涵盖去膨胀后程序拥有行为,但会导致过拟合.<ul><li>根据辛等人论文所说,Chisel在简化程度上表现最佳,因此,我们选择了Chisel作为源代码级的去膨胀器代表</li></ul></li><li>中间代码级:该级别工具的操作作用在LLVM位码上,使用部分求值法对代码进行缩减.<ul><li>例子:OCCAM算法,该算法结合部分求值和类型理论来移除不必要的代码,支持多趟跨模型分析</li><li>由于OCCAM是唯一开源的支持自动化分析的工具,所以我们选择其为中间代码级别的代表</li></ul></li><li>二进制代码级:该级别方法依赖于执行跟踪,由选择的测试用例(RAZOR)或模糊测试(Ancile)触发<ul><li>例子:Razor运行二进制代码在测试用例上,然后使用 Tracer来收集运行踪迹,然后解码踪迹,用执行过的指令来构建程序的CFG(Control Flow Graph 控制流图),Ancile还需要一组测试用例来作为模糊器的种子</li><li>因为Razor是开源的,所以我们选择其为二进制代码级的代表</li></ul></li></ul></li></ul><h4 id="2.2-%E5%BA%93%E7%BA%A7%E5%88%AB%E7%9A%84%E5%8E%BB%E8%86%A8%E8%83%80" tabindex="-1">2.2 库级别的去膨胀</h4><ul><li>库级别的去膨胀器可以分为三种:<ul><li>(1) 静态时:给定一组应用,静态去膨胀器会静态的环境下对动态链接库进行去膨胀,从而永久替代原始的库集合(e.g. Nibbler)</li><li>(2) 加载时:在将目标库加载到内存时对函数进行去膨胀(RIECE-WISE)</li><li>(3) 运行时:仅在运行时加载需要的函数(BlankIt)</li></ul></li><li>由于PIECE_WISE是开源的,所以我们选择其为库级别的代表</li></ul><h3 id="3-debloatbencha%E6%A1%86%E6%9E%B6%E7%9A%84%E7%BB%84%E6%88%90" tabindex="-1">3 DebloatBencha框架的组成</h3><p><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(1)_2_2.png" alt></p><ul><li><p>框架架构如上图.</p><ul><li>设计遵循了 开闭原则(Open-Close Principle),即对扩展开放,对修改关闭,以确保更好的可扩展性和可维护性</li><li>基于容器的方式来构建建构以隔离不同方法使用的环境,并为每个方法构建相应容器</li><li>使用基于命令行工具的管理系统(称为编排器)来构建和管理这些容器的生命周期</li><li>框架中的每个输入程序都有一个相关的配置文件描述其各种元数据(例如 测试样例位置,构建信息)</li><li>由于不同的程序使用不同的专有程序输入,为每个容器提供一个适配器将程序输入转换为框架自己的格式</li></ul></li><li><p>框架组成,主要有三部分:(1)输入程序(2)去膨胀工具(3)编排器和测量脚本.</p><ul><li>输入程序,编排器和测量脚本位于主机种,去膨胀工具和适配器位于容器中</li></ul></li></ul><h4 id="%E5%8E%BB%E8%86%A8%E8%83%80%E5%B7%A5%E5%85%B7" tabindex="-1">去膨胀工具</h4><ul><li>在框架中的每个去膨胀工具通过容器创建</li><li>框架使用一个配置文件收集与一个程序相关的输入</li><li>同时创建了一个脚本来解析配置文件并且为每个工具生成各自的输出,该脚本称为 适配器脚本,该脚本将工具和框架链接起来</li></ul><h4 id="%E7%9B%AE%E6%A0%87%E7%A8%8B%E5%BA%8F%E5%A5%97%E4%BB%B6" tabindex="-1">目标程序套件</h4><ul><li>从ChiselBencha中选择了10个实用程序,为了评估通用性,选择3个GUI程序和2个网络程序,作为目标程序套件</li><li>为了捕捉多样性,我们为每个应用选择多样性的部署上下文. 我们将一个目标程序和其特定的部署上下文称为一个变体</li><li>下表总结了完成工作负载的82个变体<br><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(1)_2_3.png" alt></li></ul><h4 id="%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B" tabindex="-1">测试用例</h4><ul><li>测试用例的数量影响基于测试用例去膨胀工具的训练时间,因此选择高质量的测试用例来最大化覆盖同时不影响性能很重要.</li><li>给定一个应用的运行配置,生成其高质量的测试用例是一个活跃的研究领域.但这个问题是一个正交问题(指与当前讨论的问题或主题无关的问题),这种自动化超出了本文的范围,因此我们使用人工创造的测试用例.</li><li>在准备这些测试用例时,我们的目标是捕捉多样化行为来最大化覆盖范围</li></ul><h4 id="%E6%B5%8B%E9%87%8F%E8%84%9A%E6%9C%AC" tabindex="-1">测量脚本</h4><ul><li>通过以下五个指标衡量 (?哪有五个)<ul><li><ol><li>去膨胀后二进制文件的正确性</li></ol></li><li><ol start="2"><li>二进制文件大小的减少</li></ol></li><li><ol start="3"><li>从 gadgets 减少的角度进行安全性分析</li></ol></li><li><ol start="4"><li>去膨胀时间</li></ol></li></ul></li><li>没有使用 CVE 进行安全评估，主要是因为与功能相关。消除它们更可能受到功能选择的影响，而不是工具本身。</li></ul><h4 id="%E5%86%85%E5%AD%98gadget%E8%AE%A1%E6%95%B0" tabindex="-1">内存gadget计数</h4><ul><li>PIECE-WISE 在 外部库 加载进入内存时 以 函数为单位 对其进行简化,然后我们使用gdb来寻找在内存中简化版本库中缺失的函数.在收集到信息后,我们通过用NOPS替换确实的函数体来创建一个新版本的库.最后我们使用个版本的库使用ROPgadget工具来收集ROP gadgets</li></ul><h3 id="4-debloatbencha-%E7%9A%84%E5%AE%9E%E9%AA%8C%E9%85%8D%E7%BD%AE" tabindex="-1">4 DebloatBenchA 的实验配置</h3><ul><li>集成4种去膨胀工具</li><li>我们进行了两组实验，以测量独立工具和它们的组合的性能。</li><li>最后，我们讨论了用于比较性能的指标。</li></ul><h4 id="4.1-%E7%8B%AC%E7%AB%8B%E6%A8%A1%E5%BC%8F" tabindex="-1">4.1 独立模式</h4><ul><li>CHISEL配置:从Chisel的作者那里，我们了解到CIL [34]用于合并较早版本的Chisel中输入程序的C文件。为了成功运行Chisel，我们重新使用了来自ChiselBench的10个coreutils程序的合并C文件。对于其他5个大型程序，我们利用了其构建系统集成功能。</li><li>OCCAM配置:OCCAM支持很多策略来简化二进制文件,每个策略都会产生不同的简化程度,从激进到没有特征化.运行一个有效性检查的试验来找到最佳配置,我们选择 the onlyonce(最佳配置) 来衡量比较OCCAM性能</li><li>RAZOR配置:RAZOR的性能取决于Pathfinder模块所使用的启发式方法的选择.由于RAZOR运行的比其它程序块,我们为每种启发式方法创建了多个版本的二进制文件,从中选择正确率最高的版本进行性能分析和与其它工具的比较</li><li>PIECE-WISE配置:首先使用了Docker容器提供的预构建编译器和加载器.我们使用 musl-libc v1.1.15 作为我们程序套件中每个输入程序的依赖库.然后,我们使用 PIECE-WISE 的对依赖库进行简化. 为了对比,我们要创建非PIECE-WISE编译的二进制文件,我们使用PIECE-WISE仓库提供的同样的Docker容器,同时下载未经修改的LLVM和Clang以及musl-libc,并与之前PIECE-WISE使用的版本相同</li></ul><h4 id="4.2-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F" tabindex="-1">4.2 组合模式</h4><ul><li>因为不同方法在不同程序代码级别运行,所以可以将多种方法运用到同一个程序上,例如CHISEL在源代码级别进行简化,然后产生的二进制用RAZOR进行进一步简化,依据这一思想,我们构思了4种工具的组合来对框架的输入程序组进行简化<ul><li><ol><li>Chisel-Occam</li></ol></li><li><ol start="2"><li>Chisel-Occam-Razor</li></ol></li><li><ol start="3"><li>Chisel-Razor</li></ol></li><li><ol start="4"><li>Occam-Razor</li></ol></li></ul></li><li>因为PIECE-WISE需要同时在源代码和二进制上进行简化,所以其只能与CHISEL进行组合,我们尝试了其组合,但效果有限</li><li>对于给定的指标,我们将 组合方法的性能 和 单个工具的最优情况 进行比较</li></ul><h3 id="5-%E5%8E%BB%E8%86%A8%E8%83%80%E5%99%A8%E7%9A%84%E8%AF%84%E4%BC%B0" tabindex="-1">5 去膨胀器的评估</h3><ul><li>研究问题<ul><li>RQ1:去膨胀方法是否会对目标应用程序的正确性产生负面影响？</li><li>RQ2:在简化单个程序大小规模时各方法的效果如何?</li><li>RQ3:简化程序对程序 gadget相关安全性有何影响?</li><li>RQ4:实际中,各简化程序的使用性如何</li><li>RQ5:组合多个 去膨胀方法是否有进一步的提升</li></ul></li></ul><h4 id="5.1-%E5%9C%A810%E4%B8%AA-utilcore%E7%A8%8B%E5%BA%8F%E4%B8%8A%E7%9A%84%E8%AF%84%E4%BC%B0" tabindex="-1">5.1 在10个 utilcore程序上的评估</h4><ul><li><p><strong>RQ1:工具正确性</strong>:首先使用测试用例评估 去膨胀器的正确性,总是会高估正确性,因为测试用例可能无法覆盖全部情况</p><ul><li><ol><li>下图表示了各方法的正确度 <img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(1)_2_4.png" alt></li></ol><ul><li>基于静态分析的方法,OCCAM和PIECE-WISE通过了全部测试用例</li><li>基于动态分析的方法,CHISEL和RAZOR通过了大部分测试用例</li><li>OCCAM的正确性最好因为他的静态部分求职方法保守地保留了给定参数地所有功能.CHISEL表现不好因为其过度依赖于给定的测试脚本</li></ul></li><li><ol start="2"><li>下图表示了方法随训练数据的变化正确度的变化:可以看出随着训练数据的增多,正确性在增加<img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(1)_2_5.png" alt></li></ol></li></ul></li><li><p><strong>RQ2:大小简化程度</strong>:去膨胀一个目标应用程序就是通过在一个特定地部署环境下删除不用的代码来减小其大小,其效果体现在磁盘中二进制文件的大小,各方法表现如下图所示(图中减少百分比为正表示二进制文件变小程度)</p><ul><li><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(1)_2_6.png" alt></li><li>CHISEL在源代码中简化,可以减少二进制代码大小,增加训练量有时会增加代码大小</li><li>OCCAM在中间代码中简化,可以减少二进制代码大小,由于OCCAM的部分求值方法可能会增加函数的数量,有时会增加代码大小</li><li>RAZOR保留原始二进制代码并使用转换后的代码扩充它</li><li>PIECE-WISE将表示程序控制流图的元数据添加到二进制文件中</li></ul></li><li><p><strong>RQ3:Gadget 的表现</strong>: 原始ROP gadget数量和代码大小并不是评估二进制文件漏洞的可靠指标.[14, 15]。Homescu等人[24]认为，gadget可以根据提供的功能类型进行分类，每个类别只需要一个成员即可用于特定类别的攻击。他们构造了“micro-gadgets”类别（限制为最大长度为3字节），这些gadget提供了每个类别的基础。我们报告了去bloating对ASLR-proof和Turing-complete表达能力的两个类别中的变化的影响。如下图示</p><ul><li><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(1)_2_7.png" alt></li><li>在两种类别中,CHISEL有着最高的减少程度</li><li>在Turing-complete中,OCCAM比RAZOR有效,而在ASLR-proof中,RAZOR比OCCAM有效</li><li>而PIECE-WISE在这两个类别中几乎没有减少gadget</li></ul></li><li><p><strong>RQ4:工具实用性</strong>:为了了解每种去膨胀工具潜在部署环境,我们测量了其在框架工作负载上所有变体上运行的时间,如下图示</p><ul><li><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(1)_2_8.png" alt></li><li>CHISEL使用13000s,是其它方法的三个数量级,因为其依靠马尔可夫决策过程来找到满足所提供测试用例的最小语句子集。</li><li>PIECE-WISE,OCCAM,RAZOR分别为22.1,4.9,5.2 s,因为其主要依靠静态分析,因此这三种方法更容易应用到传统的优化流程种</li></ul></li><li><p><strong>总结</strong></p><ul><li><strong>正确性</strong>:Chisel: 80.4%, Occam: 100%, Razor: 94.8%, Piece-Wise:100%. 基于静态分析的比基于动态分析的效果好</li><li><strong>磁盘上大小</strong>:CHISEL和OCCAM 减小大小,而RAZOR和PIECE_WISE因为扩充了原始二进制大小,造成二进制大小变大</li><li><strong>Gadat表现</strong>:CHISEL表现比其它方法都好</li><li><strong>去膨胀时间</strong>:CHISEL比其它方法时间长很多(3.75h),PIECE-WISE,OCCAM,RAZOR分别为22.1,4.9,5.2 s</li></ul></li></ul><h4 id="5.2-%E5%9C%A85%E4%B8%AA%E9%9D%9Eutilcore%E7%A8%8B%E5%BA%8F%E4%B8%8A%E7%9A%84%E8%AF%84%E4%BC%B0" tabindex="-1">5.2 在5个非utilcore程序上的评估</h4><ul><li><strong>RQ1:正确性</strong>:<ul><li>使用247个测试用例,来自5个非utilcore程序的22个变体.</li><li>在容器种对目标程序进行去膨胀</li><li>在主机系统中进行正确性测试(因为GUI不好在容器中)</li><li>评估显示<ul><li>只有OCCAM和PIECE-WISE产生了正确的二进制文件可以通过所有的测试用例</li><li>RAZOR可以产生vlc和ngnix的正确二进制文件,而其它不行</li><li>CHISEL一个都不能正确产生</li></ul></li></ul></li><li><strong>RQ2:简化性</strong>:一定程度上都增大了二进制文件的大小</li><li>RQ1和RQ2的表现如下图示 <img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(1)_2_9.png" alt></li><li><strong>RQ3:Gadget 的表现</strong><ul><li>PIECE-WISE的最大平均时间是129.67s(在Graphicsmagick上),最小是13.66s(在Gvpdf上)</li><li>OCCAM平均最大时间是95.6s(在Graphicsmagick上),最小是1.3s(在Vlc上)</li><li>RAZOR最大平均时间120s</li></ul></li><li><strong>RQ4:工具实用性</strong>:只有OCCAM将两种类别的gadget都移除了,RAZOR还增加了Turing-complete类别的gadget,如下图示<ul><li><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(1)_2_10.png" alt></li></ul></li></ul><h4 id="5.3-%E5%8E%BB%E8%86%A8%E8%83%80%E5%99%A8%E7%BB%84%E5%90%88" tabindex="-1">5.3 去膨胀器组合</h4><ul><li><p>为了更有意义的比较,尽在utilcore程序上进行比较(以为有的方法不能再非utilcore上运行)</p></li><li><p>将四种方法的组合取首字母组合进行表示,如COR表示CHISEL-OCCAM-RAZOR组合运行,组合运行时需要保证最后的二进制程序能够运行</p></li><li><p>组合后正确性和简化性如下图示</p><ul><li><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(1)_2_11.png" alt></li><li><strong>正确性</strong>:由于CHISEL在单独测试中未通过测试用例的几率大,这些未通过的测试用例在组合测试中被去除,同时由于OCCAM通过了所有测试用例,因此作为基线</li><li><strong>简化度</strong>:<ul><li>单个工具的最大简化度是CHISEL减少了70.4%,而CO组合的简化度是 74.6%,COR为67.5%</li></ul></li><li><strong>Gadget表现</strong>:<ul><li><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(1)_2_12.png" alt></li><li>在Turing-complete ROP中 单个工具的最好情况是CHISEL,减少了36.6%,然而COR达到了38.8%,CO更是达到了50.5%</li><li>在ASLR-proof ROP中,单个工具最好情况是CHISEL,减少了28.2%,而CO,CR,COR表现都更出色,分别为45.9%、40.4%和45.8%。</li></ul></li></ul></li><li><p>对于CHISEL和PIECE-WISE的组合,在使用CHISEL进行去膨胀后,PIECE-WISE只能在去膨胀的10个程序中成功编译五个,且这些程序中,grep,date和tar三个程序的变体无法被PIECE_WISE编译.这是因为musl-libc和glibc不兼容导致的,CHISEL使用的glibc而PIECE-WISE使用的musl-libc</p></li><li><p><strong>组合总结</strong></p><ul><li>正确性:对于非Chisel流水线，它能够生成正确的二进制文件</li><li>大小:CO组合由于单个方法</li><li>Gadget:CO,COR组合均优于单个Chisel</li></ul></li></ul><h3 id="6-%E8%AE%A8%E8%AE%BA" tabindex="-1">6 讨论</h3><h3 id="6.1-%E8%AE%BE%E8%AE%A1%E9%80%89%E6%8B%A9%E7%9A%84%E5%BD%B1%E5%93%8D" tabindex="-1">6.1 设计选择的影响</h3><ul><li><strong>CHISEL在测试用例上的依赖</strong>:<ul><li>我们的评估揭示了CHISEL在二进制文件上的正确性最弱,这是因为CHISEL对测试脚本有着很强的依赖.同时这些脚本也很难保证是对的,即使脚本正确,CHISEL也可能出现问题.</li><li>在我们的实验中,平均有超过96%的去膨胀的时间是用在了运行属性测试脚本上</li></ul></li><li><strong>OCCAM的部分求值法</strong>:<ul><li>部分求值法降低了OCCAM的可用性,它只允许非冲突的标志存在于去膨胀的二进制程序中.(我们称两个标志是非冲突的,仅当它们可以在同一个执行过程中同时执行).因此,对于两个冲突的标志,需要创建两个变体.</li><li>然而,我们要注意到在OCCAM中通过部分求值法,可以使得 去膨胀程序 易于通过配置去设置,以为其不需要小心和无聊地使用测试用例,其质量会影响去膨胀二进制文件地可用性</li></ul></li><li><strong>RAZOR中基于跟踪地简化</strong>:<ul><li>RAZOR的不同启发式搜索影响其正确性和简化性,所以我们需要对使用不同的启发方法进行充分评估,已选择最佳的启发方法,保留合理的功能,下图展示了启发度级别与正确性的关系</li><li><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(1)_2_13.png" alt></li><li>此外,RAZOR的训练时间取决于提供给他的测试用例数量,下图展示了其关系</li><li><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(1)_2_14.png" alt></li></ul></li><li><strong>PIECE-WISE中加载时间的缩减</strong>:<ul><li>PIECE-WISE在编译时计算程序的依赖图并将其添加到ELF头文件中的.dep部分,用于减少加载时间,但这显著增加了大小.对于一些应用而言,大小的增加可能盖过了其好处</li></ul></li></ul><h3 id="6.2-%E7%A0%94%E7%A9%B6%E7%9A%84%E9%99%90%E5%88%B6" tabindex="-1">6.2 研究的限制</h3><ul><li>目前DebloatBenchA仅选择了每一类中的单个工具,并提供了深入的分析.然而工具的覆盖范围可以很容易地进行扩展.</li><li>目前 目标应用程序的选择受到了 去膨胀器功能的限制</li><li>我们创建了大量的测试用例来覆盖训练和测试,但总有疏漏</li></ul><h3 id="7-%E7%9B%B8%E5%85%B3%E5%B7%A5%E4%BD%9C" tabindex="-1">7 相关工作</h3><ul><li><strong>C/C++程序特化方向</strong>:<ul><li>主要有三个方向<ul><li>(1)源代码级（例如Chisel [22]、C-Reduce [42]、Perses [46]和DomGad [52]）</li><li>(2)中间代码级（例如Trimmer [6, 7, 44]、LLPE [45]、LMCAS [8]和Occam [31, 33]）</li><li>(3)二进制代码级.（例如Razor [37]）</li><li>另外也有库级别 ( 例如Piece-wise [39]、BlankIt [36]和Nibbler [5])</li></ul></li><li>DebloatBenchA是第一个系统地审查所有类别的工具以强调每种方法的优势和劣势的基准测试。</li><li>我们的评估还强调，组合多种方法具有比任何单个工具更好的性能的潜力。</li></ul></li><li><strong>环境/系统级的去膨胀</strong><ul><li>MultiK [29]和shard [4]提供了针对应用程序的内核级别的去bloat化</li><li>Cimplifier [41]使用动态分析来检测容器内的具有逻辑上不同之处的应用程序，并自动将其分解为较小的容器。</li><li>LightBlue [50]利用静态分析执行应用程序引导的固件去bloat化。</li><li>CDE [20]利用执行跟踪来识别应用程序的依赖项以实现无缝移植</li><li>最近，Hassan等人开发了一个名为DebloatBenchC的框架来评估容器去bloat化器[21]。</li></ul></li><li><strong>去膨胀的其它程序语言的研究</strong><ul><li>Piranha [40]针对Objective-C</li><li>JShrink [16]; JSCleaner [17], Lacuna [35], Muzeel [30],Stubbifier [48] and [49] 针对JS</li><li>Red [26]，JAX [47]，BloatLid [18] Depclean [2]和[9]分别针对基于Java和PHP的应用程序</li><li>也有在字节码上的研究 [19, 28].</li></ul></li></ul><h3 id="8-%E7%BB%93%E8%AE%BA" tabindex="-1">8 结论</h3><ul><li><ol><li>我们提出了DebloatBenchA,一个可扩展可维护的基准测试框架,用于对程序去膨胀方法进行严格的评估</li></ol></li><li><ol start="2"><li>我们将Chisel,Occam,Razor,Piece-wise集成到该框架中,进行了全面的比较研究.</li></ol><ul><li>我们发现保守的静态分析工具更能产生正确的二进制文件</li><li>而激进的动态分析工具在减少二进制文件大小,gadget类方面表现更好</li><li>而Piece-wise在增大二进制文件大小的同时未能减少任何gadget类</li><li>基于测试用例的工具在非coreuntils程序上的表现不好</li></ul></li><li><ol start="3"><li>对不同阶段多去膨胀工具的组合使用开辟了道路</li></ol></li></ul><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;2.-sok%3A-a-tale-of-reduction%2C-security%2C-and-correctness---evaluating-program-debloating-paradigms-and-their-compositions&quot; tabin</summary>
      
    
    
    
    <category term="论文" scheme="http://example.com/categories/%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="SoftwareEngineering" scheme="http://example.com/tags/SoftwareEngineering/"/>
    
    <category term="SoftwareDebloating" scheme="http://example.com/tags/SoftwareDebloating/"/>
    
  </entry>
  
  <entry>
    <title>Software Debloating 论文阅读 (1)</title>
    <link href="http://example.com/2024/01/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/SoftwareDebloating/Software%20Debloating%20%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB(1)/"/>
    <id>http://example.com/2024/01/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/SoftwareDebloating/Software%20Debloating%20%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB(1)/</id>
    <published>2024-01-15T07:10:43.866Z</published>
    <updated>2024-01-15T07:10:43.866Z</updated>
    
    <content type="html"><![CDATA[<h2 id="studying-and-understanding-the-tradeoffs-between-generality-and-reduction-in-software-debloating" tabindex="-1">Studying and Understanding the Tradeoffs Between Generality and Reduction in Software Debloating</h2><p>2022,In 37th IEEE/ACM International Conference on Automated Software Engineering (CCF A类会议)</p><p>Q. Xin, Q. Zhang, and A. Orso, “Studying and understanding the<br>tradeoffs between generality and reduction in software debloating,”<br>in Proceedings of the 37th IEEE/ACM International Conference on<br>Automated Software Engineering, ASE ’22, (New York, NY, USA),<br>Association for Computing Machinery, 2023.</p><h3 id="00-%E6%91%98%E8%A6%81" tabindex="-1">00 摘要</h3><ul><li><p>现有程序去膨胀方法通过使用配置文件作为识别程序特性的依据,通常是以一组输入的形式提供.具体来说,给定一个程序和输入,这些技术将生成一个在这些输入上正确运行的简化程序</p></li><li><p>然而只关注简化会和输入过拟合,为此我们需要考虑通用性,即未在配置文件中的输入的正确性</p></li><li><p>为此,我们对4种去膨胀方法(3种SOTA,1种基准方法)在25个程序和这些程序的不同输入集上进行了减少和通用性的实证评估。结果表明，这些方法确实会产生对使用的输入过拟合并且通用性较低的程序。</p></li><li><p>基于这些结果，我们还提出了两种新的增强方法，并评估了它们的有效性。这个额外的评估结果显示，这两种方法可以在不显著影响减少程序大小的情况下提高程序的通用性。</p></li><li><p>最后，由于不同的方法具有不同的优势和劣势，我们还提供了指南，以帮助用户根据其特定需求和背景选择最合适的方法。</p></li></ul><h3 id="01-%E4%BB%8B%E7%BB%8D" tabindex="-1">01 介绍</h3><ul><li><p>软件越来越复杂,带来的软件肿胀问题影响软件性能和安全</p></li><li><p>基于输入的指定软件预期功能方法: 通过输入来指定软件预期功能.然而因为输入只能覆盖有限的功能,所以这种方法会导致过拟合</p></li><li><p>因此简化和通用性需要同时考虑,然而这两点有着固有的矛盾,我们的去膨胀方法要在这两点间取得平衡</p></li><li><p>早期去膨胀方法激进的追求大小的缩减,忽略了通用性;</p></li><li><p>两种新的方法考虑了通用性,但未正确地衡量,并且没有 简化和通用性地平衡</p><ul><li><strong>Debop</strong>:(Qi Xin, Myeongsoo Kim, Qirun Zhang, and Alessandro Orso. 2020. Program debloating via stochastic optimization. In 2020 IEEE/ACM 42st International Conference on Software Engineering: New Ideas and Emerging Results (ICSE-NIER).):根据提供的输入评估程序的通用性，而不考虑未观察到的输入</li><li><strong>Razor</strong>(Chenxiong Qian, Hong Hu, Mansour Alharthi, Pak Ho Chung, Taesoo Kim,and Wenke Lee. 2019. RAZOR: A Framework for Post-deployment Software Debloating):使用一个弱（基于崩溃）的预测模型来确定程序的行为正确性，并评估通用性</li></ul></li><li><p>进行一项研究,评估基于输入地去膨胀方法在 简化,通用性及二者权衡之间地表现</p><ul><li>调查了3种面向C程序的SOTA(Chisel,Debop,Razor),1种基准方法(Cov)基于代码覆盖率进行去膨胀。</li><li>应用于包含25个程序的两个不同基准测试集,进行 去膨胀和通用性评估</li><li>评估方法<ul><li>评估去膨胀方法:使用两种简化类型:基于大小和攻击面</li><li>评估通用性方法:使用两种通用类型:正确性(C-通用性) 和 鲁棒性(R-通用性)</li><li>评估二者间的平衡:使用F-score度量</li></ul></li></ul></li><li><p>实验结果显示</p><ul><li>Chesel和Debop并未考虑程序处理未观察到的输入的能力,会较低的C通用性</li><li>Razor通过基于覆盖率的减少和基于启发式的增强,在C通用性上表现较好,但在R通用性上表现较差</li></ul></li><li><p>为了解决这些问题,我们提出了两种增强方法CovF和CovA,旨在提高R,C-通用性和通用性和简化的权衡,这俩种方法均基于Cov,但是CovF基于模糊测试,而CovA基于分析的代码增强,以此识别互补相关的代码,并在去膨胀时简化这些代码</p></li><li><p>具体来说,对于程序p和输入集合I</p><ul><li><ol><li>CovF和CovA首先调用Cov从p中删除未被I执行的代码,得到去膨胀程序<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mrow><mi>c</mi><mi>o</mi><mi>v</mi></mrow></msub></mrow><annotation encoding="application/x-tex">p_{cov}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">co</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>.</li></ol></li><li><ol start="2"><li>CovF利用模糊测试生成可以暴露<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mrow><mi>c</mi><mi>o</mi><mi>v</mi></mrow></msub></mrow><annotation encoding="application/x-tex">p_{cov}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">co</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>鲁棒性问题的输入,从p中恢复代码,消除这些问题;CovA利用静态和动态分析计算得到信息来增强<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mrow><mi>c</mi><mi>o</mi><mi>v</mi></mrow></msub></mrow><annotation encoding="application/x-tex">p_{cov}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">co</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>,即通过静态程序依赖关系,执行频率和覆盖灵活性等</li></ol></li></ul></li><li><p>直观地说,CovF专注于导致<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mrow><mi>c</mi><mi>o</mi><mi>v</mi></mrow></msub></mrow><annotation encoding="application/x-tex">p_{cov}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">co</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>崩溃地代码,CovA保留与<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mrow><mi>c</mi><mi>o</mi><mi>v</mi></mrow></msub></mrow><annotation encoding="application/x-tex">p_{cov}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">co</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>相关地代码,由此产生具有增强鲁棒性和正确性地程序</p></li><li><p>实际情况下去膨胀涉及多个相互冲突地目标,本次研究中有四个具体目标</p><ul><li>高的简化度</li><li>攻击面减少</li><li>C-通用性</li><li>R-通用性</li></ul></li><li><p>同时我们所考虑的方法各有优缺点,为此我们提供了一个指南,帮助用户选择方法</p></li></ul><h3 id="02-%E8%83%8C%E6%99%AF" tabindex="-1">02 背景</h3><h4 id="2.1-%E5%9F%BA%E4%BA%8E%E8%BE%93%E5%85%A5%E7%9A%84%E5%8E%BB%E8%86%A8%E8%83%80%E6%96%B9%E6%B3%95" tabindex="-1">2.1 基于输入的去膨胀方法</h4><ul><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span></eq>为程序,<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span></eq>为一组输入的集合,<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span></eq>为<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span></eq>在输入为<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span></eq>上的执行结果.</li><li>给定<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span></eq>和<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span></eq>,基于输入的去膨胀方法通过生成一个简化程序<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>p</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">p&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></eq>,使得<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>∈</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">i\in I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6986em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span></eq>,<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>p</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mi>p</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p&#x27;(i)=p(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0019em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span></eq></li></ul><h4 id="2.2-%E8%AF%84%E4%BC%B0%E6%96%B9%E6%B3%95" tabindex="-1">2.2 评估方法</h4><h5 id="2.2.1-%E7%AE%80%E5%8C%96%E5%BA%A6" tabindex="-1">2.2.1 简化度</h5><ul><li>两种简化度度量方法<ul><li>基于大小的简化度(size reduction): <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>r</mi><mi>e</mi><mi>d</mi><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msup><mi>p</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>−</mo><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo stretchy="false">(</mo><msup><mi>p</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><mrow><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">sred(p,p&#x27;)=\frac{size(p) - size(p&#x27;)}{size(p)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0019em;vertical-align:-0.25em;"></span><span class="mord mathnormal">sre</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.5845em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0645em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">ze</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">p</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">ze</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">p</span><span class="mclose mtight">)</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">ze</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></eq>,<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo stretchy="false">(</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">size()</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ze</span><span class="mopen">(</span><span class="mclose">)</span></span></span></span></eq>为程序大小,有两种度量方法<ul><li><ol><li>语句数</li></ol></li><li><ol start="2"><li>执行时内存的字节数</li></ol></li></ul></li><li>基于攻击面的简化度(attack surface reduction): <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>r</mi><mi>e</mi><mi>d</mi><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msup><mi>p</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>a</mi><mi>s</mi><mi>u</mi><mi>r</mi><mi>f</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>−</mo><mi>a</mi><mi>s</mi><mi>u</mi><mi>r</mi><mi>f</mi><mo stretchy="false">(</mo><msup><mi>p</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><mrow><mi>a</mi><mi>s</mi><mi>u</mi><mi>r</mi><mi>f</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">ared(p,p&#x27;)=\frac{asurf(p)-asurf(p&#x27;)}{asurf(p)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0019em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">re</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.5845em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0645em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">p</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">p</span><span class="mclose mtight">)</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></eq>,<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>s</mi><mi>u</mi><mi>r</mi><mi>f</mi><mo stretchy="false">(</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">asurf()</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mclose">)</span></span></span></span></eq>表示用程序包含的面向返回编程（ROP,Return-Oriented-Programming）小工具的数量来衡量程序的攻击面。<ul><li>ROP（Return-Oriented Programming）小工具是一系列机器指令的序列，通常以返回指令结束。攻击者可以利用漏洞（例如堆栈溢出）来覆盖一个小工具的返回地址，从而改变控制流并执行恶意代码。ROP小工具通常用于测量攻击面。我们使用ROPgadget工具来计算ROP小工具的数量。</li></ul></li></ul></li></ul><h5 id="2.2.2-%E9%80%9A%E7%94%A8%E6%80%A7" tabindex="-1">2.2.2 通用性</h5><ul><li>C通用性(correctness-based):收集另一个输入集合<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>I</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">I&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></eq>,使得<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>I</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>∩</mo><mi>I</mi><mo>=</mo><mi mathvariant="normal">∅</mi></mrow><annotation encoding="application/x-tex">I&#x27; \cap I = \emptyset</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">∅</span></span></span></span></eq>,有<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>g</mi><mi>e</mi><mi>n</mi><mo stretchy="false">(</mo><msup><mi>p</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo><msup><mi>I</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><msub><mo>∑</mo><mrow><msup><mi>i</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>∈</mo><msup><mi>I</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow></msub><msup><mi>p</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><msup><mi>i</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo>=</mo><mi>p</mi><mo stretchy="false">(</mo><msup><mi>i</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><mrow><mi mathvariant="normal">∣</mi><msup><mi>I</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mi mathvariant="normal">∣</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">cgen(p&#x27;,I&#x27;)=\frac{\sum_{i&#x27;\in I&#x27;} p&#x27;(i&#x27;)=p(i&#x27;)}{|I&#x27;|}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0019em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.654em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.134em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord mtight">∣</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.5546em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mop op-symbol small-op mtight" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2854em;"><span style="top:-2.2854em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.6068em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8496em;"><span style="top:-2.8496em;margin-right:0.1em;"><span class="pstrut" style="height:2.5556em;"></span><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span><span class="mrel mtight">∈</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8496em;"><span style="top:-2.8496em;margin-right:0.1em;"><span class="pstrut" style="height:2.5556em;"></span><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3494em;"><span></span></span></span></span></span></span><span class="mspace mtight" style="margin-right:0.1952em;"></span><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose mtight">)</span><span class="mrel mtight">=</span><span class="mord mathnormal mtight">p</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></eq>,其中<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><msup><mi>p</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(),p&#x27;()</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0019em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mclose">)</span></span></span></span></eq>表示<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo separator="true">,</mo><msup><mi>p</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">p,p&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></eq>产生的输出,<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><msup><mi>I</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|I&#x27;|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0019em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span></eq>表示输入的数量<ul><li>两种不同类型的C通用性<ul><li><ol><li>当<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>I</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">I&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></eq>为输入全集时,得到的通用性称为 all-input-based c-generality</li></ol></li><li><ol start="2"><li>当𝐼’是一个包含与𝐼相关的输入（例如，用于测试类似功能）,得到的通用性称为 related-input-based c-generality</li></ol></li></ul></li></ul></li><li>R通用性(robustness-based):该指标衡量对于未被观测到的输入的适应能力,反映了程序的可靠性. 同样收集另一个输入集合<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>I</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">I&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></eq>,使得<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>I</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>∩</mo><mi>I</mi><mo>=</mo><mi mathvariant="normal">∅</mi></mrow><annotation encoding="application/x-tex">I&#x27; \cap I = \emptyset</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">∅</span></span></span></span></eq>,<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>g</mi><mi>e</mi><mi>n</mi><mo stretchy="false">(</mo><msup><mi>p</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo><msup><mi>I</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><msub><mo>∑</mo><mrow><msup><mi>i</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>∈</mo><msup><mi>I</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow></msub><mi>r</mi><mi>o</mi><mi>b</mi><mi>u</mi><mi>s</mi><mi>t</mi><mo stretchy="false">(</mo><msup><mi>p</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><msup><mi>i</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><mrow><mi mathvariant="normal">∣</mi><msup><mi>I</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mi mathvariant="normal">∣</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">rgen(p&#x27;,I&#x27;)=\frac{\sum_{i&#x27;\in I&#x27;} robust(p&#x27;(i&#x27;))}{|I&#x27;|}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0019em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.654em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.134em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord mtight">∣</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.5546em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mop op-symbol small-op mtight" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2854em;"><span style="top:-2.2854em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.6068em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8496em;"><span style="top:-2.8496em;margin-right:0.1em;"><span class="pstrut" style="height:2.5556em;"></span><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span><span class="mrel mtight">∈</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8496em;"><span style="top:-2.8496em;margin-right:0.1em;"><span class="pstrut" style="height:2.5556em;"></span><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3494em;"><span></span></span></span></span></span></span><span class="mspace mtight" style="margin-right:0.1952em;"></span><span class="mord mathnormal mtight">ro</span><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">t</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose mtight">))</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></eq>,<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>o</mi><mi>b</mi><mi>u</mi><mi>s</mi><mi>t</mi><mo stretchy="false">(</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">robust()</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ro</span><span class="mord mathnormal">b</span><span class="mord mathnormal">u</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mclose">)</span></span></span></span></eq>表示程序运行结束后是否崩溃(如 段错误). 本文通过生产 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span></eq> 的fuzzed 版本得到<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>I</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">I&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></eq></li></ul><h5 id="2.2.3-%E7%AE%80%E5%8C%96%E5%BA%A6-%E9%80%9A%E7%94%A8%E6%80%A7-%E6%9D%83%E8%A1%A1" tabindex="-1">2.2.3 简化度-通用性 权衡</h5><ul><li>使用调和平均数,或F-score<br><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>r</mi><mi>e</mi><mi>d</mi><mo separator="true">,</mo><mi>g</mi><mi>e</mi><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mn>2</mn><mo>⋅</mo><mi>r</mi><mi>e</mi><mi>d</mi><mo>⋅</mo><mi>g</mi><mi>e</mi><mi>n</mi></mrow><mrow><mi>r</mi><mi>e</mi><mi>d</mi><mo>+</mo><mi>g</mi><mi>e</mi><mi>n</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">f(red,gen) = \frac{2\cdot red \cdot gen}{red+gen}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">re</span><span class="mord mathnormal">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.4133em;vertical-align:-0.4811em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">re</span><span class="mord mathnormal mtight">d</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mbin mtight">⋅</span><span class="mord mathnormal mtight">re</span><span class="mord mathnormal mtight">d</span><span class="mbin mtight">⋅</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4811em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></eq></li></ul><h3 id="03-%E7%9B%B8%E5%85%B3%E5%8E%BB%E8%86%A8%E8%83%80%E6%96%B9%E6%B3%95" tabindex="-1">03 相关去膨胀方法</h3><ul><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>a</mi><mi>z</mi><mi>o</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">Razor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">zor</span></span></span></span></eq> 是 binary-based ,修改程序的二进制码</li><li>其他方法是 source-based ,修改程序源代码</li><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>o</mi><mi>v</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">CovA</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">A</span></span></span></span></eq>和<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>o</mi><mi>v</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">CovF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span></eq>都是基于<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>o</mi><mi>v</mi></mrow><annotation encoding="application/x-tex">Cov</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span></eq>的,他们的强化方法也可以用到其它方法上</li></ul><h4 id="3.1-previous-input-based-approaches%3A-chisel%2Cdebop%2Crazor" tabindex="-1">3.1 Previous Input-Based Approaches: ChISEL,DEBOP,RAZOR</h4><ul><li><p>CHISEL是一种基于 强化学习引导(reinforcement-learning-guided),增量调试(delta-debugging-base)的 减量化(reduction-oriented) 去膨胀算法</p></li><li><p>DEBOP 是一种 多目标方法(multi-objective),考虑了三个因素(size reduction,attack surface reduction,generality),并在这三个因素中寻求平衡</p></li><li><p>RAZOR 是一种 基于 追踪(tracing),启发式增强(heuristic-based augmentation)和二进制重写(binary-rewriting) 的 二进制级的精简方法</p></li></ul><h4 id="3.2-cov%3Acoverage-based-debloating" tabindex="-1">3.2 Cov:Coverage-Based Debloating</h4><ul><li><p>给定一个程序<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span></eq>和输入<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span></eq>,<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>o</mi><mi>v</mi></mrow><annotation encoding="application/x-tex">Cov</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span></eq> Instrument(启动,引导?) <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span></eq> 使用<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span></eq> 识别出运行的语句,<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>o</mi><mi>v</mi></mrow><annotation encoding="application/x-tex">Cov</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span></eq>会删除<strong>未被使用的语句</strong>和<strong>使用过但不需要</strong>(比如定义了但未被使用的变量)的语句</p></li><li><p><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>o</mi><mi>v</mi></mrow><annotation encoding="application/x-tex">Cov</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span></eq> 原型 使用 llvm-cov 和 gcov:依赖于Clang构建 抽象语法树(AST abstract syntax tree),遍历AST上所有语句,通过分析覆盖报告<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>o</mi><mi>v</mi></mrow><annotation encoding="application/x-tex">Cov</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span></eq>找到为执行的语句进行删除,同时通过依赖分析,还可以删除其它不必要的语句</p><ul><li><ol><li>“dangling”(悬空指令):没有实际操作且条件没有实际作用的指令,如 if(x==0){}</li></ol></li><li><ol start="2"><li>未使用的变量命名</li></ol></li><li><ol start="3"><li>未使用的标签语句</li></ol></li></ul></li></ul><h4 id="3.3-covf%3A-coverage-based-debloating-with-fuzz-based-augmentation" tabindex="-1">3.3 CovF: Coverage-Based Debloating with Fuzz-Based Augmentation</h4><ul><li><strong>问题</strong>:基于覆盖率的方法通常会消除未执行的代码生成过度简化的代码,即过拟合</li><li><strong>解决</strong>:开发CovF,基于模糊测试增强的方法,提升精简后程序的鲁棒性</li><li><strong>方法描述</strong>:<ul><li><ol><li>给定程序<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span></eq>和输入<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span></eq>,使用<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>o</mi><mi>v</mi></mrow><annotation encoding="application/x-tex">Cov</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span></eq>生成精简程序<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mrow><mi>c</mi><mi>o</mi><mi>v</mi></mrow></msub></mrow><annotation encoding="application/x-tex">p_{cov}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">co</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq></li></ol></li><li><ol start="2"><li>基于<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span></eq>进行模糊测试生成输入<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>I</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">I&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></eq>,使得<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>I</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">I&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></eq> 与 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span></eq> 鲁棒性相关,即可以使得<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mrow><mi>c</mi><mi>o</mi><mi>v</mi></mrow></msub></mrow><annotation encoding="application/x-tex">p_{cov}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">co</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>崩溃或无法终止</li></ol><ul><li>当前实现中CovF使用 <strong>黑盒模糊测试工具 Radamsa</strong> 应用于<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span></eq>,生成<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>I</mi><mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup></mrow><annotation encoding="application/x-tex">I&#x27;_{init}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0106em;vertical-align:-0.2587em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-2.4413em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ini</span><span class="mord mathnormal mtight">t</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2587em;"><span></span></span></span></span></span></span></span></span></span></eq>然后运行<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mrow><mi>c</mi><mi>o</mi><mi>v</mi></mrow></msub></mrow><annotation encoding="application/x-tex">p_{cov}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">co</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>对<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>I</mi><mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup></mrow><annotation encoding="application/x-tex">I&#x27;_{init}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0106em;vertical-align:-0.2587em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-2.4413em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ini</span><span class="mord mathnormal mtight">t</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2587em;"><span></span></span></span></span></span></span></span></span></span></eq>进行测试,识别出 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>I</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>∈</mo><msubsup><mi>I</mi><mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup></mrow><annotation encoding="application/x-tex">I&#x27;\in I&#x27;_{init}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.791em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0106em;vertical-align:-0.2587em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-2.4413em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ini</span><span class="mord mathnormal mtight">t</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2587em;"><span></span></span></span></span></span></span></span></span></span></eq>使得<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mrow><mi>c</mi><mi>o</mi><mi>v</mi></mrow></msub><mo stretchy="false">(</mo><msup><mi>I</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p_{cov}(I&#x27;)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0019em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">co</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq>崩溃或无法终止</li></ul></li><li><ol start="3"><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>o</mi><mi>v</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">CovF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span></eq>保留被<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mo separator="true">,</mo><msup><mi>I</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">I,I&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></eq>执行的语句,删除其它语句,得到最终程序<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mrow><mi>c</mi><mi>o</mi><mi>v</mi><mi>f</mi></mrow></msub></mrow><annotation encoding="application/x-tex">p_{covf}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">co</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></eq></li></ol></li></ul></li><li><strong>注意</strong>:原始程序<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span></eq>可能本来就存在鲁棒性问题,该问题并不是由去膨胀引起的,CovF只是通过模糊测试找到了这些问题</li></ul><h4 id="3.4-cova%3A-coverage-based-debloating-with-analysis-based-augmentation" tabindex="-1">3.4 CovA: Coverage-Based Debloating with Analysis-Based Augmentation</h4><ul><li><strong>问题</strong>:CovF方法可以通过 产生 不合规的输入增强程序的鲁棒性,但这些输入更多锻炼了非核心逻辑,但没有锻炼到其它不同特性<ul><li>例子:对输入<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>:</mo><mi mathvariant="normal">&quot;</mi><mo>−</mo><mi>m</mi><mn>777</mn><mi>t</mi><mi>e</mi><mi>s</mi><mi>t</mi><mi>d</mi><mi>i</mi><mi>r</mi><mi mathvariant="normal">&quot;</mi></mrow><annotation encoding="application/x-tex">i:&quot;-m 777 testdir&quot;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord">&quot;</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">m</span><span class="mord">777</span><span class="mord mathnormal">t</span><span class="mord mathnormal">es</span><span class="mord mathnormal">t</span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord">&quot;</span></span></span></span></eq>很难模糊测试到另一个输入<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>i</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>:</mo><mi mathvariant="normal">&quot;</mi><mo>−</mo><mi>m</mi><mi>a</mi><mo>=</mo><mi>r</mi><mi>w</mi><mi>x</mi><mi>t</mi><mi>e</mi><mi>s</mi><mi>t</mi><mi>d</mi><mi>i</mi><mi>r</mi><mi mathvariant="normal">&quot;</mi></mrow><annotation encoding="application/x-tex">i&#x27;:&quot;-m a=rwx testdir&quot;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord">&quot;</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ma</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">x</span><span class="mord mathnormal">t</span><span class="mord mathnormal">es</span><span class="mord mathnormal">t</span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord">&quot;</span></span></span></span></eq>,这两个鲁棒相关,但<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>i</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">i&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></eq>涉及到另一个功能<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mtext>使用符号表示权限而不是数字</mtext><mo separator="true">,</mo><mtext>创建一个目录</mtext></mrow><annotation encoding="application/x-tex">f:使用符号表示权限而不是数字,创建一个目录</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord cjk_fallback">使用符号表示权限而不是数字</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord cjk_fallback">创建一个目录</span></span></span></span></eq>,因此模糊测试很难保留该功能<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span></eq></li></ul></li><li><strong>方法</strong>:<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>o</mi><mi>v</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">CovA</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">A</span></span></span></span></eq>通过 对函数间的依赖关系和精简后的程序运行踪迹 进行 静态和静态分析 推断 需要被增强的相关代码</li><li><strong>方法效果</strong>:<ul><li><ol><li>与CovF相比,直接识别与功能相关的函数并保留</li></ol></li><li><ol start="2"><li>通过对函数进行增强,降低了生成 语法或语义无用的程序(e.g.:有循环但没break的语句)</li></ol></li><li><ol start="3"><li>CovA对每一个函数计算一个增强分数,是对与所需功能的相关估计,该分数基于函数的依赖关系,执行频率和覆盖变化,越高与功能相关性越高</li></ol></li><li><ol start="4"><li>针对不同的输入时,如果一个方法的覆盖率经常发生变化,则该方法需要进行额外的增强</li></ol></li><li><ol start="5"><li>最后我们可以根据得到的分数选择前<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span></eq>个函数进行增强</li></ol></li></ul></li><li><strong>方法具体</strong>:给定程序<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span></eq>和输入<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span></eq>,增强阈值<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>o</mi><msub><mi>p</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">top_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq><ul><li><ol><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>o</mi><mi>v</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">CovA</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">A</span></span></span></span></eq>首先得到<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span></eq>所有函数,对每个函数<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span></eq>,计算三个分数:<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>p</mi><mi>e</mi><mi>c</mi><mi>i</mi><mi>f</mi><mi>i</mi><mi>c</mi><mi>i</mi><mi>t</mi><mi>y</mi><mo>−</mo><mi>s</mi><mi>p</mi><mi>e</mi><mi>c</mi><mo separator="true">,</mo><mi>f</mi><mi>r</mi><mi>e</mi><mi>q</mi><mi>u</mi><mi>e</mi><mi>n</mi><mi>c</mi><mi>y</mi><mo>−</mo><mi>f</mi><mi>r</mi><mi>e</mi><mi>q</mi><mo separator="true">,</mo><mi>f</mi><mi>l</mi><mi>e</mi><mi>x</mi><mi>i</mi><mi>b</mi><mi>i</mi><mi>l</mi><mi>i</mi><mi>t</mi><mi>y</mi><mo>−</mo><mi>f</mi><mi>l</mi><mi>e</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">specificity-spec,frequency-freq,flexibility-flex</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">p</span><span class="mord mathnormal">ec</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">p</span><span class="mord mathnormal">ec</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">re</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.03588em;">cy</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">re</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">ibi</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span></span></span></span></eq>,用map存储;分数详解在后面</li></ol></li><li><ol start="2"><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>o</mi><mi>v</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">CovA</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">A</span></span></span></span></eq>对这些分数进行标准化,然后计算归一化分数的平均值左右增强分数<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>u</mi><mi>g</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">aug(f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03588em;">ug</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span></eq> <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>u</mi><mi>g</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>s</mi><mi>p</mi><mi>e</mi><msub><mi>c</mi><mi>n</mi></msub><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mi>r</mi><mi>e</mi><msub><mi>q</mi><mi>n</mi></msub><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mi>l</mi><mi>e</mi><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><mn>3</mn></mfrac></mrow><annotation encoding="application/x-tex">aug(f) = \frac{spec_n(f)+freq_n(f)+flex_n(f)}{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03588em;">ug</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">e</span><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mclose mtight">)</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">re</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:-0.0359em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mclose mtight">)</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">e</span><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></eq> ,其中<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>p</mi><mi>e</mi><msub><mi>c</mi><mi>n</mi></msub><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>f</mi><mi>r</mi><mi>e</mi><msub><mi>q</mi><mi>n</mi></msub><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>f</mi><mi>l</mi><mi>e</mi><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">spec_n(f),freq_n(f),flex_n(f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">p</span><span class="mord mathnormal">e</span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">re</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span></eq>分别表示<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>p</mi><mi>e</mi><mi>c</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>f</mi><mi>r</mi><mi>e</mi><mi>q</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>f</mi><mi>l</mi><mi>e</mi><mi>x</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">spec(f),freq(f),flex(f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">p</span><span class="mord mathnormal">ec</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">re</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span></eq>的标准化值</li></ol></li><li><ol start="3"><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>o</mi><mi>v</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">CovA</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">A</span></span></span></span></eq>对函数按照增强分数进行排序然后生成一个简化的程序,该简化程序包含(1) 经过输入<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span></eq>后精简的代码,和(2) 与前<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>o</mi><msub><mi>p</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">top_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>个函数相关的代码</li></ol></li></ul></li><li><strong>分数详解</strong><ul><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>p</mi><mi>e</mi><mi>c</mi><mi>i</mi><mi>f</mi><mi>i</mi><mi>c</mi><mi>i</mi><mi>t</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">Specificity</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Sp</span><span class="mord mathnormal">ec</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span></eq>(特异性值):<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>o</mi><mi>v</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">CovA</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">A</span></span></span></span></eq>通过静态分析,更具体说是以来分析计算得到,表现了函数与程序具体特点的相关程度<ul><li>为了计算<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>p</mi><mi>e</mi><mi>c</mi><mi>i</mi><mi>f</mi><mi>i</mi><mi>c</mi><mi>i</mi><mi>t</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">Specificity</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Sp</span><span class="mord mathnormal">ec</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span></eq>,<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>o</mi><mi>v</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">CovA</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">A</span></span></span></span></eq>构建了一个函数调用图,对每个函数<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span></eq>计算一个指标,该指标基于 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span></eq>依赖函数的数量<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>f</mi><mi>a</mi><mi>n</mi><mo>−</mo><mi>i</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(fan-in)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">an</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">in</span><span class="mclose">)</span></span></span></span></eq>和 依赖<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span></eq>的函数的数量<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>f</mi><mi>a</mi><mi>n</mi><mo>−</mo><mi>o</mi><mi>u</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(fan-out)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">an</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span></eq>,最后<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>p</mi><mi>e</mi><mi>c</mi><mi>i</mi><mi>f</mi><mi>i</mi><mi>c</mi><mi>i</mi><mi>t</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">Specificity</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Sp</span><span class="mord mathnormal">ec</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span></eq>计算公式如下 <section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>s</mi><mi>p</mi><mi>e</mi><mi>c</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo>−</mo><mi>u</mi><mi>t</mi><mi>i</mi><mi>l</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo>−</mo><mfrac><mrow><mi>f</mi><mi>a</mi><mi>n</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><mi>N</mi></mfrac><mo>×</mo><mfrac><mrow><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mfrac><mi>N</mi><mrow><mi>f</mi><mi>a</mi><mi>n</mi><mi>o</mi><mi>u</mi><mi>t</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></mrow></mfrac><mo stretchy="false">)</mo></mrow><mrow><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">spec(f) = 1 - util(f) = 1 - \frac{fanin(f) }{N} \times \frac{\log(\frac{N}{fanout(f)+1})}{\log(N)} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">p</span><span class="mord mathnormal">ec</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.113em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">anin</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.7183em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7823em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">an</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">t</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mclose mtight">)</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></eqn></section></li><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></eq>是函数的总数;<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>a</mi><mi>n</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>f</mi><mi>a</mi><mi>n</mi><mi>o</mi><mi>u</mi><mi>t</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">fanin(f),fanout(f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">anin</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">an</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span></eq>是<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span></eq>的<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>a</mi><mi>n</mi><mo>−</mo><mi>i</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">fan-in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">an</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">in</span></span></span></span></eq>和<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>a</mi><mi>n</mi><mo>−</mo><mi>o</mi><mi>u</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">fan-out</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">an</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span></span></span></span></eq>,分别是 图中调用<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span></eq>的函数数量和<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span></eq>调用的函数数量</li><li>由某论文可知 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mi>t</mi><mi>i</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">util</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span></eq>取值<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></eq>之间,<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>a</mi><mi>n</mi><mi>i</mi><mi>n</mi><mo separator="true">,</mo><mi>f</mi><mi>a</mi><mi>n</mi><mi>o</mi><mi>u</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">fanin,fanout</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">anin</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">an</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span></span></span></span></eq>取值0到<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>N</mi><mi mathvariant="normal">∣</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">|N|-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></eq>之间,而当<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>a</mi><mi>n</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">fanin(f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">anin</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span></eq>越大,即<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span></eq>被更多函数调用,则<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>a</mi><mi>n</mi><mi>o</mi><mi>u</mi><mi>t</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">fanout(f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">an</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span></eq>越小,即<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span></eq>调用的函数越少,则函数<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span></eq>更可能是一个工具类,有很高的实用性指标,所以它有较低的 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>p</mi><mi>e</mi><mi>c</mi><mi>i</mi><mi>f</mi><mi>i</mi><mi>c</mi><mi>i</mi><mi>t</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">Specificity</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Sp</span><span class="mord mathnormal">ec</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span></eq>值</li></ul></li><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>r</mi><mi>e</mi><mi>q</mi><mi>u</mi><mi>e</mi><mi>n</mi><mi>c</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">Frequency</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">re</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.03588em;">cy</span></span></span></span></eq>(调用频率):公式<section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mi>r</mi><mi>e</mi><mi>q</mi><mo stretchy="false">(</mo><mi>f</mi><mo separator="true">,</mo><mi>I</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><msub><mi>N</mi><mi>f</mi></msub><msub><mi>N</mi><mi>I</mi></msub></mfrac></mrow><annotation encoding="application/x-tex">freq(f,I)=\frac{N_f}{N_I}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">re</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.1963em;vertical-align:-0.836em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.836em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></eqn></section><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mi>f</mi></msub></mrow><annotation encoding="application/x-tex">N_f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></eq>表示函数<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span></eq>在<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span></eq>中被调用的次数,<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mi>I</mi></msub></mrow><annotation encoding="application/x-tex">N_I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>表示<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span></eq>中输入的数量</li><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>l</mi><mi>e</mi><mi>x</mi><mi>i</mi><mi>b</mi><mi>i</mi><mi>l</mi><mi>i</mi><mi>t</mi><mi>y</mi><mo stretchy="false">(</mo><mtext>灵活度</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Flexibility(灵活度)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">Fl</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">ibi</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord cjk_fallback">灵活度</span><span class="mclose">)</span></span></span></span></eq>:<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>o</mi><mi>v</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">CovA</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">A</span></span></span></span></eq>分析函数<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span></eq>的执行情况<ul><li>对于每个被<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span></eq>执行的函数<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span></eq>,<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>o</mi><mi>v</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">CovA</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">A</span></span></span></span></eq>跟踪对于<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span></eq>中的每个<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span></eq>,被<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span></eq>执行的所有语句集合<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo stretchy="false">(</mo><mi>f</mi><mo separator="true">,</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S(f,i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span></eq>.如果<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span></eq>没有被<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span></eq>执行,则<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo stretchy="false">(</mo><mi>f</mi><mo separator="true">,</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">∅</mi></mrow><annotation encoding="application/x-tex">S(f,i)=\emptyset</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">∅</span></span></span></span></eq></li><li>然后计算在<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span></eq>中被执行函数<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span></eq>中唯一语句集合<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo stretchy="false">(</mo><mi>f</mi><mo separator="true">,</mo><mi>I</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">c(f,I)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mclose">)</span></span></span></span></eq></li><li>例子:假设<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span></eq>中包含3个输入<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>i</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>i</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>i</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">i_0,i_1,i_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>,<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span></eq>被这些输入执行的语句集合分别是<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo stretchy="false">(</mo><mi>f</mi><mo separator="true">,</mo><msub><mi>i</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><msub><mi>s</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>s</mi><mn>1</mn></msub><mo stretchy="false">}</mo><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">(</mo><mi>f</mi><mo separator="true">,</mo><msub><mi>i</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><msub><mi>s</mi><mn>0</mn></msub><mo stretchy="false">}</mo><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">(</mo><mi>f</mi><mo separator="true">,</mo><msub><mi>i</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><msub><mi>s</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>s</mi><mn>1</mn></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">S(f,i_0)= \{ s_0,s_1 \},S(f,i_1)=\{s_0\},S(f,i_2)=\{s_0,s_1\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span></eq>,其中<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>s</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>s</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">s_0,s_1,s_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>是三个语句.此时<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo stretchy="false">(</mo><mi>f</mi><mo separator="true">,</mo><mi>I</mi><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">c(f,I)=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span></eq>,因为有两个唯一的语句集合,即<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><msub><mi>s</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>s</mi><mn>1</mn></msub><mo stretchy="false">}</mo><mo separator="true">,</mo><mo stretchy="false">{</mo><msub><mi>s</mi><mn>0</mn></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{s_0,s_1\},\{s_0\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span></eq></li><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>o</mi><mi>v</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">CovA</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">A</span></span></span></span></eq>计算<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span></eq>的灵活性<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>l</mi><mi>e</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">flex</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span></span></span></span></eq>公式:<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>l</mi><mi>e</mi><mi>x</mi><mo stretchy="false">(</mo><mi>f</mi><mo separator="true">,</mo><mi>I</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>c</mi><mo stretchy="false">(</mo><mi>f</mi><mo separator="true">,</mo><mi>I</mi><mo stretchy="false">)</mo></mrow><msub><mi>N</mi><mi>I</mi></msub></mfrac></mrow><annotation encoding="application/x-tex">flex(f,I)=\frac{c(f,I)}{N_I}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.4553em;vertical-align:-0.4453em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3567em;margin-left:-0.109em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1433em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4453em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></eq> 其中<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mi>I</mi></msub></mrow><annotation encoding="application/x-tex">N_I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>是<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span></eq>中输入的数量;</li><li>使用机理:对于低 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>l</mi><mi>e</mi><mi>x</mi><mi>i</mi><mi>b</mi><mi>i</mi><mi>l</mi><mi>i</mi><mi>t</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">flexibility</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">ibi</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span></eq>的函数,他在执行未被观察到的输入时,其行为可能会发生变化的概率较小,因此<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>o</mi><mi>v</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">CovA</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">A</span></span></span></span></eq>认为这些函数增强的优先级较低</li></ul></li></ul></li></ul><h3 id="04-%E8%AF%84%E4%BC%B0" tabindex="-1">04 评估</h3><ul><li>探究以下四个问题<br>• RQ1：就减少程度、c-普适性和它们之间的权衡而言，所考虑的方法有何区别？<br>• RQ2：就减少程度、r-普适性和它们之间的权衡而言，所考虑的方法有何区别？<br>• RQ3：当使用越来越多的输入进行精简时，所考虑的方法的表现如何？<br>• RQ4：这些方法的效率如何？</li></ul><h4 id="4.1-%E5%B7%A5%E5%85%B7%E5%AE%9E%E7%8E%B0" tabindex="-1">4.1 工具实现</h4><ul><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>H</mi><mi>I</mi><mi>S</mi><mi>E</mi><mi>L</mi><mo separator="true">,</mo><mi>D</mi><mi>E</mi><mi>B</mi><mi>O</mi><mi>P</mi><mo separator="true">,</mo><mi>R</mi><mi>A</mi><mi>Z</mi><mi>O</mi><mi>R</mi></mrow><annotation encoding="application/x-tex">CHISEL,DEBOP,RAZOR</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.05764em;">SE</span><span class="mord mathnormal">L</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.13889em;">EBOP</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.00773em;">ZOR</span></span></span></span></eq></li><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>o</mi><mi>v</mi><mi>F</mi><mo separator="true">,</mo><mi>C</mi><mi>o</mi><mi>v</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">CovF,CovA</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">A</span></span></span></span></eq></li></ul><h4 id="4.2-%E5%9F%BA%E5%87%86(benchmarks)" tabindex="-1">4.2 基准(Benchmarks)</h4><h5 id="4.2.1-%E5%9F%BA%E5%87%86%E7%A8%8B%E5%BA%8F" tabindex="-1">4.2.1 基准程序</h5><ul><li><p>在我们的评估中，我们使用了两组程序：十个实用程序（Util）和来自SIR基准[2]的15个程序（SIR）。</p><ul><li>这十个实用程序，因为它们在之前的精简方法CHISEL,DEBOP,RAZOR的评估中使用过。对于这些程序，我们使用了它们在Chisel基准[20]中提供的单文件版本。一个单文件程序包含一个C文件，将项目中所有原始C源文件合并在一起。</li><li>一组15个程序，它们是SIR基准提供的所有C程序。它们代表了不同类型的程序，包括词法分析器（printtokens）、实用程序（例如make）、Unix shell（bash）和文本编辑器（vim）。我们选择这些基准程序也是因为它们有大量（从几百到几千个）相关的测试。拥有大量的测试能够有效评估精简程序的普适性，并对使用不断增加的输入进行精简的效果进行全面调查。对于SIR程序，我们使用CIL合并工具[1]为它们获取了用于精简的单文件版本。</li></ul></li><li><p>下表表示了25个程序的基准:</p><ul><li>从属 belong (Bench)</li><li>名字 name (Program)</li><li>代码行数 size in lines of code (LOC)</li><li>函数数量 number of functions (#Func)</li><li>语句数量  statements (#Stmt)</li></ul></li><li><p>SIR基准包含七个程序(SSIR),比另外八个小(LSIR),我们应该重点分析方法在使用程序和大型程序上的效果,因为去膨胀技术更适用于大程序</p></li></ul><p><img src="/images/%E8%AE%BA%E6%96%87/%5Csoftware%20debloating%20%E8%AE%BA%E6%96%87/(1)_1_1.png" alt></p><h5 id="4.2.2-%E8%BE%93%E5%85%A5" tabindex="-1">4.2.2 输入</h5><ul><li><p>在对程序进行去膨胀和通用性评估时,由于需要大量的输入,所以没有使用与程序关联的人为创建的小的数据集,而是通过谷歌搜索,在网络上获得真实用户的输入</p></li><li><p>实用工具输入</p><ul><li>具体而言,我们为每个实用工具收集十个输入集,均来自真实用户,网站来源见引用</li><li>下1介绍了输入的统计信息，包括#TotalIn（总输入数）、#MinIn（所有输入集中最小输入数的集合𝑆𝑚𝑖𝑛）、#MaxIn（所有输入集中最大输入数的集合𝑆𝑚𝑎𝑥）和#AvgIn（所有输入集的平均输入数）,程序的总输入数（#TotalIn）</li></ul></li><li><p>SIR程序输入</p><ul><li>我们将与程序相关的输入集<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mi>u</mi></msub></mrow><annotation encoding="application/x-tex">I_u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>分为两个子集<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mi>d</mi></msub></mrow><annotation encoding="application/x-tex">I_d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>和<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mi>e</mi></msub></mrow><annotation encoding="application/x-tex">I_e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>,用于评估去简化效果和正确性</li><li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mi>d</mi></msub></mrow><annotation encoding="application/x-tex">I_d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>:从<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mi>u</mi></msub></mrow><annotation encoding="application/x-tex">I_u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>中随机选择10个输入,使其大小约等于实用工具输入的数量</li><li>额外的三个<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mi>d</mi></msub></mrow><annotation encoding="application/x-tex">I_d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>:分别占<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mi>u</mi></msub></mrow><annotation encoding="application/x-tex">I_u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>的<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>10</mn><mi mathvariant="normal">%</mi><mo separator="true">,</mo><mn>20</mn><mi mathvariant="normal">%</mi><mo separator="true">,</mo><mn>30</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">10\%,20\%,30\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9444em;vertical-align:-0.1944em;"></span><span class="mord">10%</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">20%</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">30%</span></span></span></span></eq>,并获得相应的<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mi>e</mi></msub></mrow><annotation encoding="application/x-tex">I_e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>集合,以评估输入大小与简化效果之间的关系</li></ul></li><li><p>为了评估基于相关输入的通用性，我们针对不同的程序使用了不同的方法来识别相关输入。</p><ul><li>对于接受带选项的命令行输入的程序（例如bzip2），如果它们使用相同的选项集，我们认为两个输入是相关的，这种方法类似于Razor [49]的评估中所使用的方法。</li><li>对于bash和vim，提供的输入已经使用标签标记了它们所使用的功能（例如，算术功能的标签为“arith”）。因此，对于这些输入，我们使用标签来确定它们之间的相关性。</li><li>对于所有其他程序，即SSIR程序，我们认为所有输入都是相关的。</li></ul></li><li><p>为了评估鲁棒性,我们使用了Radamsa [53]和AFL [4]基于去除冗余代码的输入来生成一组模糊输入<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>𝐼</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">𝐼&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></eq></p></li></ul><h5 id="4.2.3-%E6%A0%A1%E9%AA%8C%E5%99%A8" tabindex="-1">4.2.3 校验器</h5><ul><li>我们使用校验器来评估程序的行为正确性和稳健性<ul><li>校验器比较 简化程序的输出和原始程序的输出</li><li>对于 实用程序,也要考虑程序的 退出值,打印的消息,所生成的文件;对于文件,会检查文件内容(必要时需要检查文件的权限)</li><li>对于SIR程序,使用其原始的对应的校验器;此外我们开发了一个校验器来评估鲁棒性</li><li>为了确定程序是否崩溃，oracle会检查一系列表示异常终止的退出代码</li></ul></li></ul><h4 id="4.3-%E9%85%8D%E7%BD%AE" tabindex="-1">4.3 配置</h4><h5 id="4.3.1-%E8%AF%84%E4%BC%B0%E6%96%B9%E6%B3%95" tabindex="-1">4.3.1 评估方法</h5><ul><li><p>对与每个实用程序 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span></eq>,获得10组输入,使用 去膨胀方法<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span></eq>基于 输入<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mi>d</mi></msub></mrow><annotation encoding="application/x-tex">I_d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>生成 简化程序<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>p</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">p&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></eq>测量这些程序的简化程度、通用性和权衡得分，并计算它们的平均值作为<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑇</mi></mrow><annotation encoding="application/x-tex">𝑇</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span></eq>所实现的得分。</p><ul><li>为了衡量c-generality，我们对于每个未用于去冗余的输入集合（共九组），执行<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>𝑝</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">𝑝&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></eq>，并计算<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>𝑝</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">𝑝&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></eq>正确行为的输入比例的平均值</li></ul></li><li><p>对于每个SIR程序 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span></eq>,使用 去膨胀方法<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span></eq>基于 输入<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mi>d</mi></msub></mrow><annotation encoding="application/x-tex">I_d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>生成 简化程序<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>p</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">p&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></eq>\</p><ul><li>基于测试输入<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mi>e</mi></msub></mrow><annotation encoding="application/x-tex">I_e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>评估<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>p</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">p&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></eq>的正确性</li><li>基于模糊测试输入和校验器<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>I</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">I&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></eq>评估<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>p</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">p&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></eq>的鲁棒性</li></ul></li></ul><h5 id="4.3.2-%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE" tabindex="-1">4.3.2 参数设置</h5><ul><li>使用默认参数运行 CHISEL,DEBOP,RAZOR<ul><li>由于CHISEL和DEBOP运行时间长,设置时间上限6h</li><li>RAZOR在四个级别上进行增强并进行实验</li></ul></li><li>对于CovF,从输入集选择最多100个输入,使用Radamsa为每个选定的输入生成10模糊测试输入进行去膨胀</li><li>对于CovA,试验了15个K值,比较不同的结果</li><li>为了衡量通用性,我们设置了10s的超时,因为一个去膨胀程序对一个输入可能不会停止</li></ul><h5 id="4.3.3-%E5%B9%B3%E5%8F%B0" tabindex="-1">4.3.3 平台</h5><ul><li>Ubuntu-18.04机器上运行的260GB RAM和32 AMD-Opteron 1.4GHz处理器,该机器需要超过284小时(11天)才能完成所有实验的去膨胀工作</li></ul><h4 id="4.4-%E6%8E%A2%E7%A9%B6%E9%97%AE%E9%A2%98%E4%B8%80%3A%E7%AE%80%E5%8C%96%E5%BA%A6%2C%E6%AD%A3%E7%A1%AE%E6%80%A7%E5%92%8C%E6%9D%83%E8%A1%A1" tabindex="-1">4.4 探究问题一:简化度,正确性和权衡</h4><p><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(1)_1_2.png" alt></p><h5 id="4.4.1-chisel%E5%92%8Cdebop%2Ccov-%E6%AF%94%E8%BE%83" tabindex="-1">4.4.1 CHISEL和DEBOP,COV 比较</h5><ul><li>CHISEL和DEBOP的正确性较低,低于0.6,即这两种方法容易产生过拟合的程序</li><li>Tradeoff中,CHISEL和DEBOP的基于大小的F-score较低,即这两种方法在正确性和简化度的平衡不如Cov</li><li>原因:<ul><li><ol><li>CHISEL基于增量调试,在删除代码时非常激进.但其增量调试费时,所以在大型程序上CHISEL无法修建大量不需要的代码</li></ol></li><li><ol start="2"><li>DEBOP依赖随机优化,基于Cov的代码再进行删除,因此DEBOP不会增加COV的正确性,但可以提高简化度,所以DEBOP会生产高简化度和低正确性的程序</li></ol></li></ul></li><li>对于实用程序,CHISEL和DEBOP移除的ROP gadgets比Cov多,导致RelAF和AllAF分数略高.(ROP gadgets，全称Return Oriented Programming gadgets，指的是一段以汇编指令&quot;ret&quot;结尾的一小段指令序列。这些 gadgets 可以被用来修改某些地址的内容，从而有效地控制程序的执行流程。本文即指攻击面)<ul><li>原因:<ul><li><ol><li>DEBOP和CHISEL在执行路径中删除语句,可以有效减少ROP gadgets</li></ol></li><li><ol start="2"><li>DEBOP将ROP gadgets的减少列为目标之一</li></ol></li></ul></li><li>对于大程序,由于CHISEL费时,其减少攻击面的能力降低</li></ul></li></ul><h5 id="4.4.2-covf%2C-cova%2C-and-others-%E6%AF%94%E8%BE%83" tabindex="-1">4.4.2 CovF, CovA, and others 比较</h5><ul><li>CovF和CovA的正确性高于Cov,CovA尤其明显,且CovA时正确性最高的方法;CovF更专注于鲁棒性,所以正确性较低于CovA</li><li>CovF和CovA的简化程度小于Cov,但在4.5中可以看到这两个方法可以在不影响简化程度的情况下显著提高程序通用性</li><li>CovF和CovA的基于攻击面的F分数较低,因为方法基于Cov,无法有效减少攻击面;优化Cov以减少攻击面,这可能是未来的一个研究方向</li></ul><h5 id="4.4.3-razor%E5%92%8C%E5%9F%BA%E4%BA%8E%E6%BA%90%E4%BB%A3%E7%A0%81%E7%9A%84%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83" tabindex="-1">4.4.3 RAZOR和基于源代码的方法比较</h5><ul><li>RAZOR时基于二进制的方法,其获得了高简化和高正确的分数,即其在两个基准测试中的大小和攻击面的F分都是最高的,原因是<ul><li><ol><li>指令级别的操作</li></ol><ul><li>因此RAZOR的搜索空间比基于源代码的大,能找到更多更好的权衡空间.</li><li>同时因为RAZOR能够在指令级别上修改编译器带来的冗余代码,将其和基于源代码的方法相比可能不恰当.</li><li>为此我们使用RAZOR基于覆盖率的方法(称为RazorCov)生成没有增强的简化程序,发现通过修建指令生成的程序内存大小和攻击面都比Cov小,从而有更大的增强空间</li></ul></li><li><ol start="2"><li>使用增强来补充输入中未被测试到的代码</li></ol></li></ul></li></ul><h5 id="4.4.5-%E5%9C%A8%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%8A%E7%9A%84%E6%AF%94%E8%BE%83" tabindex="-1">4.4.5 在小程序上的比较</h5><ul><li>Cov没有达到高简化分数和高F分数,CovA和CovF简化分数提高但F分依然不高.这似乎意味着基于源代码的方法在小型程序上的效果不好</li><li>Chisel和Debop简化分数和F分数都很高,因为程序搜索空间小. Razor因为基于二进制,所以简化分数和F分数都很高</li></ul><h4 id="4.5-%E6%8E%A2%E7%A9%B6%E9%97%AE%E9%A2%98%E4%BA%8C%3A%E7%AE%80%E5%8C%96%E5%BA%A6%2C%E9%B2%81%E6%A3%92%E6%80%A7%E5%92%8C%E6%9D%83%E8%A1%A1" tabindex="-1">4.5 探究问题二:简化度,鲁棒性和权衡</h4><p><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(1)_1_3.png" alt></p><ul><li><p>上图第二列展示了所有方法的平均鲁棒性分数,这些分数基于Radamsa生成的模糊输入计算而成.同时表格显示了三种 简化分数和权衡分数</p></li><li><p>结论</p><ul><li>CovF实现了最高的鲁棒性,并且简化分数和Cov并没有差太多</li><li>基于输入的方法对于未观察到的输入鲁棒性都很低,因为其去冗余的输入只反映了程序的典型使用情况</li><li>Razor生成的简化程序鲁棒性最低,且RazorCov的鲁棒性更低,其对输入过拟合严重<ul><li>原因:大多数程序中,Razor的增强与稳定性无关,只会追求更好的简化程度,这会排除一些防御性检查,如printf和exit等,</li></ul></li></ul></li><li><p>还使用了AFL [4] 评估测试每种方法生成的简化程序的鲁棒性,结果显示CovF具有最高的r-generality（0.87），其次是Chisel，其r-generality为0.75，其他方法的得分均为0.67。CovF也是实现最高基于大小的权衡得分的方法：SF为0.76，MF为0.71。这些结果进一步证实了CovF的有效性。</p></li><li><p>还使用Radamsa生成的模糊输入对SSIR中的所有小程序进行了测试，并发现对于这些程序，所有方法都实现了较高的r-generality，其中CovF的得分最高（0.96），而Razor的得分最低（0.88）。与我们在第4.4.4节中展示的情况类似，CovF和CovA使用的基于源代码的增强策略在小程序中往往是无效的，因为这些程序只能进行有限的代码减少。</p></li></ul><h4 id="4.6-%E6%8E%A2%E7%A9%B6%E9%97%AE%E9%A2%98%E4%B8%89%3A%E5%BD%93%E4%BD%BF%E7%94%A8%E8%B6%8A%E6%9D%A5%E8%B6%8A%E5%A4%9A%E7%9A%84%E8%BE%93%E5%85%A5%E8%BF%9B%E8%A1%8C%E7%B2%BE%E7%AE%80%E6%97%B6%EF%BC%8C%E6%89%80%E8%80%83%E8%99%91%E7%9A%84%E6%96%B9%E6%B3%95%E7%9A%84%E8%A1%A8%E7%8E%B0" tabindex="-1">4.6 探究问题三:当使用越来越多的输入进行精简时，所考虑的方法的表现</h4><ul><li>实验不同数量的输入时不同的简化方法的表现</li><li>使用SIR基准进行了这个实验,因为其有大量的测试集</li><li>对每个程序<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span></eq>,创建三个输入集<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>I</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>I</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">I_1,I_2,I_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>,其中<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mn>0</mn></msub><mo>⊂</mo><msub><mi>I</mi><mn>1</mn></msub><mo>⊂</mo><msub><mi>I</mi><mn>2</mn></msub><mo>⊂</mo><msub><mi>I</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">I_0\subset I_1 \subset I_2 \subset I_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>,并且<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>I</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>I</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">I_1,I_2,I_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>的大小分别为<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span></eq>的<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>10</mn><mi mathvariant="normal">%</mi><mo separator="true">,</mo><mn>20</mn><mi mathvariant="normal">%</mi><mo separator="true">,</mo><mn>30</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">10\%,20\%,30\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9444em;vertical-align:-0.1944em;"></span><span class="mord">10%</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">20%</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">30%</span></span></span></span></eq>,<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">I_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>是之前实验的10个输入集;使用这些输入集进行去膨胀,用剩下的输入集进行正确性评估,使用Radamsa生成的模糊输入进行鲁棒性评估</li></ul><p><img src="/images/%E8%AE%BA%E6%96%87/software%20debloating%20%E8%AE%BA%E6%96%87/(1)_1_4.png" alt></p><ul><li>上图展示了不同方法在减少（mred和aread）、通用性（allcgen, relcgen, 和 rgen）以及权衡（从mf-allcgen到af-rgen）方面的平均得分</li><li>结论<ul><li>当输入规模增大,简化分数会降低,但正确性会提高</li><li>当输入规模增大,鲁棒性不会显著提升,同时由于鲁棒性的增加少于代码的增加,对应的F分可能会下降</li></ul></li></ul><h4 id="4.7-%E6%8E%A2%E7%A9%B6%E9%97%AE%E9%A2%98%E5%9B%9B%3A%E8%BF%99%E4%BA%9B%E6%96%B9%E6%B3%95%E7%9A%84%E6%95%88%E7%8E%87" tabindex="-1">4.7 探究问题四:这些方法的效率</h4><ul><li>Chisel和Debop最耗时,平均需要4.7小时和5.4小时来生成一个去臃肿的程序</li><li>Razor、Cov和CovA的效率更高，平均只需要0.2分钟、0.4分钟和0.6分钟来生成一个去臃肿的程序。</li><li>因为基于覆盖的方法不需要像Chisel和Debop那样反复执行相同的输入</li><li>此外,增强过程也是高效的,除CovF需要模糊测试外,但也只要3.3分钟</li></ul><h4 id="4.8-%E8%AE%A8%E8%AE%BA" tabindex="-1">4.8 讨论</h4><ul><li><p>选择软件去膨胀方法的建议</p><ul><li>Razor在减少大小和c-通用性之间取得了良好的平衡，但生成的去臃肿程序可能存在鲁棒性问题，即在未观察到的输入上执行时可能会崩溃或无法终止。因此，如果鲁棒性很重要且程序源代码可用，用户应考虑使用基于源代码的方法。</li><li>其中，Cov是一种简单的方法，可以产生合理的结果。在鲁棒性是优先考虑的情况下，应该优先选择CovF。</li><li>相反，如果主要目标是高正确性通用性，用户应考虑使用CovA。</li><li>如果特别关注大小减小并且效率不是问题，Chisel是一个不错的选择，因为它的去臃肿过程可能需要花费几个小时才能完成，特别是对于大型程序。</li><li>最后，如果去臃肿的主要原因是减少攻击面，应该使用Debop。</li></ul></li><li><p>我们的研究证明了在去臃肿时考虑减少和通用性的重要性，并为在不显著降低减少程度的情况下提高通用性提供了解决方案</p></li><li><p>这里的一个困难是很难衡量实际的程序通用性并确定改进它的方法</p></li><li><p>另一个可能的研究方向是,探索一种 可以指导 ,基于输入的去膨胀方法的, 估计通用性的技术</p></li></ul><h4 id="4.9-%E6%9C%89%E6%95%88%E6%80%A7%E5%A8%81%E8%83%81" tabindex="-1">4.9 有效性威胁</h4><ul><li>内部威胁:使用了作者提供的Chisel、Debop和Razor的实现，并对我们实施的方法进行了仔细测试</li><li>外部威胁:评估基于一组包含10个Unix实用程序和15个SIR程序的数据集，我们收集了不同的输入集合。需要进行额外的实证研究来评估我们的结果是否适用于其他程序和输入。</li></ul><h3 id="05-%E7%9B%B8%E5%85%B3%E5%B7%A5%E4%BD%9C" tabindex="-1">05 相关工作</h3><ul><li><p>除基于输入的方法外,还有一些其它方法</p><ul><li>基于人工注释的特征规范,基于人工开发的领域采样,数据配置和调查 的方法</li><li>针对特定类型的应用程序的 (Chrome浏览器,Android应用程序)的方法</li><li>不移除不需要的功能,而是以来静态分析删除未使用的代码或裁剪指令和库的方法</li><li>在给定领域进行程序大小缩减(如容器,服务器系统,Java应用程序等)</li><li>或专注于特定任务(如安全性检查,API特化等)</li></ul></li><li><p>Cimplifier方法,特别是在对容器的去膨胀时,使用了类似于CovF的技术</p><ul><li>但CovF使用模糊测试提高程序鲁棒性,生成额外的输入</li><li>Cimplifier使用符号执行来获取额外的输入，以改善对所需系统资源的识别。</li></ul></li></ul><h5 id="%E5%88%86%E6%94%AF%2F%E8%B7%AF%E5%BE%84-%E9%A2%84%E6%B5%8B" tabindex="-1">分支/路径 预测</h5><ul><li>CovA于CovF的增强旨在简化程序中保留正确的代码,所以本文的研究也与 静态 分支/路径 预测有关<ul><li>但是,静态分支/路径预测的目标是提高程序的性能,而不是简化程序,所以他们不需要考虑简化和泛化的权衡</li><li>且原本预测更多基于 启发式方法和机器学习,本文预测 基于模糊测试和静态和动态分析</li></ul></li></ul><h5 id="%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB%E5%AE%9A%E4%BD%8D" tabindex="-1">特征识别定位</h5><ul><li>本文去膨胀算法依赖于一组输入来识别所需的特征及对应的代码,这与特征识别定位的方法有关,这些方法可以用于简化对程序的理解,对去膨胀算法有帮助</li></ul><h5 id="%E7%A8%8B%E5%BA%8F%E4%BF%AE%E5%A4%8D" tabindex="-1">程序修复</h5><ul><li>类似于去膨胀算法,依赖于一组测试用例来指定程序的正确行为.因此同样可能会出现过拟合并,或修复错误</li><li>解决此类问题的技术包括 生成新的测试用例,根据启发式方法优先考虑补丁,使用概率模型</li></ul><h3 id="06-%E7%BB%93%E8%AE%BA%E5%92%8C%E6%9C%AA%E6%9D%A5%E5%B7%A5%E4%BD%9C" tabindex="-1">06 结论和未来工作</h3><ul><li><p>以往的去膨胀方法主要关注于简化程序,而忽略了程序的通用性和鲁棒性,为了填补这一空白,本文进行了研究</p><ul><li><ol><li>将三种SOTA的去膨胀方法和基础方法应用于25个程序和这些程序不同的输入集</li></ol></li><li><ol start="2"><li>系统的评估了他们在 简化程度,泛化程度以及二者间权衡程度的比较</li></ol></li></ul></li><li><p>同时,本文提出了两个新的方法,实验证明了他们在不影响简化程度的情况下,在简化程度和泛化程度取得了更好的权衡</p></li><li><p>本文的研究还表明了不同方法间的优势和劣势,我们提供了一份指南帮助用户根据需求来选择最合适的去膨胀方法,同时我们的研究也为未来的研究提供了方向</p></li><li><p>未来工作</p><ul><li>如何根据程序大小,输入覆盖及其它因素动态调整简化的程度</li><li>通过包括更多程序,额外的模糊测试 进行鲁棒性评估</li><li>进行用户研究,评估在实际场景使用去膨胀技术的可行性</li><li>调查在工业实际中去膨胀方法的使用情况</li></ul></li></ul><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;studying-and-understanding-the-tradeoffs-between-generality-and-reduction-in-software-debloating&quot; tabindex=&quot;-1&quot;&gt;Studying and Underst</summary>
      
    
    
    
    <category term="论文" scheme="http://example.com/categories/%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="SoftwareEngineering" scheme="http://example.com/tags/SoftwareEngineering/"/>
    
    <category term="SoftwareDebloating" scheme="http://example.com/tags/SoftwareDebloating/"/>
    
  </entry>
  
  <entry>
    <title>准备开的新坑</title>
    <link href="http://example.com/2023/12/14/%E6%9D%82%E8%AE%B0/%E5%87%86%E5%A4%87%E5%BC%80%E7%9A%84%E6%96%B0%E5%9D%91/"/>
    <id>http://example.com/2023/12/14/%E6%9D%82%E8%AE%B0/%E5%87%86%E5%A4%87%E5%BC%80%E7%9A%84%E6%96%B0%E5%9D%91/</id>
    <published>2023-12-14T09:54:04.001Z</published>
    <updated>2023-12-14T09:56:47.749Z</updated>
    
    <content type="html"><![CDATA[<h2 id="%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%80%E6%96%B0%E5%9D%91" tabindex="-1">为什么要开新坑</h2><p>太摆了，还是想学点计算机技术</p><h2 id="%E5%9D%91" tabindex="-1">坑</h2><h3 id="webserver" tabindex="-1">WebServer</h3><p>想写一个WebServer，用C++写，可以看看nginx源码，或者先嫖个其他人的<a href="https://github.com/qinguoyi/TinyWebServer">github仓库</a>对着学</p><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%80%E6%96%B0%E5%9D%91&quot; tabindex=&quot;-1&quot;&gt;为什么要开新坑&lt;/h2&gt;
&lt;p&gt;太摆了，还是想学点计算机技术&lt;/p&gt;
&lt;h2 id=&quot;%E5%9D%91&quot;</summary>
      
    
    
    
    <category term="文章" scheme="http://example.com/categories/%E6%96%87%E7%AB%A0/"/>
    
    
    <category term="杂记" scheme="http://example.com/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>笔记本win11+ubuntu20双系统配置(包括显卡驱动和双显示器显示问题)</title>
    <link href="http://example.com/2023/11/27/%E6%9D%82%E8%AE%B0/win11+ubuntu20%E5%8F%8C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://example.com/2023/11/27/%E6%9D%82%E8%AE%B0/win11+ubuntu20%E5%8F%8C%E7%B3%BB%E7%BB%9F/</id>
    <published>2023-11-27T14:17:34.607Z</published>
    <updated>2023-11-27T14:17:34.607Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/%E6%9D%82%E8%AE%B0/(x)_x.png" alt></p><p>本文记录我使用win11笔记本使用外接固态硬盘配置ubuntu20.04双系统,并安装对应驱动和解决双显示器显示问题的过程.</p><ul><li>以下为需要硬件信息<ul><li>笔记本信息:win11 + i13-900HX + 4060 Laptop GPU</li><li>外接固态:512GB(现在固态都不太贵了,512GB 299元,1TB 499元)<ul><li>当然如果本机硬盘空间足够,可以不用外接固态,直接在本机硬盘上分区安装ubuntu</li></ul></li><li>一个空4GB以上的U盘</li></ul></li></ul><h2 id="1-%E5%AE%89%E8%A3%85%E5%8F%8C%E7%B3%BB%E7%BB%9F" tabindex="-1">1 安装双系统</h2><h3 id="(1)-%E4%B8%8B%E8%BD%BDubuntu20.04%E9%95%9C%E5%83%8F" tabindex="-1">(1) 下载Ubuntu20.04镜像</h3><p>前往<a href="https://ubuntu.com/#download">官网</a> 或镜像站下载(如<a href="https://mirrors.tuna.tsinghua.edu.cn/#">清华大学镜像网站</a>)</p><h3 id="(2)-%E5%88%B6%E4%BD%9C%E5%90%AF%E5%8A%A8%E7%9B%98" tabindex="-1">(2) 制作启动盘</h3><p>使用UtraISO工具制作启动盘,前往<a href="https://cn.ultraiso.net/xiazai.html">官网</a>下载<br><strong>一个4GB以上空的U盘,记得提前保存数据,启动盘会自动格式化</strong>,之后在电脑上插入U盘</p><ol><li>打开UltraISO,选择试用即可</li><li>选择菜单栏文件,选择下载好的ubuntu镜像<img src="/images/%E6%9D%82%E8%AE%B0/(1)_1.png" alt></li><li>选择菜单栏的启动-&gt;写入硬盘映像,选择下载好的ubuntu镜像;写入方式选择USB-HDD+,点击写入,等待写入完成<img src="/images/%E6%9D%82%E8%AE%B0/(1)_2.png" alt></li></ol><h3 id="(3)-%E4%B8%BA%E5%9B%BA%E6%80%81%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA" tabindex="-1">(3) 为固态磁盘分区</h3><p>电脑插入固态磁盘,使用DiskGenius工具分区,前往<a href="https://www.diskgenius.cn/download.php">官网</a>下载</p><ol><li>打开DiskGenius,选择固态磁盘,右键选择<strong>转换分区类型为GUID模式</strong>,<img src="/images/%E6%9D%82%E8%AE%B0/(1)_3.png" alt></li><li>磁盘分区,为ubuntu系统可以准备四个区,各区的文件类型可以在下载ubuntu系统时设置,这里主要是把各个分区大小定下来<ul><li><strong>ESP(0)分区</strong>:文件系统类型为FAT32,我这里大小分了16GB. 该分区用于linux系统的**/boot引导分区**,后续启动linux系统的引导文件会在该分区EFI目录中</li><li><strong>分区(1)</strong>:该分区为为交换空间,大小分配为16GB. 该分区用于linux系统的<strong>交换空间</strong>,linux系统会把一部分内存空间用于交换空间,用于内存不足时的临时存储</li><li><strong>分区(2)</strong>:该分区为linux系统的<strong>根目录,即/</strong>,大小分配为128GB. 该分区用于linux系统的<strong>根目录</strong>,linux系统的所有文件都会存储在该分区</li><li><strong>分区(3)</strong>:该分区为linux系统的<strong>home目录,即/home</strong>,大小分配为128GB. 该分区用于linux系统的<strong>home目录</strong>,linux系统的用户文件都会存储在该分区,后续可以再加</li><li>剩余空间可以正常当作移动硬盘使用</li></ul></li></ol><h3 id="(4)-ubuntu%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85" tabindex="-1">(4) Ubuntu系统安装</h3><ol><li>电脑同时插入U盘启动盘和移动固态硬盘</li><li>重启电脑进入BIOS界面,我的电脑是 惠普暗影精灵9,重启时多按F10键进入BIOS界面</li><li>进入BIOS界面后,设置启动优先级为U盘启动优先（下图中将开机顺序进行调整，可以上下拖动） <img src="/images/%E6%9D%82%E8%AE%B0/(1)_4.jpg" alt="(1)_4"></li><li>随后就进入安装Ubuntu界面. 安装Ubuntu-&gt;选择语言-&gt;正常安装-&gt;<strong>安装类型为&quot;其它选项&quot;(因为我们要安装到固态硬盘中)</strong><ul><li>接下来进入了选择分区界面,记住我们之前各分区的作用,选择对应的分区,点击<strong>更改</strong>按钮,设置分区的<strong>挂载点</strong>,<strong>分区格式</strong>,<strong>分区大小</strong><ul><li><strong>ESP(0)分区</strong>:挂载点为 <strong>/boot/efi</strong>,分区格式为<strong>FAT32</strong>,分区大小为<strong>16GB</strong>,分区类型为<strong>EFI系统分区</strong></li><li><strong>分区(1)</strong>:挂载点为<strong>无</strong>,分区格式为<strong>swap</strong>,分区大小为<strong>16GB</strong></li><li><strong>分区(2)</strong>:挂载点为 <strong>/</strong>,分区格式为<strong>ext4</strong>,分区大小为<strong>128GB</strong> (如果这里不设置好根目录,会无法进入下一步)</li><li><strong>分区(3)</strong>:挂载点为 <strong>/home</strong>,分区格式为<strong>ext4</strong>,分区大小为<strong>128GB</strong></li><li>剩余空间可以正常当作移动硬盘使用</li></ul></li><li>随后再点击下一步即可</li></ul></li></ol><h3 id="(5)-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98" tabindex="-1">(5) 常见问题</h3><ol><li>因为是使用移动硬盘安装,所以再拔掉移动硬盘启动电脑时,因为检测不到linux系统,会进入grub界面,即一个命令行界面,在当前界面也可以进入win11系统,但是每次都要手动输入一些命令,比较麻烦<ul><li>所以我们每次启动电脑时还是先插着固态硬盘启动,进入到选择系统界面,随后进入win11后再拔掉固态硬盘,这样就不会进入grub界面了.</li><li>就算进入到grub界面,可以先插入固态硬盘,随后输入<code>exit</code>命令,就会重新进入选择操作系统的界面了</li></ul></li></ol><h2 id="2-%E5%AE%89%E8%A3%85%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8" tabindex="-1">2 安装显卡驱动</h2><p>这里是大坑，最好还是通过本机apt下载，在此之前需要几个准备工作</p><h3 id="(1)-%E7%A6%81%E7%94%A8-nouveau" tabindex="-1">(1) 禁用 nouveau</h3><ol><li>打开黑名单</li></ol><pre><code class="language-bash">sudo vim /etc/modprobe.d/blacklist-nouveau.conf</code></pre><ol start="2"><li>添加以下内容</li></ol><pre><code class="language-bash">blacklist nouveauoptions nouveau modeset=0</code></pre><ol start="3"><li>更新内核</li></ol><pre><code class="language-bash">sudo update-initramfs -u</code></pre><ol start="4"><li>重启电脑</li></ol><pre><code class="language-bash">sudo reboot</code></pre><ol start="5"><li>查看是否禁用成功</li></ol><pre><code class="language-bash">lsmod | grep nouveau</code></pre><p>如果没有输出则说明禁用成功</p><h3 id="(2)-%E5%85%B3%E9%97%AD-sercuity-boot" tabindex="-1">(2) 关闭 sercuity boot</h3><p>在下图中将安全启动关闭，否则会导致无法安装显卡驱动</p><p><img src="/images/%E6%9D%82%E8%AE%B0/(1)_4.png" alt></p><h3 id="(3)-%E4%B8%8B%E8%BD%BD%E9%A9%B1%E5%8A%A8" tabindex="-1">(3) 下载驱动</h3><ol><li>添加ppa源</li></ol><pre><code class="language-bash">sudo add-apt-repository ppa:graphics-drivers/ppa</code></pre><ol start="2"><li>为系统安装依赖项</li></ol><pre><code class="language-bash">sudo apt updatesudo apt-get install dkms build-essential</code></pre><ol start="3"><li>查看可用的显卡驱动</li></ol><pre><code class="language-bash">ubuntu-drivers devices</code></pre><p>效果如下，可以看到很多版本的驱动，我们可以看到一个<code>recommended</code>字样，这是推荐的版本，我们可以选择这个版本，但需要注意的是，这个版本不一定最好，其区别如下</p><ul><li>NVIDIA Driver 535 Server Open： 这是专为服务器环境设计的开放版本的NVIDIA驱动程序，它具有一些特定于服务器的功能或优化，以提供更好的性能和稳定性。</li><li>NVIDIA Driver 535： 这是通用版本的NVIDIA驱动程序，适用于大多数NVIDIA显卡和桌面/笔记本电脑系统，它能提供广泛的兼容性和功能，并支持各种应用程序和游戏。</li><li>NVIDIA Driver 535 Open： 这是开源版本的NVIDIA驱动程序，针对那些希望在开放源代码环境下自定义和修改驱动程序的用户，它能提供更多的灵活性和可定制性。</li></ul><p>所以我们可以选择NVIDIA Driver 535版本即可，不需要Server或者Open版本，兼容性更好一些</p><p><img src="/images/%E6%9D%82%E8%AE%B0/(1)_6.png" alt></p><ol start="4"><li>安装对应的显卡驱动</li></ol><pre><code class="language-bash">sudo apt install nvidia-driver-535</code></pre><ol start="5"><li>重启电脑</li></ol><pre><code class="language-bash">sudo reboot</code></pre><ol start="6"><li>查看显卡驱动是否安装成功</li></ol><pre><code class="language-bash">nvidia-smi</code></pre><p>如果安装成功，会显示如下信息<br>！<a href="/images/%E6%9D%82%E8%AE%B0/(1)_7.png"></a></p><h2 id="3-%E5%8F%8C%E6%98%BE%E7%A4%BA%E5%99%A8%E9%97%AE%E9%A2%98" tabindex="-1">3 双显示器问题</h2><p>在安装完显卡驱动后，插入第二个屏幕，但是终端通过<code>xrandr</code>查看，或在设置中查看，都只能看到本机的屏幕</p><p>这是因为默认状态下只是用集成显卡，所以我们需要设置为独立显卡优先，我们在BIOS中设置即可</p><p>在下图中将显卡切换设置为discrete graphics，之后在打开ubuntu可以发现双显示器已经可以正常使用了<br><img src="/images/%E6%9D%82%E8%AE%B0/(1)_5.png" alt></p><h2 id="%E6%80%BB%E7%BB%93" tabindex="-1">总结</h2><p>以上便是我安装双系统的过程，最费时间的是3双显示器问题，网络上很多资料都是认为是驱动问题，但最后看到了一个帖子，发现他设置了BIOS中的显卡设置，之后就可以正常使用了，我这里也一样，希望这篇文章可以帮助到你</p><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/%E6%9D%82%E8%AE%B0/(x)_x.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;本文记录我使用win11笔记本使用外接固态硬盘配置ubuntu20.04双系统,并安装对应驱动和解决双显示器显示问题的过程.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以</summary>
      
    
    
    
    <category term="文章" scheme="http://example.com/categories/%E6%96%87%E7%AB%A0/"/>
    
    
    <category term="杂记" scheme="http://example.com/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>On java 8 基础卷（15-21章）</title>
    <link href="http://example.com/2023/11/12/PL/On%20java8%E5%9F%BA%E7%A1%80%E5%8D%B715-21/"/>
    <id>http://example.com/2023/11/12/PL/On%20java8%E5%9F%BA%E7%A1%80%E5%8D%B715-21/</id>
    <published>2023-11-12T06:36:42.496Z</published>
    <updated>2023-11-27T14:32:38.288Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/PL/OnJava8/x_x.jpg" alt></p><h2 id="15-%E5%BC%82%E5%B8%B8" tabindex="-1">15 异常</h2><ul><li>Java的基本哲学:写得不好的代码无法运行</li></ul><h3 id="15.1-%E6%A6%82%E5%BF%B5" tabindex="-1">15.1 概念</h3><ul><li>C 语言和其他较早的语言往往有多种错误处理机制，这类机制通常是通过约定建立的，而不是作为编程语言的一部分。</li><li>异常可以降低错误处理代码的复杂性<ul><li>如果没有异常,就必须检查某个特定的错误并加以处理,可能要在程序多个地方进行</li><li>而异常可以确保有人会捕捉他们,并且只需在一个地方进行处理</li></ul></li></ul><h3 id="15.2-%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%BC%82%E5%B8%B8" tabindex="-1">15.2 基本的异常</h3><ul><li><strong>异常情况</strong>:指组织当前方法或作用域继续执行的问题.</li><li>需要区分普通问题和异常<ul><li>普通问题:当前上下文有足够的信息解决问题</li><li>异常:当前上下文没有足够的信息处理问题,因此需要跳出当前上下文,将问题委托给更上层的上下文</li></ul></li><li>当抛出一个异常时,会发生以下几件事</li></ul><ol><li>异常对象创建,使用new创建,放在堆上</li><li>当前执行路径停止,指向这个异常对象的引用被从上下文中推出</li><li>异常处理机制接管控制,寻找异常处理程序</li></ol><h4 id="%E5%BC%82%E5%B8%B8%E5%8F%82%E6%95%B0" tabindex="-1">异常参数</h4><ul><li>和Java其它对象一样,使用new在堆上创建异常,其会分配存储空间并调用构造器<ul><li>所有标准异常类有连个构造器,一个无参构造器,第二个接收一个String参数,用于放置在异常中放置的相关信息</li></ul></li></ul><pre><code class="language-java">if(t == null)    throw new NullPointerException(&quot;t = null&quot;);</code></pre><ul><li>关键词throw有意思<ul><li>使用new创建异常对象后,使用throw将其返回,这种返回类似于return,但是不会返回任何值,而是指示程序退出当前执行路径</li><li>此外可以抛出任何类型的 Throwable(异常类型的根类),通常错误信息就包含在异常类型的名字中</li></ul></li></ul><h3 id="15.3-%E6%8D%95%E6%8D%89%E5%BC%82%E5%B8%B8" tabindex="-1">15.3 捕捉异常</h3><ul><li><strong>被守护区域</strong>:一段可能产生异常的代码,后面跟着处理异常的代码</li></ul><h4 id="try-%E5%9D%97" tabindex="-1">try 块</h4><ul><li>try块包含了异常可能发生的代码,这样在代码抛出异常后,异常处理机制就能捕获它</li><li>用类似C这样不支持异常处理的语言编写的库,需要依赖临时的机制报告错误. 有了异常处理,可以把所有的内容放在一个try块中,并在一个地方捕获所有异常,意味着代码更容易编写和阅读,因为代码的正确执行目的不会被错误检查所混淆</li></ul><pre><code class="language-java">try &#123; // 可能会产生异常的代码&#125;</code></pre><h4 id="%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F" tabindex="-1">异常处理程序</h4><ul><li>异常处理程序紧跟在 try 块之后，用关键字 catch 来表示。</li></ul><pre><code class="language-java">try &#123; // 可能会产生异常的代码&#125; catch(Type1 id1) &#123; // 处理 Type1 类型的异常&#125; catch(Type2 id2) &#123; // 处理 Type2 类型的异常&#125; catch(Type3 id3) &#123; // 处理 Type3 类型的异常&#125;</code></pre><ul><li>每个catch子句(异常处理程序)像一个小方法,接收且只接收一个特定类型的参数. 标识符(id1,id2)可以在处理程序中使用,它们引用了抛出异常对象的引用</li><li>异常处理程序需要紧跟在try块后,一个异常抛出后,异常处理机制和寻找参数和异常类型相匹配的一个处理程序,然后进入catch子句,我们就认为这个异常被处理</li></ul><h4 id="%E7%BB%88%E6%AD%A2%E4%B8%8E%E6%81%A2%E5%A4%8D" tabindex="-1">终止与恢复</h4><ul><li><p>在异常处理理论中,有两种基本模型</p><ul><li><strong>终止模型 termination</strong>:异常处理程序不试图修复错误,而是终止程序运行. Java支持终止模型</li><li><strong>恢复模型 resumption</strong>:异常处理程序负责纠正错误,并重新尝试调用错误产生的方法. 支持恢复模型意味着我们仍然希望在处理完异常后继续执行</li></ul></li><li><p>如果想在Java中达到恢复模型的效果,可以把try块放在一个while循环中,不断重新进入try块直到结果令人满意</p></li><li><p>从历史上看,最终仍是使用终止模型,因为恢复模型将导致耦合,使得代码难以编写和维护</p></li></ul><h3 id="15.4-%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%BC%82%E5%B8%B8%E7%B1%BB" tabindex="-1">15.4 创建自己的异常类</h3><ul><li>通常,异常类都是继承自Exception类,或者继承自Exception的某个子类<ul><li>一个异常最重要的是其类名</li></ul></li></ul><pre><code class="language-java">class SimpleException extends Exception &#123;&#125;public class InheritingExceptions &#123;  public void f() throws SimpleException &#123;    System.out.println(      &quot;Throw SimpleException from f()&quot;);    throw new SimpleException();  &#125;  public static void main(String[] args) &#123;    InheritingExceptions sed =      new InheritingExceptions();    try &#123;      sed.f();    &#125; catch(SimpleException e) &#123;      System.out.println(&quot;Caught it!&quot;);    &#125;  &#125;&#125;/* Output:Throw SimpleException from f()Caught it!*/</code></pre><ul><li>也可以创建一个接收String参数的异常类</li></ul><pre><code class="language-java">class MyException extends Exception &#123;  MyException() &#123;&#125;  MyException(String msg) &#123; super(msg); &#125;//调用父类的构造器,Exception的构造器接收一个String参数,同时Exception继承自Throwable&#125;public class FullConstructors &#123;  public static void f() throws MyException &#123;    System.out.println(&quot;Throwing MyException from f()&quot;);    throw new MyException();  &#125;  public static void g() throws MyException &#123;    System.out.println(&quot;Throwing MyException from g()&quot;);    throw new MyException(&quot;Originated in g()&quot;);  &#125;  public static void main(String[] args) &#123;    try &#123;      f();    &#125; catch(MyException e) &#123;      e.printStackTrace(System.out);//Throwable的printStackTrace()方法,打印异常栈轨迹,这里将其输出到System.out,如果使用无参版本,则会将其输出到System.err    &#125;    try &#123;      g();    &#125; catch(MyException e) &#123;      e.printStackTrace(System.out);    &#125;  &#125;&#125;/* Output:Throwing MyException from f()MyException        at FullConstructors.f(FullConstructors.java:11)        atFullConstructors.main(FullConstructors.java:19)Throwing MyException from g()MyException: Originated in g()        at FullConstructors.g(FullConstructors.java:15)        atFullConstructors.main(FullConstructors.java:24)*/</code></pre><h4 id="%E5%BC%82%E5%B8%B8%E5%92%8C%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95" tabindex="-1">异常和日志记录</h4><ul><li>可以使用java.util.logging工具将输出记录到日志中</li></ul><p>略</p><h3 id="15.5-%E5%BC%82%E5%B8%B8%E8%AF%B4%E6%98%8E" tabindex="-1">15.5 异常说明</h3><ul><li><strong>异常声明exception specificaton</strong> 为方法声明的组成部分,出现在参数列表之后. 可以语法礼貌地告诉程序员这个方法会抛出的异常</li></ul><pre><code class="language-java">void f() throws TooBig, TooSmall, DivZero &#123; // ...</code></pre><ul><li>而以下写法意味着这个方法不会抛出异常(除了从<em>RuntimeExecption</em>继承而来的异常,这样的异常可以从任何地方抛出而不要异常说明)</li></ul><pre><code class="language-java">void f() &#123; // ...</code></pre><ul><li>Java保证在编译时提供一定程度的异常正确性,即如果方法中出现了异常,要么处理这个异常,要么使用异常说明指明这个异常可能会被抛出<ul><li>这种在编译时被检查并强制实施的异常叫做<strong>检查型异常(checked exception)</strong></li></ul></li></ul><h3 id="15.6-%E6%8D%95%E6%8D%89%E4%BB%BB%E4%BD%95%E5%BC%82%E5%B8%B8" tabindex="-1">15.6 捕捉任何异常</h3><ul><li>通过捕捉异常类型的基类Exception,可以捕捉任何异常. 使用时需要放到处理列表的最后,避免在其他异常处理程序之前捕获了异常</li></ul><pre><code class="language-java">catch(Exception e) &#123; System.out.println(&quot;Caught an exception&quot;);&#125;</code></pre><ul><li>Exception类是所有对程序员很重要的异常类的基类,因此我们不能从他得到太多信息,我们可以通过调用其基类Throwable的方法来获取信息<ul><li>getMessage()方法返回异常对象的详细信息</li><li>getLocalizedMessage()方法返回异常对象的本地化信息</li><li>toString()方法返回异常对象的类型和详细信息</li><li>以下方法打印Throwable的调用栈轨迹,调用栈显示了异常抛出的地方,以及异常传播的路径<ul><li>printStackTrace(),打印到标准错误流</li><li>printStackTrace(PrintStream),打印到指定流</li><li>printStackTrace(PrintWriter),打印到指定流</li></ul></li></ul></li></ul><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/PL/OnJava8/x_x.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;15-%E5%BC%82%E5%B8%B8&quot; tabindex=&quot;-1&quot;&gt;15 异常&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Java的基本哲学:写得不好的代码无法运行&lt;/li</summary>
      
    
    
    
    <category term="读书笔记" scheme="http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>P2PFaaS</title>
    <link href="http://example.com/2023/08/16/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BA%E6%96%87/P2PFaaS/"/>
    <id>http://example.com/2023/08/16/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BA%E6%96%87/P2PFaaS/</id>
    <published>2023-08-16T13:48:11.677Z</published>
    <updated>2023-06-06T01:30:08.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.sciencedirect.com/science/article/pii/S2352711022002084">论文连接</a></p><h2 id="0-%E6%91%98%E8%A6%81" tabindex="-1">0 摘要</h2><p>在边缘和雾计算环境中，通常会设计和测试实施调度和负载均衡解决方案的分布式算法。通常适用于该环境的操作范式要求用户调用最近的节点来执行任务，并且由于服务必须在一组节点之间分布，使用FaaS（函数即服务）的无服务器范式是最有前景的策略。基于这些前提条件，我们设计并实现了一个名为P2PFaaS的框架。该框架基于Docker容器构建，允许在一组节点之间实现完全分散的调度或负载均衡算法。通过依赖三个基本服务，即调度服务、发现服务和学习器服务，该框架允许实现任何类型的调度解决方案，即使基于强化学习。最后，该框架提供了一个即插即用的解决方案，可以在x86服务器和基于ARM的边缘节点（例如树莓派）上安装和测试。</p><h2 id="%E8%BD%AF%E4%BB%B6%E6%8F%8F%E8%BF%B0" tabindex="-1">软件描述</h2><h3 id="1.1-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84" tabindex="-1">1.1 软件架构</h3><p><img src="/images/%E8%AE%BA%E6%96%87/P2PFaaS/%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt></p><ul><li>调度器服务在端口18080上监听，并作为框架的入口，客户端可以通过REST API请求执行函数。</li><li>学习器服务在端口19020上监听，并实现了用于调度器服务进行调度决策的强化学习模型的训练和推断。</li><li>发现服务在端口19000上监听，并实现了节点的发现。</li></ul><h3 id="1.2-%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B" tabindex="-1">1.2 操作流程</h3><p><img src="/images/%E8%AE%BA%E6%96%87/P2PFaaS/%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B.PNG" alt></p><ol><li>客户端调用URL请求执行一个函数</li><li>采取操作（这里如果配置了基于RL的调度器，需将当前状态传递给 学习器服务，然后获得操作）</li><li>开始操作<ol><li>可将请求转发到另一节点，通过http来调用</li><li>可将请求加入本地队列等待执行</li><li>拒绝请求</li></ol></li><li>最终的函数执行通过向函数的容器发出http来调用，执行完毕后，输出数据转发给客户端</li><li>如果调度器基于RL，此时可进行模型的训练，调整模型参数</li></ol><h4 id="%E8%B0%83%E5%BA%A6%E6%9C%8D%E5%8A%A1" tabindex="-1">调度服务</h4><p>调度器模块是用Go语言编写的。选择这种编程语言是因为它专门为Web服务器的开发而设计。<br><img src="/images/%E8%AE%BA%E6%96%87/P2PFaaS/%E8%B0%83%E5%BA%A6%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.jpg" alt></p><ul><li><p>API模块：API模块在调度器服务中扮演重要角色，它处理来自客户端的API请求。</p><ul><li>首先，它负责准备函数执行请求，包括根据请求参数和配置信息构建请求，并将其传递给实际的调度器进行处理。</li><li>其次，API模块还负责为配置更新准备有效载荷，即根据客户端的请求更新调度器的配置信息。</li></ul></li><li><p>调度服务容器启动时，会启动两个线程</p><ul><li>Web服务器线程：负责处理HTTP API调用</li><li>工作线程：负责管理内部任务队列</li></ul></li><li><p>调度器模块</p><ul><li>设计目的：允许调度算法的可互换性，为此设置了调度接口，可以完成调度算法的实例化和配置<pre><code class="language-Go">type scheduler interface &#123;GetFullName() stringGetScheduler() *types.SchedulerDescriptorSchedule(req *types.ServiceRequest) (*JobResult, error)&#125;</code></pre></li><li>调度函数实现对函数执行请求的有效调度，可以采取三种可能操作<ul><li>拒绝请求：返回HTTP错误码500并关闭客户端请求</li><li>在当前节点执行请求：在本地进行排队</li><li>将请求转发到其它节点：再次使用调度函数来调度请求，但这次请求标记为“External”，请求的转发通过&quot;API/Peer&quot;模块实现</li></ul></li></ul></li><li><p>队列模块：限制并行运行函数的数量，通常所说的节点中可以执行的并行任务数量的参数称为K。队列由一个实现生产者-消费者模式的线程管理。</p><ul><li>采用上述方式实现的队列限制了并行性，针对没有相关计算能力的边缘设备</li><li>这种队列的设计与M/M/1/K和M/M/K/K队列模型相匹配，这些模型可以帮助设计者确定最佳的系统参数，以实现所需的性能和可靠性。</li></ul></li><li><p>FaaS管理器模块：负责将函数执行请求转发到正确的FaaS函数容器。</p><ul><li>该模块允许进一步解耦，可以使用不同的FaaS容器技术</li><li>Docker自动完成将容器名称转换为FaaS容器的IP地址名称解析</li><li>该模块保证请求被正确地路由到相应的FaaS容器，从而实现高效的函数执行。</li></ul></li><li><p>配置器模块：管理启动时的配置（称为 “静态”）和运行时的配置（称为 “动态”）</p></li><li><p>日志模块：过多的日志记录可能会减慢服务速度并增加任务的延迟</p></li><li><p>调度器服务模块和学习器服务模块：实现服务间的交互</p></li></ul><h4 id="%E5%AD%A6%E4%B9%A0%E5%99%A8%E6%9C%8D%E5%8A%A1" tabindex="-1">学习器服务</h4><p><img src="/images/%E8%AE%BA%E6%96%87/P2PFaaS/%E5%AD%A6%E4%B9%A0%E5%99%A8%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.jpg" alt></p><ul><li><p>该服务实现强化学习模型，用于进行调度决策</p></li><li><p>强化学习模型分为三个实体</p><ul><li>状态：以字符串形式编码，包含当前节点的负载</li><li>动作：被映射为调度动作</li><li>奖励：奖励驱动学习过程，可以取决于总任务的时间<ul><li>例如，如果任务在特定时间完成，可以给予正面奖励，为此，需要客户端能够训练模型，因为只有当函数输出到达客户端才能知道最终延迟</li></ul></li></ul></li><li><p>学习实体：封装成一个数据结构，包括</p><ul><li>EID：一个递增的编号</li><li>状态：一个字符串</li><li>动作：一个浮点数</li><li>奖励：一个浮点数</li></ul></li><li><p>学习线程：学习过程由学习线程执行，它负责在所有所需的实体都存在时延迟训练。（这里不是很懂强化学习）</p></li><li><p>训练模型：跳了</p></li></ul><h4 id="%E5%8F%91%E7%8E%B0%E6%9C%8D%E5%8A%A1" tabindex="-1">发现服务</h4><ul><li>使用Go语言编写，目的是让节点了解他的邻居。</li><li>该服务基于八卦算法（gossip algorithm）在启动时必须通过另一个节点的IP（称为“初始服务器”）进行配置。</li></ul><h2 id="%E5%BD%B1%E5%93%8D" tabindex="-1">影响</h2><ul><li><p>这项工作中提出的P2PFaaS框架可能是第一个开源可用的框架，它通过采用完全去中心化（对等）方案，实现了节点之间的分布式调度和负载平衡算法的实现。</p></li><li><p>该框架对于该领域的研发人员(设计和测试实施调度和负载均衡解决方案的分布式算法),可以用于测试设计的算法是否能够在真实设备上进行可能的实现，，以及在哪些条件下它们可以工作</p></li><li><p>由于代码的可移植性，P2PFaaS也很容易在多个SoC计算机（如树莓派）上部署，通过利用OpenBalena来避免使用虚拟机，以便在真实计算机设备上测试算法</p></li><li><p>在真实设备上测试这种类型的算法对研究和特别是算法设计有明显的影响。真实环境的一系列条件和特殊特征往往无法通过模拟和数学模型轻易掌握。</p></li></ul><h2 id="%E7%BB%93%E8%AE%BA" tabindex="-1">结论</h2><ul><li><p>本论文中，我们介绍了P2PFaaS框架，这是一个软件套件，可用于在一组真实节点之间测试和评估调度和负载均衡算法。我们展示了该框架的基本特点，包括模块化、可移植性以及通过设计的接口轻松更改核心调度算法的可能性。我们还详细介绍了组成框架的三个服务：调度器、学习器和发现服务。</p></li><li><p>对该框架的进一步改进主要朝着两个方向进行。</p><ul><li>第一个方向是改进服务迁移的管理，通过支持动态函数分配和可用性来实现。</li><li>第二个方向涉及绿色边缘计算，目前正在开发额外的模块，以允许评估考虑节点能量方面的调度和负载均衡算法。</li></ul></li></ul><h2 id="%E4%B8%93%E6%9C%89%E5%90%8D%E8%AF%8D%E7%90%86%E8%A7%A3" tabindex="-1">专有名词理解</h2><h3 id="%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E5%92%8C%E9%9B%BE%E8%AE%A1%E7%AE%97" tabindex="-1">边缘计算和雾计算</h3><ul><li><p>边缘计算（Edge Computing）侧重于将计算和数据处理推向物理世界的边缘，即接近数据生成源头的位置。边缘计算将计算任务和数据处理分布在边缘设备、边缘节点或边缘服务器上，以实现低延迟、实时性和快速响应的数据处理。它强调将计算资源尽可能靠近数据源，以减少数据传输延迟和网络拥塞，并支持一些特定的边缘应用场景，如智能交通、物联网、智能工厂等。边缘计算更注重在边缘节点上进行本地计算和决策，将关键的数据处理任务尽可能地下沉到边缘，减少对云端的依赖。</p></li><li><p>雾计算（Fog Computing）是一种介于边缘和云之间的计算模型，弥补了边缘设备和云数据中心之间的距离。雾计算引入了中间层的雾节点（Fog Node）或边缘节点（Edge Node），这些节点位于边缘设备和云数据中心之间，用于处理边缘设备生成的数据和提供边缘服务。雾计算的目标是解决传统云计算模型中的一些挑战，如高延迟、带宽限制和网络拥塞。它通过将计算和存储资源推向边缘，减少数据传输到云端的时间，提供更快速的数据处理和更高带宽的支持。</p></li><li><p>虽然边缘计算和雾计算有一些相似之处，例如将计算资源放置在边缘设备附近、提供低延迟的数据处理等，但也存在一些区别：</p><ul><li><p>范围和位置：边缘计算更注重在物理世界的边缘部署计算资源，即离数据生成源头较近的位置。而雾计算更关注于边缘设备和云数据中心之间的中间层，即雾节点，这些节点位于边缘和云之间的位置。</p></li><li><p>任务分发和处理：边缘计算侧重于在边缘节点上进行本地计算和决策，将关键的数据处理任务下沉到边缘。而雾计算更倾向于在雾节点上进行边缘设备生成数据的处理和分析，同时提供边缘服务。</p></li><li><p>应用场景：边缘计算更适用于对实时性、低延迟和快速响应有较高要求的应用场景，如智能交通、物联网等。而雾计算更关注于在边缘设备和云之间提供更灵活和高效的计算模型，适用于智能城市、工业物联网等场景。</p></li></ul></li></ul><p>综上所述，边缘计算和雾计算都是为了满足分布式计算需求而提出的模型，它们在计算资源的位置、任务分发和处理方式以及适用的应用场景上有一些不同。根据具体的应用需求和场景特点，可以选择合适的计算模型来满足需求。</p><h3 id="websocket%E6%B1%A0" tabindex="-1">WebSocket池</h3><ul><li><p>WebSocket池（WebSocket Pool）是一种管理和复用WebSocket连接的机制。在使用WebSocket与服务器进行实时通信时，每次创建和关闭WebSocket连接都会产生一定的开销，特别是在高并发场景下，频繁创建和关闭连接可能会对服务器的性能和资源造成负担。</p></li><li><p>为了避免频繁地创建和关闭WebSocket连接，可以使用WebSocket池来管理这些连接。WebSocket池维护一组预先创建的WebSocket连接，并在需要时将连接提供给应用程序使用，而不是每次都重新创建连接。当应用程序完成使用后，连接会被放回池中，以备下次使用。</p></li><li><p>WebSocket池的好处包括：</p><ul><li>减少连接创建和关闭的开销：通过复用连接，可以减少每次创建和关闭连接所需的时间和资源消耗，提高服务器的性能和资源利用率。</li><li>提高响应速度：由于连接已经建立，可以立即开始进行通信，而不需要等待连接建立的时间，从而减少了通信的延迟。</li><li>控制连接数：通过维护连接池，可以限制并发连接的数量，避免服务器过载或资源耗尽的情况发生。</li></ul></li></ul><h3 id="go%E8%AF%AD%E8%A8%80" tabindex="-1">Go语言</h3><ul><li>Go语言（也称为Golang）是一种开源编程语言，由Google开发。它具有高效的并发性能和内置的网络库，使其非常适合构建高性能的Web服务器和分布式系统。Go语言的设计目标之一是简单易用，同时也注重代码的可读性和可维护性。</li><li>调度器模块的编写采用Go语言，这意味着该模块可以利用Go语言的特性和生态系统，快速地处理并发请求、提供网络服务，并具备良好的性能和可靠性。通过使用Go语言编写调度器模块，可以更容易地构建可扩展的、高效的Web服务器，并实现可靠的任务调度和资源分配功能。</li></ul><h3 id="m%2Fm%2F1%2Fk%E5%92%8Cm%2Fm%2Fk%2Fk%E9%98%9F%E5%88%97%E6%A8%A1%E5%9E%8B" tabindex="-1">M/M/1/K和M/M/K/K队列模型</h3><p>M/M/1/K和M/M/K/K队列模型是用于描述排队系统的数学模型。</p><ul><li>其中&quot;M&quot;代表到达率和服务率都是随机的泊松分布，&quot;1&quot;代表只有一个服务台，&quot;K&quot;代表系统容量，即队列的最大长度。当队列长度达到K时，新到达的请求将被拒绝。</li><li>在M/M/K/K模型中，&quot;K&quot;代表服务台的数量，即系统可以同时服务的最大请求数量。</li><li>这些模型可以用于评估系统的性能，并帮助设计者确定最佳的系统参数，以实现所需的性能和可靠性。</li></ul><h3 id="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0" tabindex="-1">强化学习</h3><ul><li>强化学习（Reinforcement Learning）是一种机器学习的分支，其目标是通过代理与环境的交互来学习最优行为策略。在强化学习中，代理通过观察环境的状态并执行动作，从环境中接收奖励信号来评估其行为的好坏，然后根据奖励信号调整其策略，以最大化长期累积奖励。</li><li>强化学习的核心概念包括状态（State）、动作（Action）、奖励（Reward）和策略（Policy）：<ul><li>状态（State）：代表环境的当前情况或特征。它可以是离散的或连续的，并且通常由观察到的环境信息来表示。</li><li>动作（Action）：代理在给定状态下可以执行的操作或决策。动作可以是离散的或连续的，具体取决于问题的性质。</li><li>奖励（Reward）：代表代理在执行动作后从环境中获得的即时反馈。奖励可以是正面的、负面的或零，用于指导代理的学习过程。</li><li>策略（Policy）：代理的策略定义了在给定状态下选择动作的方式。策略可以是确定性的（确定选择一个动作）或概率性的（以一定概率选择不同的动作）。</li></ul></li><li>强化学习的核心挑战是在未知环境中通过与环境的交互来学习最优策略。代理通过尝试不同的动作，并根据获得的奖励信号来调整策略。在学习过程中，代理会通过探索（Exploration）和利用（Exploitation）的权衡来平衡对新动作的探索和对已知高奖励动作的利用。</li><li>强化学习方法包括基于值函数的方法（如Q-learning和Sarsa）和基于策略的方法（如Policy Gradient和Actor-Critic）。近年来，深度强化学习（Deep Reinforcement Learning）结合了深度神经网络和强化学习的方法，使得代理能够从原始感知输入中学习，并在复杂的任务中取得了重大突破。</li><li>强化学习在许多领域有着广泛的应用，包括机器人控制、游戏玩法、自动驾驶、金融交易等。它具有通过与环境的交互学习最优策略的能力，使得它成为解决许多复杂问题的有效工具。</li></ul><h3 id="%E5%85%AB%E5%8D%A6%E7%AE%97%E6%B3%95%EF%BC%88gossip-algorithm%EF%BC%89" tabindex="-1">八卦算法（gossip algorithm）</h3><ul><li>八卦算法（Gossip Algorithm）是一种分布式算法，用于在一个大规模的系统中进行信息传播和共享。它的设计灵感来源于人们在日常生活中进行谣言传播的行为，因此得名为&quot;八卦算法&quot;。</li><li>八卦算法的基本思想是通过节点之间的随机通信来传播信息。每个节点都维护一个局部的信息视图，包含了一部分已知节点的信息。在每一轮通信中，节点随机选择一个邻居节点，并向其发送自己所知道的信息。接收节点会将发送节点的信息与自己已知的信息进行合并，并将自己所知的信息继续传播给其他随机选择的邻居节点。通过不断的随机通信和信息传播，整个系统中的节点逐渐将信息进行共享，从而达到全局信息的一致性。</li><li>八卦算法的特点和优势包括：<ul><li>去中心化：八卦算法不依赖于中心节点或全局控制节点，每个节点都可以进行信息的传播和接收，从而实现了去中心化的通信和共享。</li><li>随机性：算法中的随机选择邻居节点的步骤使得信息能够快速传播到整个系统中，同时避免了某些节点成为瓶颈或集中点。</li><li>容错性：八卦算法具有一定的容错性，即使在系统中存在一些故障节点或通信延迟，整个系统仍然能够保持信息的传播和一致性。</li><li>可扩展性：八卦算法适用于大规模系统，随着节点数量的增加，算法的性能和效果并不会显著下降。</li></ul></li><li>八卦算法在分布式系统中有广泛的应用，例如数据复制、一致性维护、状态同步等。它提供了一种简单而有效的方式来实现节点之间的信息共享和传播，并在分布式环境中实现了一致性和可靠性。</li></ul><h3 id="soc%E8%AE%A1%E7%AE%97%E6%9C%BA" tabindex="-1">Soc计算机</h3><ul><li><p>SoC（System-on-a-Chip）计算机是一种集成了处理器、内存、存储、通信接口和其他相关组件的单芯片计算机系统。它将多个功能单元集成到一个芯片上，具有较小的尺寸和较低的功耗。SoC计算机通常用于嵌入式系统、移动设备和物联网应用中，因为它们提供了高度集成和高效的计算能力。</p></li><li><p>树莓派（Raspberry Pi）是一种知名的SoC计算机，由树莓派基金会开发。它以其低成本、小巧的尺寸和广泛的可扩展性而受到广泛关注。树莓派计算机具有基于ARM架构的处理器、内存、存储、通信接口和各种输入输出端口，可以运行不同的操作系统和应用程序。由于其易于使用和开放的设计，树莓派成为学习计算机科学和物联网开发的理想平台之一。</p></li></ul><h3 id="openbalena" tabindex="-1">OpenBalena</h3><ul><li>OpenBalena是一个开源的物联网平台，用于管理和部署容器化应用程序到大规模的嵌入式设备集群，其中包括树莓派等SoC计算机。它是Balena（<a href="http://xn--Resin-dq1hk7vmw4k.io">前身为Resin.io</a>）的开源版本，旨在提供一个灵活的解决方案，使开发者能够轻松地管理和远程部署应用程序到物联网设备。</li><li>通过OpenBalena，用户可以创建和管理设备群组、监控设备状态、远程部署应用程序、执行设备管理任务等。它提供了一套完整的工具和API，使得将应用程序部署到物联网设备变得简单和可扩展。</li><li>使用OpenBalena可以极大地简化物联网设备的管理和部署过程，尤其对于大规模的设备集群而言。它提供了可视化的界面和命令行工具，使用户能够轻松地管理和监控设备，同时支持自动化部署和更新应用程序。</li></ul><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.sciencedirect.com/science/article/pii/S2352711022002084&quot;&gt;论文连接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;0-%E6%91%98%E8%A6%81&quot; tabindex=&quot;-1&quot;&gt;0 </summary>
      
    
    
    
    <category term="论文" scheme="http://example.com/categories/%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="边缘计算" scheme="http://example.com/tags/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97/"/>
    
    <category term="Faas" scheme="http://example.com/tags/Faas/"/>
    
    <category term="ServerLess" scheme="http://example.com/tags/ServerLess/"/>
    
    <category term="雾计算" scheme="http://example.com/tags/%E9%9B%BE%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>FaaS Execution Models for Edge Applications</title>
    <link href="http://example.com/2023/08/16/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BA%E6%96%87/FaaS%20Execution%20Models%20for%20Edge%20Applications/"/>
    <id>http://example.com/2023/08/16/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BA%E6%96%87/FaaS%20Execution%20Models%20for%20Edge%20Applications/</id>
    <published>2023-08-16T13:48:11.674Z</published>
    <updated>2023-06-06T02:46:48.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://arxiv.org/pdf/2111.06595.pdf" alt="论文连接"></p><h2 id="0-%E6%91%98%E8%A6%81" tabindex="-1">0 摘要</h2><ul><li><p>在这篇论文中，我们解决了在边缘网络中支持基于函数即服务（FaaS）模型的有状态工作流的问题。</p></li><li><p>特别是我们关注数据传输问题，由于某些边缘场景中通信链路速度有限，这可能成为性能瓶颈。为此，我们提出了三种不同的方案：</p><ul><li>纯FaaS实现</li><li>StateProp（应用状态在整个函数链中传播）</li><li>以及StateLocal（状态仅保留在运行函数的工作节点上，需要时进行检索）。</li></ul></li><li><p>然后，我们将提出的方案扩展到应用程序建模为有向无环图（DAG）的更一般情况，这种建模方法涵盖了广泛的实际应用场景，例如物联网（IoT）领域。</p></li><li><p>我们的贡献通过原型实现进行了验证。在模拟条件下的实验表明，应用数据本地化原则显著减少了所需的网络流量并改善了端到端的延迟性能，尤其是在边缘节点上进行本地缓存和低链路速度的情况下。</p></li></ul><h2 id="1-%E4%BB%8B%E7%BB%8D" tabindex="-1">1 介绍</h2><ul><li>这篇论文中，我们针对有状态函数工作流中的数据传输问题（包括参数/返回值和应用状态）</li><li>以第2节中介绍的实际应用案例为动机进行了研究，</li><li>在回顾现有技术（第3节）之后，</li><li>我们在我们之前的工作中总结了研究结果（第4节），提出了三种完全去中心化的执行模型：PureFaaS、StateProp和StateLocal</li><li>第5节中，这些模型扩展到将应用程序建模到DAG的更一般情况</li><li>第6节中比较他们的性能</li><li>第7节中得出结论</li></ul><h2 id="2-%E5%8A%A8%E6%9C%BA%EF%BC%9A%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B" tabindex="-1">2 动机：实际应用案例</h2><ul><li><p>一个用于智慧城市的实时分析框架，与几个高影响的应用相关</p><ul><li>自动检测异常交通情况</li><li>检测拥挤区域</li><li>保护脆弱人群</li><li>公共事件中的情绪识别等</li></ul></li><li><p>这些应用程序有着相似的总体结构<img src="/images/%E8%AE%BA%E6%96%87/FaaS%20Execution%20Models%20for%20Edge%20Application/%E6%A1%88%E4%BE%8B%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84.jpg" alt></p><ul><li>从传感器获取数据开始，首先进行匿名化处理以删除个人数据，然后提取相关特征并用于触发基于机器学习（ML）的决策过程。</li><li>此时普通的Serverless不能在这里采用，原因<ul><li><ol><li>无状态执行是不够的：一些组件需要对程序状态进行读写访问</li></ol></li><li><ol start="2"><li>FaaS支持函数链，但这里工作流程为DAG</li></ol></li></ul></li></ul></li><li><p>这些应用的状态可以保存在3个位置</p><ul><li><ol><li>本地客户端</li></ol></li><li><ol start="2"><li>边缘节点</li></ol></li><li><ol start="3"><li>云端</li></ol></li></ul></li><li><p>而对于这些可保存状态的文职，随着传感器获得数据大小的增加，3个位置时延的增加有所不同<img src="/images/%E8%AE%BA%E6%96%87/FaaS%20Execution%20Models%20for%20Edge%20Application/%E6%A1%88%E4%BE%8B%E6%97%B6%E5%BB%B6.jpg" alt></p><ul><li>云端时延最高，且随着状态的增大而显著增大</li><li>状态在边缘或者客户端维护时，没有明显增加，但事实需要更高的网络流量成本</li></ul></li><li><p>综上：由DAG状态函数组成的数据密集型应用程序（例如实时智慧城市分析）的性能在很大程度上取决于状态的存储位置，而这也是本文研究的主题。</p></li><li><p>DAG状态应用程序并不是特殊情况，依据阿里巴巴数据中心的生产系统中收集的真实云应用程序的跟踪信息：</p><ul><li>由DAG组成的占21.7%</li><li>单个任务28.6%</li><li>链占49.7%</li></ul></li></ul><h2 id="3-%E7%9B%B8%E5%85%B3%E5%B7%A5%E4%BD%9C" tabindex="-1">3 相关工作</h2><ul><li>云中的无服务器平台依赖于底层容器编排系统，这些系统处理自动缩放并负责保持一致的性能。然而，当在边缘使用这些编排工具时，设备是异构且集群化的，这会导致低效的性能。</li><li>支持有状态应用程序是云中无服务器计算定位文件中确定的关键研究挑战之一</li><li>目前，边缘网络中的有状态FaaS在很大程度上尚未被探索，这是我们的动机，探索不同的方法来处理函数调用的链和DAG的参数和状态分配。在实际部署中，可以将复杂的状态管理系统与我们在本文中提出的执行模型结合使用。</li><li>之后再补充</li></ul><h2 id="4-%E6%9C%89%E7%8A%B6%E6%80%81%E7%9A%84%E5%87%BD%E6%95%B0%E9%93%BE" tabindex="-1">4 有状态的函数链</h2><p><img src="/images/%E8%AE%BA%E6%96%87/FaaS%20Execution%20Models%20for%20Edge%20Application/%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9E%8B.jpg" alt></p><ul><li>图中共有四个边缘节点，表示为ni，每个节点都托管一个无服务器平台，可以通过一组工作节点执行一个或多个类型的Lambda函数，表示为λi。例如，n1可以执行Lambda函数λ1和λ4，但不能执行λ2和λ3。</li></ul><p><img src="/images/%E8%AE%BA%E6%96%87/FaaS%20Execution%20Models%20for%20Edge%20Application/%E7%A4%BA%E4%BE%8B%E7%94%A8%E6%88%B7%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F.jpg" alt></p><ul><li>考虑上图的示例用户应用程序<ul><li>客户端需要将输出提供给λ1</li><li>λ1需要应用状态SA，其输出out1需要提供λ2</li><li>以此类推，最终输出out4返回客户端</li></ul></li><li>在云中，有状态函数通过访问外部服务（例如内存数据库或存储服务）来实现无状态函数。然而这种方法在边缘上并不高效，由此提出三种方法，下列方法中假设函数分配为：[λ1，λ2，λ3，λ4] → [n1，n4，n2，n1]。</li></ul><p><img src="/images/%E8%AE%BA%E6%96%87/FaaS%20Execution%20Models%20for%20Edge%20Application/PureFaaS%E6%96%B9%E6%B3%95.jpg" alt></p><ul><li>PureFaaS中，函数链中的函数一个接一个地执行，并且每次调用时都会来回传输每个函数所需的状态，如上图示，只要满足以下两个条件，就可以在商业/开源的无服务器平台上轻松实现此策略<ul><li><ol><li>函数的签名（包括参数和返回值）支持客户端嵌入所需的状态</li></ol></li><li><ol start="2"><li>客户端事先知道每个下一个被调用的函数所需的状态。</li></ol></li></ul></li></ul><p><img src="/images/%E8%AE%BA%E6%96%87/FaaS%20Execution%20Models%20for%20Edge%20Application/StateProp%E6%96%B9%E6%B3%95.jpg" alt></p><ul><li>StateProp中，它利用了大多数无服务器平台提供的链式功能，如上图示，客户端将应用程序的完整状态嵌入到函数的参数和返回值中：不使用嵌入状态的函数将简单地将其传递，而其他函数将将接收到的修改后的状态作为函数参数嵌入，并最终返回给客户端。</li></ul><p><img src="/images/%E8%AE%BA%E6%96%87/FaaS%20Execution%20Models%20for%20Edge%20Application/StateLocal%E6%96%B9%E6%B3%95.jpg" alt></p><ul><li>StateLocal将状态保留在边缘节点中,如上图所示，不是将状态嵌入到函数调用中，而是仅传递指针。<ul><li>当一个Lambda函数需要状态时，它通过指针检索状态，然后成为状态的新所有者，从而修改链中后续函数调用中的状态指针。</li><li>这样，客户端最终将返回所有状态的更新指针列表，以便在后续应用程序执行中使用它们，或者在需要时从边缘节点中撤回状态。</li></ul></li></ul><h2 id="5-%E6%89%A9%E5%B1%95%E5%88%B0dag" tabindex="-1">5 扩展到DAG</h2><h3 id="5.1-dag%E7%89%B9%E5%AE%9A%E7%AC%A6%E5%8F%B7%E8%A1%A8%E7%A4%BA" tabindex="-1">5.1 DAG特定符号表示</h3><p><img src="/images/%E8%AE%BA%E6%96%87/FaaS%20Execution%20Models%20for%20Edge%20Application/%E4%BE%9D%E8%B5%96%E5%9B%BE1.jpg" alt></p><ul><li>一组任务之间的关系：如果任务λi必须在任务λj之前执行，则存在边λi → λj。这些先行关系定义了一个有向图，称为任务依赖图，最后形成DAG</li><li>任务也可能依赖某些状态：态依赖图是一个无向图，其中边λi → Sx表示任务λj需要访问状态Sx。任务依赖图和状态依赖图的并集生成任务-状态依赖图；如上图示</li></ul><p><img src="/images/%E8%AE%BA%E6%96%87/FaaS%20Execution%20Models%20for%20Edge%20Application/%E4%BE%9D%E8%B5%96%E5%9B%BE2.jpg" alt></p><ul><li><p>在应用程序的单次执行过程中，可能会出现多个任务需要在同一状态上操作的情况，就像上图中的示例一样。根据应用程序的内部逻辑，可能会出现以下情况</p><ul><li><ol><li>执行顺序无关紧要</li></ol></li><li><ol start="2"><li>λ2必须在λ3之前执行</li></ol></li><li><ol start="3"><li>λ3必须在λ2之前执行</li></ol></li></ul></li><li><p>服务器无状态平台需要从应用程序中了解依赖于共享状态的任务的执行时间顺序，以保持状态的因果一致性。为此，我们通过以下方式来捕捉这种时间顺序，将任务-状态依赖图进行扩展：</p><ul><li>如果λi和λj都使用相同的状态，并且λi必须在λj之前执行以确保共享状态的因果一致性，我们添加一个虚拟边λi → λj，虚线表示，如上图示。</li></ul></li><li><p>添加虚拟边会影响可以实现的并行性：没有状态依赖关系的情况下，在上图中的DAG可以执行为{λ1, λ2 | λ3, λ4}（其中|表示两个任务可以并行执行）</p><ul><li>但在下图中需要虚拟边λ4 → λ2，但这会创建循环λ2 → λ3 → λ4，从而导致死锁：λ4无法执行，直到它接收到λ3的输出，而λ3无法运行，直到它接收到λ2的输出，而λ2在λ4执行完成之前无法访问状态S.</li><li>由于应用程序可以检测到这种情况，并且这反映了逻辑设计问题，因此我们假设我们感兴趣的应用程序仅限于具有非循环的扩展任务-状态依赖图。<br><img src="/images/%E8%AE%BA%E6%96%87/FaaS%20Execution%20Models%20for%20Edge%20Application/%E4%BE%9D%E8%B5%96%E5%9B%BE3.jpg" alt></li></ul></li></ul><h3 id="5.2-purefaas%E6%A8%A1%E5%9E%8B%E6%89%A9%E5%B1%95" tabindex="-1">5.2 PureFaaS模型扩展</h3><ul><li>PureFaaS在链式函数调用和DAG中的使用方式保持不变，除了可以并行执行一些任务外。类似于拓扑排序，下图为示例</li></ul><p><img src="/images/%E8%AE%BA%E6%96%87/FaaS%20Execution%20Models%20for%20Edge%20Application/PureFaaS%E6%A8%A1%E5%9E%8B%E6%8B%93%E5%B1%951.jpg" alt><br><img src="/images/%E8%AE%BA%E6%96%87/FaaS%20Execution%20Models%20for%20Edge%20Application/PureFaaS%E6%A8%A1%E5%9E%8B%E6%8B%93%E5%B1%95.jpg" alt></p><h3 id="5.3-stateprop%2Fstatelocal%E6%A8%A1%E5%9E%8B%E6%89%A9%E5%B1%95" tabindex="-1">5.3 StateProp/StateLocal模型扩展</h3><ul><li><p>StateProp和StateLocal都依赖于工作节点在当前函数完成后调用下一个函数；它们在状态管理方面有所区别：StateProp沿着函数调用链传递状态，而StateLocal将状态保留在最后使用它的边缘节点内部。</p></li><li><p>首先，一个任务可能有多个输入，比如λ2和λ3都希望在各自的任务结束后执行λ4，因此“每个函数执行下一个函数”的概念并不像链式函数那样明确定义。我们通过引入异步调用的概念来解决这个问题：当一个函数终止时，它总是调用下一个函数（根据DAG的直接后继），但只有在所有输入都可用时才触发任务的执行。(这里相当于拓朴排序)</p><ul><li>如果情况不是这样，则前一个函数的输出暂时存储在边缘节点上，函数会暂停执行<img src="/images/%E8%AE%BA%E6%96%87/FaaS%20Execution%20Models%20for%20Edge%20Application/5_3_1.jpg" alt></li><li>上图中的模式，增加了边缘节点上服务器无状态平台的复杂性，因为它们必须为每个不完整的操作维护一个临时状态。</li><li>但这种异步调用本身并不能解决问题：当λ2和λ3不同时调用n4节点的λ4时，将发生死锁</li></ul></li><li><p>因此，为了支持StateProp/StateLocal，至少在DAG应用的单个执行期间，所有工作节点都需要知道函数与边缘节点之间的映射关系。这样，我们可以确保所有工作节点将在相同的边缘节点上调用后续任务的执行，这将带来以下影响</p><ul><li><ol><li>函数与边缘节点之间的映射信息必须沿着执行DAG传递，这会略微增加协议开销</li></ol></li><li><ol start="2"><li>必须有一个能够在DAG被调用时“解析”所有函数的过程（例如，可以由客户端完成），这可能会增加启动延迟</li></ol></li></ul></li><li><p>但仍不够支持StateProp/StateLocal，如果λ2和λ3都依赖于相同的状态S。无论相对顺序如何，都需要将由第一个要执行的函数（例如λ2）修改的更新状态传递给另一个函数（例如λ3）。但是两者之间没有调用路径，即λ3不是DAG中λ2的后代，这使得仅仅依靠状态传播变得不可能。因此，提出第二个修改</p><ul><li>不再将状态嵌入函数参数（或其引用，对于StateLocal而言）</li><li>而是每个访问状态的函数将其直接发送给下一个将使用它的工作节点，根据状态依赖图和因果一致性约束，这两者已经是已知的。</li><li>因此，函数的工作节点必须准备好不仅接收异步调用并临时存储其参数，还要存储更新的状态，这些状态也是异步到达的。</li></ul></li></ul><p><img src="/images/%E8%AE%BA%E6%96%87/FaaS%20Execution%20Models%20for%20Edge%20Application/5_3_2.jpg" alt></p><ul><li>上图是同PureFaaS解决的依赖图中StateProp/StateLocal的顺序图，两者之间唯一的区别在于对于StateLocal，状态必须从最后的所有者中检索</li></ul><p><img src="/images/%E8%AE%BA%E6%96%87/FaaS%20Execution%20Models%20for%20Edge%20Application/5_3_3.jpg" alt></p><ul><li><p>上表为所有方案的流量交换</p></li><li><p>总结：StateProp和StateLocal可以支持DAG应用程序，但需要进行以下主要修改：</p><ul><li>工作节点必须支持异步函数调用</li><li>在单个DAG执行期间，函数和边缘节点之间的绑定必须为所有工作节点所知，而状态不能随参数一起传播</li></ul></li><li><p>这些变化增加了在边缘节点上运行的软件的复杂性和协议开销，并加剧了可能存在的有关披露专有信息的担忧</p></li></ul><h2 id="6-%E8%A1%A8%E7%8E%B0%E8%AF%84%E4%BC%B0" tabindex="-1">6 表现评估</h2><h3 id="6.1-%E6%89%A7%E8%A1%8C" tabindex="-1">6.1 执行</h3><ul><li><p>在ServerlessOnEdge框架中实现这三种方案</p><ul><li>该框架是一个分布式的调度无状态FaaS函数的框架</li><li>有论文团队开发和维护</li><li>在github开源</li></ul></li><li><p>在该框架中</p><ul><li>客户端通过e路由器调用请求函数</li><li>同时e路由器在无服务平台上充当中间人的角色，将无状态请求转发到根据负载和网络条件可用的多个目的地之一</li><li>实现了e计算机，它可以模拟具有特定配置的无服务器平台，包括计算速度、内存、容器数量等</li><li>ServerlessOnEdge使用谷歌的gRPC进行客户端、e路由器和e计算机之间的通信。</li></ul></li><li><p>PureFaaS的实现</p><ul><li><ol><li>客户端在每个函数调用时将所需的状态嵌入参数中</li></ol></li><li><ol start="2"><li>e计算机将嵌入的状态作为函数返回值的一部分返回</li></ol></li><li><ol start="3"><li>如果满足先决条件，会调用多个函数（仅适用于DAG）</li></ol></li></ul></li><li><p>StateProp的实现</p><ul><li><ol><li>实现异步调用：立即返回空的确认消息，而真正的输出由链中的最后一个e计算机作为主动回应消息提供给客户端</li></ol></li><li><ol start="2"><li>在每个e计算机上安装了一个附带的e路由器，用于调度由其e计算机生成的函数调用作为函数链的一部分执行，这样系统中的每个e计算机可以知道链中下一个函数的目的地</li></ol></li></ul></li></ul><p><img src="/images/%E8%AE%BA%E6%96%87/FaaS%20Execution%20Models%20for%20Edge%20Application/6_1_1.jpg" alt></p><ul><li><p>上图展示了StateProp的实现</p><ul><li λ1, λ4>图中共有5个边缘节点(主机1到主机5)，调用两个函数链</li><li>客户端在主机0上，主机0上e路由器被客户端用于调用链中的第一个函数（λ1，转发到主机1）</li><li>主机1上的e路由器接收到对λ4的下一次调用（转发到主机4）</li><li>主机4上的e计算机不需要经过其附带的e路由器，因为它可以将最终响应发送给主机0上的客户端</li></ul></li><li><p>StateLocal要求与StateProp相同，但还需要需他的一些升级</p><ul><li><ol><li>系统消息必须支持远程状态，即不直接嵌入函数调用/响应中的状态，而是通过它们的名称和端点间接引用</li></ol></li><li><ol start="2"><li>状态由称为状态服务器的新组件进行管理，它们是与每个e计算机和客户端共存的简单内存键值存储</li></ol></li><li><ol start="3"><li>消息流与StateProp完全相同，但在每个函数调用时，e计算机检索所需的远程状态，然后将其复制到本地状态服务器中；为了做到这一点，状态依赖性也嵌入在函数调用请求消息中。</li></ol></li></ul></li></ul><h3 id="6.2-%E7%BB%93%E6%9E%9C" tabindex="-1">6.2 结果</h3><ul><li>进行了两批实验，分别是函数链和有向无环图（DAG）</li></ul><h4 id="%E5%87%BD%E6%95%B0%E9%93%BE%EF%BC%9A" tabindex="-1">函数链：</h4><ul><li>实验条件：<ul><li>客户端执行长度为L（3或6）的函数链</li><li>其中每个函数随机选择自λ1、…、λ5，并可能重复。</li><li>我们假设应用程序有S个状态（3或6），其中第i个状态的大小为（1+i）×10 kB（以0为基的索引）；</li><li>每个状态依赖于随机选择的随机基数从0（无依赖关系）到L（链中的所有函数都依赖于该状态）。</li><li>输入参数和返回值的大小被假设为相同，并且等于A（10 kB或100 kB）。一组函数<br><img src="/images/%E8%AE%BA%E6%96%87/FaaS%20Execution%20Models%20for%20Edge%20Application/6_2_1.jpg" alt></li></ul></li><li>如上图示，将在各个场景中使用不同执行模型获得的平均端到端延迟进行了比较，其中网络设备之间的链路速率从1 Mb/s增加到100 Mb/s。<ul><li>在左上角的图中<ul><li>PureFaaS和StateProp几乎重叠：这是因为状态和参数的大小相对较小；</li><li>直到链路速率低于20 Mb/s，StateLocal具有更低的平均延迟，这要归功于其更智能的仅在需要时传输状态的方法</li><li>然而，随着链路速率的提高，优势逐渐减小，直到延迟高于50 Mb/s和100 Mb/s链路速率下PureFaaS/StateProp的延迟：在如此高的连接速率下，数据传输变得与（或高于）建立TCP连接来检索/更新状态的时间相当</li></ul></li><li>在相反的情况，即右下角的图中<ul><li>StateProp和StateLocal的性能相当</li><li>除了在高链路速率下：这是因为链条比其他情景中的链条要短，数据传输由输入/输出参数主导，这两种方案的处理是一样的</li></ul></li><li>右上图和左下图是中间状况<ul><li>StateLocal在所有较慢的链路速率下都实现了更好的性能</li><li>而PureFaaS始终位于StateProp的顶部。</li></ul></li></ul></li><li>总结：<ul><li>对于函数链，考虑到实际的协议开销，根据状态大小和网络速度，存在将状态保持在边缘节点（StateLocal）和将其嵌入到函数调用中之间的权衡。</li><li>StateProp的性能始终优于PureFaaS。<br><img src="/images/%E8%AE%BA%E6%96%87/FaaS%20Execution%20Models%20for%20Edge%20Application/6_2_2.jpg" alt></li></ul></li><li>对比函数链时，三种模型中的平均网络流量,如上图，此时链路速度100Mb/s，时StateLocal表现最差的时候<ul><li>PureFaaS生成的流量始终大于StateProp生成的流量，而后者始终大于StateLocal生成的流量</li><li>对于函数链，即使在高网络速度下，StateLocal的开销（以所需的流量速率为衡量）明显低于其他方案，但这并不总是转化为更低的端到端延迟。</li></ul></li></ul><h3 id="dag" tabindex="-1">DAG</h3><ul><li>考虑由一系列阶段组成的应用程序，每个阶段都有一个分支函数，该函数生成多个无状态调用，然后是一个有状态的收集任务。这种结构在ML应用程序中非常典型</li><li>我们使用了3个阶段，每个阶段有5个分支。函数是从边缘节点中随机选择的，状态依赖关系也是随机的，使用与链式结构相同的方法。<br><img src="/images/%E8%AE%BA%E6%96%87/FaaS%20Execution%20Models%20for%20Edge%20Application/6_2_3.jpg" alt></li><li>在上图中，展示了平均延迟随链路速率从1 Mb/s增加到100 Mb/s的变化（对数-对数图），以及仅针对链路速率为100 Mb/s的网络流量<ul><li>我们发现PureFaaS在所有情况下都优于StateProp，且在参数大小较小时优势更为突出。这是因为调用的总函数数量远远超过链式情况，这会严重影响将所有状态嵌入到调用和响应中。</li><li>StateLocal不需要支付这样的代价，它只传递状态的引用，并在除了非常高的链路速率之外的所有情况下表现最好，这是由于状态检索/更新操作的开销</li></ul></li><li>总结：对于具有大量函数的DAG，只有在函数调用和响应中携带引用时，状态传播才有效，即StateLocal更有效</li></ul><h2 id="7-%E7%BB%93%E8%AE%BA" tabindex="-1">7 结论</h2><ul><li>在本文中，我们探讨了在分布在边缘节点上的无服务器平台上支持有状态应用程序的问题。</li><li>我们重点关注在链式和DAG工作流中沿函数调用传递状态的问题，并提出了三种不同特性的替代方案。</li><li>我们开发了一个原型实现来验证我们的方法的可行性，并使用真实的协议开销来衡量性能。</li><li>结果表明，在函数调用链中传播状态可以显著减少通信开销。这可以降低端到端的应用程序延迟，尤其是在连接有限的情况下。</li><li>然而，对于大型DAG工作流，再嵌入状态以进行传播就不再有效了：在这些情况下，必须在边缘节点上本地存储状态并传递它们的引用。</li></ul><h2 id="%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD" tabindex="-1">专业术语</h2><h3 id="faas-%26-serverless" tabindex="-1">FaaS &amp; Serverless</h3><p>FaaS是一种云计算模型，其中开发者可以编写和部署独立的函数（代码块），并通过云服务提供商的平台执行这些函数。FaaS允许开发者根据需要执行函数，而无需管理底层的服务器和基础设施。每个函数都是独立的、无状态的，以事件驱动的方式触发执行。开发者只需关注函数的实现，而不用担心服务器的管理和扩展性。</p><p>Serverless是一种更广泛的概念，它是构建在FaaS模型之上的。Serverless强调开发者无需关心服务器和基础设施，只需专注于编写代码和业务逻辑。在Serverless架构中，云服务提供商负责自动扩展和管理底层的资源。开发者只需支付根据函数执行时间和资源消耗计算的费用，而无需事先预留或管理服务器。</p><p>FaaS和Serverless提供了更灵活、可扩展的开发和部署方式，使开发者能够更专注于核心业务逻辑而不必担心基础设施的细节。它们在构建微服务、事件驱动应用和处理短暂任务等场景中得到广泛应用，为开发者提供了高度可伸缩、成本效益高的解决方案。</p><h3 id="%E6%97%A0%E7%8A%B6%E6%80%81faas" tabindex="-1">无状态FaaS</h3><ul><li>无状态FaaS指的是函数即服务（FaaS）模型中的一种特性，即函数本身不存储任何状态信息。在无状态FaaS中，每个函数都是独立的、无状态的，它们被设计成接收输入参数并生成输出结果，而不会在函数之间保留任何状态信息。</li><li>这种设计有助于实现函数的高度可伸缩性和灵活性。由于函数本身不存储状态，它们可以独立地扩展和部署，而无需关心底层的服务器和基础设施。此外，无状态函数对于并行执行和容错性也更具优势，因为它们之间没有任何依赖或共享状态。</li><li>然而，无状态FaaS也意味着对于那些需要在函数之间共享和保持状态的应用程序来说，需要依赖外部服务（例如存储或数据库）来管理和存储状态信息。因此，无状态FaaS适用于那些可以通过函数的输入和输出进行完全描述的简单任务或短期计算，而对于复杂的应用程序或需要持久状态的任务，则可能需要其他机制来处理状态管理和共享。</li></ul><h3 id="k8s" tabindex="-1">K8s</h3><ul><li>Kubernetes（通常简称为K8s）是一个开源的容器编排平台，用于自动化部署、扩展和管理容器化应用程序。它提供了一组强大的功能和工具，帮助用户简化容器化应用程序的部署、扩展和运维工作。</li><li>以下是Kubernetes的一些主要特性和概念：<ul><li>容器编排：Kubernetes可以管理和编排容器化的应用程序，使其能够高效地运行在集群中的多个节点上。它可以自动在集群中的节点之间调度容器，并确保应用程序的高可用性和负载均衡。</li><li>自动伸缩：Kubernetes允许根据应用程序的负载情况自动扩展或缩减应用程序的副本数量。这样可以根据实际需求来调整资源的使用，以保证应用程序的性能和可用性。</li><li>服务发现和负载均衡：Kubernetes提供了内建的服务发现机制，可以为应用程序提供稳定的网络地址。同时，它还可以通过负载均衡来分发流量，确保应用程序能够平均地处理请求。</li><li>配置和存储管理：Kubernetes提供了灵活的配置管理机制，可以将应用程序的配置信息与容器分离，使得配置的修改和更新更加方便。此外，Kubernetes还支持多种存储选项，包括持久化存储和临时存储。</li><li>自愈和自修复：Kubernetes具备自愈和自修复的能力，当应用程序出现故障或节点失效时，它可以自动重新启动容器、替换故障节点，并确保应用程序的正常运行。</li><li>扩展性和可插拔性：Kubernetes的设计具有良好的扩展性和可插拔性，可以根据需要添加新的功能和组件。它提供了丰富的API和扩展点，允许开发人员根据自己的需求进行定制和扩展。</li></ul></li><li>总的来说，Kubernetes为容器化应用程序的部署、管理和运维提供了一套完整的解决方案。它可以帮助用户简化复杂的容器编排任务，并提供高可用性、弹性伸缩和自动化管理等功能，使得应用程序能够更加高效和可靠地运行在分布式环境中。</li></ul><h3 id="mininet" tabindex="-1">Mininet</h3><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://arxiv.org/pdf/2111.06595.pdf&quot; alt=&quot;论文连接&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;0-%E6%91%98%E8%A6%81&quot; tabindex=&quot;-1&quot;&gt;0 摘要&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在这篇论文中</summary>
      
    
    
    
    <category term="论文" scheme="http://example.com/categories/%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="边缘计算" scheme="http://example.com/tags/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97/"/>
    
    <category term="Faas" scheme="http://example.com/tags/Faas/"/>
    
    <category term="ServerLess" scheme="http://example.com/tags/ServerLess/"/>
    
  </entry>
  
  <entry>
    <title>How to Share:Balancing Layer and Chain Sharing in Industrial Microservice Deployment</title>
    <link href="http://example.com/2023/08/16/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BA%E6%96%87/Balancing%20Layer%20and%20Chain%20Sharing%20in%20Industrial%20Microservice%20Deployment/"/>
    <id>http://example.com/2023/08/16/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BA%E6%96%87/Balancing%20Layer%20and%20Chain%20Sharing%20in%20Industrial%20Microservice%20Deployment/</id>
    <published>2023-08-16T13:48:11.673Z</published>
    <updated>2023-06-18T14:37:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-%E6%91%98%E8%A6%81" tabindex="-1">0 摘要</h2><ul><li>随着智能制造的快速发展，面向边缘计算的微服务平台正在成为生产控制的重要组成部分。</li><li>在微服务的容器化部署中：<ul><li>层共享可以减少由于镜像拉取而导致的巨大带宽消耗</li><li>而链共享可以减少微服务之间通信引起的通信开销</li></ul></li><li>这两种共享方法利用每个微服务的特性在部署过程中共享资源。然而，由于边缘服务器资源有限，很难同时满足这两种方法的优化目标。因此，通过平衡这两种共享方法来实现提高服务响应效率至关重要。</li><li>本文研究了一种能够平衡微服务的层共享和链共享的最佳微服务部署策略。我们通过模型重构，将最小化微服务镜像拉取延迟和通信开销的问题转化为线性约束整数二次规划问题。通过连续凸近似（SCA）方法得到一个部署策略。</li><li>实验结果表明，所提出的部署策略可以平衡这两种资源共享方法。当两种共享方法被平等考虑时，平均镜像拉取延迟可以降低到基准值的65％，平均通信开销可以降低到基准值的30％。</li></ul><h2 id="1-%E4%BB%8B%E7%BB%8D" tabindex="-1">1 介绍</h2><ul><li><p>传统的工业软件采用单体服务架构。服务内部的高耦合和占用率会增加整个系统的复杂性。其可扩展性、稳定性和容错性很难满足智能制造的要求。</p></li><li><p>通过微服务架构，一个完整的服务可以拆分为多个松耦合的微服务。不同的微服务在逻辑上是独立的，具有很高的灵活性、可扩展性和容错性，可以很好地适应智能制造的需求。</p></li><li><p>根据不同的服务请求和部署策略，将打包成Docker镜像的每个微服务可以通过容器编排工具k8s部署到边缘服务器上。</p></li><li><p>在微服务的容器化部署中，服务效率是评估部署解决方案质量的重要指标。服务效率主要受两个方面的影响。</p><ul><li>一方面是微服务的启动时间。它主要取决于Docker镜像的拉动延迟，这些镜像通过不同的镜像层存储在云端</li><li>另一方面是微服务之间的通信开销。它取决于微服务之间的数据交换量。<ul><li>一个工业应用可以由部署在一个或多个边缘服务器上的多个微服务完成。这些微服务可以被称为微服务链，同一微服务链中的微服务之间将频繁进行数据交换。</li></ul></li></ul></li><li><p>基于上述两个方面，通过资源共享来提高服务效率非常重要。为提高服务效率，有两种资源共享策略。</p><ul><li>一种资源共享策略是层共享：Docker原生支持层的共享。如果部署在同一边缘服务器上的微服务使用相同的镜像层，拉取镜像时将不会重复拉取该层。这个层可以被服务器上的所有微服务共享。层共享可以有效减少镜像拉取延迟，从而提高微服务的启动速度和服务响应效率。</li><li>另一种资源共享策略是链共享：它可以定义为部署在同一服务器上的微服务之间的数据共享。在微服务链中，相邻的两个微服务之间会频繁进行数据传输。如果两个微服务部署在同一服务器上，下一个微服务可以通过链共享直接访问数据，而无需进行多跳数据传输。链共享可以减少数据传输引起的延迟和数据丢失。</li></ul></li><li><p>由于边缘服务器的资源有限，不可能将所有的微服务都部署在同一台边缘服务器上。因此，有必要找到一种在层共享和链共享之间进行权衡的最优微服务部署策略。</p></li><li><p>由于边缘服务器的资源有限，微服务部署策略无法同时充分利用不同的资源，因此，还需要一种方法来合理地分配资源给部署在服务器上的不同微服务，并最大化资源的利用。</p></li><li><p>本文贡献：</p><ul><li><ol><li>我们通过同一模型描述了微服务的分层结构和链式结构。建立了一个整数规划问题，以最小化镜像拉取延迟和通信开销。</li></ol></li><li><ol start="2"><li>通过模型重构，证明了整数规划问题可以转化为带有线性约束的整数二次规划问题。通过使用连续凸逼近（SCA）方法获得最优解。该方法可以有效平衡镜像拉取延迟和通信开销。</li></ol></li><li><ol start="3"><li>提出了一种用于边缘服务器的资源重新分配算法，以充分利用闲置的计算资源。</li></ol></li><li><ol start="4"><li>通过实验，在镜像拉取延迟和服务间通信开销等多个维度上评估了结果。实验证明了所提方法的有效性。</li></ol></li></ul></li></ul><p>第2节简要回顾了相关文献。<br>第3节对系统的分层结构和链式结构进行建模，并给出了问题的形式化描述。<br>第4节解决了提出的问题。<br>第5节提出了一种用于边缘服务器的资源重新分配算法。<br>第6节评估了所提方法的结果。<br>第7节讨论了限制和未来工作。<br>第8节对论文进行了总结。</p><h2 id="2-%E7%9B%B8%E5%85%B3%E5%B7%A5%E4%BD%9C" tabindex="-1">2 相关工作</h2><h2 id="3-%E7%B3%BB%E7%BB%9F%E5%BB%BA%E6%A8%A1%E5%92%8C%E9%97%AE%E9%A2%98%E8%A1%A8%E8%BF%B0" tabindex="-1">3 系统建模和问题表述</h2><h3 id="3.1-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90" tabindex="-1">3.1 一个简单例子</h3><p><img src="/images/%E8%AE%BA%E6%96%87/Balancing%20Layer%20and%20Chain%20Sharing%20in%20IIndustrial%20Microservice%20Deployment/3_1.png" alt><br><img src="/images/%E8%AE%BA%E6%96%87/Balancing%20Layer%20and%20Chain%20Sharing%20in%20IIndustrial%20Microservice%20Deployment/3_2.png" alt></p><ul><li><p>如图示，考虑一个有两个微服务和一个有三个微服务的应用程序，<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><msub><mi>s</mi><mrow><mi>k</mi><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">ms_{ki}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord mathnormal">m</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ki</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>表示第k个软件的第i个微服务</p></li><li><p>每个微服务镜像有不同数量的镜像层组成。三个服务器与云服务器之间的带宽为120 MB/s，并且两个相邻服务器之间可以通过单跳到达。</p></li><li><p>a为层共享策略，此时将有相同镜像层的微服务部署在一起，可以实现镜像层的共享，但同一软件间需要传输数据。</p></li><li><p>b为链共享策略，同一软件的微服务在一个服务器上部署，传输数据大小为0，但要拉取所有镜像</p></li><li><p>c为同时考虑链共享和层共享，三种策略的具体时间比较见表。</p></li></ul><h3 id="3.2-%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9E%8B" tabindex="-1">3.2 系统模型</h3><h3 id="3.3-%E9%97%AE%E9%A2%98%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%8F%8F%E8%BF%B0" tabindex="-1">3.3 问题形式化描述</h3><h2 id="4-%E5%9F%BA%E4%BA%8Esca%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88" tabindex="-1">4 基于SCA的微服务部署方案</h2><h3 id="4.1-%E9%97%AE%E9%A2%98%E8%BD%AC%E5%8C%96" tabindex="-1">4.1 问题转化</h3><h3 id="4.2-%E5%9F%BA%E4%BA%8Esca%E7%9A%84%E6%96%B9%E6%B3%95" tabindex="-1">4.2 基于SCA的方法</h3><h3 id="4.3-%E6%94%B6%E6%95%9B%E5%88%86%E6%9E%90" tabindex="-1">4.3 收敛分析</h3><h2 id="5-%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E6%96%B9%E6%B3%95" tabindex="-1">5 资源分配方法</h2><h3 id="5.1-%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0" tabindex="-1">5.1 问题描述</h3><h3 id="5.2-%E5%9F%BA%E4%BA%8E%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E4%B9%98%E6%95%B0%E6%B3%95%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88" tabindex="-1">5.2 基于拉格朗日乘数法的解决方案</h3><h2 id="6-%E8%A1%A8%E7%8E%B0%E8%AF%84%E4%BC%B0" tabindex="-1">6 表现评估</h2><h3 id="6.1-%E6%A8%A1%E6%8B%9F%E5%AE%9E%E9%AA%8C" tabindex="-1">6.1 模拟实验</h3><h3 id="6.2-%E7%94%A8%E7%9C%9F%E5%AE%9E%E7%9A%84%E8%BE%B9%E7%BC%98%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9B%E8%A1%8C%E5%AE%9E%E9%AA%8C" tabindex="-1">6.2 用真实的边缘服务器进行实验</h3><h3 id="6.3-%E5%A4%A7%E8%A7%84%E6%A8%A1%E7%9A%84%E6%A1%88%E4%BE%8B" tabindex="-1">6.3 大规模的案例</h3><h2 id="7-%E8%AE%A8%E8%AE%BA" tabindex="-1">7 讨论</h2><ul><li><p>高时间和空间复杂性：所提出的方法在大规模场景中具有高时间和空间复杂性。虽然可以在可接受的时间内获得最优解，但需要进一步优化以提高可扩展性。未来的研究应着重开发高效的算法或优化技术，以降低计算复杂度。</p></li><li><p>考虑请求频率：通信开销不仅取决于通信数据量，还取决于请求频率。即使每次传输的数据量较小，高请求频率也会显著增加通信开销。在计算通信开销时，考虑通信数据量和请求频率的乘积是非常重要的。未来的工作可以探索将请求频率作为输入参数，以准确估计通信开销。</p></li><li><p>动态微服务部署：微服务不是静态的，部署过程涉及关闭、迁移和添加新的微服务。在面对动态场景时，需要相应的部署算法以适应变化。未来的研究可以探索使用人工智能或其他方法，在初始部署结果之后进行训练，以动态调整微服务的部署。</p></li></ul><h2 id="8-%E7%BB%93%E8%AE%BA" tabindex="-1">8 结论</h2><ul><li>本文研究了微服务的层共享和链共享，并探索了一种可以平衡这两种资源共享方式的微服务部署方案。<ul><li>我们建立了一个旨在最小化图像拉取延迟和通信开销的问题。通过模型重构，将问题转化为一个具有线性约束的整数二次规划问题，并通过连续凸逼近（SCA）方法获得部署策略。</li><li>我们还提出了一种资源重新分配算法，以充分利用服务器的空闲资源。</li></ul></li></ul><h2 id="%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A" tabindex="-1">名词解释</h2><h3 id="docker%E7%9A%84%E5%B1%82%E7%BA%A7" tabindex="-1">Docker的层级</h3><ul><li><p>Docker 镜像是构建容器的基础，它包含了一个完整的文件系统，包括操作系统、应用程序和依赖项。镜像是只读的，意味着一旦创建就不可更改。</p></li><li><p>Docker 镜像采用了分层的文件系统结构，这是 Docker 的一个重要特性。每个镜像由多个文件系统层构成，每个层都是只读的，并且可以被其他镜像共享和重用。这种分层结构使得镜像的构建和管理变得非常高效。</p></li><li><p>下面是 Docker 镜像层的一些重要概念：</p><ul><li>基础镜像层（Base Image Layer）：这是 Docker 镜像的第一个层，它通常包含操作系统的基本文件系统。基础镜像层是只读的，所有其他层都依赖于它。</li><li>中间镜像层（Intermediate Image Layers）：在构建 Docker 镜像时，可以在基础镜像层之上添加多个中间镜像层。每个中间镜像层都是基于前一个层进行的修改或添加，例如安装软件包、配置环境等。每个中间镜像层都会生成一个唯一的标识符，用于表示该层的内容。</li><li>最终镜像层（Final Image Layer）：最后一个中间镜像层被称为最终镜像层。它是由之前的中间镜像层构建而成，代表了完整的容器镜像。最终镜像层是可读写的，并且可以在容器中运行和修改。</li></ul></li><li><p>使用分层结构的好处是，当多个镜像共享相同的层时，这些层只需要在磁盘上存储一次，可以被多个镜像同时使用，节省了存储空间。此外，当基础镜像或中间镜像层发生变化时，只需重新构建受影响的层，而不必重新构建整个镜像，提高了构建速度和效率。</p></li><li><p>总结一下，Docker 镜像层是构成 Docker 镜像的一组只读文件系统层，通过分层结构实现了高效的镜像构建和共享。每个镜像层都包含了特定的文件系统更改或添加，最终构成一个完整的容器镜像。</p></li></ul><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;0-%E6%91%98%E8%A6%81&quot; tabindex=&quot;-1&quot;&gt;0 摘要&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;随着智能制造的快速发展，面向边缘计算的微服务平台正在成为生产控制的重要组成部分。&lt;/li&gt;
&lt;li&gt;在微服务的容器化部署中：
&lt;ul&gt;
&lt;li&gt;层共享可以</summary>
      
    
    
    
    <category term="论文" scheme="http://example.com/categories/%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="微服务" scheme="http://example.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>面试记录</title>
    <link href="http://example.com/2023/08/16/%E6%9D%82%E8%AE%B0/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"/>
    <id>http://example.com/2023/08/16/%E6%9D%82%E8%AE%B0/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/</id>
    <published>2023-08-16T13:48:11.669Z</published>
    <updated>2023-07-26T14:53:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="%E9%98%BF%E9%87%8C" tabindex="-1">阿里</h2><h3 id="2023%E5%AE%9E%E4%B9%A0%E9%98%BF%E9%87%8Cc%2B%2B%E5%AE%A2%E6%88%B7%E7%AB%AF" tabindex="-1">2023实习阿里C++客户端</h3><h4 id="%E7%AC%94%E8%AF%95" tabindex="-1">笔试</h4><p>408+ACM算法</p><h4 id="%E4%B8%80%E9%9D%A2" tabindex="-1">一面</h4><ul><li><p>自我介绍</p></li><li><p>手写栈，队列，优先队列，延迟队列。</p></li><li><p>tcp和udp关系</p></li><li><p>三次握手时，最后发送方没收到ack有哪些原因</p></li><li><p>c++和Java区别关系。</p></li><li><p>c11特性新特性</p></li><li><p>面向对象几个特性最重要的是哪个，为什么</p></li><li><p>进程和线程。</p></li><li><p>线程并发控制。</p></li><li><p>进程通讯。</p></li><li><p>github看过的项目那个最有趣，修的课那个最有趣</p></li><li><p>算法：给2n个数，分成两组，每组n个数，使得和最接近</p></li><li><p>总结：第一次面试，八股文就没准备，全靠平时基础，而且很紧张，但不知道为什么还能二面，但是最近也比较忙，八股文还是没时间背，急急急，看二面能运气过不</p></li></ul><h4 id="%E4%BA%8C%E9%9D%A2" tabindex="-1">二面</h4><ul><li>自我介绍</li><li>项目介绍</li><li>谈学习方法</li><li>C++和JAVA</li><li>聊天</li></ul><p>这次感觉还行，没问八股啥的，总体来说不是很紧张，可惜第二天反手就挂了，乐，简历又回归人才库继续转了</p><h2 id="%E8%85%BE%E8%AE%AF" tabindex="-1">腾讯</h2><h3 id="2023-wxg-%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0" tabindex="-1">2023 WXG 后端开发实习</h3><p>简历过了后就直接到面试了</p><h4 id="%E4%B8%80%E9%9D%A2-1" tabindex="-1">一面</h4><p>自我介绍</p><p>在线写题：</p><ol><li>给定一个字符串A和一个字符串集合B，找到B中字符串在A中的索引出现位置并标记出来（直接暴力）</li><li>实现一个单例模式，要求线程安全，懒汉模式</li><li>寻找二叉搜索树中的第三大值</li><li>反转链表</li></ol><p>八股：OS系统调用，计网MTU，C++多态实现</p><p>一面完直接挂了，真不戳，当时面的时候面试官找题找了10min+，还在跟别人聊天，看来对我确实是不上心了，虽然我也很菜</p><h2 id="%E5%8D%8E%E4%B8%BA" tabindex="-1">华为</h2><h3 id="2023-bg%E7%BB%88%E7%AB%AF%E7%A1%AC%E4%BB%B6-%E5%AE%9E%E4%B9%A0" tabindex="-1">2023 BG终端硬件 实习</h3><p>当时忘改第一志愿部门了，之后发现改不了了，硬着头皮面了，蚌，确实是硬件，贴近底层</p><p>自我介绍；<br>关于自我介绍聊了会天；<br>询问项目；</p><p>共享屏幕写题：一个超大文件，无法完全放入内存，请使用C++总计该文件bit流中的1的个数</p><p>chatgpt解答：在处理一个超大文件时，无法将整个文件加载到内存中。为了计算该文件中的1的个数，你可以使用逐位读取的方式来统计。以下是一个使用C++编写的示例代码：</p><pre><code class="language-C++">#include &lt;iostream&gt;#include &lt;fstream&gt;// 计算一个整数中的1的个数int countOnes(unsigned int num) &#123;    int count = 0;    while (num) &#123;        count += num &amp; 1;        num &gt;&gt;= 1;    &#125;    return count;&#125;int main() &#123;    std::ifstream file(&quot;path/to/your/file.bin&quot;, std::ios::binary);    if (!file) &#123;        std::cout &lt;&lt; &quot;Failed to open the file.&quot; &lt;&lt; std::endl;        return 1;    &#125;    unsigned char byte;    unsigned long long totalCount = 0;    // 逐字节读取文件内容    while (file.read(reinterpret_cast&lt;char*&gt;(&amp;byte), sizeof(byte))) &#123;        // 计算每个字节中1的个数并累加        totalCount += countOnes(byte);    &#125;    file.close();    std::cout &lt;&lt; &quot;Total count of 1s: &quot; &lt;&lt; totalCount &lt;&lt; std::endl;    return 0;&#125;</code></pre><p>这种文件读入确实不会，算是硬件岗吧，果然直接挂了，期望其它志愿可以面到</p><h2 id="%E5%B0%8F%E7%B1%B3" tabindex="-1">小米</h2><h3 id="2023-java%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91-%E5%AE%9E%E4%B9%A0" tabindex="-1">2023 Java程序开发 实习</h3><p>简历过了直接面试。<br>聊了项目，问了java Hashtable那一系列，多线程等，我确实基础不太行，最后面试官说明希望是一个基础牢固的，过来可以直接开发的实习生，所以潜意思应该是我不太行了，最后也是很快就挂了，不过处于流程还是要写代码的。</p><p>代码题：问有n个数，范围为[0-n]，每个数各不相同，问如何直到哪个数没有<br>解法：将所有数求和用n*(n+1)/2减去即是答案</p><h2 id="%E5%AD%97%E8%8A%82" tabindex="-1">字节</h2><h3 id="2023-%E9%A3%9E%E4%B9%A6%E5%90%8E%E7%AB%AF%E6%97%A5%E5%B8%B8%E5%AE%9E%E4%B9%A0" tabindex="-1">2023 飞书后端日常实习</h3><h4 id="%E4%B8%80%E9%9D%A2-2" tabindex="-1">一面</h4><ul><li><p>自我介绍</p></li><li><p>算法题：</p><ul><li>题目：将一个字符串的大小写字母转换，输出所有可能转换的字符串</li><li>做法：直接dfs回溯即可</li></ul></li><li><p>聊项目</p></li><li><p>八股</p><ul><li>计网<ul><li>HTTPS，SSL加密过程</li><li>HTTP请求的全过程（DNS服务器）</li><li>TCP/IP协议 传输信息的过程</li><li>TCP/IP协议 中帧的各请求头的信息</li><li>网络攻击手段：DDOS，反射</li></ul></li><li>操作系统<ul><li>如何让CPU满载</li><li>CPU利用率</li></ul></li><li>数据库<ul><li>索引的数据结构</li><li>隔离等级</li></ul></li></ul></li><li><p>哎，八股太差了，看过的记不住</p></li></ul><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;%E9%98%BF%E9%87%8C&quot; tabindex=&quot;-1&quot;&gt;阿里&lt;/h2&gt;
&lt;h3 id=&quot;2023%E5%AE%9E%E4%B9%A0%E9%98%BF%E9%87%8Cc%2B%2B%E5%AE%A2%E6%88%B7%E7%AB%AF&quot; tabind</summary>
      
    
    
    
    <category term="文章" scheme="http://example.com/categories/%E6%96%87%E7%AB%A0/"/>
    
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>软件工程期末突击</title>
    <link href="http://example.com/2023/08/16/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/"/>
    <id>http://example.com/2023/08/16/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/</id>
    <published>2023-08-16T13:48:11.663Z</published>
    <updated>2023-05-28T08:17:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h2 id="%E7%AC%AC%E4%B8%80%E7%AB%A0-%E4%BB%8E%E7%A8%8B%E5%BA%8F%E5%88%B0%E8%BD%AF%E4%BB%B6" tabindex="-1">第一章 从程序到软件</h2><h3 id="1-%E4%BD%95%E4%B8%BA%E7%A8%8B%E5%BA%8F%E5%8F%8A%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%B4%A8%E9%87%8F%E8%A6%81%E6%B1%82" tabindex="-1">1 何为程序及程序的质量要求</h3><h4 id="%EF%BC%881%EF%BC%89%E4%BD%95%E4%B8%BA%E7%A8%8B%E5%BA%8F" tabindex="-1">（1）何为程序</h4><ul><li>程序（Program）是由程序设计语言所描述的、能为计算机所理解和处理的一组语句序列</li><li>程序严格遵循程序设计语言的各项语法和语义规定</li><li>程序代码可表现为二种形式<ul><li>源代码（Source Code）：用程序设计语言所描述的代码</li><li>可执行代码（Executable Code）：可执行的二进制或中间码</li></ul></li></ul><h4 id="%EF%BC%882%EF%BC%89-%E7%A8%8B%E5%BA%8F%E7%BB%84%E6%88%90" tabindex="-1">（2） 程序组成</h4><ul><li>语句：声明、定义、控制、计算等；实现特定的功能；</li><li>模块：包，类，方法；每个模块实现特定功能</li></ul><h4 id="%EF%BC%883%EF%BC%89%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%BA%8C%E7%B1%BB%E5%88%A9%E7%9B%8A%E7%9B%B8%E5%85%B3%E8%80%85" tabindex="-1">（3）程序的二类利益相关者</h4><ul><li>用户：<ul><li>程序的运行展示 <strong>功能和性能</strong></li><li>满足和实现用户的<strong>需求</strong></li></ul></li><li>程序员<ul><li>编写，阅读维护程序</li><li>发现和修改程序中的缺陷</li></ul></li><li>用户和程序员对程序有这不同的质量需求</li></ul><h4 id="%EF%BC%884%EF%BC%89%E7%A8%8B%E5%BA%8F%E8%B4%A8%E9%87%8F%E7%9A%84%E5%86%85%E5%9C%A8%E5%92%8C%E5%A4%96%E5%9C%A8%E4%BD%93%E7%8E%B0" tabindex="-1">（4）程序质量的内在和外在体现</h4><ul><li>外在(External)质量<ul><li>用户视点</li><li>对外可展示，用户可直接感触到、所关心的</li><li>使用流畅性、响应速度、界面美观、操作简易性、运行可靠性等</li></ul></li><li>内在(Internal)质量<ul><li>程序员视点</li><li>体现在程序的内在方面，程序员可以感触到的、所关心的</li><li>易于理解、结构清晰、易于修改、可重用好等</li></ul></li></ul><h3 id="2-%E7%A8%8B%E5%BA%8F%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81%E6%96%B9%E6%B3%95" tabindex="-1">2 程序质量保证方法</h3><ul><li>程序质量保证方法<ul><li>遵循编码风格</li><li>采用程序设计方法</li><li>开展代码重用</li><li>进行结对编程</li><li></li></ul></li></ul><h4 id="%EF%BC%881%EF%BC%89%E7%A8%8B%E5%BA%8F%E8%B4%A8%E9%87%8F%E7%9A%84%E8%AF%AD%E6%B3%95%E5%92%8C%E8%AF%AD%E4%B9%89%E4%BD%93%E7%8E%B0" tabindex="-1">（1）程序质量的语法和语义体现</h4><ul><li>代码风格规范-语法<ul><li>语法和结构层次</li><li>明确如何来规范程序的书写</li><li>表现为是否易于阅读和理解</li></ul></li><li>代码设计规范-语义<ul><li>语义和内涵层次，外在的</li><li>明确如何来组织和封装程序语句</li><li>表现为良好的结构和易于重用</li></ul></li></ul><h4 id="%EF%BC%882%EF%BC%89%E9%81%B5%E5%BE%AA%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC" tabindex="-1">（2）遵循编码风格</h4><ul><li>良好的编程行为：对代码符号进行良好的组织、合理的命名、提供必要的注释，那么将可增强代码的可读性和可理解性，进而提高代码的可维护性和可重用性，提升代码的内部质量</li><li>编码风格：程序员在编码时要遵循特定的样式及要求，以规范程序员的编程行为以及所产生程序代码的样式</li><li>编写代码的基本原则<ul><li>易懂，一看就懂</li><li>简明，降低复杂度</li><li>易改，便于维护</li><li>无二义，不产生歧义</li></ul></li><li>代码风格举例：<ul><li>代码布局：缩进，大括号换行</li><li>代码组织：按字母顺序说明对象，单入口单出口</li><li>命名规范：一看就懂，望文生义；小驼峰，大驼峰</li><li>代码注释：有效、必要、简洁的注释；注解位置</li></ul></li></ul><h4 id="%EF%BC%883%EF%BC%89%E9%87%87%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95" tabindex="-1">（3）采用程序设计方法</h4><ul><li>语句设计<ul><li>单入口单出口，少用goto语句</li><li>加强对异常处理<ul><li>将更多的时间和精力放在处理异常代码上</li></ul></li></ul></li><li>模块化设计<ul><li>模块是逻辑上相对独立、具有良定义接口的编程单位</li><li>模块可表现为函数、过程、方法、类、程序包等</li></ul></li><li>高内聚低耦合原则<ul><li>高内聚：模块内各要素紧密相关，仅实现单一功能，否则再进行拆分</li><li>低耦合：模块间的关系应设计的非常松散</li></ul></li></ul><h4 id="%EF%BC%884%EF%BC%89%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8" tabindex="-1">（4）代码重用</h4><p>定义：在编写代码过程中，充分利用已有和现成的代码，并将其集成到程序之中，从而来实现程序功能<br>好处：由于被重用的代码经过多次反复的使用，代码质量得到充分检验，因而代码重用不仅可极大提高编程效率，而且还可有效提高程序质量</p><ul><li>重用代码片段</li><li>重用函数、类和软构件</li><li>重用开源代码</li></ul><h4 id="%EF%BC%885%EF%BC%89%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B" tabindex="-1">（5）结对编程</h4><h3 id="3-%E7%A8%8B%E5%BA%8F%E8%B4%A8%E9%87%8F%E7%9A%84%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95" tabindex="-1">3 程序质量的分析方法</h3><ul><li>人工审查方法</li><li>自动化分析方法</li><li>程序测试方法</li></ul><h4 id="%EF%BC%881%EF%BC%89%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%A0%81%E4%B8%AD%E6%BD%9C%E5%9C%A8%E7%9A%84%E8%B4%A8%E9%87%8F%E9%97%AE%E9%A2%98" tabindex="-1">（1）程序代码中潜在的质量问题</h4><ul><li>质量问题<ul><li>编写不合理 – 没有遵循编码规范</li><li>设计不合理 – 没有遵循设计规范</li><li>代码有错误 – 代码编写的不正确</li></ul></li></ul><h4 id="%EF%BC%882%EF%BC%89%E4%BA%BA%E5%B7%A5%E5%AE%A1%E6%9F%A5%E4%BB%A3%E7%A0%81%EF%BC%88code-review%EF%BC%89" tabindex="-1">（2）人工审查代码（Code Review）</h4><ul><li>方法描述:阅读和理解代码；发现缺陷和问题；提出改进的建议</li><li>方法特点：人工审查效率低；难以发现一些深层次问题；难以全面地进行系统分析</li><li>审查方面：<ul><li>代码是否符合编程规范</li><li>代码中是否存在缺陷</li><li>从质量的角度哪些代码需要改进</li></ul></li></ul><h4 id="%EF%BC%883%EF%BC%89%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7%E5%AE%A1%E6%9F%A5-%E4%BB%A3%E7%A0%81%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90" tabindex="-1">（3）自动化工具审查-代码静态分析</h4><ul><li><p>由计算机软件来自动完成代码审查</p><ul><li>无需运行被测代码，仅通过分析或检查程序的语法、结构、过程、接口等来检查程序</li><li>30% - 70% 的代码缺陷可通过静态分析发现</li></ul></li><li><p>分析什么</p><ul><li>找出代码隐藏的错误和缺陷，如参数不匹配，有歧义的嵌套语句，错误的递归，非法计算，可能出现的空指针引用等等</li><li>程序遵循编码规范的程度</li></ul></li><li><p>特点：快速定位、有效发现隐藏的错误和缺陷</p></li><li><p>自动化代码分析工具：SonarQube</p><ul><li>基于Web、用于管理程序代码质量的代码分析工具</li><li><a href="http://www.sonarqube.org">www.sonarqube.org</a></li><li>能以插件的形式集成到众多的软件开发环境（如Eclipse）</li></ul></li></ul><h4 id="%EF%BC%884%EF%BC%89%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%8A%80%E6%9C%AF" tabindex="-1">（4）软件测试技术</h4><ul><li>程序本质上是对数据的处理</li><li>设计数据(测试用例) -&gt; 运行测试用例(程序来处理数据) -&gt; 判断运行结果(是否符合预期结果)</li></ul><h3 id="4-%E4%BD%95%E4%B8%BA%E8%BD%AF%E4%BB%B6%E5%8F%8A%E8%BD%AF%E4%BB%B6%E7%9A%84%E7%89%B9%E7%82%B9" tabindex="-1">4 何为软件及软件的特点</h3><h4 id="%EF%BC%881%EF%BC%89%E4%BD%95%E4%B8%BA%E8%BD%AF%E4%BB%B6" tabindex="-1">（1）何为软件</h4><ul><li>软件是指在计算机系统的支持下，能够完成特定功能与性能的<strong>程序、数据和文档</strong><ul><li>文档：记录软件开发活动和阶段性成果、软件配置及变更的阐述性资料<ul><li>定义和理解软件</li><li>记录软件开发成果</li><li>辅助不同人员间的交流</li></ul></li><li>数据：程序的加工处理对象和结果<ul><li>数据形式：用户，订单，交易，日志</li><li>数据处理：表示，获取，存储，检索，分析</li></ul></li></ul></li></ul><h4 id="%EF%BC%882%EF%BC%89%E8%BD%AF%E4%BB%B6%E6%A6%82%E5%BF%B5%E7%BB%99%E6%88%91%E4%BB%AC%E7%9A%84%E5%90%AF%E7%A4%BA" tabindex="-1">（2）软件概念给我们的启示</h4><ul><li>软件<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≠</mo><mrow></mrow></mrow><annotation encoding="application/x-tex">\not ={}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span></span><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0em;"></span><span class="mord"></span></span></span></span></eq>程序<ul><li>软件涉及更多制品</li><li>这些制品间有关联、相互依赖</li></ul></li><li>开发软件   <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≠</mo><mrow></mrow></mrow><annotation encoding="application/x-tex">\not ={}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span></span><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0em;"></span><span class="mord"></span></span></span></span></eq>      编写程序<ul><li>软件开发需要做更多事情</li><li>对软件提出更高的要求</li></ul></li><li>软件的规模和复杂性意味着要采用行之有效的方法—工程方法</li></ul><h4 id="%EF%BC%883%EF%BC%89%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" tabindex="-1">（3）软件生命周期</h4><ul><li>a 需求分析</li><li>b 软件设计</li><li>c 编码实现</li><li>d 软件测试</li><li>e 部署运行</li><li>f 使用维护</li><li>转a</li></ul><h4 id="%EF%BC%884%EF%BC%89%E8%BD%AF%E4%BB%B6%E7%89%B9%E7%82%B9" tabindex="-1">（4）软件特点</h4><ul><li>逻辑性：逻辑产品，逻辑思维（非物理活动）的结果、不会磨损和老化</li><li>设计开发：是设计开发而成的，不是生产制造而成的，而是一系列以设计为核心的软件开发活动</li><li>易变性：需求经常变、难以把控，影响软件的制品即开发过程；产品难以成熟</li><li>复杂性：规模大；运行复杂；环境复杂；</li><li>缺陷的隐蔽性：缺陷隐藏在逻辑代码中，不像硬件系统那样直观显现，很难被人们所发现和排除</li></ul><h3 id="5-%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%88%86%E7%B1%BB" tabindex="-1">5 软件的分类</h3><h4 id="%EF%BC%881%EF%BC%89%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%88%86%E7%B1%BB" tabindex="-1">（1）软件的分类</h4><ul><li><p>应用软件</p><ul><li>面向特定应用领域的专用软件。它们针对相关行业和领域的特定问题，为其提供基于计算的新颖解决方案。</li><li>示例：淘宝、12306、携程、微信、QQ等软件</li></ul></li><li><p>系统软件</p><ul><li>对计算机资源进行管理，为应用软件的运行提供基础设施和服务的一类软件。从计算服务的视角，系统软件介于计算机硬件和应用软件之间。</li><li>示例：操作系统、数据库管理系统、编译软件、软件中间件等</li></ul></li><li><p>支撑软件</p><ul><li>辅助软件开发和运维，帮助开发人员完成软件开发和维护工作的一类软件</li><li>示例：SonarQube、Visual Studio、Eclipse等</li></ul></li><li><p>通用软件产品</p><ul><li>由软件开发组织开发的，在市场上公开销售，可以独立使用的软件.</li><li>关于产品应该做什么的规格说明由开发者确定，相关的变更决策也由开发者做出.</li></ul></li><li><p>定制化软件产品</p><ul><li>受特定客户委托，由软件开发商针对特定客户需求专门设计和实现的软件.</li><li>关于产品应该做什么的规格说明由客户给出，相关的变更需求也由客户提出.</li></ul></li></ul><h4 id="%EF%BC%882%EF%BC%89%E9%97%AD%E6%BA%90%E8%BD%AF%E4%BB%B6" tabindex="-1">（2）闭源软件</h4><ul><li>何为闭源软件<ul><li>软件代码不对用户开放的一类软件，购买软件时只提供可运行软件或服务，没有提供源代码</li><li>以许可证（License）的方式授权用户使用软件</li></ul></li><li>闭源软件带来的问题<ul><li>无法掌握软件内部实现情况（如是否存在安全漏洞和恶意代码），也无法对软件进行修改和完善，极大影响了开发者的创新自由</li></ul></li><li>示例<ul><li>微软的Windows、Office软件，</li><li>典型企业：微软、IBM、Oracle等</li></ul></li></ul><h4 id="%EF%BC%883%EF%BC%89%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6" tabindex="-1">（3）开源软件</h4><ul><li>何为开源软件<ul><li>一种源代码可以自由获取和传播的计算机软件，其拥有者通过开源许可证赋予被许可人对软件进行使用、修改和传播</li></ul></li><li>开源软件的好处<ul><li>源代码可自由传播</li><li>激发创作者的热情</li><li>免费使用降低成本</li></ul></li><li>示例：开源软件<ul><li>Linux, Ubuntu</li><li>Apache, Jboss, Tomcat</li></ul></li></ul><h4 id="%EF%BC%884%EF%BC%89%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E6%89%98%E7%AE%A1%E5%B9%B3%E5%8F%B0" tabindex="-1">（4）开源软件托管平台</h4><ul><li>Github：全球最有影响力的开源软件托管平台</li><li>SourceForge：一个有影响力的开源软件开发平台和仓库，为开源软件提供存储、协作和发布的支持</li><li>Gitee：中国的开源软件托管平台</li><li>Stack Overflow：全球最大的软件开发知识分享平台，它支持开发者交流和讨论软件开发问题、分享软件开发经验和知识，进而促进相关开发问题的解决，推动开源软件的开发</li></ul><h4 id="%EF%BC%885%EF%BC%89%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E7%9A%84%E4%BC%98%E5%8A%BF" tabindex="-1">（5）开源软件的优势</h4><ul><li><p>采购和开发的成本更低</p><ul><li>开源软件通常是免费的，即使要付费，其费用也非常低廉</li></ul></li><li><p>软件质量更高、更安全</p><ul><li>核心代码都在公众的视野之中，代码问题（如缺陷、安全漏洞等）很容易被人发现</li></ul></li><li><p>软件研制和交付的更快</p><ul><li>基于开源软件的项目开发可以更为快速地给用户交付软件产品</li></ul></li><li><p>软件功能更为强大</p><ul><li>大量的软件开发者不仅参与软件开发，贡献他们的代码，而且还参与软件的创新，提出和构思软件需求，不断完善软件功能</li></ul></li><li><p>开源软件许可证</p><ul><li>何为开源许可证<ul><li>声明获得开源代码后拥有的权利，界定对别人的开源作品进行何种操作、何种操作是被禁止的，规范开源软件的使用要求和约束</li><li>开发者虽然可自由地获取开源软件的源代码，但在如何使用开源软件方面还需要遵循相关的开源软件协议</li></ul></li><li>二类许可证<ul><li>宽松式开源许可证：三方面特点：代码使用没有任何限制；用户自担代码质量的风险；用户使用开源软件时须披露原始作者</li><li>Copyleft式开源许可证：更多限制，带有许多条件和要求，比如分发二进制代码时须提供源代码，修改后的开源软件须与之前保持一致的许可证等</li></ul></li></ul></li></ul><h4 id="%EF%BC%886%EF%BC%89%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8" tabindex="-1">（6）开源软件的利用</h4><ul><li>学习开源软件<ul><li>不仅反映了核心开发者的软件技术和功能创意，而且还蕴含了高水平的软件开发技能，如架构设计、编码风格、模块封装等</li></ul></li><li>重用开源代码<ul><li>开源软件构成了支撑软件开发的可重用软件资源库，可实现更大粒度的软件重用</li></ul></li><li>参与开源建设，掌握开源技术，理解开源文化<ul><li>包括反馈软件缺陷、提出软件需求、讨论问题的解决、贡献程序代码等等</li></ul></li><li>重用和集成开源软件来快速搭建高质量的系统</li></ul><h3 id="6-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F" tabindex="-1">6 软件质量</h3><ul><li>软件质量是指软件满足给定需求的程度，它是产品生命线</li><li>正确性（Correctness）：软件满足规格说明和用户要求的程度，即在预定环境下能正确地完成预期功能和非功能需求的程度。</li><li>可靠性（Reliability）：在规定条件下、限定时间范围内，软件系统完成预期功能、不引起系统故障的能力。</li><li>健壮性（Robustness）：在计算环境发生故障、输入无效数据或操作错误等意外情况下，软件仍能做出适当响应的程度。</li><li>有效性（Efficiency）：软件利用计算资源和存储资源以实现其功能的能力</li><li>安全性：包括系统安全（Safety）和信息安全（Security），系统安全是指软件能及时有效地避免给人员、设施、环境、经济等造成损害，信息安全是指软件能有效防控各类的非法获取、传播和使用</li><li>可维护性（Maintainability）：是否易于对其进行修改以更正错误、增强功能、适应新运行环境</li><li>可移植性（Portability）：把软件从一种运行环境转移到另一种运行环境下运行的难易程度</li><li>可重用性（Reusability）：软件模块、构件、设计方案等在其他软件开发中被再次使用程度</li><li>可理解性（Comprehensibility）：软件开发者或用户理解该软件系统的容易程度</li><li>可信性（Dependability）：采取有效措施确认软件满足人们的要求和期望</li><li>持续性（Sustainability）：面对各种突发异常事件，仍能提供令人满意的服务的能力</li><li>可用性（Usability）：使用和操作软件系统难以程度</li><li>互操作性（Interoperability）：软件系统与其他的系统进行交换信息、协同工作的能力</li></ul><h2 id="%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%BF%B0" tabindex="-1">第二章 软件工程概述</h2><h3 id="1-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%BA%A7%E7%94%9F%E8%83%8C%E6%99%AF" tabindex="-1">1 软件工程产生背景</h3><h4 id="%EF%BC%881%EF%BC%89%E8%BD%AF%E4%BB%B6%E5%8D%B1%E6%9C%BA%E7%9A%84%E5%87%BA%E7%8E%B0" tabindex="-1">（1）软件危机的出现</h4><ul><li>进度经常延迟</li><li>质量无法保证</li><li>成本超出预算</li><li>软件维护困难</li><li>失败风险很大</li></ul><h4 id="%EF%BC%882%EF%BC%89%E5%A6%82%E4%BD%95%E6%9D%A5%E8%A7%A3%E5%86%B3%E8%BD%AF%E4%BB%B6%E5%8D%B1%E6%9C%BA%3F" tabindex="-1">（2）如何来解决软件危机?</h4><ul><li>软件危机根源<ul><li>对软件这样一类复杂和特殊系统的认识不清：软件是新生事物，对其特点、规律性和复杂性认识不够</li><li>没有找到支持软件系统开发的有效方法：基础理论、关键技术、开发过程、支撑工具等</li><li>缺乏成功软件开发实践以及相应的开发经验：系统总结、认真分析、充分借鉴、吸取教训</li></ul></li><li>软件开发迫切需要理论和方法指导，软件工程应运而生</li></ul><h3 id="2-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E6%9C%AC%E5%86%85%E6%B6%B5" tabindex="-1">2 软件工程基本内涵</h3><h4 id="%EF%BC%881%EF%BC%89%E4%BD%95%E4%B8%BA%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B" tabindex="-1">（1）何为软件工程</h4><ul><li><p>将系统的、规范的、可量化的方法应用于软件的开发、运行和维护的过程；以及上述方法的研究</p><ul><li>系统化：提供完整和全面的解决方法，包括目标、原则、过程模型、开发活动、开发方法和技术等</li><li>规范化：支持各类软件系统的开发，包括语言标准、质量标准、编程标准、方法标准、能力极其改进标准等</li><li>可量化：工作量、成本、进度、质量等要素可以量化，基于定量的数据支持开发和管理，确保科学性和可行性</li></ul></li><li><p>软件工程对软件开发的新认识</p><ul><li>软件是产品(Product)：面向用户，存在质量、成本、利润等特征</li><li>软件开发是一项工程(Project)：存在约束，需要质量保证，进行组织管理，…</li><li>要按工程化方法来组织软件生产<ul><li>分阶段分步骤来实施</li><li>按计划开展开发活动</li><li>进行各种形式质量保证</li><li>采用行之有效的方法</li><li>借助各种工具的支持…</li></ul></li></ul></li></ul><h4 id="%EF%BC%882%EF%BC%89%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%89%E8%A6%81%E7%B4%A0" tabindex="-1">（2）软件工程三要素</h4><p><img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/2_3_0.jpg" alt></p><ul><li>过程<ul><li>从管理的视角，回答软件开发、运行和维护需要开展哪些工作、按照什么样的步骤和次序来开展工作</li><li>对软件开发过程所涉及的人、制品、质量、成本、计划等进行有效和可量化的管理</li><li>典型成果<ul><li>过程模型，如瀑布模型、增量模型、原型模型、迭代模型、螺旋模型等等</li><li>方法，如敏捷开发方法、群体化开发方法、DevOps方法</li><li>管理，如配置管理、质量管理、团队组织等</li></ul></li></ul></li><li>方法学(Methodology)<ul><li>从技术的视角，回答软件开发、运行和维护如何做的问题</li><li>为软件开发过程中的各项开发和维护活动提供系统性、规范性的技术支持<ul><li>如何理解和认识软件模型是什么</li><li>如何用不同抽象层次的模型来描述软件制品</li><li>采用什么样的建模语言来描述软件模型等等</li></ul></li><li>典型成果<ul><li>结构化软件开发方法学</li><li>面向对象软件开发方法学</li><li>基于构件的软件开发方法学</li></ul></li></ul></li><li>工具<ul><li>从工具辅助的视角，主要回答如何借助工具来辅助软件开发、运行和维护的问题</li><li>帮助软件开发人员更为高效地运用软件开发方法学来完成软件开发过程中的各项工作，提高软件开发效率和质量，加快软件交付进度。<ul><li>如需求分析、软件设计、编码实现、软件测试、部署运行、软件维护、项目管理、质量保证等，简化软件开发任务，</li></ul></li><li>典型成果：SonarQube、Eclipse等</li></ul></li></ul><h4 id="%EF%BC%883%EF%BC%89%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BE%85%E5%8A%A9%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B" tabindex="-1">（3）计算机辅助软件工程</h4><ul><li>什么是计算机辅助软件工程(Computer-Aided Software Engineering, CASE)<ul><li>在软件工程活动中，开发人员按照软件工程的方法和原则，借助于计算机及其软件的帮助来开发、维护和管理软件产品的过程</li></ul></li><li>CASE工具：支持CASE的软件工具，如编辑器、编译器等</li><li>CASE环境：<ul><li>将CASE工具按统一标准和接口组装起来，使工具间、人员间、各个过程间能方便交互的集成环境</li><li>如Visual Studio将编辑、编译、调试、界面设计、安装程序生成等等集成在一起</li></ul></li><li>代码编写，项目管理，软件建模，软件测试，软件运维</li></ul><h4 id="%EF%BC%884%EF%BC%89%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9A%84%E6%9C%AC%E8%B4%A8" tabindex="-1">（4）软件开发的本质</h4><ul><li>软件开发 = 软件创作 + 软件生产</li><li>软件创作：基于软件开发者的经验和技能，借助于智慧，进行自由创新，如软件设计、编码实现等</li><li>软件生产：基于工程化的手段，遵循约束和规范，开展软件生产，如遵循过程、按照标准、质量保证等</li></ul><h4 id="%EF%BC%885%EF%BC%89%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%9A%84%E7%9B%AE%E6%A0%87" tabindex="-1">（5）软件工程的目标</h4><p>在成本、进度等约束下，指导软件开发和运维，开发出满足用户要求的足够好软件</p><h4 id="%EF%BC%886%EF%BC%89%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%8E%9F%E5%88%99" tabindex="-1">（6）软件工程原则</h4><ul><li>抽象与建模<ul><li>抽象：将与相关开发活动所关注的要素提取出来，不关心的要素扔掉，形成与该开发活动相关的软件要素</li><li>建模：基于特定的抽象，借助于建模语言（如数据流图、UML等），建立起基于这些抽象的软件模型，进而促进对软件系统的准确理解</li></ul></li><li>模块化<ul><li>将软件系统的功能分解和实现为若干个模块，每个模块具有独立的功能，模块之间通过接口进行调用和访问。</li></ul></li><li>软件重用<ul><li>在软件开发过程中尽可能利用已有的软件资源和资产（如函数库、类库、构件库、开源软件、代码片段等）来实现软件系统</li><li>努力开发出可被再次重用的软件资源（如函数、类、构件等）</li><li>有助于提高软件开发效率，降低软件开发成本，满足开发工程约束，得到高质量的软件产品</li></ul></li><li>信息隐藏<ul><li>模块内部信息（如内部的语句、变量等）对外不可见或不可访问，模块间仅仅交换那些为完成系统功能所必需交换的信息（如接口）</li><li>模块设计时只对外提供可见的接口，不提供内部实现细节。信息隐藏原则可提升模块的独立性，减少错误向外传播，支持模块的并行开发</li></ul></li><li>关注点分离</li><li>分而治之</li><li>双向追踪原则<ul><li>当某个软件制品发生变化时，一方面要追踪这种变化会对那些软件制品产生影响，进而指导相关的开发和维护工作，此为正向追踪；另一方面要追踪产生这种变化的来源，或者说是什么因素导致了该软件制品的变化，明确软件制品发生变化的原因及其合理性，此为反向追踪。</li></ul></li><li>工具辅助</li></ul><h2 id="%E7%AC%AC%E4%B8%89%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%92%8C%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95" tabindex="-1">第三章 软件工程和开发方法</h2><h3 id="1-%E4%BD%95%E4%B8%BA%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B" tabindex="-1">1 何为软件过程模型</h3><h4 id="%EF%BC%881%EF%BC%89%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B" tabindex="-1">（1）软件过程</h4><ul><li>过程(Process)<ul><li>活动：明确要做哪些事情，包括具体的活动</li><li>关系：活动间存在逻辑关系，如依赖和先后次序</li></ul></li><li>软件过程：<ul><li>按照项目进度、成本和质量要求，遵循用户需求，开发和维护软件、管理软件项目的一系列有序软件开发活动</li><li>软件开发活动：技术活动和管理活动</li></ul></li></ul><h4 id="%EF%BC%882%EF%BC%89%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B" tabindex="-1">（2）软件过程模型</h4><ul><li>定义了软件开发的具体活动以及活动间的逻辑关系</li><li>描述包括：<ul><li>过程中的活动以及这些活动的顺序</li><li>产品交付物：软件过程活动的产出物;</li><li>角色：反映了参与过程的人在其中的职责;</li><li>前置条件和后置条件：在一个过程活动执行之前和之后，或者产品生产之前和之后必须满足的条件。</li><li>工具</li><li>资源</li></ul></li></ul><h3 id="2-%E6%9C%89%E5%93%AA%E4%BA%9B%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B" tabindex="-1">2 有哪些软件过程模型</h3><ul><li>瀑布模型</li><li>增量模型</li><li>迭代模型</li><li>原型模型</li><li>螺旋模型</li><li>基于构件的过程模型</li><li>UP模型</li></ul><h4 id="%EF%BC%881%EF%BC%89%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B" tabindex="-1">（1）瀑布模型</h4><ul><li>步骤<ol><li><strong>需求分析</strong></li></ol><ul><li>活动<ul><li>任务：定义软件需求，包括功能、非功能需求</li><li>层次和视角：用户角度，仅描述问题和需求</li></ul></li><li>方法<ul><li>依据：用户的期望和要求</li><li>不断与用户进行交流和商讨，抽象、问题分解、多视点等技术</li></ul></li><li>产出：软件需求模型；软件需求文档；软件确认测试计划；</li></ul><ol start="2"><li><strong>概要设计</strong></li></ol><ul><li>活动<ul><li>任务：建立软件总体架构、制定集成测试计划</li><li>层次和视角：宏观、全局、整体、战略性</li></ul></li><li>方法<ul><li>依据：软件需求文档</li><li>自顶向下, 逐步求精,  抽象, 模块化, 局部化，信息隐藏</li></ul></li><li>产出：软件概要设计模型、软件概要设计文档、软件集成测试计划</li></ul><ol start="3"><li><strong>详细设计</strong></li></ol><ul><li>活动<ul><li>任务：设计模块内部细节(算法、数据结构)，制订单元测试计划</li><li>层次和视角：微观、局部、细节性</li></ul></li><li>方法<ul><li>依据：概要设计文档、软件需求文档</li><li>高质量的软件设计原则，如单入口单出口</li></ul></li><li>产出：软件详细设计模型、软件详细设计文档、单元测试计划</li></ul><ol start="4"><li><strong>编码实现</strong></li></ol><ul><li>活动<ul><li>任务：编写程序代码并进行单元测试和调试</li><li>层次和视角：最终的实现代码</li></ul></li><li>方法<ul><li>依据：软件概要和详细设计文档、单元测试计划</li><li>采用某种程序设计语言(如C、C++、Java)</li></ul></li><li>产出：经过单元测试的源程序代码</li></ul><ol start="5"><li><strong>集成测试</strong></li></ol><ul><li>活动<ul><li>任务：组装软件模块并进行测试以发现问题</li><li>层次和视角：系统结构、接口</li></ul></li><li>方法<ul><li>依据：软件概要设计文档、软件集成测试计划</li><li>软件集成测试工具</li></ul></li><li>产出：经过集成测试、修复缺陷的源程序代码，集成测试报告</li></ul><ol start="6"><li><strong>确认测试</strong></li></ol><ul><li>活动<ul><li>任务：测试软件是否满足用户需求</li><li>层次和视角：从用户角度，聚焦需求是否得以正确实现</li></ul></li><li>方法<ul><li>依据：软件确认测试计划、软件需求文档</li><li>软件测试支撑工具</li></ul></li><li>产出：经过确认测试、修复缺陷后的代码，软件确认测试报告</li></ul></li><li>特点：<ul><li>与软件生命周期相互一致</li><li>每个活动结束后需要评审</li><li>相邻活动间存在因果关系</li></ul></li><li>优点：简单，一目了然，易理解、掌握、应用和管理</li><li>缺点：违背现实</li><li>适用于需求易于定义、不易变动的软件系统</li><li>改进的瀑布模型：带反馈和回溯</li></ul><h4 id="%EF%BC%882%EF%BC%89%E5%A2%9E%E9%87%8F%E6%A8%A1%E5%9E%8B" tabindex="-1">（2）增量模型</h4><p><img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/3_2_4.jpg" alt></p><ul><li>优点：渐进快速交付，并行开发，提高效率</li><li>不足：<ul><li>要求一开始完整确定需求，建立系统架构的要求更高</li><li>管理复杂，增量开发，要保持多个版本的制品一致性</li><li>产品是慢慢成熟的，跟办事规程不匹配</li></ul></li></ul><h4 id="%EF%BC%883%EF%BC%89%E8%BF%AD%E4%BB%A3%E6%A8%A1%E5%9E%8B(iterative-model)" tabindex="-1">（3）迭代模型(Iterative Model)</h4><p><img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/3_2_5.jpg" alt></p><ul><li>优点：<ul><li>每次迭代是一完整过程</li><li>体现了小步快跑的开发理念，降低风险</li><li>适合需求难导出、不甚明确且持续变动的软件</li></ul></li><li>不足<ul><li>迭代多少次不确定</li><li>管理较为复杂</li><li>高素质管理者和团队</li></ul></li></ul><h4 id="%EF%BC%884%EF%BC%89%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%9E%8B(prototype-model)" tabindex="-1">（4）原型模型(Prototype Model)</h4><p><img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/3_2_6.jpg" alt></p><ul><li>软件原型:用户界面+执行流程</li><li>特点<ul><li>软件原型作为交流载体和媒介</li><li>支持用户参与到软件开发中</li><li>持续、渐进地导出用户要求</li></ul></li><li>适合于需求难导出、模糊且不易确定的软件</li></ul><h4 id="%EF%BC%885%EF%BC%89%E8%9E%BA%E6%97%8B%E6%A8%A1%E5%9E%8B(spiral-model)" tabindex="-1">（5）螺旋模型(Spiral Model)</h4><p><img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/3_2_7.jpg" alt></p><ul><li>优点：<ul><li>集成迭代模型和原型模型</li><li>引入风险分析，风险驱动</li><li>适合于需求不明确、开发风险高、开发过程中需求变更大的内部软件项目</li></ul></li><li>不足：风险驱动、管理复杂</li></ul><h4 id="%EF%BC%886%EF%BC%89%E4%B8%8D%E5%90%8C%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%89%B9%E7%82%B9" tabindex="-1">（6）不同软件过程模型的特点</h4><p><img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/3_2_8.jpg" alt></p><h3 id="3-%E5%A6%82%E4%BD%95%E6%9D%A5%E9%80%89%E6%8B%A9%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B" tabindex="-1">3 如何来选择软件过程模型</h3><h4 id="%EF%BC%881%EF%BC%89%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%80%89%E6%8B%A9" tabindex="-1">（1）软件过程模型的选择</h4><ul><li><p>考虑软件项目的特点</p></li><li><p>软件开发团队的水平</p></li><li><p>分析软件过程模型特点</p></li><li><p>互联网应用软件的开发过程模型</p><ul><li>特点：软件需求不确定且快速变化</li><li>如：12306 APP软件，微信软件，淘宝软件</li><li>选用瀑布模型不合适，迭代模型较为合适</li></ul></li><li><p>装备软件的开发过程模型</p><ul><li>特点：软件需求确定且较为稳定</li><li>如：飞行控制软件</li><li>可考虑选用瀑布模型，用迭代模型不是很合适</li></ul></li></ul><h4 id="%EF%BC%882%EF%BC%89%E4%BC%A0%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%89%B9%E7%82%B9%E5%92%8C%E4%B8%8D%E8%B6%B3" tabindex="-1">（2）传统软件过程模型的特点和不足</h4><ul><li>软件开发和运维的大量工作用于撰写软件文档，而非去编写程序代码</li><li>软件开发过程中会花费大量时间和精力用于软件文档的评审，以确保软件质量</li><li>一旦软件需求发生变化，开发人员需要修改软件需求文档，并据此来调整其他的一系列文档，最后再修改程序代码</li><li>等较长时间才能得到可运行软件系统</li><li><strong>以文档为中心的重型软件开发方法，非常笨重</strong></li></ul><h3 id="4-%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95%E6%A6%82%E8%BF%B0" tabindex="-1">4 软件开发方法概述</h3><ul><li>Parnas方法</li><li>结构化方法</li><li>面向对象方法</li><li>给予构件的开发方法</li><li>敏捷开发方法</li><li>群体化开发方法</li></ul><h4 id="%EF%BC%881%EF%BC%89parnas%E6%96%B9%E6%B3%95" tabindex="-1">（1）Parnas方法</h4><ul><li>出发点：可靠性，可维护性</li><li>策略<ul><li>信息隐蔽：在设计时仅列出将来可能发生变化的因素，并在模块划分时将这些因素局部化</li><li>意外故障处理：软件的非连续性，小错误会引发严重的事故，所以必须加强防范</li></ul></li><li>特点：Parnas对软件开发提出了深刻的见解，但没有明确的流程，不能独立使用</li></ul><h4 id="%EF%BC%882%EF%BC%89%E7%BB%93%E6%9E%84%E5%8C%96%E6%96%B9%E6%B3%95" tabindex="-1">（2）结构化方法</h4><ul><li>出发点：清晰的程序结构，可理解性。</li><li>求解复杂问题的一般办法：分而治之（模块化）</li><li>策略：模块化，自顶向下、逐步求精；SA+SD+SP（系统分析（System Analysis），系统设计（System Design），软件编程（Software Programming））</li><li>程序=数据+算法，分为：<ul><li>面向数据流的结构化方法</li><li>面向数据结构的结构化方法</li></ul></li><li>特点：<ul><li>数据和行为分开——鸿沟</li><li>难开发、难理解、不安全、可维护性低</li></ul></li></ul><h4 id="%EF%BC%883%EF%BC%89%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95" tabindex="-1">（3）面向对象的方法</h4><ul><li>出发点：对问题领域的实体特征直接自然模拟，更易于理解和开发，结构更稳定。<ul><li>程序=对象+消息</li></ul></li><li>策略：<ul><li>通过一组对象的交互来完成系统的功能，对象是领域实体的软件抽象</li><li>OOA+OOD+OOP 面向对象分析（Object-Oriented Analysis）、面向对象设计（Object-Oriented Design）和面向对象编程（Object-Oriented Programming）</li><li>自顶向下和自底向上相结合</li></ul></li><li>特点：<ul><li>对象把数据和操作封装在一起</li><li>更稳定、更安全、提高了可维护性和可重用性</li></ul></li></ul><h4 id="%EF%BC%884%EF%BC%89%E5%9F%BA%E4%BA%8E%E6%9E%84%E4%BB%B6%E7%9A%84%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95" tabindex="-1">（4）基于构件的开发方法</h4><ul><li>出发点：提高软件开发效率和质量的基本途径是复用，用大块编程取代，程序=构件+连接件</li><li>策略：<ul><li>有目的地开发可复用的构件（develop for reuse）</li><li>管理已有的构件 （management for reuse）</li><li>复用已有的构件开发新软件（development by reuse）</li></ul></li><li>特点：<ul><li>降低开发和维护成本</li><li>提升开发效率和质量</li></ul></li></ul><h4 id="%EF%BC%885%EF%BC%89%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95" tabindex="-1">（5）敏捷开发方法</h4><ul><li><p>定义：一种轻量级软件开发方法（相对于重量级的软件开发方法而言）</p></li><li><p>主张软件开发要以代码为中心，快速、轻巧和主动应对需求变化，持续、及时交付可运行的软件系统</p></li><li><p>敏捷开发方法的基本观点</p><ul><li>较之于过程和工具，应更加重视人和交互的价值</li><li>较之于面面俱到文档，应更加重视可运行软件系统的价值</li><li>较之于合同谈判，应更加重视客户合作的价值</li><li>较之于遵循计划，应更加重视响应用户需求变化的价值</li></ul></li><li><p>敏捷方法体现的思想</p><ul><li>强化可运行的软件，弱化文档：以可运行软件为中心来开展软件开发</li><li>以适应变化为目的来推进开发：针对变化不断进行优化和调整任务、产品和计划等</li><li>以人为本：敏捷软件开发是面向人的而不是面向过程的，让方法、技术、工具、过程等来适应人，而不是让人来适应它们</li></ul></li><li><p><strong>敏捷开发方法是一大类方法的统称，它们遵循敏捷思想</strong></p></li><li><p>支持敏捷软件开发的技术</p><ul><li>极限编程</li><li>测试驱动开发<ul><li>在开发程序代码之前，先确定和编写测试</li><li>程序员首先要思考如何对某个功能进行测试，设计好相应的测试用例，编写好相关的测试代码，然后编写相应的程序代码以通过软件测试</li></ul></li><li>Scrum方法：旨在通过增量或迭代的方式加强软件项目的管理<ul><li>首先，产品拥有者需创建软件产品订单库即“Backblog”<ul><li>描述软件产品需提供的功能需求以及它们的优先级排序</li></ul></li><li>其次，筛选出最应该实现的软件需求，<ul><li>Scrum主人基于“Backblog”中各项软件需求及其优先级，形成待实现的软件产品冲刺订单库，即“SprintLog”</li></ul></li><li>然后，软件开发将进入冲刺“Sprint”周期<ul><li>以实现选定软件订单，每个冲刺就是一次增量开发，一般持续1到4周</li></ul></li><li>最后，共同开展Scrum评审<ul><li>一次冲刺完成后，每个团队成员演示自己的开发成果，大家共同审查成果是否高质量地实现了既定功能，并就其中的问题进行反思，以指导和改进下一次冲刺</li></ul></li></ul></li></ul></li></ul><h4 id="%EF%BC%886%EF%BC%89%E7%BE%A4%E4%BD%93%E5%8C%96%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95" tabindex="-1">（6）群体化软件开发方法</h4><ul><li><p>依托互联网平台来吸引、汇聚、组织和管理互联网上的大规模软件开发人员，通过竞争、合作、协商等多种自主协同方式，让他们参与软件开发、分享软件开发知识和成果、贡献智慧和力量的一种新颖软件开发方法</p></li><li><p>群体化软件开发是一种基于社区的软件开发模式<br><img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/3_4_1.jpg" alt></p></li><li><p>群体化软件开发方法的支撑关键技术</p><ul><li>基于社区的群体化组织<ul><li>开源软件社区将核心开发人员与外围开发人员有机地结合在一起，依托软件仓库进行分布式协同开发</li></ul></li><li>基于Issue的任务管理<ul><li>开发任务的二类形式：修复软件缺陷、功能实现需求</li><li>创建Issue，提出软件开发任务</li><li>讨论Issue，分析开发任务的意义和价值</li><li>指派Issue，安排人员来完成Issue</li><li>掌控Issue，掌握Issue解决的进展状况</li></ul></li><li>基于Git的分布式版本管理</li><li>基于Pull/Request的分布式协同开发<ul><li>每个开发人员在本地完成编程工作后，不是直接向中心仓库推送代码，而是通过发送一个P/R合并请求，将原始代码库的克隆库推荐合并到中心仓库之中</li><li>接收到合并请求后，软件项目管理团队和开发人员群体需要对P/R进行审查</li></ul></li><li>基于群智的知识分享</li></ul></li></ul><h2 id="%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E8%AE%A1%E5%88%92%E7%AE%A1%E7%90%86" tabindex="-1">第四章 软件计划管理</h2><h3 id="1-%E8%BD%AF%E4%BB%B6%E8%AE%A1%E5%88%92" tabindex="-1">1 软件计划</h3><h4 id="%EF%BC%881%EF%BC%89%E8%BD%AF%E4%BB%B6%E8%AE%A1%E5%88%92%E6%A6%82%E8%BF%B0" tabindex="-1">（1）软件计划概述</h4><ul><li>软件计划是对软件实施所涉及的目标、任务、活动、资源、进度等进行规划</li><li>合同和策划阶段<ul><li>制定初步软件开发计划</li><li>软件项目计划分发到各个开发成员</li><li>每个成员准确了解各自任务和工作以及实施进度要求</li></ul></li><li>项目实施过程<ul><li>根据软件开发的具体计划有序实施项目</li><li>发现项目实施中存在的问题：如进度滞后</li><li>出现偏差后调整软件项目计划</li></ul></li><li>项目完成之后<ul><li>总结项目计划实施情况</li><li>分析原因，指导后续其他项目的计划制定</li></ul></li></ul><h4 id="%EF%BC%882%EF%BC%89%E8%BD%AF%E4%BB%B6%E8%BF%9B%E5%BA%A6%E5%AE%89%E6%8E%92" tabindex="-1">（2）软件进度安排</h4><ul><li><p>两种途径</p><ul><li>项目、资源 → 制定计划、交付日期</li><li>从后往前安排 ← 最后期限</li></ul></li><li><p>进度管理中要妥善处理的2个问题</p><ul><li>识别任务之间的并行、依赖关系</li><li>资源的分配和优化</li></ul></li><li><p>甘特图</p><ul><li>优点：简单，醒目，能动态地反映开发进展</li><li>缺点：不表示活动之间的依赖关系</li></ul></li><li><p>计划网络图</p><ul><li>反映任务间的顺序、并行依赖关系</li></ul></li><li><p>软件进度计划的任务</p><ul><li>确定每个活动的最早（最迟）开始时间和完成时间。</li><li>在开发方已有的资源投入下求解该软件项目的交付日期（工期），或给定工期（投资方要求）条件下来安排各活动的开始时间和结束时间。</li><li>确定关键活动、重点监管关键线路。所谓<strong>关键活动</strong>是指由于这些活动完成的耽误或更改，将直接影响项目工期目标完成。全部由关键活动组成的线路或者线路长度最长的线路称为关键线路。</li><li>根据给定的工期目标和已有项目各活动时长的条件下，对进度进行调整和优化</li></ul></li></ul><h4 id="%EF%BC%883%EF%BC%89%E8%AE%A1%E5%88%92%E7%9A%84%E4%BC%98%E5%8C%96" tabindex="-1">（3）计划的优化</h4><ul><li>工期优化<ul><li>若网络计划图的计算工期大于要求的工期时，必须根据要求计划的进度，缩短工程项目的完工工期。主要从两个方面考虑：<ul><li>优化活动间的逻辑关系，串行到并行</li><li>采取技术措施，提高开发效率，缩短关键工序的持续时间。</li><li>采取组织措施，充分利用非关键工序的机动时间，合理调配人力、物力和资金等，增加对关键工序的投入，以便缩短关键工序的持续时间</li></ul></li></ul></li><li>资源优化<ul><li>在项目工期不变的条件下，合理地利用资源。具体包括：<ul><li>优先安排关键工序所需的资源</li><li>利用非关键工序的机动时间，错开各工序的开始时间，避开在同一时区内集中使用同一资源以免出现高峰</li><li>在确实受到资源制约，或在考虑综合经济效益的条件下，在许可时也可适当推迟工期，实现错开高峰的目的。</li></ul></li></ul></li></ul><h3 id="2-%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86" tabindex="-1">2 软件管理</h3><h4 id="%EF%BC%881%EF%BC%89%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86%E7%9A%84%E7%89%B9%E7%82%B9" tabindex="-1">（1）软件管理的特点</h4><ul><li>目标性: 获得预期的结果</li><li>进度性: 在限定期间完成</li><li>约束性: 具有有限的资源（如人员、经费、工具等）</li><li>多方性: 涉及多个不同人与组织</li><li>独立性: 无重复性</li><li>不确定性: 项目的实施及其结果不确定性</li></ul><h4 id="%EF%BC%882%EF%BC%89%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86%E5%86%85%E5%AE%B9" tabindex="-1">（2）软件管理内容</h4><p><img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/4_2_2.jpg" alt></p><ul><li><p>何为软件项目管理?</p><ul><li>对软件项目所涉及的过程、人员、产品、成本和进度等要素进行度量、分析、规划、组织和控制的过程，以确保软件项目按照预定的成本、进度、质量要求顺利完成</li><li>人员：团队建设和管理纪律和激励机制</li><li>过程：过程定义，软件度量，项目计划，项目跟踪</li><li>产品：软件产品质量管理，软件产品配置管理，软件产品需求管理</li></ul></li><li><p>过程管理</p><ul><li><ol><li>过程定义：定义、文档化软件开发过程、明确软件开发活动，得到一个良定义、全面、灵活、简洁和可供剪裁的软件开发过程</li></ol></li><li><ol start="2"><li>软件度量：对软件项目的过程、产品、资源的属性的定量描述，如软件项目的规模、成本、工作量、质量等</li></ol></li><li><ol start="3"><li>项目计划</li></ol></li><li><ol start="4"><li>项目跟踪：随时掌握软件项目的实际开发情况，提供项目实施情况的可视性，保证计划的适时调整</li></ol></li><li><ol start="5"><li>风险管理：对软件开发过程中各种风险进行识别、分析、预测、评估、监控的过程</li></ol></li></ul></li><li><p>产品管理</p><ul><li>软件质量保证：为软件产品的质量提供某种可视性，知道哪些地方有质量问题，便于改进方法和措施，提高软件产品的质量</li><li>软件配置管理：对软件基线产品进行标识、存储、更动和发放，记录和报告其状态，确保软件产品的正确性和一致性，并对上述工作的审计的过程</li><li>软件需求管理：获取、文档化和评审用户需求，对用户需求变更进行控制和管理</li></ul></li><li><p>人员管理</p><ul><li>软件项目团队：确定开发团体的结构、明确人员的角色和任务、加强人员间的交流与合作，结构合理、任务明确、团结协作、交流顺畅</li><li>纪律激励机制：制定和实施纪律约束团体，通过激励机制激发人员的激情，严格的纪律，饱满的激情</li></ul></li></ul><h4 id="%EF%BC%883%EF%BC%89%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86%E7%9A%84%E6%96%B9%E6%B3%95" tabindex="-1">（3）软件管理的方法</h4><ul><li>人员组织方式<ul><li>民主制程序员组</li><li>主程序员组</li><li>现代程序员组：实际的“主程序员”应该由两个人共同担任：  一个技术负责人，负责小组的技术活动；一个行政负责人，负责所有非技术性事务的管理决策。</li></ul></li></ul><h2 id="%E7%AC%AC%E4%BA%94%E7%AB%A0-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90" tabindex="-1">第五章 需求分析</h2><h3 id="1-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80" tabindex="-1">1 需求分析基础</h3><ul><li>需求的概念：分类、特点、质量要求、重要性</li><li>需求工程<ul><li>需求工程的一般过程</li><li>需求工程的常用方法<ul><li>结构化需求分析方法</li><li>面向对象需求分析方法</li></ul></li></ul></li><li>需求工程的输出、评审和管理</li></ul><h4 id="%EF%BC%881%EF%BC%89%E9%9C%80%E6%B1%82%E7%9A%84%E6%A6%82%E5%BF%B5" tabindex="-1">（1）需求的概念</h4><ul><li><p>软件开发的本质<br><img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/5_1_1.jpg" alt></p></li><li><p>何为利益相关方(stakeholder)</p><ul><li>从软件系统中受益或与软件系统相关的人、组织或者系统</li><li>受益：使用、获益、盈利</li><li>相关：发生操作和交互、存在关联性</li></ul></li><li><p>软件利益相关方的表现形式</p><ul><li>用户：最终使用软件的人</li><li>客户：从中获取利益的组织</li><li>系统：与待开发系统进行交互的系统</li><li>开发者：负责开发软件系统的人</li><li>示例：空巢老人看护软件利益相关方<ul><li>用户：老人，家属，医生</li><li>客户：投资方</li><li>系统：机器人</li></ul></li></ul></li><li><p>何为软件需求(Software Requirement)?</p><ul><li>从软件本身的角度，软件需求是指软件用于解决现实世界问题时所表现出的功能和性能等方面的要求</li><li>从软件利益相关方的角度，软件需求是指软件系统的利益相关方对软件系统的功能和质量，以及软件运行环境、交付进度等方面提出的期望和要求</li></ul></li><li><p>软件需求的类别</p><ul><li>软件功能性需求(Functional)<ul><li>能够完成的功能及在某些场景下可展现的外部可见行为或效果</li></ul></li><li>软件质量方面的需求(Quality)<ul><li>外部质量属性，外部可展现的，用户、客户等会非常关心，如运行性能、可靠性、易用性等</li><li>内部质量属性，隐藏在内部的，软件开发工程师会非常关心，如可扩展性、可维护性、可理解性</li></ul></li><li>软件开发约束性需求(Constraint)<ul><li>开发成本、交付进度、技术选型、遵循标准等方面提出的要求</li></ul></li><li>软件需求示例：空巢老人看护软件<ul><li>功能性需求：自主跟随老人、获取老人图像和视频信息、检测老人是否摔倒等</li><li>质量方面的需求：始终保持在2米的安全距离，对机器人的控制在2秒内响应等</li><li>约束性需求：成本不能超出50万元，要求半年内交付使用等等</li></ul></li></ul></li><li><p>软件需求的重要性</p><ul><li>软件的价值所在</li><li>软件开发的基础和前提</li><li>软件验收的标准和依据</li></ul></li></ul><h4 id="%EF%BC%882%EF%BC%89%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B" tabindex="-1">（2）需求工程</h4><ul><li><p>旨在用工程的理念和方法来指导软件需求实践，它提供了一系列的过程、策略、方法学和工具，帮助需求工程师加强对业务或领域问题及其环境的理解、获取和分析软件需求，指导软件需求的文档化和评审，以尽可能获得准确、一致和完整的软件需求，产生软件需求的相关软件制品<br><img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/5_1_2.jpg" alt></p></li><li><p>需求工程的方法学</p><ul><li>抽象<ul><li>20世纪70年代结构化数据和数据流抽象</li><li>20世纪90年代面向对象抽象</li></ul></li><li>建模<ul><li>采用自然语言或结构化自然语言</li><li>图形化的需求建模语言</li></ul></li><li>分析<ul><li>循序渐进地获得软件需求细节，进而逐步得到详细的软件需求</li></ul></li></ul></li><li><p>需求工程方法（详见复习重点）</p><ul><li>结构化需求分析方法</li><li>面向对象需求分析方法</li></ul></li><li><p>需求工程的输出</p><ul><li>软件需求模型</li><li>软件需求文档</li><li>软件原型</li><li>修正的软件开发计划</li><li>验收测试计划</li></ul></li></ul><h3 id="2-%E9%9C%80%E6%B1%82%E8%8E%B7%E5%8F%96" tabindex="-1">2 需求获取</h3><ul><li><p>获取软件需求是指得到或产生软件需求</p></li><li><p>明确问题和基于软件的解决方案</p></li><li><p>导出和构思初步软件需求</p></li><li><p>描述初步软件需求</p><ul><li>自然语言描述</li><li>软件原型模式</li><li><strong>用例图描述</strong>（详见复习重点）</li></ul></li><li><p>用例的进一步详细描述</p><ul><li>用例名：用户登录</li><li>用例标识： UC-UserLogin</li><li>主要执行者：家属、医生</li><li>目标：通过合法身份登录系统以获得操作权限</li><li>范围：空巢老人看护软件</li><li>前置条件：使用App软件之时</li><li>交互动作：<ul><li>用户输入账号和密码</li><li>系统验证用户账号和密码的正确性和合法性</li><li>验证正确和合法则意味着登录成功</li></ul></li></ul></li></ul><h3 id="3-%E5%88%86%E6%9E%90%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82" tabindex="-1">3 分析软件需求</h3><h4 id="%EF%BC%881%EF%BC%89%E5%88%86%E6%9E%90%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E6%A6%82%E8%BF%B0" tabindex="-1">（1）分析软件需求概述</h4><ul><li><p>基于初步软件需求，进一步精化和分析软件需求，确定软件需求优先级，建立软件需求模型，发现和解决软件需求缺陷，形成高质量的软件需求模型和软件需求规格说明书</p></li><li><p>用例视角</p><ul><li>具有哪些功能、功能间有何关系、功能与利益相关方有何关系</li><li>UML提供了用例图来分析和描述用例视角的软件需求模型</li></ul></li><li><p>行为视角</p><ul><li>用例是如何通过业务领域中一组对象以及它们间的交互来达成的</li><li>UML提供了交互图、状态图来描述行为视角的软件需求模型</li></ul></li><li><p>结构视角</p><ul><li>业务领域有哪些重要的领域概念以及它们之间具有什么样的关系</li><li>UML提供了类图来描述和分析业务领域的概念模型</li></ul></li><li><p><strong>UML交互图</strong> 详见重点</p></li><li><p><strong>类图</strong> 详见重点</p></li><li><p><strong>对象图</strong></p><ul><li>类图在系统的运行过程中某个时刻点上或某一时间段内的实例化样本<ul><li>类图中的一个类在对象图中可表现为多个活跃的对象实例</li><li>对象图的链接边是类图中关联边的实例化</li><li>类图中的其他边，如继承、依赖等在对象图中则无从表现</li></ul></li><li>示例：<img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/%E5%AF%B9%E8%B1%A1%E5%9B%BE%E7%A4%BA%E4%BE%8B.jpg" alt></li><li>不常用</li></ul></li><li><p><strong>状态图</strong></p><ul><li>功效<ul><li>描述实体（对象、系统）在事件刺激下的反应式动态行为及其导致的状态变化</li><li>刻画了实体的可能状态、每个状态下可响应事件、响应动作、状态迁移</li></ul></li><li>图的构成<ul><li>节点：状态</li><li>边：迁移，即状态间因事件刺激而触发的状态变化</li></ul></li></ul></li></ul><h4 id="%EF%BC%882%EF%BC%89%E5%88%86%E6%9E%90%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E8%BF%87%E7%A8%8B" tabindex="-1">（2）分析软件需求过程</h4><ol><li>分析和确定软件需求优先级<ul><li>分析软件需求重要性</li><li>分析软件需求优先级</li><li>确定用例分析和实现的次序</li></ul></li><li>分析和确定软件需求模型<br><img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/%E5%BB%BA%E7%AB%8B%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E6%A8%A1%E5%9E%8B%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4.jpg" alt><br><strong>分析和建立用例的交互模型</strong>见重点<ul><li>分析和建立分析类模型<ul><li>确定分析类</li><li>确定分析类的职责</li><li>确定分析类的属性</li><li>确定分析类之间的关系</li><li>绘制分析类图</li></ul></li><li>分析和建立软件需求的状态模型<ul><li>用UML的状态图来描述这些对象的状态模型，以刻画对象拥有哪些状态、对象的状态如何受事件的影响而发生变化</li></ul></li></ul></li></ol><h4 id="%EF%BC%883%EF%BC%89%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E6%96%87%E6%A1%A3%E5%8F%8A%E8%AF%84%E5%AE%A1" tabindex="-1">（3）软件需求文档及评审</h4><h2 id="%E7%AC%AC%E5%85%AD%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1" tabindex="-1">第六章 软件设计</h2><h3 id="1-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0" tabindex="-1">1 软件设计概述</h3><h4 id="%EF%BC%881%EF%BC%89%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80" tabindex="-1">（1）软件设计基础</h4><ul><li><p>软件设计：针对软件需求，综合考虑各种制约因素，探究软件实现的解决方案</p></li><li><p>设计前提：软件需求</p><ul><li>定义了要做什么样的软件</li></ul></li><li><p>设计考虑：制约因素</p><ul><li>资源：时间、人力、财力、开发辅助工具</li><li>技术：技术平台，如DBMS还是文件系统<br><img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B.jpg" alt></li></ul></li><li><p>软件设计过程</p><ul><li>软件结构设计<ul><li>从全局和宏观视角、站在最高抽象层次来设计软件系统</li></ul></li><li>用户界面设计<ul><li>设计软件对外展示以及与用户进行交互的界面，关注软件如何与用户进行交互</li></ul></li><li>软件详细设计<ul><li>对体系结构设计和人机交互设计成果进行细化和精化，获得高质量的、充分细化的软件设计模型</li><li>数据设计；接口设计；类设计；算法设计；</li></ul></li></ul></li><li><p>软件设计元素</p><ul><li>设计类：类既是最基本的设计单元，也是最基本的模块单元<br>软构件</li><li>软构件<ul><li>可分离、可单独重用、可独立部署和执行的一类设计元素</li><li>如动态链接库（.DLL）、可运行的Java JAR包、微服务镜像等就属于软构件</li></ul></li><li>子系统<ul><li>完成特定功能、逻辑上相互关联的一组模块集合</li><li>有助于管理软件系统的复杂度，简化软件设计和实现</li></ul></li></ul></li><li><p>软件设计基本原则</p><ul><li>抽象原则</li><li>模块化、高内聚度和低耦合度原则</li><li>信息隐藏原则</li><li>关注点分离原则</li><li>软件重用原则</li></ul></li></ul><h4 id="%EF%BC%882%EF%BC%89%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95" tabindex="-1">（2）软件设计方法</h4><ul><li>结构化方法<ul><li><ol><li>复审并精化数据流图</li></ol></li><li><ol start="2"><li>确定输入流和输出流的边界</li></ol></li><li><ol start="3"><li>第一级分解方法</li></ol></li><li><ol start="4"><li>第二级分解方法</li></ol></li><li><ol start="5"><li>软件结构求精</li></ol></li></ul></li><li>面向对象方法<ul><li><img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B.jpg" alt></li><li>用包图表示的软件系统的结构设计</li><li>用交互图来表示用户界面设计</li></ul></li></ul><h3 id="2-%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1" tabindex="-1">2 软件体系结构设计</h3><h4 id="%EF%BC%881%EF%BC%89%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80" tabindex="-1">（1）软件体系结构基础</h4><ul><li><p>软件体系结构设计元素</p><ul><li>构件/组件(Component)：构成体系结构的基本功能部件<ul><li>软件系统中的物理模块，具有特定的功能和精确定义的对外接口，外界可通过接口来访问它</li><li>例：.dll,.jar文件</li></ul></li><li>连接件：组件之间的连接和交互关系<ul><li>每个软构件并非孤立，它们之间通过连接进行交互</li><li>交互的目的是为了交换数据、获得服务</li><li>例：接口，端口</li></ul></li><li>约束</li></ul></li><li><p>软件体系结构设计视图</p><ul><li>逻辑视图</li><li>开发视图</li><li>部署视图</li><li>运行视图</li></ul></li><li><p>软件体系结构建模</p><ul><li>包图</li><li>构件图</li><li>部署图<br>软件体系结构风格<br>分层风格、管道过滤器风格、黑板风格、MVC风格、SOA风格、消息总线风格</li></ul></li><li><p>软件设计模式：以设计重用为目的，采用一种良定义的、正规的、一致的方式记录的软件设计经验</p></li><li><p>常用软件体系结构风格</p><ul><li>分层风格<ul><li>层次间的关系<ul><li>每层为其紧邻上层提供服务，使用紧邻下层所提供的服务</li><li>上层向下层发出服务请求，下层为上层反馈服务结果</li><li>下层向上层提供事件信息，上层对下层通知做出处理</li></ul></li><li>特点：松耦合，可替换，可复用，标准化</li></ul></li><li>管道与过滤器风格<ul><li>构件<ul><li>将软件功能实现为一系列处理步骤，每个步骤封装在一个过滤器构件中</li></ul></li><li>连接子<ul><li>相邻过滤器间以管道连接，一个过滤器的输出数据借助管道流向后续过滤器，作为其输入数据</li></ul></li><li>编译器采用的就是一个典型的管道/过滤器风格</li></ul></li><li>黑板风格：将软件系统划分为黑板、知识源和控制器三类构件<ul><li>黑板：负责保存问题求解过程中的状态数据，并提供这些数据的读写服务</li><li>知识源：负责根据黑板中存储的问题求解状态评价其自身的可应用性，进行部分问题求解工作，并将此工作的结果数据写入黑板</li><li>控制器：负责监视黑板中不断更新的状态数据，安排（多个）知识源的活动</li></ul></li><li>MVC风格<ul><li>模型构件：负责存储业务数据并提供业务逻辑处理功能</li><li>视图构件：负责向用户呈现模型中的数据</li><li>控制器：在接获模型的业务逻辑处理结果后，负责选择适当的视图作为软件系统对用户的界面动作的响应</li><li>步骤：<ul><li>创建视图，视图对象从模型中获取数据并呈现用户界面</li><li>控制器将用户界面事件转换为业务逻辑处理功能的调用</li><li>模型进行业务逻辑处理，将处理结果回送给控制器，必要时还需将业务数据变化事件通知给所有视图</li></ul></li></ul></li><li>SOA风格<ul><li>将软件系统的软构件抽象为一个个的服务（Service），每个服务封装了特定的功能并提供了对外可访问的接口</li><li>任何一个服务既可以充当服务的提供方，接受其他服务的访问请求；也可充当服务的请求方，请求其他服务为其提供功能</li><li>任何服务需要向服务注册中心进行注册登记，描述其可提供的服务以及访问方式，才可对外提供服务</li></ul></li><li>总线风格：包含了一组软构件和一条称为“消息总线”的连接件来连接各个软构件</li></ul></li></ul><h4 id="%EF%BC%882%EF%BC%89%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B" tabindex="-1">（2）软件体系结构设计过程</h4><ul><li><p>软件体系结构设计的原则</p><ul><li>高层抽象和组织</li><li>模块化</li><li>信息隐藏</li><li>软件重用</li><li>多视点分离<br><img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B.jpg" alt></li></ul></li><li><p>设计初步的软件体系结构</p><ul><li>任务：基于功能性和非功能性软件需求，参考业界已有的软件体系结构设计风格，设计出目标软件系统的初始体系结构，明确每个构件的职责以及构件间的通信和协作关系</li><li>输出：初步的软件体系结构<br><img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/%E4%B8%8D%E5%90%8C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E9%A3%8E%E6%A0%BC%E9%80%82%E5%90%88%E7%9A%84%E5%BA%94%E7%94%A8.jpg" alt></li></ul></li><li><p>重用开源软件及已有软件资产</p><ul><li>可直接使用的软件资产<ul><li>清晰地定义它们与当前软件系统间的交互接口</li><li>包括数据交换的格式、互操作协议等</li></ul></li><li>不可直接使用但具复用潜力的设计资产<ul><li>采用接口重构、适配器等方法将其引入到当前体系结构中</li><li>接口重构是指，调整当前体系结构中面向可复用设计资产的调用接口，使之与其提供的服务接口相匹配</li></ul></li></ul></li><li><p>精化软件体系结构</p><ul><li>选择软件体系结构所依赖的公共基础设施：如操作系统、软件中间件、数据库管理系统、软件开发框架、安全服务等</li><li>确定软件体系结构中的设计元素：包括子系统、软构件和关键设计类等，明确其职责和接口，从而为开展详细设计奠定基础</li></ul></li><li><p>设计部署模型：刻画软件系统的各个子系统、软构件如何部署到计算节点上运行的，描述它们的部署和运行环境</p></li></ul><h3 id="3-%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1" tabindex="-1">3 用户界面设计</h3><h4 id="%EF%BC%881%EF%BC%89%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E5%9F%BA%E7%A1%80" tabindex="-1">（1）用户界面基础</h4><ul><li><p>人机交互的关键</p><ul><li>用户的满意度</li><li>方便输入</li><li>直观输出</li></ul></li><li><p>用户界面元素及实现方式</p><ul><li>静态元素</li><li>动态元素</li><li>用户输入元素</li><li>用户命令元素</li></ul></li><li><p>用UML类图表示用户界面元素</p><ul><li>窗口或对话框 -&gt; 对象类</li><li>静态和动态元素 -&gt; 类属性</li><li>输入元素 -&gt; 类属性</li><li>命令元素 -&gt; 类方法</li></ul></li></ul><h4 id="%EF%BC%882%EF%BC%89%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B" tabindex="-1">（2）用户界面设计过程</h4><ul><li><p>用户界面设计的任务</p><ul><li>根据软件需求及其操作流程，为其设计出与用户进行交互的界面，支持用户对软件的操作和使用</li></ul></li><li><p>用户界面设计的原则</p><ul><li>直观性</li><li>易操作性</li><li>反应性</li><li>一致性</li><li>容错性</li><li>人性化</li></ul></li><li><p>用户界面设计的过程<img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B.jpg" alt></p></li><li><p>用户界面初步设计</p><ul><li>根据需求确定用户界面</li><li>确定用户界面的设计元素（属性和操作）</li></ul></li><li><p>建立用户界面间的跳转关系</p><ul><li>用UML图来表示用户界面的跳转关系<ul><li>交互图：表示特定场景下的跳转及跳转发生时的消息传递</li><li>类图：表示界面间所有可能发生的跳转及跳转的原因</li></ul></li></ul></li></ul><h3 id="4-%E8%BD%AF%E4%BB%B6%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1" tabindex="-1">4 软件详细设计</h3><h4 id="%EF%BC%881%EF%BC%89%E8%BD%AF%E4%BB%B6%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80" tabindex="-1">（1）软件详细设计基础</h4><ul><li>详细设计的任务<ul><li>输入：软件体系结构设计、用户界面设计、软件需求</li><li>任务：对体系结构设计和用户界面设计成果进行细化和精化，获得高质量、面向实现的设计模型</li></ul></li><li>软件详细设计UML模型（活动图）</li></ul><h4 id="%EF%BC%882%EF%BC%89%E8%BD%AF%E4%BB%B6%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1%E6%B4%BB%E5%8A%A8" tabindex="-1">（2）软件详细设计活动</h4><ul><li>用例设计<ul><li>任务：为需求模型中每个用例设计软件实现方案</li><li>原则：整体性、正确性、优化性等</li><li>输出：用例实现方案的交互图、设计类图</li></ul></li><li>类设计<ul><li>任务<ul><li>对界面类、关键设计类、设计类等进行设计优化和精化，</li><li>明确设计类的内部实现细节</li><li>精化到可以提交软件实现的程度</li></ul></li><li>结果<ul><li>类图、状态图、活动图等</li></ul></li></ul></li><li>数据设计<ul><li>任务<ul><li>设计需要持久保存的数据以及这些数据之间的关系</li><li>数据组织方式（例如关系数据库中的表、关键字、外键等）之间进行映射</li><li>为提高数据存储、操作性能而设计持久存储机制优化设施</li></ul></li><li>设计与建模<ul><li>设计数据的结构、存储、组织和访问</li><li>对数据设计的结果进行建模</li></ul></li></ul></li><li>子系统<ul><li>任务<ul><li>确定子系统内部结构，设置包含于其中的更小粒度子系统、构件和设计类，明确它们之间的协作关系</li><li>确保它们能够协同实现子系统接口规定的所有功能和行为</li></ul></li></ul></li><li>构件设计<ul><li>任务<ul><li>定义构件内部的设计元素及其协作方法</li><li>内部设计元素可以是子构件，也可以是粒度更细的类</li></ul></li></ul></li></ul><h3 id="5-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%95%B4%E5%90%88%E3%80%81%E9%AA%8C%E8%AF%81%E5%8F%8A%E8%AF%84%E5%AE%A1" tabindex="-1">5 软件设计整合、验证及评审</h3><ul><li>设计整合<ul><li>汇总迄今获得的所有设计模型<ul><li>包括体系结构模型、界面设计模型、用例设计模型、子系统/构件/类设计模型、数据模型等</li></ul></li><li>形成系统、完整的软件设计方案</li></ul></li><li>设计验证<ul><li>验证整个设计的正确性、优化性和充分性等</li><li>验证设计模型之间的不一致性、冗余性等</li><li>发现设计方案中的问题并进行整改</li></ul></li></ul><h2 id="%E7%AC%AC%E4%B8%83%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0%E5%92%8C%E6%B5%8B%E8%AF%95" tabindex="-1">第七章 软件实现和测试</h2><h3 id="1-%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0" tabindex="-1">1 软件实现</h3><h4 id="%EF%BC%881%EF%BC%89%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%A6%82%E8%BF%B0" tabindex="-1">（1）软件实现概述</h4><ul><li><p>软件实现的任务</p><ul><li>根据软件设计模型（包括体系结构设计模型、用户界面设计模型和详细设计模型），采用编程语言编写出目标软件系统的程序代码，并对代码进行必要的测试，以发现和纠正代码存在中的缺陷，并将可运行的目标代码部署到目标计算机上运行<br><img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B.jpg" alt></li></ul></li><li><p>这三项工作均由程序员负责完成</p><ul><li>编码：基于软件设计模型和文档，采用选定的程序设计语言，编写出目标软件系统的程序代码</li><li>单元测试：对自己编写的各个基本模块进行单元测试，以发现模块单元中存在的缺陷和问题</li><li>调试：发现产生缺陷原因，定位缺陷位置，进而对代码缺陷进行修复</li></ul></li><li><p>软件测试由软件测试工程师完成</p></li></ul><h4 id="%EF%BC%882%EF%BC%89%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%92%8C%E9%80%89%E6%8B%A9" tabindex="-1">（2）编程语言的类型和选择</h4><ul><li>选择<ul><li>软件的应用领域<ul><li>不同应用领域的软件通常会选择不同的程序设计语言来加以实现</li><li>科学和工程计算领域选用Fortran、C等程序设计语言，数据库应用软件开发会选用Delphi、Visual Basic、SQL等程序设计语言，机器人等嵌入式应用选用C、C++、Python等程序设计语言，互联网应用开发选用Java、ASP等程序设计语言</li></ul></li><li>与遗留软件系统的交互</li><li>软件的特殊功能及需求<ul><li>是否需要与底层的硬件系统进行交互，如果需要，可以考虑采用诸如C、汇编语言</li><li>是否需要丰富的软件库来支持功能的实现，如果需要，可以考虑具有丰富软件库的编程语言，如Python、Java等</li><li>是否需要对相关的知识进行表示和推理，如果需要，可以考虑选用描述性的程序设计语言，如Prolog、Lisp等</li></ul></li><li>软件的目标平台<ul><li>如果目标软件系统需要部署在J2EE架构之上，那么就需要选择Java编程语言；如果需要借助于ROS来开发机器人软件，那么建议选择C、C++和Python等编程语言</li></ul></li><li>程序员的编程经验</li></ul></li></ul><h3 id="2-%E7%BC%96%E7%A0%81" tabindex="-1">2 编码</h3><h4 id="%EF%BC%881%EF%BC%89%E7%BC%96%E7%A0%81%E6%A6%82%E8%BF%B0" tabindex="-1">（1）编码概述</h4><ul><li>编码的原则<ul><li>易读，一看就懂</li><li>易改，便于维护</li><li>降低代码的复杂度</li><li>尽可能地开展软件重用和编写可重用的程序代码</li><li>要有处理异常和提高代码的容错性</li><li>代码要与模型和文档相一致</li></ul></li><li>遵循编码风格</li></ul><h4 id="%EF%BC%882%EF%BC%89%E7%BC%96%E7%A0%81%E8%BF%87%E7%A8%8B" tabindex="-1">（2）编码过程</h4><ul><li>编写类代码<ul><li>编写实现类的代码</li><li>编写实现类方法的代码</li><li>编写实现类间关联的代码</li><li>编写实现设计类间聚合和组合关系的代码</li><li>编写实现接口关系的代码</li><li>编写实现继承关系的程序代码</li><li>编写实现包的代码</li></ul></li><li>编写用户界面代码</li><li>代码片段的重用</li></ul><h4 id="%EF%BC%883%EF%BC%89%E7%BC%BA%E9%99%B7" tabindex="-1">（3）缺陷</h4><ul><li>软件缺陷是指软件制品中存在不正确的软件描述和实现</li></ul><h3 id="3-%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95" tabindex="-1">3 软件测试</h3><h4 id="%EF%BC%881%EF%BC%89%E6%B5%8B%E8%AF%95%E6%A6%82%E8%BF%B0" tabindex="-1">（1）测试概述</h4><ul><li>软件缺陷不可避免</li><li>如何应对缺陷？<ul><li>预防缺陷</li><li>容忍缺陷</li><li>发现缺陷</li><li>修复缺陷</li></ul></li><li>何为软件测试<ul><li>运行软件或模拟软件的执行，发现软件缺陷的过程——缺陷测试</li><li>向开发人员和客户展示软件的有效性——确认测试</li></ul></li><li>软件测试的原理<ul><li>程序本质上是对数据的处理<ul><li>设计数据(测试用例) -&gt; 运行测试用例(程序来处理数据) -&gt; 判断运行结果(是否符合预期结果)</li></ul></li></ul></li><li>测试执行的步骤<ul><li><ol><li>明确待测试对象</li></ol></li><li><ol start="2"><li>设计测试用例</li></ol></li><li><ol start="3"><li>运行代码和测试用例</li></ol></li><li><ol start="4"><li>分析运行结果</li></ol></li></ul></li></ul><h4 id="%EF%BC%882%EF%BC%89%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1" tabindex="-1">（2）测试用例设计</h4><ul><li><p>测试用例是一个四元偶</p><ul><li>输入数据：交由待测试程序代码进行处理的数据</li><li>前置条件：程序处理输入数据的运行上下文，即要满足前置条件</li><li>测试步骤：程序代码对输入数据的处理可能涉及到一系列的步骤，其中的某些步骤需要用户的进一步输入</li><li>预期输出：程序代码的预期输出结果</li></ul></li><li><p>白盒测试技术：基于程序内部的执行流程来设计测试用例</p><ul><li>特点：必须了解程序的内部工作流程才能设计测试用例</li><li>基本路径测试<ul><li><ol><li>根据程序逻辑画出流程图</li></ol></li><li><ol start="2"><li>将流程图转换为流图</li></ol></li><li><ol start="3"><li>确定基本路径集合</li></ol></li><li><ol start="4"><li>针对测试路径设计测试用例</li></ol></li></ul></li></ul></li><li><p>黑盒测试技术：基于程序的外在功能和接口来设计测试用例</p><ul><li>特点：<ul><li>知道程序功能和性能，不必了解程序内部结构和处理细节</li><li>黑盒测试与软件如何实现无关，如果软件实现发生变化，测试用例仍然可以使用</li><li>黑盒测试用例的开发可以与软件开发并行进行，能够缩短软件开发周期</li></ul></li><li>方法：<ul><li>等价分类法<ul><li>思想<ul><li>把程序的输入数据集合按输入条件划分为若干个等价类</li><li>每一个等价类对于输入条件而言是等价的</li><li>为每一个等价类设计一个测试用例，包括有效或无效的输入</li></ul></li><li>优点<ul><li>可以滤掉同类数据，减少测试次数，不丢失发现错误的机会</li></ul></li></ul></li><li>边界值分析法</li></ul></li></ul></li></ul><h4 id="%EF%BC%883%EF%BC%89%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E7%AD%96%E7%95%A5" tabindex="-1">（3）软件测试的过程和策略</h4><p><img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%92%8C%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%85%B3%E7%B3%BB.jpg" alt></p><ul><li><p>单元测试</p><ul><li>测试对象<ul><li>对软件基本模块单元进行测试</li><li>过程、函数、方法、类</li></ul></li><li>测试方法：大多采用白盒测试技术</li></ul></li><li><p>集成测试</p><ul><li>测试对象<ul><li>对软件模块之间的接口进行测试</li><li>过程调用、函数调用、消息传递、远程过程调用</li></ul></li><li>测试技术：采用黑盒测试技术</li></ul></li><li><p>确认测试</p><ul><li>测试对象<ul><li>对软件的功能和性能进行测试</li><li>判断目标软件系统是否满足用户需求</li></ul></li><li>依据和标准<ul><li>软件需求规格说明书</li></ul></li><li>测试技术：采用黑盒测试技术</li></ul></li><li><p>α测试</p><ul><li>软件开发公司组织内部人员模拟各类用户行为对即将面市的软件产品（称为α版本、内部测试版）进行测试，发现错误并修正</li><li>尽可能逼真地模拟实际运行环境和用户对软件产品的操作，并尽最大努力涵盖所有可能的用户操作方式</li><li>经α测试并进行修改后的软件产品称为β版本（也称外部测试版）</li></ul></li><li><p>β测试</p><ul><li>软件开发公司组织各方面的典型用户在日常工作中实际使用β版本，或为对外进行宣传而将β版本免费赠送给典型用户（很多情况下，β版本可以通过Internet免费下载，也可以向软件公司索取），并要求用户报告异常情况、提出批评意见</li><li>β测试是在与开发者无法控制的环境下进行的软件现场应用</li></ul></li></ul><h4 id="%EF%BC%884%EF%BC%89%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95" tabindex="-1">（4）面向对象软件测试</h4><ul><li>OO软件的构成基础与传统结构化程序设计不同</li><li>需要开发测试驱动程序</li><li>采用白盒测试方法</li></ul><h4 id="%EF%BC%885%EF%BC%89%E9%9D%9E%E5%8A%9F%E8%83%BD%E6%80%A7%E6%B5%8B%E8%AF%95" tabindex="-1">（5）非功能性测试</h4><ul><li>性能测试</li><li>强度测试</li><li>配置和兼容性测试</li><li>安全性测试</li><li>可靠性测试</li><li>用户界面测试</li><li>本地化测试</li><li>Web测试</li><li>安装测试</li></ul><h3 id="4-%E8%BD%AF%E4%BB%B6%E8%B0%83%E8%AF%95" tabindex="-1">4 软件调试</h3><ul><li>软件调试就是要基于程序代码，确定软件缺陷的原因、定位缺陷的位置，从而知道那里错了、如何修复缺陷</li><li>目的<ul><li>测试发现缺陷</li><li>调试定位缺陷</li><li>排错纠正错误</li></ul></li><li>独立性不同<ul><li>测试由独立的测试小组进行</li><li>调试和排错由开发人员完成<br><img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/%E8%B0%83%E8%AF%95%E7%9A%84%E6%AD%A5%E9%AA%A4.jpg" alt></li></ul></li></ul><h2 id="%E7%AC%AC%E5%85%AB%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4%E5%92%8C%E6%BC%94%E5%8C%96" tabindex="-1">第八章 软件维护和演化</h2><h3 id="1.-%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4%E4%B8%8E%E6%BC%94%E5%8C%96" tabindex="-1">1. 软件维护与演化</h3><h4 id="%EF%BC%881%EF%BC%89%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4" tabindex="-1">（1）软件维护</h4><ul><li><p>软件变更和修改是不可避免的</p><ul><li>待修复的错误</li><li>需求的变更/新的需求</li><li>技术和商务环境变化</li><li>系统的性能或可靠性等需要改进</li><li>系统中增加了新的计算机和设备</li></ul></li><li><p>软件需要进行维护</p><ul><li>出故障，不可正常工作</li><li>服务变化，需要升级</li><li>运行环境变化，需要适应</li></ul></li><li><p>软件维护：软件在交付使用后，由于应用需求和环境变化以及自身问题，对软件系统进行改造和调整的过程</p></li><li><p>维护形式：</p><ul><li>纠正性维护：纠正软件中的缺陷和错误</li><li>完善性维护：对软件进行改造以增加新的功能、修改已有的功能</li><li>适应性维护：对软件进行改造以便适应新的运行环境和平台</li><li>预防性维护：对软件结构进行改造以便提高软件的可靠性和可维护性等</li></ul></li><li><p>软件维护工程师</p></li></ul><h4 id="%EF%BC%882%EF%BC%89%E8%BD%AF%E4%BB%B6%E6%BC%94%E5%8C%96" tabindex="-1">（2）软件演化</h4><ul><li>特点：软件演化与开发是一个集成的、完整的、增量式的过程，可以用螺旋模型表示。主要针对软件的大规模功能增强和结构调整，以实现变化的软件需求，或者提高软件系统的质量。</li></ul><table><thead><tr><th>概念</th><th>功能增强粒度</th><th>应对变化方式</th><th>持续性或间隔性</th><th>版本变化</th></tr></thead><tbody><tr><td>软件演化</td><td>粗粒度</td><td>主动</td><td>持续性</td><td>是</td></tr><tr><td>软件维护</td><td>细粒度</td><td>被动</td><td>间隔性</td><td>不一定</td></tr></tbody></table><ul><li>软件演化法则<ul><li>持续变化法则</li><li>增加复杂性法则</li><li>自我调节法则</li><li>组织稳定性守恒法则</li><li>熟悉度守恒法则</li><li>功能持续增长法则</li><li>质量衰减法则</li><li>反馈系统法则</li></ul></li></ul><h3 id="2.-%E8%BD%AF%E4%BB%B6%E9%80%BB%E8%BE%91%E8%80%81%E5%8C%96" tabindex="-1">2. 软件逻辑老化</h3><h4 id="%EF%BC%881%EF%BC%89%E9%80%BB%E8%BE%91%E8%80%81%E5%8C%96%E7%9A%84%E7%89%B9%E7%82%B9" tabindex="-1">（1）逻辑老化的特点</h4><ul><li>何为逻辑老化<ul><li>软件在维护和演化的过程中出现的用户满意度降低、质量逐渐下降、变更成本不断上升这样一种现象</li></ul></li><li>软件逻辑老化的现象<ul><li>质量下降</li><li>变更成本增加</li><li>用户满意度降低</li></ul></li><li>软件逻辑老化的原因<ul><li>缺乏变更</li><li>负面变更</li></ul></li></ul><h4 id="%EF%BC%882%EF%BC%89%E8%A7%A3%E5%86%B3%E9%80%BB%E8%BE%91%E8%80%81%E5%8C%96%E7%9A%84%E6%96%B9%E6%B3%95" tabindex="-1">（2）解决逻辑老化的方法</h4><p>逻辑老化软件的维护和升级将会收到预算、期限等多种因素的约束，因此维护团队需要对逻辑老化软件基于其质量（失效率和可维护性等）及其业务价值（系统的使用情况、支持的业务流程、系统的可靠性、输出的价值）进行评估，再做出适当决策。</p><h3 id="3.-%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%8E%E6%8A%80%E6%9C%AF" tabindex="-1">3. 软件维护的过程与技术</h3><h4 id="%EF%BC%881%EF%BC%89%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4%E6%8A%80%E6%9C%AF" tabindex="-1">（1）软件维护技术</h4><ul><li>代码重组：在不改变软件功能的前提下，对程序代码进行重新组织，使得重组后的代码具有更好的可维护性，能够有效支持对代码的变更</li><li>逆向工程：基于低抽象层次软件制品，通过对其进行理解和分析，产生高抽象层次的软件制品</li><li>设计重构</li><li>再工程</li></ul><h4 id="%EF%BC%882%EF%BC%89%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4%E8%BF%87%E7%A8%8B" tabindex="-1">（2）软件维护过程</h4><p><img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4%E8%BF%87%E7%A8%8B.jpg" alt></p><ul><li>软件维护需要解决的问题<ul><li>人员的问题</li><li>软件制品的问题</li><li>维护副作用的问题</li><li>维护成本不断增加的问题</li></ul></li></ul><h2 id="%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9" tabindex="-1">复习重点</h2><h3 id="%E7%BB%93%E6%9E%84%E5%8C%96%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95" tabindex="-1">结构化需求分析方法</h3><ul><li>基本思想：数据主义认为，整个宇宙都是由数据流构成的，各个数据处理系统构成人类的社会</li><li>数据流图<ul><li>Data Flow Diagram(简称DFD)：描述输入数据流到输出数据流的变换(即加工)过程，用于对系统的功能建模</li><li>基本元素<img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/5_1_2_1_1.jpg" alt></li></ul></li><li>画分层数据流图的步骤<ul><li><ol><li>画系统的输入和输出</li></ol></li><li><ol start="2"><li>画系统内部</li></ol></li><li><ol start="3"><li>画加工内部</li></ol></li><li><ol start="4"><li>根据自顶向下逐层分解的思想，重复第3步，继续分解加工，直至每个尚未分解的加工都足够简单(即不必再分解)</li></ol></li></ul></li><li>分层数据流图示例——空巢老人看护系统<ul><li>确定源或宿：老人、家属、医生、机器人和时钟<ul><li>除了时钟外，都既是源又是宿</li></ul></li><li>顶层图唯一的加工：软件系统(空巢老人看护系统)</li><li>确定数据流：系统的输入/输出信息<ul><li>输入数据流：老人的呼叫、家属和医生的控制命令、老人的图像和视频、定时器</li><li>输出数据流：家属和医生的语音和视频、异常状态和警告信息、机器人执行指令</li></ul></li><li>顶层图通常没有文件<br><img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/%E8%BD%AF%E5%B7%A5%E9%A1%B6%E5%B1%82%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE.jpg" alt><br><img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/%E8%BD%AF%E5%B7%A5%E6%80%BB%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE.jpg" alt></li></ul></li></ul><h3 id="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95" tabindex="-1">面向对象需求分析方法</h3><ul><li><p>基本思想:现实世界（应用问题）还是计算机世界（软件系统），它们都是由多样化的对象所构成的，每个对象都有其状态并可提供功能和服务，不同对象之间通过交互来开展协作来实现功能和提供服务</p></li><li><p>面向对象软件工程提供对象、类、属性、操作、消息、继承等概念来抽象表示现实世界的应用，分析其软件需求特征，建立起软件需求模型，描述软件需求</p></li><li><p>面向对象建模语言</p><ul><li>概念:基于面向对象的概念和抽象，提供图形化的图符，用来表示软件系统的一种语言</li><li>示例：<img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/%E9%A1%BA%E5%BA%8F%E5%9B%BE.jpg" alt></li></ul></li><li><p>UML: Unified Modeling Language</p><ul><li>Unified(统一)<ul><li>提取不同方法中最好建模技术，如OMT(James Rumbaugh)，Booch method(Grady Booch )和OOSE(Ivar Jacobson)</li><li>采用统一、标准化的表示方式</li></ul></li><li>Modeling(建模)<ul><li>对现实系统和软件系统进行可视化建模</li><li>建立系统模型</li></ul></li><li>Language(语言)<ul><li>图形化语言：语法、语义和语用<ul><li>包括规则，约束 扩展机制</li></ul></li></ul></li><li>UML用途：用来可视化(visualize) 、描述(specify)、构造(construct)和文档化(document)软件密集型系统的各种产品</li></ul></li><li><p>多视点建模</p><ul><li>结构视点（Structural View）<ul><li>用于描述系统的构成</li><li>UML提供了包图（Package Diagram）、类图（Class Diagram）、对象图（Object Diagram）和构件图（Component Diagram），从不同的抽象层次来表示系统的静态组织及结构</li></ul></li><li>行为视点（Behavioral View）<ul><li>刻画系统的行为</li><li>UML提供了交互图（Interaction Diagram）、状态图（Statechart Diagram）与活动图（Activity Diagram），以从不同侧面刻画系统的动态行为。</li></ul></li><li>部署视点（Deployment View）<ul><li>刻画目标软件系统的软件制品及其运行环境</li><li>UML提供了部署图（Deployment Diagram）来描述软件系统的部署模型</li></ul></li><li>用例视点（Use Case View）<ul><li>刻画系统的功能</li><li>UML提供了用例图（Use Case Diagram）以描述系统的用例及其与外部执行者之间的关系。<br><img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%BB%BA%E6%A8%A1%E8%AF%95%E7%82%B9%E5%9B%BE.jpg" alt></li></ul></li></ul></li><li><p>面向对象需求分析步骤</p><ul><li>明确问题边界，获取软件需求，建立用例模型</li><li>开展用例分析，精化软件需求，建立分析模型</li><li>汇总需求模型，撰写需求文档，评审软件需求</li></ul></li></ul><h3 id="%E7%94%A8%E4%BE%8B%E5%9B%BE%E6%8F%8F%E8%BF%B0" tabindex="-1">用例图描述</h3><ul><li><p>用例图用来描述初步软件需求</p></li><li><p>图的构成</p><ul><li>执行者<ul><li>系统之外的实体，他们使用软件系统功能、与软件系统交换信息</li><li>可以是一类用户，也可以是其他软件系统或物理设备</li></ul></li><li>用例<ul><li>表示执行者为达成一项相对独立、完整的业务目标而要求软件系统完成的功能</li></ul></li><li>边：执行者与用例间、用例之间、执行者之间的关系<br><img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/%E6%89%A7%E8%A1%8C%E8%80%85%E4%B8%8E%E7%94%A8%E4%BE%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.jpg" alt></li></ul></li><li><p>用例间的关系</p><ul><li>用例间的关系-包含关系<ul><li>如果用例B是用例A的某项子功能，则称用例A包含用例B</li></ul></li><li>用例间的关系-扩展关系<ul><li>如果用例A与B相似，但A的功能较B多，A的动作序列是在B的动作序列中的某些执行点上插入附加动作序列而构成的，则称用例A扩展用例B</li></ul></li><li>用例间的关系-继承<ul><li>如果A与B相似，但A的动作序列是通过改写B的部分动作或者扩展B的动作而获得的，则称用例A继承用例B<br><img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/%E7%94%A8%E4%BE%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.jpg" alt></li></ul></li><li>边界框<ul><li>表示整个软件系统或子系统的边界<br><img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/%E7%A9%BA%E5%B7%A2%E8%80%81%E4%BA%BA%E7%9C%8B%E6%8A%A4%E8%BD%AF%E4%BB%B6%E7%94%A8%E4%BE%8B%E5%9B%BE.jpg" alt></li></ul></li></ul></li></ul><h3 id="uml%E4%BA%A4%E4%BA%92%E5%9B%BE" tabindex="-1">UML交互图</h3><ul><li><p>作用：刻画对象间的消息传递，分析如何通过交互协作完成功能</p><ul><li>用例的功能实现方式</li><li>软件系统在某种使用场景下对象间的交互协作流程</li><li>软件系统的某个复杂操作的逻辑实现模型</li></ul></li><li><p>二类交互图</p><ul><li>顺序图(Sequence Diagram)：强调消息传递的时间序</li><li>通信图(Communication Diagram)：突出对象间的合作</li><li>顺序图和通信图语义上等价，没必要针对同一建模目标同时创建这二个图</li></ul></li><li><p>顺序图：描述对象间的消息交互序列</p><ul><li>纵向：时间轴，对象及其生命线(虚线)，活跃期(长条矩形)</li><li>横向：对象间的消息传递<br><img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/%E4%BA%A4%E4%BA%92%E5%9B%BE%E4%B9%8B%E9%A1%BA%E5%BA%8F%E5%9B%BE.jpg" alt></li></ul></li></ul><h3 id="%E7%B1%BB%E5%9B%BE" tabindex="-1">类图</h3><ul><li>功效：描述系统的类构成，刻画系统的静态组成结构</li><li>图的构成<ul><li>结点：表示系统中的类（或接口）及其属性和操作</li><li>边：类之间的关系</li></ul></li><li>类的表示<img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/%E7%B1%BB%E7%9A%84%E8%A1%A8%E7%A4%BA.jpg" alt></li><li>属性的表示：<ul><li>[可见性] 名称 [: 类型] [多重性] [= 初值]  [{约束特性}]</li><li>可见性<ul><li>公开(+): 所有对象均可访问</li><li>保护(#): 所在类及子类对象均可访问</li><li>私有(-): 仅所在类的对象才可访问</li></ul></li><li>多重性：属性取值数量, 如1，0…1，0…* ，1…<em>，</em></li><li>约束特性<ul><li changeable>可更改性：{readOnly}表示只读，缺省为</li><li unordered>顺序性： {ordered}表示属性取值是有序的，缺省为</li><li>唯一性： {bag}表示属性取值元素允许出现重复元素（缺省）</li><li>静态性：{static}表示静态属性，属性值由类所有实例对象共享</li></ul></li></ul></li><li>方法的表示<ul><li>[可见性]  名称[(参数表)] [: 返回类型] [{约束特性}]</li><li>操作的约束特性<ul><li>查询操作： {isQuery = true}表示查询操作，{ isQuery = false}表示修改操作，缺省为修改操作。</li><li>多态性：{isPolymorphic = true}表示本操作允许多态，即可被子类中相同定义形式的操作所覆盖</li><li>并发性：{concurrency = sequential} 任一时刻只有一个对象调用可执行。{concurrency = guarded} 并行线程可同时调用多个对象的本操作，但同一时刻只允许一个调用执行。{concurrency = concurrent} 并行线程可以同时调用多个对象的本操作且这些调用可并发执行</li><li>异常：操作在执行过程中可能引发异常</li></ul></li></ul></li><li>接口<ul><li>一种不包含操作实现部分的特殊类</li><li>接口的形式<ul><li>供给接口: 对外提供的接口</li><li>需求接口: 需要使用的接口</li></ul></li></ul></li><li>类间的关系<ul><li>关联</li><li>依赖</li><li>集成</li><li>实现</li><li>聚合</li><li>组成</li></ul></li><li>类图注意事项<ul><li>用单数名词来描述类名，少用缩写</li><li>按照方向表示类间关系<ul><li>垂直方向表示继承关系</li><li>水平方向表示关联、聚合、组合、依赖、实现关系</li></ul></li><li>注意画图位置<ul><li>关联名应位于关联边的居中位置</li><li>多重性、角色名、约束特性等应靠近关联端</li></ul></li></ul></li></ul><h3 id="%E5%88%86%E6%9E%90%E5%92%8C%E5%BB%BA%E7%AB%8B%E7%94%A8%E4%BE%8B%E7%9A%84%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%9E%8B" tabindex="-1">分析和建立用例的交互模型</h3><ul><li><p>任务:分析和描述用例是如何通过一组对象之间的交互来完成的</p></li><li><p>步骤</p><ul><li>分析和确定用例所涉及的对象及其类</li><li>分析和确定对象之间的消息传递</li><li>绘制用例的交互图</li></ul></li><li><p>软件需求用例的处理通常涉及三种不同类对象:边界类，控制类，实体类</p></li><li></li><li><p>边界类</p><ul><li>定义：由于这些类对象处于系统的边界，需与系统外的执行者进行交互，因而将这些对象所对应的类称之为边界类</li><li>作用<ul><li>交互控制，处理外部执行者的输入数据，或者向外部执行者输出数据</li><li>外部接口，如果外部执行者表现为其他的系统或者设备，那么边界类对象需要与系统之外的其他系统或设备进行信息交互</li></ul></li></ul></li><li><p>控制类</p><ul><li>控制类对象作为完成用例任务的主要协调者</li><li>一般而言，控制类并不负责处理具体的任务细节，而是负责分解任务，并通过消息传递将任务分派给其他对象类来完成，协调这些对象之间的信息交互</li></ul></li><li><p>实体类</p><ul><li>用例所对应业务流程中的所有具体功能最终要交由具体的类对象来完成，这些类称之为实体类<br><img src="/images/%E6%9C%AC%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/%E7%94%A8%E4%BE%8B%E7%9A%84%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%9E%8B.jpg" alt></li></ul></li><li><p>分析和确定对象之间的消息</p><ul><li>确定消息的名称<ul><li>直接反映了对象间交互的意图，也体现了接收方对象所对应的类需承担的职责和任务</li><li>意图：请求、通知</li><li>一般地，消息名称用动名词来表示</li></ul></li><li>确定消息传递的信息<ul><li>信息：通知和请求的内容</li><li>这些信息通常以消息参数的形式出现，也即一个对象在向另一个对象发送消息的过程中，需要提供必要的参数，以向目标对象提供相应的信息</li></ul></li></ul></li></ul><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;%E7%AC%AC%E4%B8%80%E7%AB%A0-%E4%BB%8E%E7%A8%8B%E5%BA%8F%E5%88%B0%E8%BD%AF%E4%BB%B6&quot; tabindex=&quot;-1&quot;&gt;第一章 从程序到软件&lt;/h2&gt;
&lt;h3 i</summary>
      
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="软件工程" scheme="http://example.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
</feed>
